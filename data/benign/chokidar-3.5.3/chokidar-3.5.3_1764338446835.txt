let cont = FSEventsWatchers.get(watchPath)
const undef = (opts, key) => opts[key] === undefined
cont || watchedParent
DirEntry = package/index.js::program:DirEntry:<init>
lst.delete(filteredListener)
let cont = FsWatchFileInstances.get(fullPath)
sysPath.relative(this.watchPath, this.checkGlobSymlink(entry))
copts && (copts.persistent < options.persistent || copts.interval > options.interval)
cont = {
      listeners: listener,
      rawEmitters: rawEmitter,
      options,
      watcher: fs.watchFile(fullPath, options, (curr, prev) => {
        foreach(cont.rawEmitters, (rawEmitter) => {
          rawEmitter(EV_CHANGE, fullPath, {curr, prev});
        });
        const currmtime = curr.mtimeMs;
        if (curr.size !== prev.size || currmtime > prev.mtimeMs || currmtime === 0) {
          foreach(cont.listeners, (listener) => listener(path, curr));
        }
      })
    }
_tmp_15.watcher = fs.watchFile(fullPath, options, (curr, prev) => {
        foreach(cont.rawEmitters, (rawEmitter) => {
          rawEmitter(EV_CHANGE, fullPath, {curr, prev});
        });
        const currmtime = curr.mtimeMs;
        if (curr.size !== prev.size || currmtime > prev.mtimeMs || currmtime === 0) {
          foreach(cont.listeners, (listener) => listener(path, curr));
        }
      })
FsWatchFileInstances.set(fullPath, cont)
FsWatchFileInstances.delete(fullPath)
const action = this._throttled.get(actionType)
const actionPath = action.get(path)
const clear = () => {
    const item = action.get(path);
    const count = item ? item.count : 0;
    action.delete(path);
    clearTimeout(timeoutObject);
    if (item) clearTimeout(item.timeoutObject);
    return count;
  }
const item = action.get(path)
const count = item ? item.count : 0
action.delete(path)
return count
timeoutObject = setTimeout(clear, timeout)
const thr = {timeoutObject, clear, count: 0}
action.set(path, thr)
