function gatherNodeParts = function gatherNodeParts(node, parts) {
  if (t.isModuleDeclaration(node)) {
    if (node.source) {
      gatherNodeParts(node.source, parts);
    } else if (node.specifiers && node.specifiers.length) {
      for (var _iterator2 = node.specifiers, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : (0, _getIterator3.default)(_iterator2);;) {
        var _ref2;

        if (_isArray2) {
          if (_i2 >= _iterator2.length) break;
          _ref2 = _iterator2[_i2++];
        } else {
          _i2 = _iterator2.next();
          if (_i2.done) break;
          _ref2 = _i2.value;
        }

        var specifier = _ref2;

        gatherNodeParts(specifier, parts);
      }
    } else if (node.declaration) {
      gatherNodeParts(node.declaration, parts);
    }
  } else if (t.isModuleSpecifier(node)) {
    gatherNodeParts(node.local, parts);
  } else if (t.isMemberExpression(node)) {
    gatherNodeParts(node.object, parts);
    gatherNodeParts(node.prop...
var earliestKeyIndex = keys.indexOf(earliest.parentKey)
function isnt = function isnt(key) {
  return !this.has(key);
}
left.isUnaryExpression({ operator: "typeof" })
t.isAnyTypeAnnotation(type2) || _isBaseType(name, type2, true)
function skip = function skip() {
  this.shouldSkip = true;
}
function getAllPrevSiblings = function getAllPrevSiblings() {
  var _key = this.key;
  var sibling = this.getSibling(--_key);
  var siblings = [];
  while (sibling.node) {
    siblings.push(sibling);
    sibling = this.getSibling(--_key);
  }
  return siblings;
}
function skipKey = function skipKey(key) {
  this.skipKeys[key] = true;
}
function get = function get(key, context) {
  if (context === true) context = this.context;
  var parts = key.split(".");
  if (parts.length === 1) {
    return this._getKey(key, context);
  } else {
    return this._getPattern(parts, context);
  }
}
nodes.unshift(t.expressionStatement(t.assignmentExpression("=", temp, this.node)))
key = path.listKey + "[" + key + "]"
this.replaceExpressionWithStatements(nodes)
visitor[alias] = (0, _clone2.default)(_fns)
var target = this.get("object").resolve(dangerous, resolved)
target.isObjectExpression()
var props = target.get("properties")
var _iterator3 = _isArray3 ? _iterator3 : (0, _getIterator3.default)(_iterator3)
this.generateUidIdentifier(id.slice(0, 20))
Scope.prototype.isStatic = function isStatic(node) {
    if (t.isThisExpression(node) || t.isSuper(node)) {
      return true;
    }

    if (t.isIdentifier(node)) {
      var binding = this.getBinding(node.name);
      if (binding) {
        return binding.constant;
      } else {
        return this.hasBinding(node.name);
      }
    }

    return false;
  }
_ref3 = _i3.value
t.isIdentifier(node)
callee.isMemberExpression()
var _property = callee.get("property")
_object.isIdentifier() && _property.isIdentifier() && VALID_CALLEES.indexOf(_object.node.name) >= 0 && INVALID_METHODS.indexOf(_property.node.name) < 0
prop.get("value").resolve(dangerous, resolved)
Scope.prototype.maybeGenerateMemoised = function maybeGenerateMemoised(node, dontPush) {
    if (this.isStatic(node)) {
      return null;
    } else {
      var _id2 = this.generateUidIdentifierBasedOnNode(node);
      if (!dontPush) this.push({ id: _id2 });
      return _id2;
    }
  }
_type === "string" || _type === "number"
