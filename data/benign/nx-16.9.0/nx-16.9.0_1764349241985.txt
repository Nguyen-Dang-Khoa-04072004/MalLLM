function getIgnoredGlobsFromFile = function getIgnoredGlobsFromFile(file, root) {
    try {
        const results = [];
        const contents = (0, fs_extra_1.readFileSync)(file, 'utf-8');
        const lines = contents.split('\n');
        for (const line of lines) {
            const trimmed = line.trim();
            if (!trimmed || trimmed.startsWith('#')) {
                continue;
            }
            else if (trimmed.startsWith('/')) {
                if (root) {
                    results.push((0, path_1.joinPathFragments)(root, trimmed));
                }
                else {
                    results.push((0, path_1.joinPathFragments)('.', trimmed));
                }
            }
            else {
                results.push(trimmed);
            }
        }
        return results;
    }
    catch (e) {
        return [];
    }
}
function getPackageManagerCommand = function getPackageManagerCommand(packageManager = detectPackageManager(), root = workspace_root_1.workspaceRoot) {
    const commands = {
        yarn: () => {
            const yarnVersion = getPackageManagerVersion('yarn', root);
            const useBerry = (0, semver_1.gte)(yarnVersion, '2.0.0');
            return {
                preInstall: `yarn set version ${yarnVersion}`,
                install: 'yarn',
                ciInstall: useBerry
                    ? 'yarn install --immutable'
                    : 'yarn install --frozen-lockfile',
                add: useBerry ? 'yarn add' : 'yarn add -W',
                addDev: useBerry ? 'yarn add -D' : 'yarn add -D -W',
                rm: 'yarn remove',
                exec: 'yarn',
                run: (script, args) => `yarn ${script} ${args}`,
                list: useBerry ? 'yarn info --name-only' : 'yarn list',
            };
        },
        pnpm: () => {
            const pnpmVersion = getPackageManagerVersion(...
function handleServerProcessTermination = async function handleServerProcessTermination({ server, reason, }) {
    try {
        server.close();
        (0, cache_1.deleteDaemonJsonProcessCache)();
        if (sourceWatcherSubscription) {
            await sourceWatcherSubscription.unsubscribe();
            logger_1.serverLogger.watcherLog(`Unsubscribed from changes within: ${workspace_root_1.workspaceRoot} (sources)`);
        }
        if (outputsWatcherSubscription) {
            await outputsWatcherSubscription.unsubscribe();
            logger_1.serverLogger.watcherLog(`Unsubscribed from changes within: ${workspace_root_1.workspaceRoot} (outputs)`);
        }
        if (processJsonSubscription) {
            await processJsonSubscription.unsubscribe();
            logger_1.serverLogger.watcherLog(`Unsubscribed from changes within: ${workspace_root_1.workspaceRoot} (server-process.json)`);
        }
        if (watcherInstance) {
            await watcherInstance.stop();
            logger_1.serverLogger.watcherLog(`S...
function generateGeneratorOverviewOutput = function generateGeneratorOverviewOutput({ pluginName, name, description, aliases, }) {
    const ui = cliui();
    const overviewItemsLabelWidth = 
    // Chars in labels "From" and "Name"
    4 +
        // The `:` char
        1;
    let installedVersion;
    try {
        installedVersion = (0, package_json_1.readModulePackageJson)(pluginName).packageJson.version;
    }
    catch { }
    ui.div(...[
        {
            text: chalk.bold('From:'),
            padding: [1, 0, 0, 0],
            width: overviewItemsLabelWidth,
        },
        {
            text: pluginName +
                (installedVersion ? chalk.dim(` (v${installedVersion})`) : ''),
            padding: [1, 0, 0, 2],
        },
    ]);
    ui.div(...[
        {
            text: chalk.bold('Name:'),
            padding: [0, 0, 0, 0],
            width: overviewItemsLabelWidth,
        },
        {
            text: `${name}${aliases.length ? chalk.dim(` (aliases: ${aliases.join(', ')})`) : ''}`,
           ...
function getInstalledPluginsAndCapabilities = async function getInstalledPluginsAndCapabilities(workspaceRoot) {
    const plugins = findInstalledPlugins().map((p) => p.name);
    const result = new Map();
    for (const plugin of Array.from(plugins).sort()) {
        try {
            const capabilities = await (0, plugin_capabilities_1.getPluginCapabilities)(workspaceRoot, plugin);
            if (capabilities &&
                (capabilities.executors ||
                    capabilities.generators ||
                    capabilities.projectGraphExtension ||
                    capabilities.projectInference)) {
                result.set(plugin, capabilities);
            }
        }
        catch { }
    }
    return result;
}
function getGlobPatternsFromPackageManagerWorkspaces = function getGlobPatternsFromPackageManagerWorkspaces(root, readJson = (path) => (0, fileutils_1.readJsonFile)((0, node_path_1.join)(root, path)) // making this an arg allows us to reuse in devkit
) {
    try {
        const patterns = [];
        const packageJson = readJson('package.json');
        patterns.push(...normalizePatterns(Array.isArray(packageJson.workspaces)
            ? packageJson.workspaces
            : packageJson.workspaces?.packages ?? []));
        if ((0, node_fs_1.existsSync)((0, node_path_1.join)(root, 'pnpm-workspace.yaml'))) {
            try {
                const { packages } = (0, fileutils_1.readYamlFile)((0, node_path_1.join)(root, 'pnpm-workspace.yaml'));
                patterns.push(...normalizePatterns(packages || []));
            }
            catch (e) {
                output_1.output.warn({
                    title: `${logger_1.NX_PREFIX} Unable to parse pnpm-workspace.yaml`,
                    bodyLines: [e.toString()],
                })...
function withDeps = function withDeps(original, subsetNodes) {
    const res = { nodes: {}, dependencies: {} };
    const visitedNodes = [];
    const visitedEdges = [];
    Object.values(subsetNodes).forEach(recurNodes);
    Object.values(subsetNodes).forEach(recurEdges);
    return res;
    // ---------------------------------------------------------------------------
    function recurNodes(node) {
        if (visitedNodes.indexOf(node.name) > -1)
            return;
        res.nodes[node.name] = node;
        if (!res.dependencies[node.name]) {
            res.dependencies[node.name] = [];
        }
        visitedNodes.push(node.name);
        original.dependencies[node.name].forEach((n) => {
            if (original.nodes[n.target]) {
                recurNodes(original.nodes[n.target]);
            }
        });
    }
    function recurEdges(node) {
        if (visitedEdges.indexOf(node.name) > -1)
            return;
        visitedEdges.push(node.name);
        const ds = original.dependencie...
function listPluginCapabilities = async function listPluginCapabilities(pluginName) {
    const plugin = await getPluginCapabilities(workspace_root_1.workspaceRoot, pluginName);
    if (!plugin) {
        const pmc = (0, package_manager_1.getPackageManagerCommand)();
        output_1.output.note({
            title: `${pluginName} is not currently installed`,
            bodyLines: [
                `Use "${pmc.addDev} ${pluginName}" to install the plugin.`,
                `After that, use "${pmc.exec} nx g ${pluginName}:init" to add the required peer deps and initialize the plugin.`,
            ],
        });
        return;
    }
    const hasBuilders = (0, shared_1.hasElements)(plugin.executors);
    const hasGenerators = (0, shared_1.hasElements)(plugin.generators);
    const hasProjectGraphExtension = !!plugin.projectGraphExtension;
    const hasProjectInference = !!plugin.projectInference;
    if (!hasBuilders &&
        !hasGenerators &&
        !hasProjectGraphExtension &&
        !hasProjectInference) {
 ...
function allPackageJsonFiles = function allPackageJsonFiles(repoRoot, dirName) {
    const ignoredGlobs = getIgnoredGlobs(repoRoot);
    const relDirName = (0, path_1.relative)(repoRoot, dirName);
    if (relDirName &&
        (ignoredGlobs.ignores(relDirName) ||
            relDirName.indexOf(`node_modules`) > -1)) {
        return [];
    }
    let res = [];
    try {
        (0, fs_1.readdirSync)(dirName).forEach((c) => {
            const child = (0, path_1.join)(dirName, c);
            if (ignoredGlobs.ignores((0, path_1.relative)(repoRoot, child))) {
                return;
            }
            try {
                const s = (0, fs_1.statSync)(child);
                if (s.isFile() && c == 'package.json') {
                    res.push((0, path_1.relative)(repoRoot, child));
                }
                else if (s.isDirectory()) {
                    res = [...res, ...allPackageJsonFiles(repoRoot, child)];
                }
            }
            catch { }
        });
    }
    catch { }
    ...
(_tmp_15 = highlightedLines
        .split(NEWLINE)
        .slice(start, end)
        .map((line, index) => {
        const number = start + 1 + index;
        const paddedNumber = ` ${number}`.slice(-numberMaxWidth);
        const gutter = ` ${paddedNumber} | `;
        const hasMarker = markerLines[number];
        if (hasMarker) {
            let markerLine = '';
            if (Array.isArray(hasMarker)) {
                const markerSpacing = line
                    .slice(0, Math.max(hasMarker[0] - 1, 0))
                    .replace(/[^\t]/g, ' ');
                const numberOfMarkers = hasMarker[1] || 1;
                markerLine = [
                    '\n ',
                    defs.gutter(gutter.replace(/\d/g, ' ')),
                    markerSpacing,
                    defs.marker('^').repeat(numberOfMarkers),
                ].join('');
            }
            return [defs.marker('>'), defs.gutter(gutter), line, markerLine].join('');
        }
        else {
            retu...).join
function writeCache = function writeCache(cache, projectGraph) {
    perf_hooks_1.performance.mark('write cache:start');
    let retry = 1;
    let done = false;
    do {
        // write first to a unique temporary filename and then do a
        // rename of the file to the correct filename
        // this is to avoid any problems with half-written files
        // in case of crash and/or partially written files due
        // to multiple parallel processes reading and writing this file
        const unique = (Math.random().toString(16) + '0000000').slice(2, 10);
        const tmpProjectGraphPath = `${exports.nxProjectGraph}~${unique}`;
        const tmpFileMapPath = `${exports.nxFileMap}~${unique}`;
        try {
            (0, fileutils_1.writeJsonFile)(tmpProjectGraphPath, projectGraph);
            (0, fs_extra_1.renameSync)(tmpProjectGraphPath, exports.nxProjectGraph);
            (0, fileutils_1.writeJsonFile)(tmpFileMapPath, cache);
            (0, fs_extra_1.renameSync)(tmpFileMapPath, exports....
(_tmp_27 = withExcludeOption(yargs)
        .parserConfiguration({
        'strip-dashed': true,
        'unknown-options-as-args': true,
        'populate--': true,
    })
        .option('files', {
        describe: 'Change the way Nx is calculating the affected command by providing directly changed files, list of files delimited by commas or spaces',
        type: 'string',
        requiresArg: true,
        coerce: parseCSV,
    })
        .option('uncommitted', {
        describe: 'Uncommitted changes',
        type: 'boolean',
    })
        .option('untracked', {
        describe: 'Untracked changes',
        type: 'boolean',
    })
        .option('base', {
        describe: 'Base of the current branch (usually main)',
        type: 'string',
        requiresArg: true,
    })
        .option('head', {
        describe: 'Latest commit of the current branch (usually HEAD)',
        type: 'string',
        requiresArg: true,
    })
        .group(['base'], 'Run command using --base=[SHA1]...).conflicts
const p = (0, child_process_1.fork)(this.cliPath, {
                    stdio: ['inherit', 'pipe', 'pipe', 'ipc'],
                    env: this.getEnvVariablesForTask(task, process.env.FORCE_COLOR === undefined
                        ? 'true'
                        : process.env.FORCE_COLOR, null, null),
                })
function extractFileFromTarball = async function extractFileFromTarball(tarballPath, file, destinationFilePath) {
    return new Promise((resolve, reject) => {
        (0, fs_1.mkdirSync)((0, path_1.dirname)(destinationFilePath), { recursive: true });
        var tarExtractStream = tar.extract();
        const destinationFileStream = (0, fs_1.createWriteStream)(destinationFilePath);
        let isFileExtracted = false;
        tarExtractStream.on('entry', function (header, stream, next) {
            if (header.name === file) {
                stream.pipe(destinationFileStream);
                stream.on('end', () => {
                    isFileExtracted = true;
                });
                destinationFileStream.on('close', () => {
                    resolve(destinationFilePath);
                });
            }
            stream.on('end', function () {
                next();
            });
            stream.resume();
        });
        tarExtractStream.on('finish', function () {
            if (!isFil...
lockfileToSave = {
            ...lockfile,
            importers: mapValues(lockfile.importers, (importer) => {
                const normalizedImporter = {};
                if (!isEmpty(importer.specifiers ?? {}) || !isLockfileV6) {
                    normalizedImporter['specifiers'] = importer.specifiers ?? {};
                }
                if (importer.dependenciesMeta != null &&
                    !isEmpty(importer.dependenciesMeta)) {
                    normalizedImporter['dependenciesMeta'] = importer.dependenciesMeta;
                }
                for (const depType of DEPENDENCIES_FIELDS) {
                    if (!isEmpty(importer[depType] ?? {})) {
                        normalizedImporter[depType] = importer[depType];
                    }
                }
                if (importer.publishDirectory) {
                    normalizedImporter.publishDirectory = importer.publishDirectory;
                }
                return normalizedImporter;
         ...
function createWorkflow = function createWorkflow(fsHost, root, opts) {
    const NodeWorkflow = require('@angular-devkit/schematics/tools').NodeWorkflow;
    const workflow = new NodeWorkflow(fsHost, {
        force: false,
        dryRun: opts.dryRun,
        packageManager: (0, package_manager_1.detectPackageManager)(),
        root: (0, core_1.normalize)(root),
        registry: new core_1.schema.CoreSchemaRegistry(require('@angular-devkit/schematics').formats.standardFormats),
        resolvePaths: [process.cwd(), root],
    });
    workflow.registry.addPostTransform(core_1.schema.transforms.addUndefinedDefaults);
    workflow.engineHost.registerOptionsTransform(require('@angular-devkit/schematics/tools').validateOptionsWithSchema(workflow.registry));
    if (opts.interactive) {
        workflow.registry.usePromptProvider(createPromptProvider());
    }
    return workflow;
}
new Promise((res) => {
        const childProcess = (0, child_process_1.exec)(commandConfig.command, {
            maxBuffer: exports.LARGE_BUFFER,
            env: processEnv(color, cwd),
            cwd,
        });
        /**
         * Ensure the child process is killed when the parent exits
         */
        const processExitListener = (signal) => () => childProcess.kill(signal);
        process.on('exit', processExitListener);
        process.on('SIGTERM', processExitListener);
        process.on('SIGINT', processExitListener);
        process.on('SIGQUIT', processExitListener);
        childProcess.stdout.on('data', (data) => {
            process.stdout.write(addColorAndPrefix(data, commandConfig));
            if (readyWhen && data.toString().indexOf(readyWhen) > -1) {
                res(true);
            }
        });
        childProcess.stderr.on('data', (err) => {
            process.stderr.write(addColorAndPrefix(err, commandConfig));
            if (readyWhen && ...
function runExecutor = async function runExecutor(targetDescription, overrides, context) {
    return await runExecutorInternal(targetDescription, {
        ...overrides,
        __overrides_unparsed__: (0, serialize_overrides_into_command_line_1.serializeOverridesIntoCommandLine)(overrides),
    }, context.root, context.cwd, context.projectsConfigurations, context.nxJsonConfiguration, context.projectGraph, context.taskGraph, context.isVerbose);
}
_tmp_1.graph = [
        {
            command: 'graph',
            description: 'Open the project graph of the workspace in the browser',
        },
        {
            command: 'graph --file=output.json',
            description: 'Save the project graph into a json file',
        },
        {
            command: 'graph --file=output.html',
            description: 'Generate a static website with project graph into an html file, accompanied by an asset folder called static',
        },
        {
            command: 'graph --focus=todos-feature-main',
            description: 'Show the graph where every node is either an ancestor or a descendant of todos-feature-main',
        },
        {
            command: 'graph --include=project-one,project-two',
            description: 'Include project-one and project-two in the project graph',
        },
        {
            command: 'graph --exclude=project-one,project-two',
            description: 'Exclude project-one and project-two from the pro...
const promiseOrObservable = tasksRunner(tasks, {
        ...runnerOptions,
        lifeCycle: new life_cycle_1.CompositeLifeCycle(constructLifeCycles(lifeCycle)),
    }, {
        initiatingProject: nxArgs.outputStyle === 'compact' ? null : initiatingProject,
        projectGraph,
        nxJson,
        nxArgs,
        taskGraph,
        hasher: {
            hashTask(task, taskGraph_) {
                if (!taskGraph_) {
                    output_1.output.warn({
                        title: `TaskGraph is now required as an argument to hashTasks`,
                        bodyLines: [
                            `The TaskGraph object can be retrieved from the context`,
                        ],
                    });
                    taskGraph_ = taskGraph;
                }
                return hasher.hashTask(task, taskGraph_);
            },
            hashTasks(task, taskGraph_) {
                if (!taskGraph_) {
                    output_1.output.warn({
                ...
function findAllNpmDeps = function findAllNpmDeps(projectFileMap, projectNode, graph, npmDeps, seen, ignoredDependencies, dependencyPatterns, rootPatterns) {
    if (seen.has(projectNode.name))
        return;
    seen.add(projectNode.name);
    const projectFiles = (0, task_hasher_1.filterUsingGlobPatterns)(projectNode.data.root, projectFileMap[projectNode.name] || [], rootPatterns ?? dependencyPatterns);
    const projectDependencies = new Set();
    projectFiles.forEach((fileData) => fileData.deps?.forEach((dep) => projectDependencies.add((0, project_graph_1.fileDataDepTarget)(dep))));
    for (const dep of projectDependencies) {
        const node = graph.externalNodes[dep];
        if (seen.has(dep)) {
            // if it's in peerDependencies, move it to regular dependencies
            // since this is a direct dependency of the project
            if (node && npmDeps.peerDependencies[node.data.packageName]) {
                npmDeps.dependencies[node.data.packageName] = node.data.version;
          ...
function runVersionOnProjects = async function runVersionOnProjects(projectGraph, nxJson, args, tree, generatorData, projectNames, newVersionSpecifier) {
    // Should be impossible state
    if (!newVersionSpecifier) {
        devkit_exports_1.output.error({
            title: `No version or semver keyword could be determined`,
        });
        process.exit(1);
    }
    // Specifier could be user provided so we need to validate it
    if (!(0, semver_1.valid)(newVersionSpecifier) &&
        !(0, semver_2.isRelativeVersionKeyword)(newVersionSpecifier)) {
        devkit_exports_1.output.error({
            title: `The given version specifier "${newVersionSpecifier}" is not valid. You provide an exact version or a valid semver keyword such as "major", "minor", "patch", etc.`,
        });
        process.exit(1);
    }
    const generatorOptions = {
        projects: projectNames.map((p) => projectGraph.nodes[p]),
        projectGraph,
        specifier: newVersionSpecifier,
        preid: args.preid,
        ......
function findMisalignedPackagesForPackage = function findMisalignedPackagesForPackage(base) {
    const misalignedPackages = [];
    let migrateTarget = base.version;
    const { packageGroup } = (0, package_json_1.readNxMigrateConfig)(base);
    for (const entry of packageGroup ?? []) {
        const { package: packageName, version } = entry;
        // should be aligned
        if (version === '*') {
            const installedVersion = readPackageVersion(packageName);
            if (installedVersion && installedVersion !== base.version) {
                if ((0, semver_1.valid)(installedVersion) && (0, semver_1.gt)(installedVersion, migrateTarget)) {
                    migrateTarget = installedVersion;
                }
                misalignedPackages.push({
                    name: packageName,
                    version: installedVersion,
                });
            }
        }
    }
    return misalignedPackages.length
        ? {
            basePackage: base.name,
            misalignedPackages,
           ...
packages = Object.fromEntries(Object.entries(lockfile.packages ?? {}).map(([depPath, pkgSnapshot]) => {
            const newSnapshot = { ...pkgSnapshot };
            if (newSnapshot.dependencies != null) {
                newSnapshot.dependencies = mapValues(newSnapshot.dependencies, convertOldRefToNewRef);
            }
            if (newSnapshot.optionalDependencies != null) {
                newSnapshot.optionalDependencies = mapValues(newSnapshot.optionalDependencies, convertOldRefToNewRef);
            }
            return [convertOldDepPathToNewDepPath(depPath), newSnapshot];
        }))
const app = http.createServer(async (req, res) => {
        // parse URL
        const parsedUrl = new node_url_1.URL(req.url, `http://${host}:${port}`);
        // extract URL path
        // Avoid https://en.wikipedia.org/wiki/Directory_traversal_attack
        // e.g curl --path-as-is http://localhost:9000/../fileInDanger.txt
        // by limiting the path to current directory only
        const sanitizePath = (0, path_1.basename)(parsedUrl.pathname);
        if (sanitizePath === 'project-graph.json') {
            res.writeHead(200, { 'Content-Type': 'application/json' });
            res.end(JSON.stringify(currentDepGraphClientResponse));
            return;
        }
        if (sanitizePath === 'task-graph.json') {
            res.writeHead(200, { 'Content-Type': 'application/json' });
            res.end(JSON.stringify(await createTaskGraphClientResponse()));
            return;
        }
        if (sanitizePath === 'currentHash') {
            res.writeHead(200, { 'Content-Type...
