var providedOptions = typeof equalityCheckOrOptions === 'object' ? equalityCheckOrOptions : {
    equalityCheck: equalityCheckOrOptions
  }
const selector = memoize(function dependenciesChecker() {
      const params = []
      const length = dependencies.length

      for (let i = 0; i < length; i++) {
        // apply arguments instead of spreading and mutate a local list of params for performance.
        // @ts-ignore
        params.push(dependencies[i].apply(null, arguments))
      }

      // apply arguments instead of spreading for performance.
      lastResult = memoizedResultFunc.apply(null, params)
      return lastResult
    } as F)
const providedOptions =
    typeof equalityCheckOrOptions === 'object'
      ? equalityCheckOrOptions
      : { equalityCheck: equalityCheckOrOptions }
typeof equalityCheckOrOptions === 'object' ? equalityCheckOrOptions : { equalityCheck: equalityCheckOrOptions }
var value = cache.get(arguments)
lastResult = memoizedResultFunc.apply(null, params)
equalityCheck = _tmp_6.equalityCheck === void 0 ? defaultEqualityCheck : _tmp_6.equalityCheck
Object.assign(selector, {
      resultFunc,
      memoizedResultFunc,
      dependencies,
      lastResult: () => lastResult,
      recomputations: () => recomputations,
      resetRecomputations: () => (recomputations = 0)
    })
var resultSelector = selectorCreator( // @ts-ignore
  objectKeys.map(function (key) {
    return selectors[key];
  }), function () {
    for (var _len3 = arguments.length, values = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      values[_key3] = arguments[_key3];
    }

    return values.reduce(function (composition, value, index) {
      composition[objectKeys[index]] = value;
      return composition;
    }, {});
  })
const cache =
    maxSize === 1
      ? createSingletonCache(comparator)
      : createLruCache(maxSize, comparator)
exports.AllArrayKeys = AllArrayKeys
values.reduce(function (composition, value, index) {
      composition[objectKeys[index]] = value;
      return composition;
    }, {})
createSelector as CreateSelectorFunction<
    F,
    MemoizeFunction,
    MemoizeOptions
  >
type RemoveNames<T extends readonly any[]> = [any, ...T] extends [
  any,
  ...infer U
]
  ? U
  : never
const matchingEntry = entries.find(entry =>
          resultEqualityCheck(entry.value, value)
        )
exports.createStructuredSelector = createStructuredSelector
value = matchingEntry.value
cache.put(arguments, value)
return value
