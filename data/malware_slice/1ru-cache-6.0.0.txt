// File: package/index.js
// ======================================================================
Line 4: const Yallist = require('yallist')
Line 28: {
    if (typeof options === 'number')
      options = { max: options }

    if (!options)
      options = {}

    if (options.max && (typeof options.max !== 'number' || options.max < 0))
      throw new TypeError('max must be a non-negative number')
    // Kind of weird to have a default max of Infinity, but oh well.
    const max = this[MAX] = options.max || Infinity

    const lc = options.length || naiveLength
    this[LENGTH_CALCULATOR] = (typeof lc !== 'function') ? naiveLength : lc
    this[ALLOW_STALE] = options.stale || false
    if (options.maxAge && typeof options.maxAge !== 'number')
      throw new TypeError('maxAge must be a number')
    this[MAX_AGE] = options.maxAge || 0
    this[DISPOSE] = options.dispose
    this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false
    this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false
    this.reset()
  }
Line 38: const max = this[MAX] = options.max || Infinity
Line 41: this[LENGTH_CALCULATOR] = (typeof lc !== 'function') ? naiveLength : lc
Line 42: this[ALLOW_STALE] = options.stale || false
Line 45: this[MAX_AGE] = options.maxAge || 0
Line 46: this[DISPOSE] = options.dispose
Line 47: this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false
Line 48: this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false
Line 53: {
    if (typeof mL !== 'number' || mL < 0)
      throw new TypeError('max must be a non-negative number')

    this[MAX] = mL || Infinity
    trim(this)
  }
Line 57: this[MAX] = mL || Infinity
Line 58: trim(this)
Line 64: {
    this[ALLOW_STALE] = !!allowStale
  }
Line 65: this[ALLOW_STALE] = !!allowStale
Line 71: {
    if (typeof mA !== 'number')
      throw new TypeError('maxAge must be a non-negative number')

    this[MAX_AGE] = mA
    trim(this)
  }
Line 75: this[MAX_AGE] = mA
Line 76: trim(this)
Line 87: {
      this[LENGTH_CALCULATOR] = lC
      this[LENGTH] = 0
      this[LRU_LIST].forEach(hit => {
        hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key)
        this[LENGTH] += hit.length
      })
    }
Line 88: this[LENGTH_CALCULATOR] = lC
Line 89: this[LENGTH] = 0
Line 90: this[LRU_LIST].forEach(hit => {
        hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key)
        this[LENGTH] += hit.length
      })
Line 91: hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key)
Line 92: this[LENGTH] += hit.length
Line 95: trim(this)
Line 128: {
    if (this[DISPOSE] &&
        this[LRU_LIST] &&
        this[LRU_LIST].length) {
      this[LRU_LIST].forEach(hit => this[DISPOSE](hit.key, hit.value))
    }

    this[CACHE] = new Map() // hash of items by key
    this[LRU_LIST] = new Yallist() // list of items in order of use recency
    this[LENGTH] = 0 // length of items in the list
  }
Line 129: this[DISPOSE] &&
        this[LRU_LIST] &&
        this[LRU_LIST].length
Line 130: this[LRU_LIST]
Line 131: {
      this[LRU_LIST].forEach(hit => this[DISPOSE](hit.key, hit.value))
    }
Line 132: this[LRU_LIST].forEach(hit => this[DISPOSE](hit.key, hit.value))
Line 135: this[CACHE] = new Map()
Line 136: this[LRU_LIST] = new Yallist()
Line 137: this[LENGTH] = 0
Line 153: {
    maxAge = maxAge || this[MAX_AGE]

    if (maxAge && typeof maxAge !== 'number')
      throw new TypeError('maxAge must be a number')

    const now = maxAge ? Date.now() : 0
    const len = this[LENGTH_CALCULATOR](value, key)

    if (this[CACHE].has(key)) {
      if (len > this[MAX]) {
        del(this, this[CACHE].get(key))
        return false
      }

      const node = this[CACHE].get(key)
      const item = node.value

      // dispose of the old one before overwriting
      // split out into 2 ifs for better coverage tracking
      if (this[DISPOSE]) {
        if (!this[NO_DISPOSE_ON_SET])
          this[DISPOSE](key, item.value)
      }

      item.now = now
      item.maxAge = maxAge
      item.value = value
      this[LENGTH] += len - item.length
      item.length = len
      this.get(key)
      trim(this)
      return true
    }

    const hit = new Entry(key, value, len, now, maxAge)

    // oversized objects fall out of cache automatically.
    if (hit.length > th...
Line 154: maxAge = maxAge || this[MAX_AGE]
Line 160: const len = this[LENGTH_CALCULATOR](value, key)
Line 162: {
      if (len > this[MAX]) {
        del(this, this[CACHE].get(key))
        return false
      }

      const node = this[CACHE].get(key)
      const item = node.value

      // dispose of the old one before overwriting
      // split out into 2 ifs for better coverage tracking
      if (this[DISPOSE]) {
        if (!this[NO_DISPOSE_ON_SET])
          this[DISPOSE](key, item.value)
      }

      item.now = now
      item.maxAge = maxAge
      item.value = value
      this[LENGTH] += len - item.length
      item.length = len
      this.get(key)
      trim(this)
      return true
    }
Line 163: {
        del(this, this[CACHE].get(key))
        return false
      }
Line 164: del(this, this[CACHE].get(key))
Line 168: const node = this[CACHE].get(key)
Line 181: this[LENGTH] += len - item.length
Line 184: trim(this)
Line 198: this[LENGTH] += hit.length
Line 199: this[LRU_LIST].unshift(hit)
Line 200: this[CACHE].set(key, this[LRU_LIST].head)
Line 201: trim(this)
Line 205: {
    if (!this[CACHE].has(key)) return false
    const hit = this[CACHE].get(key).value
    return !isStale(this, hit)
  }
Line 207: const hit = this[CACHE].get(key).value
Line 219: {
    const node = this[LRU_LIST].tail
    if (!node)
      return null

    del(this, node)
    return node.value
  }
Line 220: const node = this[LRU_LIST].tail
Line 228: {
    del(this, this[CACHE].get(key))
  }
Line 229: del(this, this[CACHE].get(key))
Line 238: {
      const hit = arr[l]
      const expiresAt = hit.e || 0
      if (expiresAt === 0)
        // the item was created without expiration in a non aged cache
        this.set(hit.k, hit.v)
      else {
        const maxAge = expiresAt - now
        // dont add already expired items
        if (maxAge > 0) {
          this.set(hit.k, hit.v, maxAge)
        }
      }
    }
Line 239: const hit = arr[l]
Line 254: {
    this[CACHE].forEach((value, key) => get(this, key, false))
  }
Line 255: this[CACHE].forEach((value, key) => get(this, key, false))
Line 259: {
  const node = self[CACHE].get(key)
  if (node) {
    const hit = node.value
    if (isStale(self, hit)) {
      del(self, node)
      if (!self[ALLOW_STALE])
        return undefined
    } else {
      if (doUse) {
        if (self[UPDATE_AGE_ON_GET])
          node.value.now = Date.now()
        self[LRU_LIST].unshiftNode(node)
      }
    }
    return hit.value
  }
}
Line 260: const node = self[CACHE].get(key)
Line 268: {
        if (self[UPDATE_AGE_ON_GET])
          node.value.now = Date.now()
        self[LRU_LIST].unshiftNode(node)
      }
Line 271: self[LRU_LIST].unshiftNode(node)
Line 283: hit.maxAge ? diff > hit.maxAge : self[MAX_AGE] && (diff > self[MAX_AGE])
Line 284: self[MAX_AGE] && (diff > self[MAX_AGE])
Line 302: {
    const hit = node.value
    if (self[DISPOSE])
      self[DISPOSE](hit.key, hit.value)

    self[LENGTH] -= hit.length
    self[CACHE].delete(hit.key)
    self[LRU_LIST].removeNode(node)
  }
Line 307: self[LENGTH] -= hit.length
Line 308: self[CACHE].delete(hit.key)
Line 309: self[LRU_LIST].removeNode(node)
Line 331: fn.call(thisp, hit.value, hit.key, self)
