toNextSibling = curToNodeChild.___nextSibling
copyProps(renderingLogicProps, component.constructor.prototype)
function renderBody = function renderBody(err, data) {
    if (awaitInfo.finished) {
      return;
    }

    if (err) {
      awaitInfo.error = err;
    }

    if (!beforeRenderEmitted) {
      beforeRenderEmitted = true;
      out.emit("await:beforeRender", awaitInfo);
    }

    renderContents(err, data, input, asyncOut);

    awaitInfo.finished = true;

    if (clientReorder) {
      asyncOut.end();
      out.flush();
    } else {
      // When using client reordering we want to delay
      // this event until after the code to move
      // the async fragment into place has been written
      let asyncLastOut = asyncOut.beginAsync(LAST_OPTIONS);
      asyncOut.onLast(function () {
        var oldWriter = asyncOut.writer;
        // We swap out the writer so that writing will happen to our `asyncLastOut`
        // even though we are still passing along the original `asyncOut`. We have
        // to pass along the original `asyncOut` because that has contextual
        // information (such as the ren...
var el = (host.ownerDocument || host).createElementNS(
      namespaceURI,
      tagName
    )
var ownerComponent = curToNodeChild.___ownerComponent || parentComponent
curToNodeType === COMPONENT_NODE
out.emit("await:beforeRender", awaitInfo)
var rootNode = beginFragmentNode(curFromNodeChild, fromNode)
vComponentNode.___component = component = registry.___createComponent(
            typeName,
            component.id
          )
component.shouldUpdate(input, component.___state) === false
globalComponentsContext.___renderedComponentsById[id] = true
asyncOut.onLast(function () {
        var oldWriter = asyncOut.writer;
        // We swap out the writer so that writing will happen to our `asyncLastOut`
        // even though we are still passing along the original `asyncOut`. We have
        // to pass along the original `asyncOut` because that has contextual
        // information (such as the rendered UI components)
        asyncOut.writer = asyncLastOut.writer;
        out.emit("await:finish", awaitInfo);
        asyncOut.writer = oldWriter;
        asyncLastOut.end();
        out.flush();
      })
el.defaultValue = el.value = this.___value
insertVirtualComponentBefore(
              curToNodeChild,
              curFromNodeChild,
              fromNode,
              component,
              curToNodeKey,
              ownerComponent,
              parentComponent
            )
fromNode
var subscribeToOptions = target.___isComponent
      ? COMPONENT_SUBSCRIBE_TO_OPTIONS
      : NON_COMPONENT_SUBSCRIBE_TO_OPTIONS
templateRenderFunc(
      input,
      out,
      componentDef,
      component,
      component.___rawState,
      out.global
    )
fromComponent = componentByDOMNode.get(curFromNodeChild)
handleCustomEventWithMethodListener(
        this,
        targetMethodName,
        args,
        extraArgs
      )
_tmp_6.___doFinish = <lambda>16
insertBefore(
              matchingFromComponent.___rootNode,
              curFromNodeChild,
              fromNode
            )
_tmp_26.parentOut = this
curFromNodeChild =
              curFromNodeChild && nextSibling(curFromNodeChild)
curFromNodeChild && nextSibling(curFromNodeChild)
VElement.___removePreservedAttributes = function (attrs) {
  // By default this static method is a no-op, but if there are any
  // compiled components that have "no-update" attributes then
  // `preserve-attrs.js` will be imported and this method will be replaced
  // with a method that actually does something
  return attrs;
}
state.events !== state.stream
function virtualizeElement = function virtualizeElement(node, virtualizeChildNodes, ownerComponent) {
  var attributes = node.attributes;
  var attrCount = attributes.length;

  var attrs = null;
  var props = null;

  if (attrCount) {
    attrs = {};
    for (var i = 0; i < attrCount; i++) {
      var attr = attributes[i];
      var attrName = attr.name;
      if (!xmlnsRegExp.test(attrName)) {
        if (attrName === "data-marko") {
          props = componentsUtil.___getMarkoPropsFromEl(node);
        } else if (attr.namespaceURI === NS_XLINK) {
          attrs[ATTR_XLINK_HREF] = attr.value;
        } else {
          attrs[attrName] = attr.value;
        }
      }
    }
  }

  var tagName = node.nodeName;

  if (node.namespaceURI === NS_HTML) {
    tagName = tagName.toLowerCase();
  }

  var vdomEl = new VElement(
    tagName,
    attrs,
    null /*key*/,
    ownerComponent,
    0 /*child count*/,
    0 /*flags*/,
    props
  );

  if (vdomEl.___nodeName === "textarea") {
    vdomEl.___valueInternal = node...
var file = nodePath.join(dir, basename)
ownerComponent !== parentComponent
curToNodeKey += ":" + ownerComponent.id
curToNodeKey = (
          keySequences[referenceComponent.id] ||
          (keySequences[referenceComponent.id] = new KeySequence())
        ).___nextKey(curToNodeKey)
throw Error(
        "Tried to render async while in sync mode. Note: Client side await is not currently supported in re-renders (Issue: #942)."
      );
curFromNodeKey = keysByDOMNode.get(curFromNodeChild)
curVFromNodeChild = vElementByDOMNode.get(curFromNodeChild)
fromNextSibling = nextSibling(curFromNodeChild)
curFromNodeKey === curToNodeKey
var vdomEl = new VElement(
    tagName,
    attrs,
    null /*key*/,
    ownerComponent,
    0 /*child count*/,
    0 /*flags*/,
    props
  )
detachNode(curFromNodeChild, fromNode, ownerComponent)
insertVirtualNodeBefore(
                curToNodeChild,
                curToNodeKey,
                curFromNodeChild,
                fromNode,
                ownerComponent,
                parentComponent
              )
virtualizeChildNodes(node, vdomEl, ownerComponent)
walk(
    args.files,
    {
      file: function (file, context) {
        var basename = nodePath.basename(file);

        if (
          basename.endsWith(".marko.js") ||
          basename.endsWith(".marko.html") ||
          basename.endsWith(".marko.xml.js")
        ) {
          context.beginAsync();
          fs.unlink(file, function (err) {
            if (err) {
              return context.endAsync(err);
            }
            deleteCount++;
            console.log("Deleted: " + file);
            context.endAsync();
          });
        }
      },
    },
    function () {
      if (deleteCount === 0) {
        console.log("No *.marko.js files were found. Already clean.");
      } else {
        console.log("Deleted " + deleteCount + " file(s)");
      }
    }
  )
var timeoutId = this._timeoutId
{
      file: function (file, context) {
        var basename = nodePath.basename(file);

        if (
          basename.endsWith(".marko.js") ||
          basename.endsWith(".marko.html") ||
          basename.endsWith(".marko.xml.js")
        ) {
          context.beginAsync();
          fs.unlink(file, function (err) {
            if (err) {
              return context.endAsync(err);
            }
            deleteCount++;
            console.log("Deleted: " + file);
            context.endAsync();
          });
        }
      },
    }
_tmp_29.file = <lambda>10
var basename = nodePath.basename(file)
matchingFromEl = referenceComponent.___keyedElements[curToNodeKey]
matchingFromEl === undefined ||
            matchingFromEl === curFromNodeChild
fs.unlink(file, function (err) {
            if (err) {
              return context.endAsync(err);
            }
            deleteCount++;
            console.log("Deleted: " + file);
            context.endAsync();
          })
isHydrate === true && curFromNodeChild
curFromNodeChild.nodeType === ELEMENT_NODE &&
                (curToNodeChild.___preserve ||
                  caseInsensitiveCompare(
                    curFromNodeChild.nodeName,
                    curToNodeChild.___nodeName || ""
                  ))
caseInsensitiveCompare(
                    curFromNodeChild.nodeName,
                    curToNodeChild.___nodeName || ""
                  )
eventDelegation.___handleNodeDetach(node) !== false
(_tmp_9 = node.parentNode).removeChild
curVFromNodeChild = virtualizeElement(curFromNodeChild)
console.log("No *.marko.js files were found. Already clean.")
vElementByDOMNode.set(curFromNodeChild, curVFromNodeChild)
var fragment = createFragmentNode(
                    curFromNodeChild,
                    endNode.nextSibling,
                    fromNode
                  )
failed.push(
            'Failed to write "' + path + '". Error: ' + (err.stack || err)
          )
'Failed to write "' + path + '". Error: ' + (err.stack || err)
state.events.on(event, callback)
keysByDOMNode.set(fragment, curToNodeKey)
vElementByDOMNode.set(fragment, curToNodeChild)
referenceComponent.___keyedElements[curToNodeKey] = fragment
state.___set(name, value, true /* ensure:true */)
var lastArray = this._last
this.___vnode = node = vdomTree.___actualize(host, null)
morphdom(node, vdomTree, host, this.___components)
_tmp_4.setStateDirty = <lambda>14
var state = this.___state
fromNextSibling = curFromNodeChild
detachedByDOMNode.get(matchingFromEl) !== undefined
detachedByDOMNode.set(matchingFromEl, undefined)
curVFromNodeChild = vElementByDOMNode.get(matchingFromEl)
var container = docFragment.ownerDocument.createElement("div")
(function next() {
        if (i === lastArray.length) {
          return;
        }
        var lastCallback = lastArray[i++];
        lastCallback(next);

        if (lastCallback.length === 0) {
          next();
        }
      })()
toNextSibling &&
                    toNextSibling.___key === curFromNodeKey
var promise = new Promise(function (resolve, reject) {
      out.on("error", reject).on(EVENT_FINISH, function (result) {
        resolve(result);
      });
    })
insertBefore(matchingFromEl, curFromNodeChild, fromNode)
fromNextSibling = nextSibling(fromNextSibling)
console.log("Compiled " + compileCount + " templates(s)")
insertAfter(matchingFromEl, curFromNodeChild, fromNode)
detachNode(curFromNodeChild, fromNode, ownerComponent)
morphEl(
                  matchingFromEl,
                  curVFromNodeChild,
                  curToNodeChild,
                  parentComponent
                )
this.___queueUpdate()
e = new Error(JSON.stringify(e))
_tmp_4.___queueUpdate = <lambda>18
insertVirtualNodeBefore(
                  curToNodeChild,
                  curToNodeKey,
                  curFromNodeChild,
                  fromNode,
                  ownerComponent,
                  parentComponent
                )
"\nRendered by" +
        (name ? " " + name : "") +
        (stack ? ":\n" + stack : "")
stack ? ":\n" + stack : ""
_tmp_4.update = <lambda>19
this.emit("error", e)
detachNode(matchingFromEl, fromNode, ownerComponent)
processUpdateHandlers(this, state.___changes, state.___old, state)
curToNodeChild = toNextSibling
fromNextSibling = nextSibling(curFromNodeChild)
fromComponent = componentByDOMNode.get(curFromNodeChild)
destroyComponent(fromComponent)
curFromNodeType === curToNodeType
curFromNodeType === ELEMENT_NODE
curVFromNodeChild = vElementByDOMNode.get(curFromNodeChild)
selfClosingTags.svgElements.indexOf(tagName) !== -1
curVFromNodeChild = virtualizeElement(curFromNodeChild)
caseInsensitiveCompare(
                    curVFromNodeChild.___nodeName,
                    curToNodeChild.___nodeName
                  )
self.___rerender(input, false).afterInsert(self.___host)
curToNodeChild.___nodeName
curVFromNodeChild.___nodeName = curToNodeChild.___nodeName
compareNodeNames(curVFromNodeChild, curToNodeChild) === true
morphEl(
                curFromNodeChild,
                curVFromNodeChild,
                curToNodeChild,
                parentComponent
              )
var targetNode = out.___getOutput().___firstChild
this.write(str)
morphdom(rootNode, targetNode, host, componentsContext)
this._elStack
curFromNodeType === TEXT_NODE ||
            curFromNodeType === COMMENT_NODE
this.___domEventListenerHandles = null
_tmp_46 = __ecma.Array.factory()
toNextSibling.___nodeType === TEXT_NODE
curFromNodeChild.nodeValue !== curToNodeChild.___nodeValue
curToNodeChild = toNextSibling
detachNode(curFromNodeChild, fromNode, ownerComponent)
insertVirtualNodeBefore(
        curToNodeChild,
        curToNodeKey,
        curFromNodeChild,
        fromNode,
        ownerComponent,
        parentComponent
      )
var preserve = this._elStack.pop()
if ("MARKO_DEBUG") {
      complain(
        'The "this.els" attribute is deprecated. Please use "this.getEls(key)" instead.'
      );
    }
complain(
        'The "this.els" attribute is deprecated. Please use "this.getEls(key)" instead.'
      )
"The "this.els" attribute is deprecated. Please use "this.getEls(key)" instead."
parentComponent
curToNodeChild = toNextSibling
var fragmentBoundary =
        fromNode.nodeType === FRAGMENT_NODE ? fromNode.endNode : null
fromNode.nodeType === FRAGMENT_NODE ? fromNode.endNode : null
curFromNodeChild && curFromNodeChild !== fragmentBoundary
fromNextSibling = nextSibling(curFromNodeChild)
fromComponent = componentByDOMNode.get(curFromNodeChild)
curFromNodeChild = fromNextSibling
destroyComponent(fromComponent)
curVFromNodeChild = vElementByDOMNode.get(curFromNodeChild)
curFromNodeKey = keysByDOMNode.get(fromNode)
componentProto.___update = componentProto.update
referenceComponent =
            curVFromNodeChild && curVFromNodeChild.___ownerComponent
curVFromNodeChild && curVFromNodeChild.___ownerComponent
detachNode(curFromNodeChild, fromNode, referenceComponent)
var detachedFromComponent = detachedByDOMNode.get(node)
detachedFromComponent !== undefined
detachedByDOMNode.set(node, undefined)
var componentToDestroy = componentByDOMNode.get(node)
