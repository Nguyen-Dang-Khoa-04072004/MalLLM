(function walk(node) {
    if (ts20.isTypeReferenceNode(node) && ts20.isIdentifier(node.typeName)) {
      const declaration = reflector.getDeclarationOfIdentifier(node.typeName);
      if (declaration !== null) {
        if (declaration.node.getSourceFile() !== contextFile) {
          const emittedType = refEmitter.emit(new Reference(declaration.node), contextFile, ImportFlags.NoAliasing | ImportFlags.AllowTypeImports | ImportFlags.AllowRelativeDtsImports);
          assertSuccessfulReferenceEmit(emittedType, node, "type");
        } else if (!reflector.isStaticallyExported(declaration.node)) {
          throw new FatalDiagnosticError(ErrorCode.SYMBOL_NOT_EXPORTED, type, `Symbol must be exported in order to be used as the type of an Input transform function`, [makeRelatedInformation(declaration.node, `The symbol is declared here.`)]);
        }
      }
    }
    node.forEachChild(walk);
  })(type)
ts20.isTypeReferenceNode(node) && ts20.isIdentifier(node.typeName)
const declaration = reflector.getDeclarationOfIdentifier(node.typeName)
this.config = config
const emittedType = refEmitter.emit(new Reference(declaration.node), contextFile, ImportFlags.NoAliasing | ImportFlags.AllowTypeImports | ImportFlags.AllowRelativeDtsImports)
const fnName = ts25.factory.createIdentifier(`_tcb_${this.ref.node.pos}`)
this.perf.inPhase(PerfPhase.TtcAutocompletion, () => engine.getGlobalCompletions(context, node))
const type = this.refEmitter.emit(exportRef, context)
assertSuccessfulReferenceEmit(type, node, "NgModule")
const directives = remoteScope.directives.map((directive) => {
          const type = this.refEmitter.emit(directive, context);
          assertSuccessfulReferenceEmit(type, node, "directive");
          return type.expression;
        })
const type = this.refEmitter.emit(directive, context)
assertSuccessfulReferenceEmit(type, node, "directive")
const sfPath = absoluteFromSourceFile(sf)
const pipes = remoteScope.pipes.map((pipe) => {
          const type = this.refEmitter.emit(pipe, context);
          assertSuccessfulReferenceEmit(type, node, "pipe");
          return type.expression;
        })
const type = this.refEmitter.emit(pipe, context)
assertSuccessfulReferenceEmit(type, node, "pipe")
(_tmp_1223 = this.typeCheckAdapter).typeCheck
