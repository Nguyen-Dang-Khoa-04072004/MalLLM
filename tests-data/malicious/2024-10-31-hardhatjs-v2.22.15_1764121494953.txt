function printRecommendedDepsInstallationInstructions = async function printRecommendedDepsInstallationInstructions(projectType) {
    console.log(`You need to install these dependencies to run the sample project:`);
    const cmd = await getRecommendedDependenciesInstallationCommand(await getDependencies(projectType));
    console.log(`  ${cmd.join(" ")}`);
}
_tmp_31.description = "You are trying to run Hardhat outside of a Hardhat project, and we couldn't initialize one.

If you were trying to create a new project, please try again using Windows Subsystem for Linux (WSL) or PowerShell.

You can learn how to use Hardhat by reading the [Getting Started guide](/hardhat-runner/docs/getting-started)."
function getAction = async function getAction(isEsm) {
    if (process.env.HARDHAT_CREATE_JAVASCRIPT_PROJECT_WITH_DEFAULTS !== undefined) {
        return Action.CREATE_JAVASCRIPT_PROJECT_ACTION;
    }
    else if (process.env.HARDHAT_CREATE_TYPESCRIPT_PROJECT_WITH_DEFAULTS !== undefined) {
        return Action.CREATE_TYPESCRIPT_PROJECT_ACTION;
    }
    else if (process.env.HARDHAT_CREATE_TYPESCRIPT_VIEM_PROJECT_WITH_DEFAULTS !==
        undefined) {
        return Action.CREATE_TYPESCRIPT_VIEM_PROJECT_ACTION;
    }
    const { default: enquirer } = await Promise.resolve().then(() => __importStar(require("enquirer")));
    try {
        const actionResponse = await enquirer.prompt([
            {
                name: "action",
                type: "select",
                message: "What do you want to do?",
                initial: 0,
                choices: Object.values(Action)
                    .filter((a) => {
                    if (isEsm && a === Action.CREATE_TYPESCRIPT_VIEM_PROJECT_ACTIO...
subtask(
  TASK_FLATTEN_GET_FLATTENED_SOURCE_AND_METADATA,
  "Returns all contracts and their dependencies flattened. Also return metadata about pragma directives and SPDX licenses"
)
  .addOptionalParam("files", undefined, undefined, types.any)
  .setAction(
    async (
      { files }: { files?: string[] },
      { run }
    ): Promise<[string, FlattenMetadata | null]> => {
      const dependencyGraph: DependencyGraph = await run(
        TASK_FLATTEN_GET_DEPENDENCY_GRAPH,
        { files }
      );

      let flattened = "";

      if (dependencyGraph.getResolvedFiles().length === 0) {
        return [flattened, null];
      }

      const packageJson = await getPackageJson();
      flattened += `// Sources flattened with hardhat v${packageJson.version} https://hardhat.org`;

      const sortedFiles = getSortedFiles(dependencyGraph);

      const [licenses, filesWithoutLicenses] = getLicensesInfo(sortedFiles);
      const [
        pragmaDirective,
        filesWithoutPragmaDirec...
function edrTracingStepToMinimalInterpreterStep = function edrTracingStepToMinimalInterpreterStep(
  step: TracingStep
): MinimalInterpreterStep {
  const minimalInterpreterStep: MinimalInterpreterStep = {
    pc: Number(step.pc),
    depth: step.depth,
    opcode: {
      name: step.opcode,
    },
    stack: step.stack,
  };

  if (step.memory !== undefined) {
    minimalInterpreterStep.memory = step.memory;
  }

  return minimalInterpreterStep;
}
function mergeCompilationJobsWithBug = function mergeCompilationJobsWithBug(
  compilationJobs: taskTypes.CompilationJob[]
): taskTypes.CompilationJob[] {
  return mergeCompilationJobs(compilationJobs, (job) => job.hasSolc9573Bug());
}
const inputFile: CLIArgumentType<string> = {
  name: "inputFile",
  parse(argName: string, strValue: string): string {
    try {
      fs.accessSync(strValue, fsExtra.constants.R_OK);
      const stats = fs.lstatSync(strValue);

      if (stats.isDirectory()) {
        // This is caught and encapsulated in a hardhat error.
        // eslint-disable-next-line @nomicfoundation/hardhat-internal-rules/only-hardhat-error
        throw new Error(`${strValue} is a directory, not a file`);
      }
    } catch (error) {
      if (error instanceof Error) {
        throw new HardhatError(
          ERRORS.ARGUMENTS.INVALID_INPUT_FILE,
          {
            name: argName,
            value: strValue,
          },
          error
        );
      }

      // eslint-disable-next-line @nomicfoundation/hardhat-internal-rules/only-hardhat-error
      throw error;
    }

    return strValue;
  },

  /**
   * Check if argument value is of type "inputFile"
   * File string validation succeeds if it can be ...
_tmp_28.choices = Object.values(Action)
                    .filter((a) => {
                    if (isEsm && a === Action.CREATE_TYPESCRIPT_VIEM_PROJECT_ACTION) {
                        // we omit the viem option for ESM projects to avoid showing
                        // two disabled options
                        return false;
                    }
                    return true;
                })
                    .map((a) => {
                    let message;
                    if (isEsm) {
                        if (a === Action.CREATE_EMPTY_HARDHAT_CONFIG_ACTION) {
                            message = a.replace(".js", ".cjs");
                        }
                        else if (a === Action.CREATE_TYPESCRIPT_PROJECT_ACTION) {
                            message = `${a} (not available for ESM projects)`;
                        }
                        else {
                            message = a;
                        }
                    }
                    else {
   ...
exports.inputFile = {
    name: "inputFile",
    parse(argName, strValue) {
        try {
            fs.accessSync(strValue, fs_extra_1.default.constants.R_OK);
            const stats = fs.lstatSync(strValue);
            if (stats.isDirectory()) {
                // This is caught and encapsulated in a hardhat error.
                // eslint-disable-next-line @nomicfoundation/hardhat-internal-rules/only-hardhat-error
                throw new Error(`${strValue} is a directory, not a file`);
            }
        }
        catch (error) {
            if (error instanceof Error) {
                throw new errors_1.HardhatError(errors_list_1.ERRORS.ARGUMENTS.INVALID_INPUT_FILE, {
                    name: argName,
                    value: strValue,
                }, error);
            }
            // eslint-disable-next-line @nomicfoundation/hardhat-internal-rules/only-hardhat-error
            throw error;
        }
        return strValue;
    },
    /**
     * Check if arg...
function printAlreadySetKeys = function printAlreadySetKeys(varsManagerSetup: VarsManagerSetup) {
  const requiredKeysAlreadySet = varsManagerSetup.getRequiredVarsAlreadySet();
  const optionalKeysAlreadySet = varsManagerSetup.getOptionalVarsAlreadySet();
  const envVars = varsManagerSetup.getEnvVars();

  if (
    requiredKeysAlreadySet.length === 0 &&
    optionalKeysAlreadySet.length === 0 &&
    envVars.length === 0
  ) {
    return;
  }

  console.log(
    `${chalk.bold(`${emoji("✔️  ")}Configuration variables already set:`)}`
  );
  console.log();

  if (requiredKeysAlreadySet.length > 0) {
    console.log("  Mandatory:");
    console.log(requiredKeysAlreadySet.map((x) => `    ${x}`).join("\n"));
    console.log();
  }

  if (optionalKeysAlreadySet.length > 0) {
    console.log("  Optional:");
    console.log(optionalKeysAlreadySet.map((x) => `    ${x}`).join("\n"));
    console.log();
  }

  if (envVars.length > 0) {
    console.log("  Set via environment variables:");
    console.log(envVars.map((x) => ` ...
_tmp_15.INVALID_BIG_NUMBER = {
      number: 17,
      message: "The input value cannot be normalized to a BigInt: %message%",
      title: "Invalid big number",
      description:
        "Hardhat attempted to convert the input value to a BigInt, but no known conversion method was applicable to the given value.",
      shouldBeReported: false,
    }
_tmp_16.ESM_PROJECT_WITHOUT_CJS_CONFIG = {
            number: 19,
            message: `Your project is an ESM project (you have "type": "module" set in your package.json) but your Hardhat config file uses the .js extension.

Rename the file to use the .cjs to fix this problem.`,
            title: "Hardhat config with .js extension in an ESM project",
            description: "Your project is an ESM project but your Hardhat config uses the .js extension. Hardhat config files cannot be an ES module. To fix this, rename your Hardhat config to use the .cjs extension.",
            shouldBeReported: false,
        }
throw new HardhatError(
          ERRORS.RESOLVER.INVALID_IMPORT_WRONG_CASING,
          {
            imported,
            from: from.sourceName,
          },
          error
        );
function printRecommendedDepsInstallationInstructions = async function printRecommendedDepsInstallationInstructions(
  projectType: SampleProjectTypeCreationAction
) {
  console.log(
    `You need to install these dependencies to run the sample project:`
  );

  const cmd = await getRecommendedDependenciesInstallationCommand(
    await getDependencies(projectType)
  );

  console.log(`  ${cmd.join(" ")}`);
}
function arePreviousMtimesCorrect = function arePreviousMtimesCorrect(mtimes) {
    try {
        return Object.entries(mtimes).every(([file, mtime]) => fs.statSync(file).mtime.valueOf() === mtime);
    }
    catch {
        return false;
    }
}
const provider = await Provider.withConfig(
      getGlobalEdrContext(),
      {
        allowBlocksWithSameTimestamp:
          config.allowBlocksWithSameTimestamp ?? false,
        allowUnlimitedContractSize: config.allowUnlimitedContractSize,
        bailOnCallFailure: config.throwOnCallFailures,
        bailOnTransactionFailure: config.throwOnTransactionFailures,
        blockGasLimit: BigInt(config.blockGasLimit),
        chainId: BigInt(config.chainId),
        chains: Array.from(config.chains, ([chainId, hardforkConfig]) => {
          return {
            chainId: BigInt(chainId),
            hardforks: Array.from(
              hardforkConfig.hardforkHistory,
              ([hardfork, blockNumber]) => {
                return {
                  blockNumber: BigInt(blockNumber),
                  specId: ethereumsjsHardforkToEdrSpecId(
                    getHardforkName(hardfork)
                  ),
                };
              }
            ),
          };
        }),
    ...
_tmp_15.NETWORK = {
        CONFIG_NOT_FOUND: {
            number: 100,
            message: "Network %network% doesn't exist",
            title: "Selected network doesn't exist",
            description: `You are trying to run Hardhat with a nonexistent network.

Read the [documentation](https://hardhat.org/hardhat-runner/docs/config#networks-configuration) to learn how to define custom networks.`,
            shouldBeReported: false,
        },
        INVALID_GLOBAL_CHAIN_ID: {
            number: 101,
            message: "Hardhat was set to use chain id %configChainId%, but connected to a chain with id %connectionChainId%.",
            title: "Connected to the wrong network",
            description: `Your config specifies a chain id for the network you are trying to use, but Hardhat detected a different chain id.

Please make sure you are setting your config correctly.`,
            shouldBeReported: false,
        },
        ETHSIGN_MISSING_DATA_PARAM: {
            number: 102,
           ...
errors.push(getErrorMessage(`HardhatConfig.networks.${constants_1.HARDHAT_NETWORK_NAME}.accounts`, hardhatNetwork.accounts, "[{privateKey: string, balance: string}] | HardhatNetworkHDAccountsConfig | undefined"))
_tmp_39.description = "You are trying to initialize a project but you are not in an interactive shell.

Please re-run the command inside an interactive shell."
function getMaximalMnemonicPhrase = function getMaximalMnemonicPhrase(
  matches: WordMatch[],
  originalMessage: string,
  startIndex: number,
  mnemonicWordlist: string[]
): WordMatch[] {
  const maximalPhrase: WordMatch[] = [];
  for (let i = startIndex; i < matches.length; i++) {
    const thisMatch = matches[i];
    if (!mnemonicWordlist.includes(thisMatch.word)) {
      break;
    }

    if (maximalPhrase.length > 0) {
      // Check that there's only whitespace until this word.
      const lastMatch = maximalPhrase[maximalPhrase.length - 1];
      const lastIndex = lastMatch.index + lastMatch.word.length;
      const sliceBetweenWords = originalMessage.slice(
        lastIndex,
        thisMatch.index
      );
      if (!/\s+/u.test(sliceBetweenWords)) {
        break;
      }
    }

    maximalPhrase.push(thisMatch);
  }
  return maximalPhrase;
}
_tmp_41.NOT_LOCAL_ACCOUNT = {
            number: 103,
            message: "Account %account% is not managed by the node you are connected to.",
            title: "Unrecognized account",
            description: `You are trying to send a transaction or sign some data with an
account not managed by your Ethereum node nor Hardhat.

Please double check your accounts and the \`from\` parameter in your RPC calls.`,
            shouldBeReported: false,
        }
const compilationJobsCreationResults = await Promise.all(
        connectedComponents.map((graph) =>
          createCompilationJobsFromConnectedComponent(
            graph,
            (file: taskTypes.ResolvedFile) =>
              run(TASK_COMPILE_SOLIDITY_GET_COMPILATION_JOB_FOR_FILE, {
                file,
                dependencyGraph,
                solidityFilesCache,
              })
          )
        )
      )
errors.push(`'enableTransientStorage' cannot be enabled if the hardfork is explicitly set to a pre-cancun value. If you want to use transient storage, use 'cancun' as the hardfork.`)
function resolvePathFrom = function resolvePathFrom(from, defaultPath, relativeOrAbsolutePath = defaultPath) {
    if (path_1.default.isAbsolute(relativeOrAbsolutePath)) {
        return relativeOrAbsolutePath;
    }
    return path_1.default.join(from, relativeOrAbsolutePath);
}
_tmp_9.operation = <operator>.formatString("Responding with "", actionResponse.action, "" to the project initialization wizard")
(proxiedHre as any).adhocProfileSync = (_name: string, f: () => any) => {
        const adhocProfile = createTaskProfile(_name);
        taskProfile!.children.push(adhocProfile);
        try {
          return f();
        } finally {
          completeTaskProfile(adhocProfile);
        }
      }
function getCachedCompletionData = async function getCachedCompletionData(
  projectId: string
): Promise<CachedCompletionData | undefined> {
  const cachedCompletionDataPath = await getCachedCompletionDataPath(projectId);

  if (fs.existsSync(cachedCompletionDataPath)) {
    try {
      const cachedCompletionData = fs.readJsonSync(cachedCompletionDataPath);
      return cachedCompletionData;
    } catch {
      // remove the file if it seems invalid
      fs.unlinkSync(cachedCompletionDataPath);
      return undefined;
    }
  }
}
taskName === TASK_TEST &&
      !isRunningOnCiServer() &&
      process.stdout.isTTY === true
_tmp_49.message = "Received invalid value `%value%` from/to the node's JSON-RPC, but a Quantity was expected."
throw new errors_1.HardhatError(errors_list_1.ERRORS.TASK_DEFINITIONS.MANDATORY_PARAM_AFTER_OPTIONAL, {
                paramName: name,
                taskName: this.name,
            });
function showStarOnGitHubMessage = function showStarOnGitHubMessage() {
  console.log(
    chalk.cyan("Give Hardhat a star on Github if you're enjoying it!") +
      emoji(" ⭐️✨")
  );
  console.log();
  console.log(chalk.cyan("     https://github.com/NomicFoundation/hardhat"));
}
await wasmDownloader.downloadCompiler(solcVersion, async (isCompilerDownloaded) => {
        // callback called before compiler download
        await run(task_names_1.TASK_COMPILE_SOLIDITY_LOG_DOWNLOAD_COMPILER_START, {
            solcVersion,
            isCompilerDownloaded,
            quiet,
        });
    }, 
    // callback called after compiler download
    async (isCompilerDownloaded) => {
        await run(task_names_1.TASK_COMPILE_SOLIDITY_LOG_DOWNLOAD_COMPILER_END, {
            solcVersion,
            isCompilerDownloaded,
            quiet,
        });
    })
