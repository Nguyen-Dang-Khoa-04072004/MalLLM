var fs = (function patchFs(_fs) {
    'use strict';
    _fs.readlink = _fs.readlinkSync || _fs.readlink;
    if (!_fs.hasOwnProperty('absolute')) {
        var _path = require('path');
        _fs.absolute = function absolute(path) {
            return _path.resolve(path);
        };
    }
    if (_fs.hasOwnProperty('base')) {
        _fs.basename = _fs.base;
    } else if (!_fs.hasOwnProperty('basename')) {
        _fs.basename = function basename(path) {
            return path.replace(/.*\//, '');
        };
    }
    if (_fs.hasOwnProperty('directory')) {
        _fs.dirname = _fs.directory;
    } else if (!_fs.hasOwnProperty('dirname')) {
        _fs.dirname = function dirname(path) {
            if (!path) {
                return null;
            }
            return path.toString().replace(/\\/g, '/').replace(/\/[^\/]*$/, '');
        };
    }
    if (!_fs.hasOwnProperty('islink')) {
        _fs.islink = function islink(path) {
            return fs.lstatSync(path).isSymbolicLi...
QueryString.unescapeBuffer = function(s, decodeSpaces) {
  var out = new Buffer(s.length);
  var state = 'CHAR'; // states: CHAR, HEX0, HEX1
  var n, m, hexchar;

  for (var inIndex = 0, outIndex = 0; inIndex <= s.length; inIndex++) {
    var c = s.charCodeAt(inIndex);
    switch (state) {
      case 'CHAR':
        switch (c) {
          case charCode('%'):
            n = 0;
            m = 0;
            state = 'HEX0';
            break;
          case charCode('+'):
            if (decodeSpaces) c = charCode(' ');
            // pass thru
          default:
            out[outIndex++] = c;
            break;
        }
        break;

      case 'HEX0':
        state = 'HEX1';
        hexchar = c;
        if (charCode('0') <= c && c <= charCode('9')) {
          n = c - charCode('0');
        } else if (charCode('a') <= c && c <= charCode('f')) {
          n = c - charCode('a') + 10;
        } else if (charCode('A') <= c && c <= charCode('F')) {
          n = c - charCode('A') +...
casper.each(terms, function(casper, term, i) {
    this.echo('Fetching score for ' + term);
    this.then(function() {
        this.fill('form[action="/search"]', {q: '"' + term + '"'}, true);
    });
    this.then(function() {
        var score = this.fetchScore();
        scores.push({
            term: term,
            score: score
        });
        this.echo(term + ': ' + score);
    });
})
void function() {

    // cujos bind shim instead of MDN shim, see #1396
    var isFunction = function(o) {
      return 'function' === typeof o;
    };
    var bind;
    var slice = [].slice;
    var proto = Function.prototype;
    var featureMap = {
      'function-bind': 'bind'
    };
    function has(feature) {
      var prop = featureMap[feature];
      return isFunction(proto[prop]);
    }
    // check for missing features
    if (!has('function-bind')) {
      // adapted from Mozilla Developer Network example at
      // https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function/bind
      bind = function bind(obj) {
        var args = slice.call(arguments, 1),
          self = this,
          nop = function() {
          },
          bound = function() {
            return self.apply(this instanceof nop ? this : (obj || {}), args.concat(slice.call(arguments)));
          };
        nop.prototype = this.prototype || {}; // Firefox cries sometimes if prototy...
var extract = {
        args: [],
        options: {},
        raw: {
            args: [],
            options: {}
        },
        drop: function drop(what) {
            if (utils.isNumber(what)) {
                // deleting an arg by its position
                this.args = this.args.filter(function _filter(arg, index) {
                    return index !== what;
                });
                // raw
                if ('raw' in this) {
                    this.raw.args = this.raw.args.filter(function _filter(arg, index) {
                        return index !== what;
                    });
                }
            } else if (utils.isString(what)) {
                // deleting an arg by its value
                this.args = this.args.filter(function _filter(arg) {
                    return arg !== what;
                });
                // deleting an option by its name (key)
                delete this.options[what];
                // raw
                if ('raw...
this.wait(1000, function() {
            this.then(next);
            currentLink++;
        })
EventEmitter.prototype.setMaxListeners = function(nb) {
    "use strict";
    if (!this._events) {
        this._events = {};
    }
    this._maxListeners = nb;
}
buildPage = function() {
    var fs, pageHtml;
    this.echo("Build result page");
    fs = require("fs");
    this.viewport(624, 400);
    pageHtml = "<html><body style='background:black;margin:0;padding:0'>";
    images.forEach(function(image) {
        pageHtml += "<img src='file://" + fs.workingDirectory + "/" + image + "'><br>";
    });
    pageHtml += "</body></html>";
    fs.write("result.html", pageHtml, 'w');
    this.thenOpen("file://" + fs.workingDirectory + "/result.html", function() {
        this.echo("Resulting image saved to result.png");
        this.capture("result.png");
    });
}
function selectXPath = function selectXPath(expression) {
    "use strict";
    return {
        type: 'xpath',
        path: expression,
        toString: function() {
            return this.type + ' selector: ' + this.path;
        }
    };
}
this.thenOpen("file://" + fs.workingDirectory + "/result.html", function() {
        this.echo("Resulting image saved to result.png");
        this.capture("result.png");
    })
this.raw.args = this.raw.args.filter(function _filter(arg) {
                        return arg !== what;
                    })
this.__call = function __call(method, args) {
            if (method === "__call") {
                return;
            }
            try {
                return this[method].apply(this, args);
            } catch (err) {
                err.__isCallError = true;
                return err;
            }
        }
throw new CasperError("Unsupported cli arg tester " + typeof what);
var CASPER_PATH = fs.absolute(fs.pathJoin(fs.dirname(fs.scriptDir(system.args)), '..'))
var SYS_ARGS = typeof phantom !== 'undefined' ? system.args.slice(1) : system.args.slice(2)
basenames.forEach(function(basename) {
                paths.push(fs.absolute(fs.pathJoin(dir, basename)));
                extensions.forEach(function(extension) {
                    paths.push(fs.absolute(fs.pathJoin(dir, [basename, extension].join('.'))));
                });
            })
ENGINE_NATIVE_ARGS_WITH_SPACE.indexOf(SYS_ARGS[i]) !== -1
system.stderr.write('Fatal: Missing expected value for parameter "' + SYS_ARGS[i] + '"\n')
var CASPER_COMMAND = [ENGINE_EXECUTABLE].concat(ENGINE_ARGS).concat([
    fs.pathJoin(CASPER_PATH, 'bin', 'bootstrap.js'),
    '--casper-path=' + CASPER_PATH,
    '--cli'
]).concat(CASPER_ARGS)
Casper.prototype.callUtils = function callUtils(method) {
    "use strict";
    var args = [].slice.call(arguments, 1);
    var result = this.evaluate(function(method, args) {
        return __utils__.__call(method, args);
    }, method, args);
    if (utils.isObject(result) && result.__isCallError) {
        throw new CasperError(f("callUtils(%s) with args %s thrown an error: %s",
                              method, args, result.message));
    }
    return result;
}
resolveFile(path, fs.pathJoin(phantom.casperPath, 'modules'))
var args = [].slice.call(arguments, 1)
out.fields[fieldSelector] = this.setFieldValue(this.makeSelector(fieldSelector, findType), vals[fieldSelector], form)
child.stdout.on('data', function (data) {
    'use strict';
    system.stdout.write(data + "\n");
})
system.stdout.write(data + "\n")
formatted += value.map(function(entry) {
                return format('in %s() in %s:%d', (entry['function'] || "anonymous"), entry.file, entry.line);
            }).join('\n')
var patchedRequire = function patchedRequire(path) {
            try {
                return require(casperBuiltinPath(path) ||
                               nodeModulePath(path)    ||
                               localModulePath(path)   ||
                               path);
            } catch (e) {
                throw new CasperError("Can't find module " + path);
            }
        }
