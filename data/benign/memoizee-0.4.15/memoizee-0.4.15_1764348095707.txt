defineProperties(
				function (obj) {
					var result, args = arguments;
					if (resolve) args = resolve(args);
					obj = args[0];
					if (map.has(obj)) return map.get(obj);
					result = fn.apply(this, args);
					if (map.has(obj)) {
						throw customError("Circular invocation", "CIRCULAR_INVOCATION");
					}
					map.set(obj, result);
					return result;
				},
				{
					__memoized__: d(true),
					delete: d(function (obj) {
						if (resolve) obj = resolve(arguments)[0];
						return map.delete(obj);
					})
				}
			)
throw new Error(
					"Memoizee error: Detected unordered then|done & finally resolution, which " +
						"in turn makes proper detection of success/failure impossible (when in " +
						"'done:finally' mode)\n" +
						"Consider to rely on 'then' or 'done' mode instead."
				);
i = indexOf.call(set[0], args[index])
resolve = resolveResolve(options.resolvers)
toPrc = function (initialCount, cachedCount) {
		if (!initialCount && !cachedCount) {
			return "0.00";
		}
		return ((cachedCount / (initialCount + cachedCount)) * 100).toFixed(2);
	}
memoized = defineLength(function (arg) {
			var id, result, args = arguments;
			if (resolve) args = resolve(args);
			id = get(args);
			if (id !== null) {
				if (hasOwnProperty.call(cache, id)) {
					if (getListeners) conf.emit("get", id, args, this);
					return cache[id];
				}
			}
			if (args.length === 1) result = call.call(original, this, args[0]);
			else result = apply.call(original, this, args);
			if (id === null) {
				id = get(args);
				if (id !== null) throw customError("Circular invocation", "CIRCULAR_INVOCATION");
				id = set(args);
			} else if (hasOwnProperty.call(cache, id)) {
				throw customError("Circular invocation", "CIRCULAR_INVOCATION");
			}
			cache[id] = result;
			if (setListeners) conf.emit("set", id, null, result);
			return result;
		}, memLength)
(_tmp_8 = (cachedCount / (initialCount + cachedCount)) * 100).toFixed
currentCallback = currentContext = currentArgs = null
nextTick(function () {
			var data;
			if (hasOwnProperty.call(cache, id)) {
				data = cache[id];
				conf.emit("getasync", id, args, context);
				apply.call(cb, data.context, data.args);
			} else {
				// Purged in a meantime, we shouldn't rely on cached value, recall
				currentCallback = cb;
				currentContext = context;
				currentArgs = args;
				base.apply(context, args);
			}
		})
log = "------------------------------------------------------------\n"
result = call.call(original, this, args[0])
result = apply.call(original, this, args)
delete preFetchTimeouts[id]
_tmp_9 = __ecma.Array.factory()
memoized = defineProperties(
			defineLength(function (obj) {
				var memoizer, args = arguments;
				if (resolve) {
					args = resolve(args);
					obj = args[0];
				}
				memoizer = map.get(obj);
				if (!memoizer) {
					if (normalizer) {
						options = copy(options);
						options.normalizer = copy(normalizer);
						options.normalizer.get = partial.call(options.normalizer.get, obj);
						options.normalizer.set = partial.call(options.normalizer.set, obj);
						if (options.normalizer.delete) {
							options.normalizer.delete = partial.call(
								options.normalizer.delete, obj
							);
						}
					}
					map.set(obj, memoizer = memoize(partial.call(fn, obj), options));
				}
				return memoizer.apply(this, slice.call(args, 1));
			}, length),
			{
				__memoized__: d(true),
				delete: d(
					defineLength(function (obj) {
						var memoizer, args = arguments;
						if (resolve) {
							args = resolve(args);
							obj = args[0];
						}
						memoizer = map.get(obj);
	...
defineLength(function (obj) {
				var memoizer, args = arguments;
				if (resolve) {
					args = resolve(args);
					obj = args[0];
				}
				memoizer = map.get(obj);
				if (!memoizer) {
					if (normalizer) {
						options = copy(options);
						options.normalizer = copy(normalizer);
						options.normalizer.get = partial.call(options.normalizer.get, obj);
						options.normalizer.set = partial.call(options.normalizer.set, obj);
						if (options.normalizer.delete) {
							options.normalizer.delete = partial.call(
								options.normalizer.delete, obj
							);
						}
					}
					map.set(obj, memoizer = memoize(partial.call(fn, obj), options));
				}
				return memoizer.apply(this, slice.call(args, 1));
			}, length)
i = indexOf.call(set[0], args[index])
this[nameA].initial + this[nameA].cached
conf.original = function () {
		var args, cb, origCb, result;
		if (!currentCallback) return apply.call(original, this, arguments);
		args = aFrom(arguments);
		cb = function self(err) {
			var cb, args, id = self.id;
			if (id == null) {
				// Shouldn't happen, means async callback was called sync way
				nextTick(apply.bind(self, this, arguments));
				return undefined;
			}
			delete self.id;
			cb = waiting[id];
			delete waiting[id];
			if (!cb) {
				// Already processed,
				// outcome of race condition: asyncFn(1, cb), asyncFn.clear(), asyncFn(1, cb)
				return undefined;
			}
			args = aFrom(arguments);
			if (conf.has(id)) {
				if (err) {
					conf.delete(id);
				} else {
					cache[id] = { context: this, args: args };
					conf.emit("setasync", id, typeof cb === "function" ? 1 : cb.length);
				}
			}
			if (typeof cb === "function") {
				result = apply.call(cb, this, args);
			} else {
				cb.forEach(function (cb) { result = apply.call(cb, this, args); }, this);
			}...
nextTick(onSuccess.bind(this, result))
apply.call(original, this, arguments)
memoizer.apply(this, slice.call(args, 1))
{
		memoized = function (arg) {
			var result, args = arguments, id;
			if (resolve) args = resolve(arguments);
			id = String(args[0]);
			if (hasOwnProperty.call(cache, id)) {
				if (getListeners) conf.emit("get", id, args, this);
				return cache[id];
			}
			if (args.length === 1) result = call.call(original, this, args[0]);
			else result = apply.call(original, this, args);
			if (hasOwnProperty.call(cache, id)) {
				throw customError("Circular invocation", "CIRCULAR_INVOCATION");
			}
			cache[id] = result;
			if (setListeners) conf.emit("set", id, null, result);
			return result;
		};
	}
memoized = function (arg) {
			var result, args = arguments, id;
			if (resolve) args = resolve(arguments);
			id = String(args[0]);
			if (hasOwnProperty.call(cache, id)) {
				if (getListeners) conf.emit("get", id, args, this);
				return cache[id];
			}
			if (args.length === 1) result = call.call(original, this, args[0]);
			else result = apply.call(original, this, args);
			if (hasOwnProperty.call(cache, id)) {
				throw customError("Circular invocation", "CIRCULAR_INVOCATION");
			}
			cache[id] = result;
			if (setListeners) conf.emit("set", id, null, result);
			return result;
		}
_tmp_2.delete = d(
					defineLength(function (obj) {
						var memoizer, args = arguments;
						if (resolve) {
							args = resolve(args);
							obj = args[0];
						}
						memoizer = map.get(obj);
						if (!memoizer) return;
						memoizer.delete.apply(this, slice.call(args, 1));
					}, length)
				)
defineLength(function (obj) {
						var memoizer, args = arguments;
						if (resolve) {
							args = resolve(args);
							obj = args[0];
						}
						memoizer = map.get(obj);
						if (!memoizer) return;
						memoizer.delete.apply(this, slice.call(args, 1));
					}, length)
log +=
			ipad.call(data.initial) +
			"  " +
			cpad.call(data.cached) +
			"  " +
			ppad.call(toPrc(data.initial, data.cached)) +
			"  " +
			name +
			"\n"
ipad.call(data.initial) +
			"  " +
			cpad.call(data.cached) +
			"  " +
			ppad.call(toPrc(data.initial, data.cached)) +
			"  " +
			name +
			"\n"
"Memoizee error: Retrieved promise does not implement 'finally' " +
						"in 'done:finally' mode"
_tmp_4.deleteRef = d(
				defineLength(function (obj) {
					var memoizer, args = arguments;
					if (resolve) {
						args = resolve(args);
						obj = args[0];
					}
					memoizer = map.get(obj);
					if (!memoizer) return null;
					return memoizer.deleteRef.apply(this, slice.call(args, 1));
				}, length)
			)
conf = {
		original: original,
		memoized: memoized,
		profileName: options.profileName,
		get: function (args) {
			if (resolve) args = resolve(args);
			if (get) return get(args);
			return String(args[0]);
		},
		has: function (id) { return hasOwnProperty.call(cache, id); },
		delete: function (id) {
			var result;
			if (!hasOwnProperty.call(cache, id)) return;
			if (del) del(id);
			result = cache[id];
			delete cache[id];
			if (deleteListeners) conf.emit("delete", id, result);
		},
		clear: function () {
			var oldCache = cache;
			if (clear) clear();
			cache = create(null);
			conf.emit("clear", oldCache);
		},
		on: function (type, listener) {
			if (type === "get") getListeners = true;
			else if (type === "set") setListeners = true;
			else if (type === "delete") deleteListeners = true;
			return on.call(this, type, listener);
		},
		emit: emit,
		updateEnv: function () { original = conf.original; }
	}
_tmp_0.profileName = options.profileName
_tmp_0.get = <lambda>4
memoizer = map.get(obj)
var emit = function () { conf.emit("getasync", id, args, context); }
conf.on("set", function (id) {
		if (!currentCallback) {
			conf.delete(id);
			return;
		}
		if (waiting[id]) {
			// Race condition: asyncFn(1, cb), asyncFn.clear(), asyncFn(1, cb)
			if (typeof waiting[id] === "function") waiting[id] = [waiting[id], currentCallback.cb];
			else waiting[id].push(currentCallback.cb);
		} else {
			waiting[id] = currentCallback.cb;
		}
		delete currentCallback.cb;
		currentCallback.id = id;
		currentCallback = null;
	})
defineLength(function (obj) {
					var memoizer, args = arguments;
					if (resolve) {
						args = resolve(args);
						obj = args[0];
					}
					memoizer = map.get(obj);
					if (!memoizer) return 0;
					return memoizer.getRefCount.apply(this, slice.call(args, 1));
				}, length)
waiting[id] = [waiting[id], currentCallback.cb]
waiting[id].push(currentCallback.cb)
waiting[id] = currentCallback.cb
conf.on("delete", function (id) {
		delete promises[id];
		if (waiting[id]) {
			delete waiting[id];
			return; // Not yet resolved
		}
		if (!hasOwnProperty.call(cache, id)) return;
		var result = cache[id];
		delete cache[id];
		conf.emit("deleteasync", id, [result]);
	})
memoizer.getRefCount.apply(this, slice.call(args, 1))
extDel = defineLength(function (arg) {
			var id, args = arguments;
			if (resolve) args = resolve(args);
			id = get(args);
			if (id === null) return;
			conf.delete(id);
		}, memLength)
promises = create(null)
conf.emit("clearasync", objectMap(oldCache, function (data) { return [data]; }))
extGet = defineLength(function () {
		var id, args = arguments;
		if (length === 0) return cache.data;
		if (resolve) args = resolve(args);
		if (get) id = get(args);
		else id = String(args[0]);
		return cache[id];
	})
args = resolve(args)
id = get(args)
extHas = defineLength(function () {
		var id, args = arguments;
		if (length === 0) return conf.has("data");
		if (resolve) args = resolve(args);
		if (get) id = get(args);
		else id = String(args[0]);
		if (id === null) return false;
		return conf.has(id);
	})
args = resolve(args)
id = get(args)
id === null
conf.has(id)
