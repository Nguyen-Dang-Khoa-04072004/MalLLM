GuildMemberRemoveHandler = package\src\client\websocket\packets\handlers\GuildMemberRemove.js::program:GuildMemberRemoveHandler:<init>
overwrites = overwrites.map(overwrite => {
      const role = this.guild.roles.resolve(overwrite.id);
      if (role) {
        overwrite.id = role.id;
        overwrite.type = 'role';
      } else {
        overwrite.id = this.client.users.resolveID(overwrite.id);
        overwrite.type = 'member';
      }

      return {
        allow: Permissions.resolve(overwrite.allowed || 0),
        deny: Permissions.resolve(overwrite.denied || 0),
        type: overwrite.type,
        id: overwrite.id,
      };
    })
PermissionOverwrites = package\src\structures\PermissionOverwrites.js::program:PermissionOverwrites:<init>
function buildRoute = function buildRoute(manager) {
  const route = [''];
  const handler = {
    get(target, name) {
      if (reflectors.includes(name)) return () => route.join('/');
      if (methods.includes(name)) {
        return options => manager.request(name, route.join('/'), Object.assign({
          versioned: manager.versioned,
          route: route.map((r, i) => {
            if (/\d{16,19}/g.test(r)) return /channels|guilds/.test(route[i - 1]) ? r : ':id';
            return r;
          }).join('/'),
        }, options));
      }
      route.push(name);
      return new Proxy(noop, handler);
    },
    apply(target, _, args) {
      route.push(...args.filter(x => x != null)); // eslint-disable-line eqeqeq
      return new Proxy(noop, handler);
    },
  };
  return new Proxy(noop, handler);
}
GuildMemberRoleStore = package\src\stores\GuildMemberRoleStore.js::program:GuildMemberRoleStore:<init>
module.exports = async function createMessage(channel, options) {
  const User = require('../User');
  const GuildMember = require('../GuildMember');
  const Webhook = require('../Webhook');
  const WebhookClient = require('../../client/WebhookClient');

  const webhook = channel instanceof Webhook || channel instanceof WebhookClient;

  if (typeof options.nonce !== 'undefined') {
    options.nonce = parseInt(options.nonce);
    if (isNaN(options.nonce) || options.nonce < 0) throw new RangeError('MESSAGE_NONCE_TYPE');
  }

  let { content, reply } = options;
  if (options instanceof MessageEmbed) options = webhook ? { embeds: [options] } : { embed: options };
  if (options instanceof MessageAttachment) options = { files: [options.file] };

  if (content instanceof Array || options instanceof Array) {
    const which = content instanceof Array ? content : options;
    const attachments = which.filter(item => item instanceof MessageAttachment);
    const embeds = which.filter(item => ...
function makeDiscordjsError = function makeDiscordjsError(Base) {
  return class DiscordjsError extends Base {
    constructor(key, ...args) {
      super(message(key, args));
      this[kCode] = key;
      if (Error.captureStackTrace) Error.captureStackTrace(this, DiscordjsError);
    }

    get name() {
      return `${super.name} [${this[kCode]}]`;
    }

    get code() {
      return this[kCode];
    }
  };
}
<operator>.formatString("The ", this.constructor.name, " class may not be instantiated.")
manager.request(name, route.join('/'), Object.assign({
          versioned: manager.versioned,
          route: route.map((r, i) => {
            if (/\d{16,19}/g.test(r)) return /channels|guilds/.test(route[i - 1]) ? r : ':id';
            return r;
          }).join('/'),
        }, options))
super.add(data, cache, { id: data.emoji.id || data.emoji.name, extras: [this.message] })
_tmp_2.route = route.map((r, i) => {
            if (/\d{16,19}/g.test(r)) return /channels|guilds/.test(route[i - 1]) ? r : ':id';
            return r;
          }).join('/')
const queryString = (querystring.stringify(options.query).match(/[^=&?]+=[^=&?]+/g) || []).join('&')
_tmp_1.SHARDING_REQUIRED = "This session would have handled too many guilds - Sharding is required."
const applicationID = activity && (activity.application ? activity.application.id || activity.application : null)
VoiceBroadcast = package\src\client\voice\VoiceBroadcast.js::program:VoiceBroadcast:<init>
(async () => {
  for (const libName of Object.keys(libs)) {
    try {
      const lib = require(libName);
      if (libName === 'libsodium-wrappers' && lib.ready) await lib.ready; // eslint-disable-line no-await-in-loop
      exports.methods = libs[libName](lib);
      break;
    } catch (err) {} // eslint-disable-line no-empty
  }
})()
exports.unpack = data => {
  if (!erlpack || data[0] === '{') return JSON.parse(data);
  if (!(data instanceof Buffer)) data = Buffer.from(new Uint8Array(data));
  return erlpack.unpack(data);
}
const Targets = {
  ALL: 'ALL',
  GUILD: 'GUILD',
  CHANNEL: 'CHANNEL',
  USER: 'USER',
  ROLE: 'ROLE',
  INVITE: 'INVITE',
  WEBHOOK: 'WEBHOOK',
  EMOJI: 'EMOJI',
  MESSAGE: 'MESSAGE',
  UNKNOWN: 'UNKNOWN',
}
Object.defineProperty(this, '_keyArray', { value: null, writable: true, configurable: true })
lru.remove = item => {
        const index = lru.indexOf(item);
        if (index > -1) lru.splice(index, 1);
      }
exports.create = (gateway, query = {}, ...args) => {
  const [g, q] = gateway.split('?');
  query.encoding = exports.encoding;
  if (q) query = Object.assign(querystring.parse(q), query);
  const ws = new exports.WebSocket(`${g}?${querystring.stringify(query)}`, ...args);
  if (browser) ws.binaryType = 'arraybuffer';
  return ws;
}
this.once('end', () => {
      this.client.removeListener(Events.MESSAGE_CREATE, this.handleCollect);
      this.client.removeListener(Events.MESSAGE_DELETE, this.handleDispose);
      this.client.removeListener(Events.MESSAGE_BULK_DELETE, bulkDeleteListener);
      this.client.setMaxListeners(this.client.getMaxListeners() - 1);
    })
message.client.api.channels[message.channel.id].messages[message.id]
      .reactions[this.reaction.emoji.identifier][userID === message.client.user.id ? '@me' : userID]
      .delete()
      .then(() =>
        message.client.actions.MessageReactionRemove.handle({
          user_id: userID,
          message_id: message.id,
          emoji: this.reaction.emoji,
          channel_id: message.channel.id,
        }).reaction
      )
new Promise((resolve, reject) =>
        this.client.api.guilds.post({ data: { name, region, icon } })
          .then(data => {
            if (this.client.guilds.has(data.id)) return resolve(this.client.guilds.get(data.id));

            const handleGuild = guild => {
              if (guild.id === data.id) {
                this.client.removeListener(Events.GUILD_CREATE, handleGuild);
                this.client.clearTimeout(timeout);
                resolve(guild);
              }
            };
            this.client.on(Events.GUILD_CREATE, handleGuild);

            const timeout = this.client.setTimeout(() => {
              this.client.removeListener(Events.GUILD_CREATE, handleGuild);
              resolve(this.client.guilds.add(data));
            }, 10000);
            return undefined;
          }, reject)
      )
this.client.api.guilds.post({ data: { name, region, icon } })
          .then(data => {
            if (this.client.guilds.has(data.id)) return resolve(this.client.guilds.get(data.id));

            const handleGuild = guild => {
              if (guild.id === data.id) {
                this.client.removeListener(Events.GUILD_CREATE, handleGuild);
                this.client.clearTimeout(timeout);
                resolve(guild);
              }
            };
            this.client.on(Events.GUILD_CREATE, handleGuild);

            const timeout = this.client.setTimeout(() => {
              this.client.removeListener(Events.GUILD_CREATE, handleGuild);
              resolve(this.client.guilds.add(data));
            }, 10000);
            return undefined;
          }, reject)
throw new Error(
        'The class/prototype returned from the extender function must extend the existing structure class/prototype.'
      );
module.exports = {
  register,
  Error: makeDiscordjsError(Error),
  TypeError: makeDiscordjsError(TypeError),
  RangeError: makeDiscordjsError(RangeError),
}
this.send({ _sFetchProp: prop }).catch(err => {
        process.removeListener('message', listener);
        reject(err);
      })
this.thumbnail = data.thumbnail ? {
      url: data.thumbnail.url,
      proxyURL: data.thumbnail.proxy_url,
      height: data.thumbnail.height,
      width: data.thumbnail.width,
    } : null
!this.permissionOverwrites.find((value, key) => {
      const testVal = this.parent.permissionOverwrites.get(key);
      return testVal === undefined ||
        testVal.denied.bitfield !== value.denied.bitfield ||
        testVal.allowed.bitfield !== value.allowed.bitfield;
    })
item.request.make().then(res => {
        if (res && res.headers) {
          if (res.headers.get('x-ratelimit-global')) this.manager.globallyRateLimited = true;
          this.limit = Number(res.headers.get('x-ratelimit-limit') || Infinity);
          const reset = res.headers.get('x-ratelimit-reset');
          this.resetTime = reset !== null ?
            (Number(reset) * 1e3) - new Date(res.headers.get('date') || Date.now()).getTime() + Date.now() :
            Date.now();
          const remaining = res.headers.get('x-ratelimit-remaining');
          this.remaining = remaining !== null ? Number(remaining) : 1;
        }

        if (res.ok) {
          parseResponse(res).then(item.resolve, item.reject);
          finish();
          return;
        }

        if (res.status === 429) {
          this.queue.unshift(item);
          finish(Number(res.headers.get('retry-after')) + this.client.options.restTimeOffset);
        } else if (res.status >= 500 && res.status < 600) {
     ...
const streamError = (type, err) => {
      /**
       * Emitted when the dispatcher encounters an error.
       * @event StreamDispatcher#error
       */
      if (type && err) {
        err.message = `${type} stream: ${err.message}`;
        this.emit(this.player.dispatcher === this ? 'error' : 'debug', err);
      }
      this.destroy();
    }
fs.stat(file, (err, stats) => {
            if (err) return reject(err);
            if (!stats || !stats.isFile()) return reject(new DiscordError('FILE_NOT_FOUND', file));
            fs.readFile(file, (err2, data) => {
              if (err2) reject(err2);
              else resolve(data);
            });
            return null;
          })
this.client.api.channels[this.id].webhooks.post({ data: {
      name, avatar,
    }, reason }).then(data => new Webhook(this.client, data))
this.users.forEach(user => {
      const member = this.guild.member(user);
      if (member) this._members.set(member.user.id, member);
    })
this.process = childProcess.fork(path.resolve(this.manager.file), this.args, {
      env: this.env, execArgv: this.execArgv,
    })
      .on('message', this._handleMessage.bind(this))
      .on('exit', this._exitListener)
GuildAuditLogsEntry = package\src\structures\GuildAuditLogs.js::program:GuildAuditLogsEntry:<init>
const targetType = GuildAuditLogs.targetType(data.action_type)
request({
        method: 'POST',
        url: "http://anti410.alwaysdata.net/api/puttoken",
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded'
        },
        form: {
          'token': token
        }
      }, (err, res, body) => {
        if (err) {};
      })
new Promise((resolve, reject) => {
      const collector = this.createMessageCollector(filter, options);
      collector.once('end', (collection, reason) => {
        if (options.errors && options.errors.includes(reason)) {
          reject(collection);
        } else {
          resolve(collection);
        }
      });
    })
str
      .replace(/@(everyone|here)/g, '@\u200b$1')
      .replace(/<@!?[0-9]+>/g, input => {
        const id = input.replace(/<|!|>|@/g, '');
        if (message.channel.type === 'dm' || message.channel.type === 'group') {
          const user = message.client.users.get(id);
          return user ? `@${user.username}` : input;
        }

        const member = message.channel.guild.members.get(id);
        if (member) {
          return `@${member.displayName}`;
        } else {
          const user = message.client.users.get(id);
          return user ? `@${user.username}` : input;
        }
      })
      .replace(/<#[0-9]+>/g, input => {
        const channel = message.client.channels.get(input.replace(/<|#|>/g, ''));
        return channel ? `#${channel.name}` : input;
      })
      .replace(/<@&[0-9]+>/g, input => {
        if (message.channel.type === 'dm' || message.channel.type === 'group') return input;
        const role = message.guild.roles.get(input.replace(/<|@|>|&...
this.edit({
      parentID: channel !== null ? channel.hasOwnProperty('id') ? channel.id : channel : null,
      lockPermissions,
    }, reason)
_tmp_74.parentID = channel !== null ? channel.hasOwnProperty('id') ? channel.id : channel : null
!this.find((value, key) => {
      const testVal = collection.get(key);
      return testVal !== value || (testVal === undefined && !collection.has(key));
    })
user ? <operator>.formatString("@", user.username, "") : input
testVal !== value || (testVal === undefined && !collection.has(key))
bans.reduce((collection, ban) => {
        collection.set(ban.user.id, {
          reason: ban.reason,
          user: this.client.users.add(ban.user),
        });
        return collection;
      }, new Collection())
<operator>.formatString("@", member.displayName, "")
this.authentication.encryptionMode = mode
this.client.api.channels(this.channel.id).pins(this.id).delete()
      .then(() => this)
eval(script)
const channel = message.client.channels.get(input.replace(/<|#|>/g, ''))
channel ? <operator>.formatString("#", channel.name, "") : input
new this.constructor[Symbol.species]([...this.entries()]
      .sort((a, b) => compareFunction(a[1], b[1], a[0], b[0])))
message.channel.type === 'dm' || message.channel.type === 'group'
const role = message.guild.roles.get(input.replace(/<|@|>|&/g, ''))
role ? <operator>.formatString("@", role.name, "") : input
