function handleKeyboard = function handleKeyboard(s, plt, e) {
        var win = plt.win();
        var kc = e.keyCode || e.charCode;
        // Directions locks
        if (!s._allowSwipeToNext && (swiper_utils_1.isHorizontal(s) && kc === 39 || !swiper_utils_1.isHorizontal(s) && kc === 40)) {
            return false;
        }
        if (!s._allowSwipeToPrev && (swiper_utils_1.isHorizontal(s) && kc === 37 || !swiper_utils_1.isHorizontal(s) && kc === 38)) {
            return false;
        }
        if (e.shiftKey || e.altKey || e.ctrlKey || e.metaKey) {
            return;
        }
        var activeEle = plt.getActiveElement();
        if (activeEle && activeEle.nodeName && (activeEle.nodeName.toLowerCase() === 'input' || activeEle.nodeName.toLowerCase() === 'textarea')) {
            return;
        }
        if (kc === 37 || kc === 39 || kc === 38 || kc === 40) {
            var inView = false;
            // Check that swiper should be inside of visible area of window
            if (s.container.clo...
var ModalImpl = (function (_super) {
    __extends(ModalImpl, _super);
    function ModalImpl(app, component, data, opts, config) {
        if (opts === void 0) { opts = {}; }
        var _this = this;
        data = data || {};
        data.component = component;
        opts.showBackdrop = isPresent(opts.showBackdrop) ? !!opts.showBackdrop : true;
        opts.enableBackdropDismiss = isPresent(opts.enableBackdropDismiss) ? !!opts.enableBackdropDismiss : true;
        data.opts = opts;
        _this = _super.call(this, ModalCmp, data, null) || this;
        _this._app = app;
        _this._enterAnimation = opts.enterAnimation;
        _this._leaveAnimation = opts.leaveAnimation;
        _this.isOverlay = true;
        config.setTransition('modal-slide-in', ModalSlideIn);
        config.setTransition('modal-slide-out', ModalSlideOut);
        config.setTransition('modal-md-slide-in', ModalMDSlideIn);
        config.setTransition('modal-md-slide-out', ModalMDSlideOut);
        return _th...
function PanGesture = function PanGesture(plt, element, opts) {
            if (opts === void 0) { opts = {}; }
            this.plt = plt;
            this.element = element;
            util_1.defaults(opts, {
                threshold: 20,
                maxAngle: 40,
                direction: 'x',
                zone: true,
                capture: false,
                passive: false,
            });
            this.events = new ui_event_manager_1.UIEventManager(plt);
            if (opts.domController) {
                this.debouncer = opts.domController.debouncer();
            }
            this.gestute = opts.gesture;
            this.direction = opts.direction;
            this.eventsConfig = {
                element: this.element,
                pointerDown: this.pointerDown.bind(this),
                pointerMove: this.pointerMove.bind(this),
                pointerUp: this.pointerUp.bind(this),
                zone: opts.zone,
                capture: opts.capture,
                pa...
var ActionSheetCmp = (function () {
        function ActionSheetCmp(_viewCtrl, config, _elementRef, gestureCtrl, params, renderer) {
            this._viewCtrl = _viewCtrl;
            this._elementRef = _elementRef;
            this.gestureBlocker = gestureCtrl.createBlocker(gesture_controller_1.BLOCK_ALL);
            this.d = params.data;
            this.mode = config.get('mode');
            renderer.setElementClass(_elementRef.nativeElement, "action-sheet-" + this.mode, true);
            if (this.d.cssClass) {
                this.d.cssClass.split(' ').forEach(function (cssClass) {
                    // Make sure the class isn't whitespace, otherwise it throws exceptions
                    if (cssClass.trim() !== '')
                        renderer.setElementClass(_elementRef.nativeElement, cssClass, true);
                });
            }
            this.id = (++actionSheetIds);
            if (this.d.title) {
                this.hdrId = 'acst-hdr-' + this.id;
            ...
_tmp_4.args = [{
                    selector: 'ion-refresher-content',
                    template: '<div class="refresher-pulling">' +
                        '<div class="refresher-pulling-icon" *ngIf="pullingIcon">' +
                        '<ion-icon [name]="pullingIcon"></ion-icon>' +
                        '</div>' +
                        '<div class="refresher-pulling-text" [innerHTML]="pullingText" *ngIf="pullingText"></div>' +
                        '</div>' +
                        '<div class="refresher-refreshing">' +
                        '<div class="refresher-refreshing-icon">' +
                        '<ion-spinner [name]="refreshingSpinner"></ion-spinner>' +
                        '</div>' +
                        '<div class="refresher-refreshing-text" [innerHTML]="refreshingText" *ngIf="refreshingText"></div>' +
                        '</div>',
                    host: {
                        '[attr.state]': 'r.state'
                    },
                    ...
function AlertCmp = function AlertCmp(_viewCtrl, _elementRef, config, gestureCtrl, params, _renderer, _plt) {
            this._viewCtrl = _viewCtrl;
            this._elementRef = _elementRef;
            this._renderer = _renderer;
            this._plt = _plt;
            // gesture blocker is used to disable gestures dynamically
            this.gestureBlocker = gestureCtrl.createBlocker(gesture_controller_1.BLOCK_ALL);
            this.d = params.data;
            this.mode = this.d.mode || config.get('mode');
            this.keyboardResizes = config.getBoolean('keyboardResizes', false);
            _renderer.setElementClass(_elementRef.nativeElement, "alert-" + this.mode, true);
            if (this.d.cssClass) {
                this.d.cssClass.split(' ').forEach(function (cssClass) {
                    // Make sure the class isn't whitespace, otherwise it throws exceptions
                    if (cssClass.trim() !== '')
                        _renderer.setElementClass(_elementRef.nativeElemen...
function NavControllerBase = function NavControllerBase(parent, _app, config, plt, elementRef, _zone, renderer, _cfr, _gestureCtrl, _trnsCtrl, _linker, _domCtrl, _errHandler) {
        var _this = _super.call(this, config, elementRef, renderer) || this;
        _this.parent = parent;
        _this._app = _app;
        _this.config = config;
        _this.plt = plt;
        _this._zone = _zone;
        _this._cfr = _cfr;
        _this._gestureCtrl = _gestureCtrl;
        _this._trnsCtrl = _trnsCtrl;
        _this._linker = _linker;
        _this._domCtrl = _domCtrl;
        _this._errHandler = _errHandler;
        _this._ids = -1;
        _this._init = false;
        _this._queue = [];
        _this._trnsId = null;
        _this._trnsTm = false;
        _this._views = [];
        _this._zIndexOffset = 0;
        _this.viewDidLoad = new EventEmitter();
        _this.viewWillEnter = new EventEmitter();
        _this.viewDidEnter = new EventEmitter();
        _this.viewWillLeave = new EventEmitter();
        _this....
function renderTextFormat = function renderTextFormat(format, value, date, locale) {
    if (format === FORMAT_DDDD || format === FORMAT_DDD) {
        try {
            value = (new Date(date.year, date.month - 1, date.day)).getDay();
            if (format === FORMAT_DDDD) {
                return (isPresent(locale.dayNames) ? locale.dayNames : DAY_NAMES)[value];
            }
            return (isPresent(locale.dayShortNames) ? locale.dayShortNames : DAY_SHORT_NAMES)[value];
        }
        catch (e) { }
        return '';
    }
    if (format === FORMAT_A) {
        return date ? date.hour < 12 ? 'AM' : 'PM' : isPresent(value) ? value.toUpperCase() : '';
    }
    if (format === FORMAT_a) {
        return date ? date.hour < 12 ? 'am' : 'pm' : isPresent(value) ? value : '';
    }
    if (isBlank(value)) {
        return '';
    }
    if (format === FORMAT_YY || format === FORMAT_MM ||
        format === FORMAT_DD || format === FORMAT_HH ||
        format === FORMAT_mm || format === FORMAT_ss) {
        r...
function BaseInput = function BaseInput(config, elementRef, renderer, name, _defaultValue, _form, _item, _ngControl) {
            var _this = _super.call(this, config, elementRef, renderer, name) || this;
            _this._defaultValue = _defaultValue;
            _this._form = _form;
            _this._item = _item;
            _this._ngControl = _ngControl;
            _this._isFocus = false;
            _this._disabled = false;
            _this._debouncer = new debouncer_1.TimeoutDebouncer(0);
            _this._init = false;
            _this._initModel = false;
            /**
             * @output {Range} Emitted when the range selector drag starts.
             */
            _this.ionFocus = new core_1.EventEmitter();
            /**
             * @output {Range} Emitted when the range value changes.
             */
            _this.ionChange = new core_1.EventEmitter();
            /**
             * @output {Range} Emitted when the range selector drag ends.
             */
            _t...
var Platform = (function () {
    function Platform() {
        var _this = this;
        this._versions = {};
        this._qp = new QueryParams();
        this._bbActions = [];
        this._pW = 0;
        this._pH = 0;
        this._lW = 0;
        this._lH = 0;
        this._isPortrait = null;
        this._uiEvtOpts = false;
        /** @internal */
        this._platforms = [];
        // Events meant to be triggered by the engine
        // **********************************************
        /**
         * @hidden
         */
        this.backButton = new EventEmitter();
        /**
         * The pause event emits when the native platform puts the application
         * into the background, typically when the user switches to a different
         * application. This event would emit when a Cordova app is put into
         * the background, however, it would not fire on a standard web browser.
         */
        this.pause = new EventEmitter();
        /**
         * The res...
function Platform = function Platform() {
        var _this = this;
        this._versions = {};
        this._qp = new QueryParams();
        this._bbActions = [];
        this._pW = 0;
        this._pH = 0;
        this._lW = 0;
        this._lH = 0;
        this._isPortrait = null;
        this._uiEvtOpts = false;
        /** @internal */
        this._platforms = [];
        // Events meant to be triggered by the engine
        // **********************************************
        /**
         * @hidden
         */
        this.backButton = new EventEmitter();
        /**
         * The pause event emits when the native platform puts the application
         * into the background, typically when the user switches to a different
         * application. This event would emit when a Cordova app is put into
         * the background, however, it would not fire on a standard web browser.
         */
        this.pause = new EventEmitter();
        /**
         * The resume event emits when the nativ...
function updateSlidesProgress = function updateSlidesProgress(s, translate) {
    if (typeof translate === 'undefined') {
        translate = s._translate || 0;
    }
    if (s._slides.length === 0)
        return;
    if (typeof s._slides[0].swiperSlideOffset === 'undefined') {
        updateSlidesOffset(s);
    }
    var offsetCenter = -translate;
    if (s._rtl)
        offsetCenter = translate;
    // Visible Slides
    removeClass(s._slides, CLS.slideVisible);
    for (var i = 0; i < s._slides.length; i++) {
        var slide = s._slides[i];
        var slideProgress = (offsetCenter + (s.centeredSlides ? minTranslate(s) : 0) - slide.swiperSlideOffset) / (slide.swiperSlideSize + s.spaceBetween);
        if (s.watchSlidesVisibility) {
            var slideBefore = -(offsetCenter - slide.swiperSlideOffset);
            var slideAfter = slideBefore + s._slidesSizesGrid[i];
            var isVisible = (slideBefore >= 0 && slideBefore < s._renderedSize) ||
                (slideAfter > 0 && slideAfter <= s._rendere...
function updatePaginationClasses = function updatePaginationClasses(s) {
    // Current/Total
    var current;
    var total = s.loop ? Math.ceil((s._slides.length - s.loopedSlides * 2) / s.slidesPerGroup) : s._snapGrid.length;
    if (s.loop) {
        current = Math.ceil((s._activeIndex - s.loopedSlides) / s.slidesPerGroup);
        if (current > s._slides.length - 1 - s.loopedSlides * 2) {
            current = current - (s._slides.length - s.loopedSlides * 2);
        }
        if (current > total - 1) {
            current = current - total;
        }
        if (current < 0 && s.paginationType !== 'bullets') {
            current = total + current;
        }
    }
    else {
        if (typeof s._snapIndex !== 'undefined') {
            current = s._snapIndex;
        }
        else {
            current = s._activeIndex || 0;
        }
    }
    // Types
    if (s.paginationType === 'bullets' && s._bullets) {
        var selector = current + (current < 0 ? s._bullets.length : 0);
        for (var i = 0; i < s....
function commonInputTest = function commonInputTest(input, config) {
    // TODO test form register/deregister
    // TODO test item classes
    // TODO test disable
    const zone = new NgZone({ enableLongStackTrace: true });
    zone.run(() => {
        if (config.testItem === true && !input._item) {
            (void 0) /* assert */;
        }
        if (config.testForm === true && !input._form) {
            (void 0) /* assert */;
        }
        // Run tests before initialization
        testInput(input, config, false);
        input.ngAfterContentInit();
        input.ngAfterViewInit && input.ngAfterViewInit();
        // Run tests after initialization
        testInput(input, config, true);
        // Run tests without item
        if (config.testItem === true && !input._item) {
            input._item = undefined;
            testInput(input, config, true);
        }
        // Run tests without item
        if (config.testForm === true && !input._form) {
            input._form = undefined;
      ...
IOSTransition.prototype.init = function () {
            _super.prototype.init.call(this);
            var plt = this.plt;
            var OFF_RIGHT = plt.isRTL ? '-99.5%' : '99.5%';
            var OFF_LEFT = plt.isRTL ? '33%' : '-33%';
            var enteringView = this.enteringView;
            var leavingView = this.leavingView;
            var opts = this.opts;
            this.duration(util_1.isPresent(opts.duration) ? opts.duration : DURATION);
            this.easing(util_1.isPresent(opts.easing) ? opts.easing : EASING);
            var backDirection = (opts.direction === 'back');
            var enteringHasNavbar = (enteringView && enteringView.hasNavbar());
            var leavingHasNavbar = (leavingView && leavingView.hasNavbar());
            if (enteringView) {
                // get the native element for the entering page
                var enteringPageEle = enteringView.pageRef().nativeElement;
                // entering content
                var enteringContent...
function renderTextFormat = function renderTextFormat(format, value, date, locale) {
        if (format === FORMAT_DDDD || format === FORMAT_DDD) {
            try {
                value = (new Date(date.year, date.month - 1, date.day)).getDay();
                if (format === FORMAT_DDDD) {
                    return (util_1.isPresent(locale.dayNames) ? locale.dayNames : DAY_NAMES)[value];
                }
                return (util_1.isPresent(locale.dayShortNames) ? locale.dayShortNames : DAY_SHORT_NAMES)[value];
            }
            catch (e) { }
            return '';
        }
        if (format === FORMAT_A) {
            return date ? date.hour < 12 ? 'AM' : 'PM' : util_1.isPresent(value) ? value.toUpperCase() : '';
        }
        if (format === FORMAT_a) {
            return date ? date.hour < 12 ? 'am' : 'pm' : util_1.isPresent(value) ? value : '';
        }
        if (util_1.isBlank(value)) {
            return '';
        }
        if (format === FORMAT_YY || format === FORMAT_MM ||
  ...
var ModalSlideOut = (function (_super) {
    __extends(ModalSlideOut, _super);
    function ModalSlideOut() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ModalSlideOut.prototype.init = function () {
        _super.prototype.init.call(this);
        var ele = this.leavingView.pageRef().nativeElement;
        var backdrop = new Animation(this.plt, ele.querySelector('ion-backdrop'));
        var wrapperEle = ele.querySelector('.modal-wrapper');
        var wrapperEleRect = wrapperEle.getBoundingClientRect();
        var wrapper = new Animation(this.plt, wrapperEle);
        // height of the screen - top of the container tells us how much to scoot it down
        // so it's off-screen
        wrapper.fromTo('translateY', '0px', this.plt.height() - wrapperEleRect.top + "px");
        backdrop.fromTo('opacity', 0.4, 0.0);
        this
            .element(this.leavingView.pageRef())
            .easing('ease-out')
            .duration(250)
            ....
function Platform = function Platform() {
            var _this = this;
            this._versions = {};
            this._qp = new query_params_1.QueryParams();
            this._bbActions = [];
            this._pW = 0;
            this._pH = 0;
            this._lW = 0;
            this._lH = 0;
            this._isPortrait = null;
            this._uiEvtOpts = false;
            /** @internal */
            this._platforms = [];
            // Events meant to be triggered by the engine
            // **********************************************
            /**
             * @hidden
             */
            this.backButton = new core_1.EventEmitter();
            /**
             * The pause event emits when the native platform puts the application
             * into the background, typically when the user switches to a different
             * application. This event would emit when a Cordova app is put into
             * the background, however, it would not fire on a standard web browser....
_tmp_0.android = {
        superset: 'mobile',
        subsets: [
            'phablet',
            'tablet'
        ],
        settings: {
            activator: function (plt) {
                // md mode defaults to use ripple activator
                // however, under-powered devices shouldn't use ripple
                // if this a linux device, and is using Android Chrome v36 (Android 5.0)
                // or above then use ripple, otherwise do not use a ripple effect
                if (plt.testNavigatorPlatform('linux')) {
                    let chromeVersion = plt.matchUserAgentVersion(/Chrome\/(\d+).(\d+)?/);
                    if (chromeVersion) {
                        // linux android device using modern android chrome browser gets ripple
                        if (parseInt(chromeVersion.major, 10) < 36 || plt.version().major < 5) {
                            return 'none';
                        }
                        else {
                            return 'ripple';
   ...
function updateSlidesProgress = function updateSlidesProgress(s, translate) {
        if (typeof translate === 'undefined') {
            translate = s._translate || 0;
        }
        if (s._slides.length === 0)
            return;
        if (typeof s._slides[0].swiperSlideOffset === 'undefined') {
            swiper_utils_1.updateSlidesOffset(s);
        }
        var offsetCenter = -translate;
        if (s._rtl)
            offsetCenter = translate;
        // Visible Slides
        swiper_utils_1.removeClass(s._slides, swiper_utils_1.CLS.slideVisible);
        for (var i = 0; i < s._slides.length; i++) {
            var slide = s._slides[i];
            var slideProgress = (offsetCenter + (s.centeredSlides ? swiper_utils_1.minTranslate(s) : 0) - slide.swiperSlideOffset) / (slide.swiperSlideSize + s.spaceBetween);
            if (s.watchSlidesVisibility) {
                var slideBefore = -(offsetCenter - slide.swiperSlideOffset);
                var slideAfter = slideBefore + s._slidesSizesGrid[i];
      ...
