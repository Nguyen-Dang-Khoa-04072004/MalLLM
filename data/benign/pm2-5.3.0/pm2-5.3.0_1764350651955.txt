var contentTypes = {
  '3gp': 'video/3gpp',
  'a': 'application/octet-stream',
  'ai': 'application/postscript',
  'aif': 'audio/x-aiff',
  'aiff': 'audio/x-aiff',
  'asc': 'application/pgp-signature',
  'asf': 'video/x-ms-asf',
  'asm': 'text/x-asm',
  'asx': 'video/x-ms-asf',
  'atom': 'application/atom+xml',
  'au': 'audio/basic',
  'avi': 'video/x-msvideo',
  'bat': 'application/x-msdownload',
  'bin': 'application/octet-stream',
  'bmp': 'image/bmp',
  'bz2': 'application/x-bzip2',
  'c': 'text/x-c',
  'cab': 'application/vnd.ms-cab-compressed',
  'cc': 'text/x-c',
  'chm': 'application/vnd.ms-htmlhelp',
  'class': 'application/octet-stream',
  'com': 'application/x-msdownload',
  'conf': 'text/plain',
  'cpp': 'text/x-c',
  'crt': 'application/x-x509-ca-cert',
  'css': 'text/css',
  'csv': 'text/csv',
  'cxx': 'text/x-c',
  'deb': 'application/x-debian-package',
  'der': 'application/x-x509-ca-cert',
  'diff': 'text/x-diff',
  'djv': 'image/vnd.djvu',
  'djvu': 'image/vnd.djvu',
 ...
module.exports = function (opts) {
  var params = {
    state: opts.state,
    version: opts.version
  }

  try {
    params.os = os.type()
    params.uptime = Math.floor(process.uptime())
    params.nodev = process.versions.node
    params.docker = hasDockerEnv() || hasDockerCGroup()
  } catch(e) {
  }

  vCheck.runCheck(params, (err, pkg) => {
    if (err) return false
    if (!pkg.current_version) return false
    if (opts.version && semver.lt(opts.version, pkg.current_version)) {
      console.log('[PM2] This PM2 is not UP TO DATE')
      console.log('[PM2] Upgrade to version %s', pkg.current_version)
    }
  })
}
God.registerCron = function(pm2_env) {
    if (!pm2_env ||
        pm2_env.pm_id === undefined ||
        !pm2_env.cron_restart ||
        pm2_env.cron_restart == '0' ||
        God.CronJobs.has(God.getCronID(pm2_env.pm_id)))
      return;

    var pm_id = pm2_env.pm_id
    console.log('[PM2][WORKER] Registering a cron job on:', pm_id);

    var job = Cron(pm2_env.cron_restart, function() {
      God.restartProcessId({id: pm_id}, function(err, data) {
        if (err)
          console.error(err.stack || err);
        return;
      });
    });

    God.CronJobs.set(God.getCronID(pm_id), job);
  }
var getGroups = function(cb) {
  var groups

  try {
    groups = fs.readFileSync('/etc/group')
  } catch(e) {
    return e
  }

  return groups
    .toString()
    .split('\n')
    .filter(function (group) {
      return group.length && group[0] != '#';
    })
    .reduce(function(map, group) {
      var fields = group.split(':');
      map[fields[0]] = map[fields[2]] = {
        name : fields[0],
        password : fields[1],
        id : fields[2],
        members : fields[3].split(',')
      };
      return map;
    }, {})
}
new Promise((resolve, reject) => {
      if (this.authenticated) return resolve(true)

      let tokensPath = cst.PM2_IO_ACCESS_TOKEN
      fs.readFile(tokensPath, (err, tokens) => {
        if (err && err.code === 'ENOENT') return resolve(false)
        if (err) return reject(err)

        // verify that the token is valid
        try {
          tokens = JSON.parse(tokens || '{}')
        } catch (err) {
          fs.unlinkSync(tokensPath)
          return resolve(false)
        }

        // if the refresh tokens is here, the user could be automatically authenticated
        return resolve(typeof tokens.refresh_token === 'string')
      })
    })
module.exports = function(proc) {
  var table = new Table({
    style : {'padding-left' : 1, head : ['cyan', 'bold'], compact : true}
  })

  var pm2_env = proc.pm2_env

  var created_at = 'N/A'

  if (pm2_env.axm_options && pm2_env.axm_options.human_info) {
    postModuleInfos(pm2_env.name, pm2_env.axm_options.human_info)
  }

  try {
    if (pm2_env.created_at != null)
      created_at = new Date(pm2_env.created_at).toISOString()
  } catch (e) {
  }

  console.log(chalk.bold.inverse(' Describing process with id %d - name %s '), pm2_env.pm_id, pm2_env.name)
  UxHelpers.safe_push(table,
            { 'status' : UxHelpers.colorStatus(pm2_env.status) },
            { 'name': pm2_env.name },
            { 'namespace': pm2_env.namespace },
            { 'version': pm2_env.version },
            { 'restarts' : pm2_env.restart_time },
            { 'uptime' : (pm2_env.pm_uptime && pm2_env.status == 'online') ? UxHelpers.timeSince(pm2_env.pm_uptime) : 0 },
            { 'script path' : pm2...
God.nodeApp = function nodeApp(env_copy, cb){
    var clu = null;

    console.log(`App [${env_copy.name}:${env_copy.pm_id}] starting in -cluster mode-`)
    if (env_copy.node_args && Array.isArray(env_copy.node_args)) {
      cluster.settings.execArgv = env_copy.node_args;
    }

    env_copy._pm2_version = pkg.version;

    try {
      // node.js cluster clients can not receive deep-level objects or arrays in the forked process, e.g.:
      // { "args": ["foo", "bar"], "env": { "foo1": "bar1" }} will be parsed to
      // { "args": "foo, bar", "env": "[object Object]"}
      // So we passing a stringified JSON here.
      clu = cluster.fork({pm2_env: JSON.stringify(env_copy), windowsHide: true});
    } catch(e) {
      God.logAndGenerateError(e);
      return cb(e);
    }

    clu.pm2_env = env_copy;

    /**
     * Broadcast message to God
     */
    clu.on('message', function cluMessage(msg) {
      /*********************************
       * If you edit this function
       * ...
Daemon.prototype.start = function() {
  var that = this;
  var d = domain.create();

  d.once('error', function(err) {
    fmt.sep();
    fmt.title('PM2 global error caught');
    fmt.field('Time', new Date());
    console.error(err.message);
    console.error(err.stack);
    fmt.sep();

    console.error('[PM2] Resurrecting PM2');

		var path = cst.IS_WINDOWS ? __dirname + '/../bin/pm2' : process.env['_'];
    var fork_new_pm2 = require('child_process').spawn('node', [path, 'update'], {
      detached: true,
      windowsHide: true,
      stdio: 'inherit'
    });

    fork_new_pm2.on('close', function() {
      console.log('PM2 successfully forked');
      process.exit(0);
    })

  });

  d.run(function() {
    that.innerStart();
  });
}
require('vizion').update({
        folder: proc.pm2_env.versioning.repo_path
      }, function(err, meta) {
        if (err !== null) {
          return cb ? cb({msg:err}) : that.exitCli(cst.ERROR_EXIT);
        }

        if (meta.success === true) {
          getPostUpdateCmds(proc.pm2_env.versioning.repo_path, process_name, function (command_list) {
            execCommands(proc.pm2_env.versioning.repo_path, command_list, function(err, res) {
              if (err !== null) {
                printError(err);
                return cb ? cb({msg: meta.output + err}) : that.exitCli(cst.ERROR_EXIT);
              }
              else {
                printOut(cst.PREFIX_MSG + 'Process successfully updated %s', process_name);
                printOut(cst.PREFIX_MSG + 'Current commit %s', meta.current_revision);
                return that[reload_type](process_name, function(err, procs) {
                  if (err && cb) return cb(err);
                  if (err) console.error(err);
 ...
function checkDockerSetup = function checkDockerSetup() {
  return new Promise(function(resolve, reject) {
    exec("docker version -f '{{.Client.Version}}'", function(err, stdout, stderr) {
      if (err) {
        console.error(chalk.red.bold('[Docker access] Error while trying to use docker command'));
        if (err.message && err.message.indexOf('Cannot connect to the Docker') > -1) {
          console.log();
          console.log(chalk.blue.bold('[Solution] Setup Docker to be able to be used without sudo rights:'));
          console.log(chalk.bold('$ sudo groupadd docker'));
          console.log(chalk.bold('$ sudo usermod -aG docker $USER'));
          console.log(chalk.bold('Then LOGOUT and LOGIN your Linux session'));
          console.log('Read more: http://bit.ly/29JGdCE');
        }
        return reject(err);
      }
      return resolve();
    });
  });
}
pm2.connect(function() {
      if (commander.web) {
        var port = commander.web === true ? cst.WEB_PORT : commander.web;
        pm2.web(port);
      }

      pm2.start(cmd, commander, function(err, obj) {
        if (process.env.PM2_RUNTIME_DEBUG) {
          return pm2.disconnect(function() {});
        }

        if (err) {
          console.error(err);
          return process.exit(1);
        }

        var pm_id = obj[0].pm2_env.pm_id;

        if (commander.instances == undefined) {
          return pm2.attach(pm_id, function() {
            exitPM2();
          });
        }

        if (commander.json === true)
          Log.jsonStream(pm2.Client, pm_id);
        else if (commander.format === true)
          Log.formatStream(pm2.Client, pm_id, false, 'YYYY-MM-DD-HH:mm:ssZZ');
        else
          Log.stream(pm2.Client, 'all', true);
      });
    })
God.getMonitorData = function getMonitorData(env, cb) {
    var processes = God.getFormatedProcesses();
    var pids = processes.filter(filterBadProcess)
      .map(function(pro, i) {
        var pid = getProcessId(pro)
        return pid;
      })

    // No pids, return empty statistics
    if (pids.length === 0) {
      return cb(null, processes.map(function(pro) {
        pro['monit'] = {
          memory : 0,
          cpu : 0
        };

        return pro
      }))
    }

    pidusage(pids, function retPidUsage(err, statistics) {
      // Just log, we'll set empty statistics
      if (err) {
        console.error('Error caught while calling pidusage');
        console.error(err);

        return cb(null, processes.map(function(pro) {
          pro['monit'] = {
            memory : 0,
            cpu : 0
          };
          return pro
        }))
      }

      if (!statistics) {
        console.error('Statistics is not defined!')

        return cb(null, processes.map(func...
function listModulesAndAppsManaged = function listModulesAndAppsManaged(list, commander) {
  var name_col_size = 11

  if (list && list.length > 0)
    name_col_size = (list.reduce((p, c) => (p.name.length > c.name.length) ? p : c)).name.length + 5

  var id_width = Math.max(
    2 + (Math.max(...list.map((l) => String(l.pm2_env.pm_id || 0).length)) || 0),
    4
  );
  
  var app_head = {
    id: id_width,
    name: name_col_size,
    namespace: 13,
    version: 9,
    mode: 9,
    pid: 10,
    uptime: 8,
    '↺': 6,
    status: 11,
    cpu: 10,
    mem: 10,
    user: 10,
    watching: 10
  }

  var mod_head = {
    id: id_width,
    module: 30,
    version: 15,
    pid: 10,
    status: 10,
    '↺': 6,
    cpu: 10,
    mem: 10,
    user: 10
  }

  if (CONDENSED_MODE) {
    app_head = {
      id: id_width,
      name: 20,
      mode: 10,
      '↺': 6,
      status: 11,
      cpu: 10,
      memory: 10
    }

    mod_head = {
      id: id_width,
      name: 20,
      status: 10,
      cpu: 10,
      mem: 10
    }
  }

  v...
function postExecCmd = function postExecCmd(command, cb) {
  var exec_cmd = exec(command);

  if (commander.silentExec !== true) {
    exec_cmd.stdout.on('data', function(data) {
      process.stdout.write(data);
    });

    exec_cmd.stderr.on('data', function(data) {
      process.stderr.write(data);
    });
  }

  exec_cmd.on('close', function done() {
    if (cb) cb(null);
  });

  exec_cmd.on('error', function (err) {
    console.error(err.stack || err);
  });
}
God.executeApp(new_env, function(err, new_worker) {
    if (err) return cb(err);

    var timer = null;

    var onListen = function () {
      clearTimeout(timer);
      softCleanDeleteProcess();
      console.log('-softReload- New worker listening');
    };

    // Bind to know when the new process is up
    new_worker.once('listening', onListen);

    timer = setTimeout(function() {
      new_worker.removeListener('listening', onListen);
      softCleanDeleteProcess();
    }, new_env.listen_timeout || cst.GRACEFUL_LISTEN_TIMEOUT);

    // Remove old worker properly
    var softCleanDeleteProcess = function () {
      var cleanUp = function () {
        clearTimeout(timer);
        console.log('-softReload- Old worker disconnected');
        return God.deleteProcessId(t_key, cb);
      };

      old_worker.once('disconnect', cleanUp);

      try {
        if (old_worker.state != 'dead' && old_worker.state != 'disconnected')
          old_worker.send && old_worker.send('shutdown');...
