overwrites = overwrites.map(overwrite => {
      const role = this.client.resolver.resolveRole(guild, overwrite.id);
      if (role) {
        overwrite.id = role.id;
        overwrite.type = 'role';
      } else {
        overwrite.id = this.client.resolver.resolveUserID(overwrite.id);
        overwrite.type = 'member';
      }

      return {
        allow: Permissions.resolve(overwrite.allow || overwrite.allowed || 0),
        deny: Permissions.resolve(overwrite.deny || overwrite.denied || 0),
        type: overwrite.type,
        id: overwrite.id,
      };
    })
function fetch = function fetch(Encoder, engineOptions) {
  try {
    return new Encoder(engineOptions);
  } catch (err) {
    if (err.message.includes('Cannot find module')) return null;

    // The Opus engine exists, but another error occurred.
    throw err;
  }
}
ClientUserGuildSettings = package\src\structures\ClientUserGuildSettings.js::program:ClientUserGuildSettings:<init>
this.build({
      url: url || this.constructor.DFEAULT.url,
      version: version || this.constructor.DEFAULT.version,
    })
error.message && flattened ? <operator>.formatString("", error.message, "\n", flattened, "") : error.message || flattened
VoiceServerUpdate = package\src\client\websocket\packets\handlers\VoiceServerUpdate.js::program:VoiceServerUpdate:<init>
SequentialRequestHandler = package\src\client\rest\RequestHandlers\Sequential.js::program:SequentialRequestHandler:<init>
WebSocketPacketManager = package\src\client\websocket\packets\WebSocketPacketManager.js::program:WebSocketPacketManager:<init>
TextBasedChannel = package\src\structures\interfaces\TextBasedChannel.js::program:TextBasedChannel:<init>
ReactionCollector = package\src\structures\ReactionCollector.js::program:ReactionCollector:<init>
const WebSocket = (function findWebSocket() {
  if (browser) return window.WebSocket; // eslint-disable-line no-undef
  try {
    const uws = require('@discordjs/uws');
    process.emitWarning('uws support is being removed in the next version of discord.js',
      'DeprecationWarning', findWebSocket);
    return uws;
  } catch (e) {
    return require('ws');
  }
}())
VoiceWebSocket = package\src\client\voice\VoiceWebSocket.js::program:VoiceWebSocket:<init>
Object.defineProperty(this, '_member', {
      writable: true,
      value: typeof member === 'object' && !(member instanceof Array) ? member : null,
    })
this.register(Constants.WSEvents.READY, require('./handlers/Ready'))
process.emitWarning('uws support is being removed in the next version of discord.js',
      'DeprecationWarning', findWebSocket)
StreamDispatcher = package\src\client\voice\dispatcher\StreamDispatcher.js::program:StreamDispatcher:<init>
lib.ready.then(() => {
        exports.methods = libs[libName](lib);
      }).catch(() => {
        const tweetnacl = require('tweetnacl');
        exports.methods = libs.tweetnacl(tweetnacl);
      }).catch(() => undefined)
Collector = package\src\structures\interfaces\Collector.js::program:Collector:<init>
this.register(Constants.WSEvents.GUILD_BAN_ADD, require('./handlers/GuildBanAdd'))
handler.push({
        request: apiRequest,
        resolve,
        reject,
        retries: 0,
      })
MessageFlags.FLAGS = {
  CROSSPOSTED: 1 << 0,
  IS_CROSSPOST: 1 << 1,
  SUPPRESS_EMBEDS: 1 << 2,
  SOURCE_MESSAGE_DELETED: 1 << 3,
  URGENT: 1 << 4,
}
TypingData = package\src\client\websocket\packets\handlers\TypingStart.js::program:TypingData:<init>
member = guild._addMember({
          user,
          roles: data.roles,
          deaf: false,
          mute: false,
        }, false)
this.client.setTimeout(() => this.deleted.delete(guildID + userID), this.client.options.restWsBridgeTimeout)
exports.DefaultOptions = {
  apiRequestMethod: 'sequential',
  shardId: 0,
  shardCount: 0,
  messageCacheMaxSize: 200,
  messageCacheLifetime: 0,
  messageSweepInterval: 0,
  fetchAllMembers: false,
  disableEveryone: false,
  sync: false,
  restWsBridgeTimeout: 5000,
  retryLimit: Infinity,
  disabledEvents: [],
  restTimeOffset: 500,

  /**
   * WebSocket options (these are left as snake_case to match the API)
   * @typedef {Object} WebsocketOptions
   * @property {number} [large_threshold=250] Number of members in a guild to be considered large
   * @property {boolean} [compress=true] Whether to compress data sent on the connection
   * (defaults to `false` for browsers)
   */
  ws: {
    large_threshold: 250,
    compress: require('os').platform() !== 'browser',
    properties: {
      $os: process ? process.platform : 'discord.js',
      $browser: 'discord.js',
      $device: 'discord.js',
      $referrer: '',
      $referring_domain: '',
    },
    version: 6,
  },

  /**
   ...
this._reEmitter = message => {
      /**
       * Emitted when the collector receives a message.
       * @event MessageCollector#message
       * @param {Message} message The message
       * @deprecated
       */
      this.emit('message', message);
    }
const timeout = this.client.setTimeout(() => reject(new Error(Constants.Errors.TOOK_TOO_LONG)), 1000 * 300)
new Promise((resolve, reject) => {
      process.send(message, err => {
        if (err) reject(err); else resolve();
      });
    })
key ? isNaN(k) ? <operator>.formatString("", key, ".", k, "") : <operator>.formatString("", key, "[", k, "]") : k
this.on('fullCollect', (reaction, user) => {
      this.users.set(user.id, user);
      this.total++;
    })
this.client.ws.connection.once('close', event => {
        if (event.code === 4004) reject(new Error(Constants.Errors.BAD_LOGIN));
        if (event.code === 4010) reject(new Error(Constants.Errors.INVALID_SHARD));
        if (event.code === 4011) reject(new Error(Constants.Errors.SHARDING_REQUIRED));
      })
channel.client.setTimeout(() => {
    channel.client.emit(Constants.Events.TYPING_STOP, channel, user, channel._typing.get(user.id));
    channel._typing.delete(user.id);
  }, 6000)
channel.client.emit(Constants.Events.TYPING_STOP, channel, user, channel._typing.get(user.id))
throw new Error('You do not have permission to join this voice channel; it is full.');
item.request.gen().end((err, res) => {
        if (res && res.headers) {
          this.requestLimit = Number(res.headers['x-ratelimit-limit']);
          this.requestResetTime = Number(res.headers['x-ratelimit-reset']) * 1000;
          this.requestRemaining = Number(res.headers['x-ratelimit-remaining']);
          this.timeDifference = Date.now() - new Date(res.headers.date).getTime();
        }
        if (err) {
          if (err.status === 429) {
            this.queue.unshift(item);
            this.client.setTimeout(() => {
              this.globalLimit = false;
              resolve();
            }, Number(res.headers['retry-after']) + this.client.options.restTimeOffset);
            if (res.headers['x-ratelimit-global']) this.globalLimit = true;
          } else if (err.status >= 500 && err.status < 600) {
            if (item.retries === this.client.options.retryLimit) {
              item.reject(err);
              resolve();
            } else {
              item.retr...
new Promise((resolve, reject) => {
      const listener = message => {
        if (!message || message._sFetchProp !== prop) return;
        process.removeListener('message', listener);
        if (!message._error) resolve(message._result); else reject(Util.makeError(message._error));
      };
      process.on('message', listener);

      this.send({ _sFetchProp: prop }).catch(err => {
        process.removeListener('message', listener);
        reject(err);
      });
    })
this.rest.makeRequest('get', Endpoints.Guild(guildID).embed, true).then(data => ({
      enabled: data.enabled,
      channel: data.channel_id ? this.client.channels.get(data.channel_id) : null,
    }))
this._idletimeout = this.client.setTimeout(() => this.stop('idle'), options.idle)
new Promise((resolve, reject) => {
      this.once('ready', resolve);
      this.once('disconnect', () => reject(new Error(`Shard ${this.id}'s Client disconnected before becoming ready.`)));
      this.once('death', () => reject(new Error(`Shard ${this.id}'s process exited before its Client became ready.`)));
      setTimeout(() => reject(new Error(`Shard ${this.id}'s Client took too long to become ready.`)), 30000);
    }).then(() => this.process)
const Actions = {
  ALL: null,
  GUILD_UPDATE: 1,
  CHANNEL_CREATE: 10,
  CHANNEL_UPDATE: 11,
  CHANNEL_DELETE: 12,
  CHANNEL_OVERWRITE_CREATE: 13,
  CHANNEL_OVERWRITE_UPDATE: 14,
  CHANNEL_OVERWRITE_DELETE: 15,
  MEMBER_KICK: 20,
  MEMBER_PRUNE: 21,
  MEMBER_BAN_ADD: 22,
  MEMBER_BAN_REMOVE: 23,
  MEMBER_UPDATE: 24,
  MEMBER_ROLE_UPDATE: 25,
  MEMBER_MOVE: 26,
  MEMBER_DISCONNECT: 27,
  BOT_ADD: 28,
  ROLE_CREATE: 30,
  ROLE_UPDATE: 31,
  ROLE_DELETE: 32,
  INVITE_CREATE: 40,
  INVITE_UPDATE: 41,
  INVITE_DELETE: 42,
  WEBHOOK_CREATE: 50,
  WEBHOOK_UPDATE: 51,
  WEBHOOK_DELETE: 52,
  EMOJI_CREATE: 60,
  EMOJI_UPDATE: 61,
  EMOJI_DELETE: 62,
  MESSAGE_DELETE: 72,
  MESSAGE_BULK_DELETE: 73,
  MESSAGE_PIN: 74,
  MESSAGE_UNPIN: 75,
  INTEGRATION_CREATE: 80,
  INTEGRATION_UPDATE: 81,
  INTEGRATION_DELETE: 82,
}
_tmp_12.d = {
          protocol: 'udp',
          data: {
            address: packet.address,
            port: packet.port,
            mode: 'xsalsa20_poly1305',
          },
        }
this.player.on('error', e => {
      /**
       * Warning info from the connection.
       * @event VoiceConnection#warn
       * @param {string|Error} warning The warning
       */
      this.emit('warn', e);
    })
_tmp_13.data = {
            address: packet.address,
            port: packet.port,
            mode: 'xsalsa20_poly1305',
          }
dispatcher.once('end', () => this.unregisterDispatcher(dispatcher))
dispatcher.on('volumeChange', (o, n) => {
        this.unregisterDispatcher(dispatcher, o);
        if (!this._dispatchers.has(n)) {
          this._dispatchers.set(n, new Set());
          this._encoders.set(n, OpusEncoders.fetch());
        }
        this._dispatchers.get(n).add(dispatcher);
      })
function parseLocalPacket = function parseLocalPacket(message) {
  try {
    const packet = Buffer.from(message);
    let address = '';
    for (let i = 4; i < packet.indexOf(0, i); i++) address += String.fromCharCode(packet[i]);
    const port = parseInt(packet.readUIntLE(packet.length - 2, 2).toString(10), 10);
    return { address, port };
  } catch (error) {
    return { error };
  }
}
transcoder.once('error', e => {
      if (this.listenerCount('error') > 0) this.emit('error', e);
      /**
       * Emitted whenever the VoiceBroadcast has any warnings.
       * @event VoiceBroadcast#warn
       * @param {string|Error} warning The warning that was raised
       */
      else this.emit('warn', e);
    })
<operator>.formatString("", base, "/messages/", messageID, "")
this.authenticateFailed('Token not provided from voice server packet.')
this.rest.makeRequest('post', Endpoints.Channel(channel).messages.bulkDelete, true, {
      messages: messages,
    }).then(() =>
      this.client.actions.MessageDeleteBulk.handle({
        channel_id: channel.id,
        ids: messages,
      }).messages
    )
new Promise(resolve => {
      let status = this.localPresence.status || this.presence.status;
      let game = this.localPresence.game;
      let afk = this.localPresence.afk || this.presence.afk;

      if (!game && this.presence.game) {
        game = {
          name: this.presence.game.name,
          type: this.presence.game.type,
          url: this.presence.game.url,
        };
      }

      if (data.status) {
        if (typeof data.status !== 'string') throw new TypeError('Status must be a string');
        if (this.bot) {
          status = data.status;
        } else {
          this.settings.update(Constants.UserSettingsMap.status, data.status);
          status = 'invisible';
        }
      }

      if (data.game) {
        game = data.game;
        game.type = game.url && typeof game.type === 'undefined' ? 1 : game.type || 0;
        if (typeof game.type === 'string') {
          game.type = Constants.ActivityTypes.indexOf(game.type.toUpperCase());
        }
      }...
this.client.actions.MessageDeleteBulk.handle({
        channel_id: channel.id,
        ids: messages,
      }).messages
this.client.channels.find(c => c.type === 'dm' && c.recipient.id === this.id)
options.maxID = long.fromNumber(options.before.getTime() - 14200704e5).shiftLeft(22).toString()
const user = this.client.users.get(user_id)
content = Util.escapeMarkdown(this.client.resolver.resolveString(content), true)
Util.mergeDefault({
      name: this.name,
      permissionOverwrites: this.permissionOverwrites,
      topic: this.topic,
      type: this.type,
      nsfw: this.nsfw,
      parent: this.parent,
      bitrate: this.bitrate,
      userLimit: this.userLimit,
      rateLimitPerUser: this.rateLimitPerUser,
      reason: null,
    }, nameOrOptions)
const voiceState = this._rawVoiceStates.get(member.user.id)
member.selfStream = voiceState.self_stream || false
this.client.channels.get(voiceState.channel_id).members.set(member.user.id, member)
this.client.emit(Constants.Events.GUILD_MEMBER_ADD, member)
const member = this.members.get(user)
member && member.speaking !== speaking
this.client.emit(Constants.Events.GUILD_MEMBER_SPEAKING, member, speaking)
