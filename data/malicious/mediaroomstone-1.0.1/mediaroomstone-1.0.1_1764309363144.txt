params.maxPacketLifeTime && typeof params.maxPacketLifeTime !== 'number'
throw new TypeError('cannot provide both maxPacketLifeTime and maxRetransmits');
const reqData = {
            type,
            sctpStreamParameters,
            label,
            protocol
        }
params.ordered = false
_tmp_114.push(router.createPipeTransport({ listenIp, enableSctp, numSctpStreams, enableRtx, enableSrtp }))
const dataProducer = new DataProducer_1.DataProducer({
            internal,
            data,
            channel: this.channel,
            payloadChannel: this.payloadChannel,
            appData
        })
function generateRouterRtpCapabilities = function generateRouterRtpCapabilities(mediaCodecs = []) {
    // Normalize supported RTP capabilities.
    validateRtpCapabilities(supportedRtpCapabilities_1.supportedRtpCapabilities);
    if (!Array.isArray(mediaCodecs))
        throw new TypeError('mediaCodecs must be an Array');
    const clonedSupportedRtpCapabilities = utils.clone(supportedRtpCapabilities_1.supportedRtpCapabilities);
    const dynamicPayloadTypes = utils.clone(DynamicPayloadTypes);
    const caps = {
        codecs: [],
        headerExtensions: clonedSupportedRtpCapabilities.headerExtensions
    };
    for (const mediaCodec of mediaCodecs) {
        // This may throw.
        validateRtpCodecCapability(mediaCodec);
        const matchedSupportedCodec = clonedSupportedRtpCapabilities
            .codecs
            .find((supportedCodec) => (matchCodecs(mediaCodec, supportedCodec, { strict: false })));
        if (!matchedSupportedCodec) {
            throw new errors_1.UnsupportedError(`medi...
_tmp_117.push(localPipeTransport.connect({
                            ip: remotePipeTransport.tuple.localIp,
                            port: remotePipeTransport.tuple.localPort,
                            srtpParameters: remotePipeTransport.srtpParameters
                        }))
dataProducer.on('@close', () => {
            this.dataProducers.delete(dataProducer.id);
            this.emit('@dataproducerclose', dataProducer);
        })
const caps = {
        codecs: [],
        headerExtensions: clonedSupportedRtpCapabilities.headerExtensions
    }
type = 'sctp'
codec.kind === 'video'
const reqData = {
            type,
            sctpStreamParameters,
            label,
            protocol
        }
_tmp_79.parameters = {
                    apt: codec.preferredPayloadType
                }
const data = await this.channel.request('transport.consumeData', internal, reqData)
const dataConsumer = new DataConsumer_1.DataConsumer({
            internal,
            data,
            channel: this.channel,
            payloadChannel: this.payloadChannel,
            appData
        })
_tmp_92.data = data
this.dataConsumers.set(dataConsumer.id, dataConsumer)
dataConsumer.on('@close', () => {
            this.dataConsumers.delete(dataConsumer.id);
            if (this.#sctpStreamIds)
                this.#sctpStreamIds[sctpStreamId] = 0;
        })
this.dataConsumers.delete(dataConsumer.id)
dataConsumer.on('@dataproducerclose', () => {
            this.dataConsumers.delete(dataConsumer.id);
            if (this.#sctpStreamIds)
                this.#sctpStreamIds[sctpStreamId] = 0;
        })
this.dataConsumers.delete(dataConsumer.id)
