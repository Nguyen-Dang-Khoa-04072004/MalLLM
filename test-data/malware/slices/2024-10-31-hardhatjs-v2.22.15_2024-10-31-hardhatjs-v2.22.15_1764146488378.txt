function createLazyProxy = function createLazyProxy<ActualT extends GuardT, GuardT extends object>(
  targetCreator: () => ActualT,
  dummyTargetCreator: (getRealTarget: () => ActualT) => GuardT,
  validator: (target: any) => void
): ActualT {
  let realTarget: ActualT | undefined;

  const dummyTarget: ActualT = dummyTargetCreator(getRealTarget) as any;

  function getRealTarget(): ActualT {
    if (realTarget === undefined) {
      const target = targetCreator();
      validator(target);

      // We copy all properties. We won't use them, but help us avoid Proxy
      // invariant violations
      const properties = Object.getOwnPropertyNames(target);
      for (const property of properties) {
        const descriptor = Object.getOwnPropertyDescriptor(target, property)!;
        Object.defineProperty(dummyTarget, property, descriptor);
      }

      Object.setPrototypeOf(dummyTarget, Object.getPrototypeOf(target));

      // Using a null prototype seems to tirgger a V8 bug, so we forbid it
      // See: h...
function applyProviderWrappers = function applyProviderWrappers(provider, netConfig, extenders) {
    // These dependencies are lazy-loaded because they are really big.
    const LocalAccountsProvider = importProvider("./accounts", "LocalAccountsProvider");
    const HDWalletProvider = importProvider("./accounts", "HDWalletProvider");
    const FixedSenderProvider = importProvider("./accounts", "FixedSenderProvider");
    const AutomaticSenderProvider = importProvider("./accounts", "AutomaticSenderProvider");
    const AutomaticGasProvider = importProvider("./gas-providers", "AutomaticGasProvider");
    const FixedGasProvider = importProvider("./gas-providers", "FixedGasProvider");
    const AutomaticGasPriceProvider = importProvider("./gas-providers", "AutomaticGasPriceProvider");
    const FixedGasPriceProvider = importProvider("./gas-providers", "FixedGasPriceProvider");
    const ChainIdValidatorProvider = importProvider("./chainId", "ChainIdValidatorProvider");
    if (isResolvedHttpNetworkConfig(netConfig)) {...
function createCompilationJobFromFile = async function createCompilationJobFromFile(dependencyGraph, file, solidityConfig) {
    const directDependencies = dependencyGraph.getDependencies(file);
    const transitiveDependencies = dependencyGraph.getTransitiveDependencies(file);
    const compilerConfig = getCompilerConfigForFile(file, directDependencies, transitiveDependencies, solidityConfig);
    // if the config cannot be obtained, we just return the failure
    if (isCompilationJobCreationError(compilerConfig)) {
        return compilerConfig;
    }
    log(`File '${file.absolutePath}' will be compiled with version '${compilerConfig.version}'`);
    const compilationJob = new CompilationJob(compilerConfig);
    compilationJob.addFileToCompile(file, true);
    for (const { dependency } of transitiveDependencies) {
        log(`File '${dependency.absolutePath}' added as dependency of '${file.absolutePath}'`);
        compilationJob.addFileToCompile(dependency, false);
    }
    return compilationJob;
}
function analyzeModuleNotFoundError = function analyzeModuleNotFoundError(error, configPath) {
    const stackTraceParser = require("stacktrace-parser");
    if (error.code !== "MODULE_NOT_FOUND") {
        return;
    }
    const stackTrace = stackTraceParser.parse(error.stack);
    const throwingFile = stackTrace
        .filter((x) => x.file !== null)
        .map((x) => x.file)
        // ignore frames related to source map support
        .filter((x) => !x.includes(path_1.default.join("@cspotcode", "source-map-support")))
        .find((x) => path_1.default.isAbsolute(x));
    if (throwingFile === null || throwingFile === undefined) {
        return;
    }
    // if the error comes from the config file, we ignore it because we know it's
    // a direct import that's missing
    if (throwingFile === configPath) {
        return;
    }
    const packageJsonPath = (0, packageInfo_1.findClosestPackageJson)(throwingFile);
    if (packageJsonPath === null) {
        return;
    }
    const packageJson = fs_extra_1.defaul...
const bigint: CLIArgumentType<bigint> = {
  name: "bigint",
  parse: (argName, strValue) => {
    const decimalPattern = /^\d+(?:n)?$/;
    const hexPattern = /^0[xX][\dABCDEabcde]+$/;

    if (
      strValue.match(decimalPattern) === null &&
      strValue.match(hexPattern) === null
    ) {
      throw new HardhatError(ERRORS.ARGUMENTS.INVALID_VALUE_FOR_TYPE, {
        value: strValue,
        name: argName,
        type: bigint.name,
      });
    }

    return BigInt(strValue.replace("n", ""));
  },
  /**
   * Check if argument value is of type "bigint".
   *
   * @param argName {string} argument's name - used for context in case of error.
   * @param value {any} argument's value to validate.
   *
   * @throws HH301 if value is not of type "bigint"
   */
  validate: (argName: string, value: any): void => {
    const isBigInt = typeof value === "bigint";
    if (!isBigInt) {
      throw new HardhatError(ERRORS.ARGUMENTS.INVALID_VALUE_FOR_TYPE, {
        value,
        name: argName,
  ...
_tmp_15.LIB_IMPORTED_FROM_THE_CONFIG = {
      number: 9,
      message: `Error while loading Hardhat's configuration.

You probably tried to import the "hardhat" module from your config or a file imported from it.
This is not possible, as Hardhat can't be initialized while its config is being defined.

To learn more about how to access the Hardhat Runtime Environment from different contexts go to https://hardhat.org/hre`,
      title: "Failed to load config file",
      description: `There was an error while loading your config file.

The most common source of errors is trying to import the Hardhat Runtime Environment from your config or a file imported from it.
This is not possible, as Hardhat can't be initialized while its config is being defined.

You may also have accidentally imported \`hardhat\` instead of \`hardhat/config\`.

Please make sure your config file is correct.

To learn more about how to access the Hardhat Runtime Environment from different contexts go to https://hardhat.org/hre`,
      shouldBeReporte...
function resolveHardhatNetworkConfig = function resolveHardhatNetworkConfig(
  hardhatNetworkConfig: HardhatNetworkUserConfig = {}
): HardhatNetworkConfig {
  const cloneDeep = require("lodash/cloneDeep") as LoDashStatic["cloneDeep"];
  const clonedDefaultHardhatNetworkParams = cloneDeep(
    defaultHardhatNetworkParams
  );

  const accounts: HardhatNetworkAccountsConfig =
    hardhatNetworkConfig.accounts === undefined
      ? defaultHardhatNetworkHdAccountsConfigParams
      : Array.isArray(hardhatNetworkConfig.accounts)
      ? hardhatNetworkConfig.accounts.map(({ privateKey, balance }) => ({
          privateKey: normalizeHexString(privateKey),
          balance,
        }))
      : {
          ...defaultHardhatNetworkHdAccountsConfigParams,
          ...hardhatNetworkConfig.accounts,
        };

  const forking: HardhatNetworkForkingConfig | undefined =
    hardhatNetworkConfig.forking !== undefined
      ? {
          url: hardhatNetworkConfig.forking.url,
          enabled: hardhatNetworkConfig.forking.enabled ??...
(0, config_env_1.subtask)(task_names_1.TASK_COMPILE_SOLIDITY_GET_DEPENDENCY_GRAPH)
    .addOptionalParam("rootPath", undefined, undefined, config_env_1.types.string)
    .addParam("sourceNames", undefined, undefined, config_env_1.types.any)
    .addOptionalParam("solidityFilesCache", undefined, undefined, config_env_1.types.any)
    .setAction(async ({ rootPath, sourceNames, solidityFilesCache, }, { config, run }) => {
    const parser = new parse_1.Parser(solidityFilesCache);
    const remappings = await run(task_names_1.TASK_COMPILE_GET_REMAPPINGS);
    const resolver = new resolver_1.Resolver(rootPath ?? config.paths.root, parser, remappings, (absolutePath) => run(task_names_1.TASK_COMPILE_SOLIDITY_READ_FILE, { absolutePath }), (importName) => run(task_names_1.TASK_COMPILE_TRANSFORM_IMPORT_NAME, {
        importName,
        deprecationCheck: true,
    }));
    const resolvedFiles = await Promise.all(sourceNames.map((sn) => resolver.resolveSourceName(sn)));
    return dependencyG...
const scope = new SimpleScopeDefinition(
      name,
      description,
      (taskName, descriptionOrAction, action) =>
        // if this function is updated, update the dsl.task function too
        this._addTask(
          { scope: name, task: taskName },
          descriptionOrAction,
          action,
          false
        ),
      (subtaskName, descriptionOrAction, action) =>
        // if this function is updated, update the dsl.subtask function too
        this._addTask(
          { scope: name, task: subtaskName },
          descriptionOrAction,
          action,
          true
        )
    )
throw new errors_1.HardhatError(errors_list_1.ERRORS.RESOLVER.IMPORTED_MAPPED_FILE_NOT_FOUND, {
                        imported,
                        importName,
                        from: from.sourceName,
                    }, error);
_tmp_27.description = "An internal invariant was violated.
This is probably caused by a programming error in hardhat or in one of the used plugins.

Please [report it](https://github.com/nomiclabs/hardhat/issues/new) to help us improve Hardhat."
await Promise.all([
                fs_extra_1.default.writeJSON(artifactPath, artifact, {
                    spaces: 2,
                }),
                (async () => {
                    if (pathToBuildInfo === undefined) {
                        return;
                    }
                    // save debug file
                    const debugFilePath = this._getDebugFilePath(artifactPath);
                    const debugFile = this._createDebugFile(artifactPath, pathToBuildInfo);
                    await fs_extra_1.default.writeJSON(debugFilePath, debugFile, {
                        spaces: 2,
                    });
                })(),
            ])
function resolveHttpNetworkConfig = function resolveHttpNetworkConfig(networkConfig) {
    const cloneDeep = require("lodash/cloneDeep");
    const accounts = networkConfig.accounts === undefined
        ? default_config_1.defaultHttpNetworkParams.accounts
        : isHdAccountsConfig(networkConfig.accounts)
            ? {
                ...default_config_1.defaultHdAccountsConfigParams,
                ...networkConfig.accounts,
            }
            : Array.isArray(networkConfig.accounts)
                ? networkConfig.accounts.map(normalizeHexString)
                : "remote";
    const url = networkConfig.url;
    (0, errors_1.assertHardhatInvariant)(url !== undefined, "Invalid http network config provided. URL missing.");
    return {
        ...cloneDeep(default_config_1.defaultHttpNetworkParams),
        ...networkConfig,
        accounts,
        url,
        gas: networkConfig.gas ?? default_config_1.defaultHttpNetworkParams.gas,
        gasPrice: networkConfig.gasPrice ?? default_config_1.defaultHttp...
const accounts = networkConfig.accounts === undefined
        ? default_config_1.defaultHttpNetworkParams.accounts
        : isHdAccountsConfig(networkConfig.accounts)
            ? {
                ...default_config_1.defaultHdAccountsConfigParams,
                ...networkConfig.accounts,
            }
            : Array.isArray(networkConfig.accounts)
                ? networkConfig.accounts.map(normalizeHexString)
                : "remote"
Sentry.init({
      dsn: SENTRY_DSN,
      transport: getSubprocessTransport(),
      integrations: () => [linkedErrorsIntegration],
    })
(0, config_env_1.subtask)(task_names_1.TASK_COMPILE_SOLIDITY_GET_COMPILATION_JOB_FOR_FILE)
    .addParam("dependencyGraph", undefined, undefined, config_env_1.types.any)
    .addParam("file", undefined, undefined, config_env_1.types.any)
    .addOptionalParam("solidityFilesCache", undefined, undefined, config_env_1.types.any)
    .setAction(async ({ dependencyGraph, file, }, { config }) => {
    return (0, compilation_job_1.createCompilationJobFromFile)(dependencyGraph, file, config.solidity);
})
function printAlreadySetKeys = function printAlreadySetKeys(varsManagerSetup) {
    const requiredKeysAlreadySet = varsManagerSetup.getRequiredVarsAlreadySet();
    const optionalKeysAlreadySet = varsManagerSetup.getOptionalVarsAlreadySet();
    const envVars = varsManagerSetup.getEnvVars();
    if (requiredKeysAlreadySet.length === 0 &&
        optionalKeysAlreadySet.length === 0 &&
        envVars.length === 0) {
        return;
    }
    console.log(`${chalk_1.default.bold(`${(0, emoji_1.emoji)("✔️  ")}Configuration variables already set:`)}`);
    console.log();
    if (requiredKeysAlreadySet.length > 0) {
        console.log("  Mandatory:");
        console.log(requiredKeysAlreadySet.map((x) => `    ${x}`).join("\n"));
        console.log();
    }
    if (optionalKeysAlreadySet.length > 0) {
        console.log("  Optional:");
        console.log(optionalKeysAlreadySet.map((x) => `    ${x}`).join("\n"));
        console.log();
    }
    if (envVars.length > 0) {
        console.log("  Set via environment var...
function createCompilationJobFromFile = async function createCompilationJobFromFile(
  dependencyGraph: taskTypes.DependencyGraph,
  file: ResolvedFile,
  solidityConfig: SolidityConfig
): Promise<CompilationJob | CompilationJobCreationError> {
  const directDependencies = dependencyGraph.getDependencies(file);
  const transitiveDependencies =
    dependencyGraph.getTransitiveDependencies(file);

  const compilerConfig = getCompilerConfigForFile(
    file,
    directDependencies,
    transitiveDependencies,
    solidityConfig
  );

  // if the config cannot be obtained, we just return the failure
  if (isCompilationJobCreationError(compilerConfig)) {
    return compilerConfig;
  }
  log(
    `File '${file.absolutePath}' will be compiled with version '${compilerConfig.version}'`
  );

  const compilationJob = new CompilationJob(compilerConfig);

  compilationJob.addFileToCompile(file, true);
  for (const { dependency } of transitiveDependencies) {
    log(
      `File '${dependency.absolutePath}' added as dependency of '${...
function analyzeModuleNotFoundError = function analyzeModuleNotFoundError(error: any, configPath: string) {
  const stackTraceParser =
    require("stacktrace-parser") as typeof StackTraceParserT;

  if (error.code !== "MODULE_NOT_FOUND") {
    return;
  }
  const stackTrace = stackTraceParser.parse(error.stack);
  const throwingFile = stackTrace
    .filter((x) => x.file !== null)
    .map((x) => x.file!)
    // ignore frames related to source map support
    .filter((x) => !x.includes(path.join("@cspotcode", "source-map-support")))
    .find((x) => path.isAbsolute(x));

  if (throwingFile === null || throwingFile === undefined) {
    return;
  }

  // if the error comes from the config file, we ignore it because we know it's
  // a direct import that's missing
  if (throwingFile === configPath) {
    return;
  }

  const packageJsonPath = findClosestPackageJson(throwingFile);

  if (packageJsonPath === null) {
    return;
  }

  const packageJson = fsExtra.readJsonSync(packageJsonPath);
  const peerDependencies: { [na...
const HardhatNetworkConfig = t.type({
    ...commonNetworkConfigFields,
    hardfork: (0, io_ts_1.optional)(t.keyof((0, lang_1.fromEntries)(constants_1.HARDHAT_NETWORK_SUPPORTED_HARDFORKS.map((hf) => [hf, null])))),
    accounts: (0, io_ts_1.optional)(t.union([t.array(HardhatNetworkAccount), HardhatNetworkHDAccountsConfig])),
    blockGasLimit: (0, io_ts_1.optional)(t.number),
    minGasPrice: (0, io_ts_1.optional)(t.union([t.number, t.string])),
    throwOnTransactionFailures: (0, io_ts_1.optional)(t.boolean),
    throwOnCallFailures: (0, io_ts_1.optional)(t.boolean),
    allowUnlimitedContractSize: (0, io_ts_1.optional)(t.boolean),
    initialDate: (0, io_ts_1.optional)(t.string),
    loggingEnabled: (0, io_ts_1.optional)(t.boolean),
    forking: (0, io_ts_1.optional)(HardhatNetworkForkingConfig),
    mining: (0, io_ts_1.optional)(HardhatNetworkMiningConfig),
    coinbase: (0, io_ts_1.optional)(exports.address),
    chains: (0, io_ts_1.optional)(HardhatNetworkChainsConfig),
})
transaction = ethereumjs_tx_1.FeeMarketEIP1559Transaction.fromTxData({
                ...txData,
                accessList,
                gasPrice: undefined,
            }, { common })
function getAction = async function getAction(isEsm) {
    if (process.env.HARDHAT_CREATE_JAVASCRIPT_PROJECT_WITH_DEFAULTS !== undefined) {
        return Action.CREATE_JAVASCRIPT_PROJECT_ACTION;
    }
    else if (process.env.HARDHAT_CREATE_TYPESCRIPT_PROJECT_WITH_DEFAULTS !== undefined) {
        return Action.CREATE_TYPESCRIPT_PROJECT_ACTION;
    }
    else if (process.env.HARDHAT_CREATE_TYPESCRIPT_VIEM_PROJECT_WITH_DEFAULTS !==
        undefined) {
        return Action.CREATE_TYPESCRIPT_VIEM_PROJECT_ACTION;
    }
    const { default: enquirer } = await Promise.resolve().then(() => __importStar(require("enquirer")));
    try {
        const actionResponse = await enquirer.prompt([
            {
                name: "action",
                type: "select",
                message: "What do you want to do?",
                initial: 0,
                choices: Object.values(Action)
                    .filter((a) => {
                    if (isEsm && a === Action.CREATE_TYPESCRIPT_VIEM_PROJECT_ACTIO...
this.paramDefinitions[name] = {
      name,
      defaultValue: false,
      type: types.boolean,
      description,
      isFlag: true,
      isOptional: true,
      isVariadic: false,
    }
subtask(
  TASK_FLATTEN_GET_FLATTENED_SOURCE_AND_METADATA,
  "Returns all contracts and their dependencies flattened. Also return metadata about pragma directives and SPDX licenses"
)
  .addOptionalParam("files", undefined, undefined, types.any)
  .setAction(
    async (
      { files }: { files?: string[] },
      { run }
    ): Promise<[string, FlattenMetadata | null]> => {
      const dependencyGraph: DependencyGraph = await run(
        TASK_FLATTEN_GET_DEPENDENCY_GRAPH,
        { files }
      );

      let flattened = "";

      if (dependencyGraph.getResolvedFiles().length === 0) {
        return [flattened, null];
      }

      const packageJson = await getPackageJson();
      flattened += `// Sources flattened with hardhat v${packageJson.version} https://hardhat.org`;

      const sortedFiles = getSortedFiles(dependencyGraph);

      const [licenses, filesWithoutLicenses] = getLicensesInfo(sortedFiles);
      const [
        pragmaDirective,
        filesWithoutPragmaDirec...
_tmp_15.NOT_INSIDE_PROJECT_ON_WINDOWS = {
      number: 15,
      message: `You are not inside a project and Hardhat failed to initialize a new one.

If you were trying to create a new project, please try again using Windows Subsystem for Linux (WSL) or PowerShell.
`,
      title:
        "You are not inside a Hardhat project and Hardhat failed to initialize a new one",
      description: `You are trying to run Hardhat outside of a Hardhat project, and we couldn't initialize one.

If you were trying to create a new project, please try again using Windows Subsystem for Linux (WSL) or PowerShell.

You can learn how to use Hardhat by reading the [Getting Started guide](/hardhat-runner/docs/getting-started).`,
      shouldBeReported: false,
    }
const actionResponse = await enquirer.prompt([
            {
                name: "action",
                type: "select",
                message: "What do you want to do?",
                initial: 0,
                choices: Object.values(Action)
                    .filter((a) => {
                    if (isEsm && a === Action.CREATE_TYPESCRIPT_VIEM_PROJECT_ACTION) {
                        // we omit the viem option for ESM projects to avoid showing
                        // two disabled options
                        return false;
                    }
                    return true;
                })
                    .map((a) => {
                    let message;
                    if (isEsm) {
                        if (a === Action.CREATE_EMPTY_HARDHAT_CONFIG_ACTION) {
                            message = a.replace(".js", ".cjs");
                        }
                        else if (a === Action.CREATE_TYPESCRIPT_PROJECT_ACTION) {
                            mes...
function getMessageFromLastStackTraceEntry = function getMessageFromLastStackTraceEntry(
  stackTraceEntry: SolidityStackTraceEntry
): string | undefined {
  switch (stackTraceEntry.type) {
    case StackTraceEntryType.PRECOMPILE_ERROR:
      return `Transaction reverted: call to precompile ${stackTraceEntry.precompile} failed`;

    case StackTraceEntryType.FUNCTION_NOT_PAYABLE_ERROR:
      return `Transaction reverted: non-payable function was called with value ${stackTraceEntry.value.toString(
        10
      )}`;

    case StackTraceEntryType.INVALID_PARAMS_ERROR:
      return `Transaction reverted: function was called with incorrect parameters`;

    case StackTraceEntryType.FALLBACK_NOT_PAYABLE_ERROR:
      return `Transaction reverted: fallback function is not payable and was called with value ${stackTraceEntry.value.toString(
        10
      )}`;

    case StackTraceEntryType.FALLBACK_NOT_PAYABLE_AND_NO_RECEIVE_ERROR:
      return `Transaction reverted: there's no receive function, fallback function is not payable an...
_tmp_16.CORRUPTED_LOCKFILE = {
            number: 18,
            message: `You installed Hardhat with a corrupted lockfile due to the NPM bug #4828.

Please delete your node_modules, package-lock.json, reinstall your project, and try again.`,
            title: "Corrupted lockfile",
            description: `Some versions of NPM are affected [by a bug](https://github.com/npm/cli/issues/4828) that leads to corrupt lockfiles being generated.

This bug can only affect you if you, or someone at your team, installed the project without a lockfile, but with an existing node_modules.

To avoid it, please delete both your node_modules and package-lock.json, and reinstall your project.

Note that you don't need to do this every time you install a new dependency, but please make sure to delete your node_modules every time you delete your package-lock.json.`,
            shouldBeReported: true,
        }
exports.inputFile = {
    name: "inputFile",
    parse(argName, strValue) {
        try {
            fs.accessSync(strValue, fs_extra_1.default.constants.R_OK);
            const stats = fs.lstatSync(strValue);
            if (stats.isDirectory()) {
                // This is caught and encapsulated in a hardhat error.
                // eslint-disable-next-line @nomicfoundation/hardhat-internal-rules/only-hardhat-error
                throw new Error(`${strValue} is a directory, not a file`);
            }
        }
        catch (error) {
            if (error instanceof Error) {
                throw new errors_1.HardhatError(errors_list_1.ERRORS.ARGUMENTS.INVALID_INPUT_FILE, {
                    name: argName,
                    value: strValue,
                }, error);
            }
            // eslint-disable-next-line @nomicfoundation/hardhat-internal-rules/only-hardhat-error
            throw error;
        }
        return strValue;
    },
    /**
     * Check if arg...
function getCompilerConfigForFile = function getCompilerConfigForFile(
  file: ResolvedFile,
  directDependencies: ResolvedFile[],
  transitiveDependencies: taskTypes.TransitiveDependency[],
  solidityConfig: SolidityConfig
): SolcConfig | CompilationJobCreationError {
  const transitiveDependenciesVersionPragmas = transitiveDependencies
    .map(({ dependency }) => dependency.content.versionPragmas)
    .flat();
  const versionRange = Array.from(
    new Set([
      ...file.content.versionPragmas,
      ...transitiveDependenciesVersionPragmas,
    ])
  ).join(" ");

  const overrides = solidityConfig.overrides ?? {};

  const overriddenCompiler = overrides[file.sourceName];

  // if there's an override, we only check that
  if (overriddenCompiler !== undefined) {
    if (!semver.satisfies(overriddenCompiler.version, versionRange)) {
      return getCompilationJobCreationError(
        file,
        directDependencies,
        transitiveDependencies,
        [overriddenCompiler.version],
        true
      );
    }

 ...
assertHardhatInvariant(
        scopeDefinition !== undefined,
        "It shouldn't be possible to create a task in a scope that doesn't exist"
      )
console.warn(chalk_1.default.yellow(`Solidity remappings are not currently supported; you may experience unexpected compilation results. Remove any 'remappings' fields from your configuration to suppress this warning.

Learn more about compiler configuration at https://hardhat.org/config
`))
_tmp_16.ESM_PROJECT_WITHOUT_CJS_CONFIG = {
            number: 19,
            message: `Your project is an ESM project (you have "type": "module" set in your package.json) but your Hardhat config file uses the .js extension.

Rename the file to use the .cjs to fix this problem.`,
            title: "Hardhat config with .js extension in an ESM project",
            description: "Your project is an ESM project but your Hardhat config uses the .js extension. Hardhat config files cannot be an ES module. To fix this, rename your Hardhat config to use the .cjs extension.",
            shouldBeReported: false,
        }
function includesOwnPackageName = async function includesOwnPackageName(
  sourceName: string
): Promise<boolean> {
  const packageName = await getPackageName(sourceName);
  if (packageName !== "") {
    return sourceName.startsWith(`${packageName}/`);
  }
  return false;
}
throw new HardhatError(
          ERRORS.RESOLVER.INVALID_IMPORT_WRONG_CASING,
          {
            imported,
            from: from.sourceName,
          },
          error
        );
_tmp_16.ESM_TYPESCRIPT_PROJECT_CREATION = {
            number: 20,
            message: `Your project is an ESM project (you have "type": "module" set in your package.json) and you are trying to initialize a TypeScript project. This is not supported yet.`,
            title: "Initializing a TypeScript sample project in an ESM project",
            description: `Your project is an ESM project (you have "type": "module" set in your package.json) and you are trying to initialize a TypeScript project. This is not supported yet.`,
            shouldBeReported: false,
        }
const provider = await Provider.withConfig(
      getGlobalEdrContext(),
      {
        allowBlocksWithSameTimestamp:
          config.allowBlocksWithSameTimestamp ?? false,
        allowUnlimitedContractSize: config.allowUnlimitedContractSize,
        bailOnCallFailure: config.throwOnCallFailures,
        bailOnTransactionFailure: config.throwOnTransactionFailures,
        blockGasLimit: BigInt(config.blockGasLimit),
        chainId: BigInt(config.chainId),
        chains: Array.from(config.chains, ([chainId, hardforkConfig]) => {
          return {
            chainId: BigInt(chainId),
            hardforks: Array.from(
              hardforkConfig.hardforkHistory,
              ([hardfork, blockNumber]) => {
                return {
                  blockNumber: BigInt(blockNumber),
                  specId: ethereumsjsHardforkToEdrSpecId(
                    getHardforkName(hardfork)
                  ),
                };
              }
            ),
          };
        }),
    ...
_tmp_36.message = "Your project is an ESM project (you have "type": "module" set in your package.json) and you are trying to initialize a TypeScript project. This is not supported yet."
_tmp_33.description = "Some versions of NPM are affected [by a bug](https://github.com/npm/cli/issues/4828) that leads to corrupt lockfiles being generated.

This bug can only affect you if you, or someone at your team, installed the project without a lockfile, but with an existing node_modules.

To avoid it, please delete both your node_modules and package-lock.json, and reinstall your project.

Note that you don't need to do this every time you install a new dependency, but please make sure to delete your node_modules every time you delete your package-lock.json."
const response = (await this._wrappedProvider.request({
        method: "eth_feeHistory",
        params: [
          "0x1",
          "latest",
          [AutomaticGasPriceProvider.EIP1559_REWARD_PERCENTILE],
        ],
      })) as { baseFeePerGas: string[]; reward: string[][] }
runSuperFunction = async (
        _taskArguments: TaskArguments = taskArguments,
        _subtaskArguments: SubtaskArguments = subtaskArguments
      ) => {
        log("Running %s's super", taskDefinition.name);

        if (taskProfile === undefined) {
          return this._runTaskDefinition(
            taskDefinition.parentTaskDefinition,
            _taskArguments,
            _subtaskArguments
          );
        }

        const parentTaskProfile = createParentTaskProfile(taskProfile);
        taskProfile.children.push(parentTaskProfile);

        try {
          return await this._runTaskDefinition(
            taskDefinition.parentTaskDefinition,
            _taskArguments,
            _subtaskArguments,
            parentTaskProfile
          );
        } finally {
          completeTaskProfile(parentTaskProfile);
        }
      }
function checkEmptyConfig = function checkEmptyConfig(
  userConfig: any,
  { showSolidityConfigWarnings }: { showSolidityConfigWarnings: boolean }
) {
  if (userConfig === undefined || Object.keys(userConfig).length === 0) {
    let warning = `Hardhat config is returning an empty config object, check the export from the config file if this is unexpected.\n`;

    // This 'learn more' section is also printed by the solidity config warning,
    // so we need to check to avoid printing it twice
    if (!showSolidityConfigWarnings) {
      warning += `\nLearn more about configuring Hardhat at https://hardhat.org/config\n`;
    }

    console.warn(chalk.yellow(warning));
  }
}
errors.push(getErrorMessage(`HardhatConfig.networks.${constants_1.HARDHAT_NETWORK_NAME}`, hardhatNetwork, "HardhatNetworkConfig"))
function getAction = async function getAction(isEsm: boolean): Promise<Action> {
  if (
    process.env.HARDHAT_CREATE_JAVASCRIPT_PROJECT_WITH_DEFAULTS !== undefined
  ) {
    return Action.CREATE_JAVASCRIPT_PROJECT_ACTION;
  } else if (
    process.env.HARDHAT_CREATE_TYPESCRIPT_PROJECT_WITH_DEFAULTS !== undefined
  ) {
    return Action.CREATE_TYPESCRIPT_PROJECT_ACTION;
  } else if (
    process.env.HARDHAT_CREATE_TYPESCRIPT_VIEM_PROJECT_WITH_DEFAULTS !==
    undefined
  ) {
    return Action.CREATE_TYPESCRIPT_VIEM_PROJECT_ACTION;
  }

  const { default: enquirer } = await import("enquirer");
  try {
    const actionResponse = await enquirer.prompt<{ action: string }>([
      {
        name: "action",
        type: "select",
        message: "What do you want to do?",
        initial: 0,
        choices: Object.values(Action)
          .filter((a: Action) => {
            if (isEsm && a === Action.CREATE_TYPESCRIPT_VIEM_PROJECT_ACTION) {
              // we omit the viem option for ESM projects to avoi...
function getAllWordMatches = function getAllWordMatches(errorMessage) {
    const matches = [];
    const re = /\p{Letter}+/gu;
    let match = re.exec(errorMessage);
    while (match !== null) {
        matches.push({
            word: match[0],
            index: match.index,
        });
        match = re.exec(errorMessage);
    }
    return matches;
}
(rpcQuantityToBigInt(response.baseFeePerGas[1]) *
            9n **
              (AutomaticGasPriceProvider.EIP1559_BASE_FEE_MAX_FULL_BLOCKS_PREFERENCE -
                1n)) /
          8n **
            (AutomaticGasPriceProvider.EIP1559_BASE_FEE_MAX_FULL_BLOCKS_PREFERENCE -
              1n)
function createProject = async function createProject() {
    printAsciiLogo();
    await printWelcomeMessage();
    let packageJson;
    if (await fs_extra_1.default.pathExists("package.json")) {
        packageJson = await fs_extra_1.default.readJson("package.json");
    }
    const isEsm = packageJson?.type === "module";
    const action = await getAction(isEsm);
    if (action === Action.QUIT_ACTION) {
        return;
    }
    if (isEsm && action === Action.CREATE_TYPESCRIPT_PROJECT_ACTION) {
        throw new errors_1.HardhatError(errors_list_1.ERRORS.GENERAL.ESM_TYPESCRIPT_PROJECT_CREATION);
    }
    if (packageJson === undefined) {
        await createPackageJson();
    }
    if (action === Action.CREATE_EMPTY_HARDHAT_CONFIG_ACTION) {
        await writeEmptyHardhatConfig(isEsm);
        console.log(`${(0, emoji_1.emoji)("✨ ")}${chalk_1.default.cyan(`Config file created`)}${(0, emoji_1.emoji)(" ✨")}`);
        if (!isInstalled(HARDHAT_PACKAGE_NAME)) {
            console.log("");
            consol...
_tmp_2.push({
        name: "action",
        type: "select",
        message: "What do you want to do?",
        initial: 0,
        choices: Object.values(Action)
          .filter((a: Action) => {
            if (isEsm && a === Action.CREATE_TYPESCRIPT_VIEM_PROJECT_ACTION) {
              // we omit the viem option for ESM projects to avoid showing
              // two disabled options
              return false;
            }

            return true;
          })
          .map((a: Action) => {
            let message: string;
            if (isEsm) {
              if (a === Action.CREATE_EMPTY_HARDHAT_CONFIG_ACTION) {
                message = a.replace(".js", ".cjs");
              } else if (a === Action.CREATE_TYPESCRIPT_PROJECT_ACTION) {
                message = `${a} (not available for ESM projects)`;
              } else {
                message = a;
              }
            } else {
              message = a;
            }

            return {
              name: a,
         ...)
_tmp_41.INVALID_GLOBAL_CHAIN_ID = {
            number: 101,
            message: "Hardhat was set to use chain id %configChainId%, but connected to a chain with id %connectionChainId%.",
            title: "Connected to the wrong network",
            description: `Your config specifies a chain id for the network you are trying to use, but Hardhat detected a different chain id.

Please make sure you are setting your config correctly.`,
            shouldBeReported: false,
        }
task(
  TASK_FLATTEN,
  "Flattens and prints contracts and their dependencies. If no file is passed, all the contracts in the project will be flattened."
)
  .addOptionalVariadicPositionalParam(
    "files",
    "The files to flatten",
    undefined,
    types.inputFile
  )
  .setAction(async ({ files }: { files: string[] | undefined }, { run }) => {
    const [flattenedFile, metadata]: [string, FlattenMetadata | null] =
      await run(TASK_FLATTEN_GET_FLATTENED_SOURCE_AND_METADATA, { files });

    console.log(flattenedFile);

    if (metadata === null) return;

    if (metadata.filesWithoutLicenses.length > 0) {
      console.warn(
        chalk.yellow(
          `\nThe following file(s) do NOT specify SPDX licenses: ${metadata.filesWithoutLicenses.join(
            ", "
          )}`
        )
      );
    }

    if (
      metadata.pragmaDirective !== "" &&
      metadata.filesWithoutPragmaDirectives.length > 0
    ) {
      console.warn(
        chalk.yellow(
          `\nPrag...
_tmp_41.NOT_LOCAL_ACCOUNT = {
            number: 103,
            message: "Account %account% is not managed by the node you are connected to.",
            title: "Unrecognized account",
            description: `You are trying to send a transaction or sign some data with an
account not managed by your Ethereum node nor Hardhat.

Please double check your accounts and the \`from\` parameter in your RPC calls.`,
            shouldBeReported: false,
        }
log(
        `The dependency graph was divided in '${connectedComponents.length}' connected components`
      )
throw new HardhatError(
          ERRORS.RESOLVER.LIBRARY_NOT_INSTALLED,
          {
            library: libraryName,
          },
          error as Error
        );
