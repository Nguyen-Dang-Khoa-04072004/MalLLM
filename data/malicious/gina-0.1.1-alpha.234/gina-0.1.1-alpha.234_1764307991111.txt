var removeEnv = function(projects, target) {
        var err = null, env = local.env;
        // default `dev env` cannot be removed
        if(env === projects[self.projectName]['dev_env']|| env === projects[self.projectName]['def_env']) {
            if (env === projects[self.projectName]['def_env']) {
                err = new Error('Environment [ '+env+' ] is set as "default environment"')
            } else {
                err = new Error('Environment [ '+env+' ] is linked as "development environment"')
            }

            return end(err);
        }

        projects[self.projectName]['envs'].splice(projects[self.projectName]['envs'].indexOf(env), 1);
        lib.generator.createFileFromDataSync(
            projects,
            target
        );
        // clean ports & reverse ports registered for the project
        var portsPath = _(GINA_HOMEDIR + '/ports.json')
            , portsReversePath = _(GINA_HOMEDIR + '/ports.reverse.json')
            , ports = require(port...
var setup = function(namespace) {
        if ( typeof(namespace) == 'undefined' || namespace == '') {
            console.error('[ MODEL ][ '+ namespace +' ] MODEL:ERR:1 EEMPTY: Model namespace',  __stack);
        }

        var model, namespace = namespace.split(/\//g);
        _connector = namespace[1];//Has to be writtien the same for the connetors.json decalration or for the model folder
        var bundle = namespace[0];
        namespace.shift();
        //Capitalize - Normalize
        if (namespace.length > 1) {
            //            for (var i; i<namespace.length; ++i) {
            //                namespace[i] = namespace[i].substring(0, 1).toUpperCase() + namespace[i].substring(1);
            //            }

            model = namespace.join(".");
        } else {
            //Dir name.
            model = namespace[0];
        }


        console.debug('[ MODEL ][ ' + model +' ] Bundle: '+ bundle);
        //console.debug('[ MODEL ][ ' + model +' ] Model: '+ model...
var saveEnvs = function() {
        var file    = _(self.projects[self.projectName].path + '/env.json')
            , ports = require(_(GINA_HOMEDIR + '/ports.json'))
        ;


        if ( !fs.existsSync( _(self.projects[self.projectName].path + '/manifest.json') )) {
            console.error('project corrupted');
            process.exit(1)
        }

        self.project = requireJSON(_(self.projects[self.projectName].path + '/manifest.json'));
        self.portsList = []; // list of all ports to ignore whles scanning
        var protocols = self.projects[self.projectName].protocols;
        var schemes = self.projects[self.projectName].schemes;
        for (let protocol in ports) {
            if (protocols.indexOf(protocol) < 0) continue;
            for (let scheme in ports[protocol]) {
                if (schemes.indexOf(scheme) < 0) continue;
                for (let p in ports[protocol][scheme]) {
                    if ( self.portsList.indexOf(p) > -1 ) continue;
          ...
_tmp_0.windows-1255 = [8364,129,8218,402,8222,8230,8224,8225,710,8240,138,8249,140,141,142,143,144,8216,8217,8220,8221,8226,8211,8212,732,8482,154,8250,156,157,158,159,160,161,162,163,8362,165,166,167,168,169,215,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,247,187,188,189,190,191,1456,1457,1458,1459,1460,1461,1462,1463,1464,1465,null,1467,1468,1469,1470,1471,1472,1473,1474,1475,1520,1521,1522,1523,1524,null,null,null,null,null,null,null,1488,1489,1490,1491,1492,1493,1494,1495,1496,1497,1498,1499,1500,1501,1502,1503,1504,1505,1506,1507,1508,1509,1510,1511,1512,1513,1514,null,null,8206,8207,null]
self.checkIfVersionDir = function(done) {

        var version = require(self.opt.pack).version;

        if ( !getEnvVar('GINA_VERSION') ) {
            setEnvVar('GINA_VERSION', version)
        } else {
            version = getEnvVar('GINA_VERSION')
        }

        if ( !getEnvVar('GINA_SHORT_VERSION') ) {
            var shortVersion = version.split('.');
            shortVersion.splice(2);
            shortVersion = shortVersion.join('.');
            setEnvVar('GINA_SHORT_VERSION', shortVersion);
        }


        var release = version.split('.').splice(0,2).join(".");
        setEnvVar('GINA_RELEASE', release, true);
        var releasePath = self.opt.homedir + '/' + release;
        self.release = self.opt.release = release;

        console.debug('Checking version path... [ '+ releasePath +' ]');

        if ( !fs.existsSync(releasePath) ) {
            try {
                fs.mkdirSync(releasePath, 0775)
            } catch (err) {
                // console.error(e...
gina.onError(function(err, req, res, next){
                // (code)   message
                // (16)     Generic network failure. Enable detailed error codes (via LCB_CNTL_DETAILED_ERRCODES, or via `detailed_errcodes` in the connection string) and/or enable logging to get more information
                // (23)     Client-Side timeout exceeded for operation. Inspect network conditions or increase the timeout
                //          cannot perform operations on a shutdown bucket
                //          err instanceof CouchbaseError

                if (!self.instance.connected) {
                    self.instance.reconnected = false;
                    self.instance.reconnecting = false;
                }

                if (
                    err instanceof couchbase.Error && err.code == 16 && !self.reconnected
                    //|| err instanceof couchbase.Error && err.code == 23 && !self.reconnecting
                    || /cannot perform operations on a shutdow...
var processSrc = function(method, src, target, zipInstance, options, cb) {

            if ( !fs.existsSync(src) ) {
                self.emit('archiver-'+ method +'#complete', new Error('file not found `'+ src +'`'));

                return;
            }

            stats = fs.statSync(src);

            var isBatchProcessing = ( typeof(cb) != 'undefined' ) ? true : false;

            if ( stats.isFile() ) { // single file compression


                var input   = null;
                var output  = null;

                if ( isBatchProcessing ) {
                    input   = src;
                    output  = target
                } else {
                    // targeted filename
                    if ( typeof(options.name) != 'undefined' && options.name != 'default') {
                        target += options.name;
                    } else {
                        target += src.substr(src.lastIndexOf('/')+1);
                    }

                    input   = fs.creat...
var setDefaultEvents = function(bundle, PID, proc) {


        if ( typeof(PID) != 'undefined' && typeof(PID) == 'number' ) {

            console.debug('[ PROC ] Setting listeners for ', PID, ':', bundle);

            proc.dismiss = dismiss;
            proc.isMaster = isMaster;


            proc.on('SIGTERM', function(code){
                if ( typeof(code) == 'undefined')
                    code = 0;
                // will handle `dismiss()`
                proc.exit(code);
            });

            proc.on('SIGABRT', function(code){
                if ( typeof(code) == 'undefined')
                    code = 0;
                // will handle `dismiss()`
                proc.exit(code);
            });


            proc.on('SIGINT', function(code){

                if (code == undefined)
                    code = 0;

                console.warn('[ PROC ] Got exit code. Now killing: ', code);
                // will handle `dismiss()`
                proc.exit(code);
      ...
var outputTo = function(data) {

        var targetObj = null;
        if (self.filename) {
            targetObj = new _(self.filename);
            if ( targetObj.existsSync() ) {
                targetObj.rmSync()
            }
        }
        if ( /^conf$/.test(self.format) ) {
            if (typeof(data) != 'string' ) {
                var str = '', i = 0, len = data.length;
                while (i<len) {
                    let d = data[i];
                    str += d.env +'_'+ d.bundle +'_'+ d.protocol +'_'+ d.scheme +'='+ d.port +':'+ d.port +'\n';
                    // Adding debug port
                    if (
                        typeof(self.selectedDebugPorts) != 'undefined'
                        && typeof(self.selectedDebugPorts[d.bundle]) != 'undefined'
                    ) {
                        str += d.env +'_'+ d.bundle +'_debug_port='+ d.debug_port +':'+ d.debug_port +'\n';
                    }
                    i++;
                }

              ...
var addBundlePorts = function(b) {
        loadAssets();

        if (b > self.bundles.length-1) { // writing to files on complete

            hasPastProtocolAndSchemeCheck(self.defaultProtocol, self.defaultScheme, true);

            //console.debug('self.protocols ...', self.protocols);
            // get user protocols list
            var protocols = JSON.clone(self.protocols);
            // get user schemes list
            var schemes = JSON.clone(self.schemes);
            var projectConfig   = JSON.clone(self.projects);

            //console.debug('about to update project ports conf\n\rBundles: '+ JSON.stringify(self.projectData, null, 4));
            var ports               = JSON.clone(self.portsData) // cloning
                , portsReverse      = JSON.clone(self.portsReverseData) // cloning
                , portsList         = local.ports
                , isPortUsed        = false
                , envs              = self.envs
                , i                 = 0
...
function startMQListener = function startMQListener(opt, cb) {
        var port = opt.port;
        var host = opt.hostV4;
        var server = net.createServer( function(conn) {//'connection' listener

            conn.sessionId = uuid.v4();
            // conn.request = 'report'; // by default
            sessions[conn.sessionId] = conn;
            conn.write(JSON.stringify({ sessionId: conn.sessionId }) +'\r\n' );

            //feedback.
            var forwardId = null;
            conn.on('end', function() {
                delete sessions[this.sessionId];
                if ( this.request != 'report' ) {
                    forwardId = forwardList[this.request].indexOf(this.sessionId);
                    if ( forwardId > -1 && typeof(forwardList[this.request]) != 'undefined') {
                        forwardList[this.request].splice(forwardId, 1);
                    }
                }
                console.debug('[MQListener] (end) client disconected');
                //process.stdout.write('[M...
var addViews = function(b) {
        if (b > self.bundles.length-1) {// done
            process.exit(0)
        }

        var bundle = self.bundles[b];


        if ( /^[a-z0-9_.]/.test(bundle) ) {

            if ( !fs.existsSync(self.envPath) ) {
                lib.generator.createFileFromDataSync({}, self.envPath);
            }

            local.bundle    = bundle;
            local.b         = b;
            local.env       = self.projects[self.projectName]['def_env'];
            local.root      = self.projects[self.projectName].path;
            local.src       = _(self.bundlesLocation +'/'+ bundle, true);

            console.info('Adding view folder for: '+ local.bundle +'@'+ self.projectName);

            // local.namespaces = checkForNamespaces(local.src);


            addConfFile()

        } else {
            console.error('[ '+ bundle+' ] is not a valid bundle name')
            process.exit(1)
        }
    }
var queryFromFrontend = function(options, errorMessage) {
        var errors      = self[this['name']]['errors'] || {};
        var id          = this.target.id || this.target.getAttribute('id');


        // stop if
        //  - previous error detected
        if ( !self.isValid() ) {
            console.debug('stopping on errors ...');
            triggerEvent(gina, this.target, 'asyncCompleted.' + id, self[this['name']]);
            //return self[this.name];
            return;
        }

        var testedValue = this.target.dataset.ginaFormValidatorTestedValue;
        console.debug('[ '+ this['name'] +' ]', 'TESTED VALUE -> ' + this.value +' vs '+ testedValue);
        var _evt = 'asyncCompleted.' + id;
        var currentFormId = this.target.form.getAttribute('id');
        var cachedErrors = (
                            typeof(gina.validator) != 'undefined'
                            && typeof(gina.validator.$forms[currentFormId]) != 'undefined'
                            &...
e.once(trigger, function onBundleStarted(done) {
                clearInterval(nIntervId);
                nIntervId = null;

                opt.client.write('\nOk, I am ready :)');
                lib.generator.createFileFromDataSync(GINA_ARCH, projectArchFile);
                lib.generator.createFileFromDataSync(GINA_PLATFORM, projectPlatformFile);
                setTimeout(() => {
                    done(false)
                }, 1000);

            })
var dic = {
            'release' : self.release,
            'version' : version,
            'prefix' : prefix,
            'global_mode': globalMode
        }
proc.on('uncaughtException', function(err) {

                if ( /ERR\_HTTP\_HEADERS\_SENT/.test(err.stack) ) {
                    console.error('[ SERVER ][ HTTP UNCAUGHT EXCEPTION ]', err.stack);
                    return false;
                }

                if ( /ERR\_HTTP2/.test(err.stack) ) {
                    console.warn('[ SERVER ][ HTTP2 UNCAUGHT EXCEPTION ]', err.stack);
                    return false;
                }

                //console.debug("[ PROC ] @=>", self.args);
                var bundle = self.bundle;
                var pid = self.getPidByBundleName(bundle);
                // Do not dissmis the framework
                if ( /^gina\-v/.test(bundle) ) {
                    if ( err.code == 'EPIPE' ) {
                        proc.stdout.write(err.stack);
                        return;
                    }
                    console.warn('[ FRAMEWORK ][ uncaughtException ] ', err.stack);
                    return;
                }

   ...
function basename = function basename(path) {
  var f = splitPathPosix(path)[2];
  if (f === path)
    f = splitPathWindows(path)[2];
  return f;
}
conn.on('data', function(data) {
                payloads = data.toString();

                // filter payloads
                if ( /^(\{\"|\[\{\")/.test(payloads) ) {
                    payloads = payloads.split(/\r\n/g);
                    //console.log(payloads);
                    i = -1;
                    while(i < payloads.length) {
                        i++;
                        let payload = payloads[i];
                        if ( /^\{/.test(payload) && /\}$/.test(payload)) {
                            let pl = JSON.parse(payload);


                            // mostly after client that acknowledeged sessionId
                            if (!pl.content) {
                                process.stdout.write(  '[MQListener] (undefined content) '+ JSON.stringify(pl, null) +'\n' );
                            }

                            if (pl.loggers) {
                                sharedConfig.loggers = merge(sharedConfig.loggers, pl.loggers);// jshint...
self.checkIfSettings = function(done) {
        console.debug('Checking framework settings...');
        var main            = require( _(self.opt.homedir + '/main.json', true) )
            , version       = getEnvVar('GINA_VERSION')
            , prefix        = getEnvVar('GINA_PREFIX') || main['def_prefix'][self.release]
            , globalMode    = getEnvVar('GINA_GLOBAL_MODE') || main['def_global_mode'][self.release]
            , arch          = getEnvVar('GINA_ARCH') || main['def_arch'][self.release]
            , platform      = getEnvVar('GINA_PLATFORM') || main['def_platform'][self.release]
            , env           = getEnvVar('GINA_ENV') || main['def_env'][self.release]
            , scope         = getEnvVar('GINA_SCOPE') || main['def_scope'][self.release]
            , settings      = requireJSON( _( getPath('gina').root + '/resources/home/settings.json', true ) )
            , userSettings  = {}
            , target        = _(self.opt.homedir +'/'+ self.release +'...
_tmp_63.labels = [
          "csmacintosh",
          "mac",
          "macintosh",
          "x-mac-roman"
        ]
var dic = {
                'prefix' : prefix,
                'global_mode': globalMode,
                'version' : version,
                'arch' : arch,
                'platform': platform,
                'env' : env,
                'env_is_dev' : (main['dev_env'][self.release] == env) ? true : false,
                'dev_env' : main['dev_env'][self.release],
                'scope' : scope,
                'scope_is_local' : (main['local_scope'][self.release] == scope) ? true : false,
                'local_scope': main['local_scope'][self.release],
                'culture' : getEnvVar('GINA_CULTURE'),
                'timezone' : getEnvVar('GINA_TIMEZONE'),
                'node_version': process.version,
                'port' : getEnvVar('GINA_PORT') || 8124, // TODO - scan for the next available port
                'debug_port' : getEnvVar('GINA_DEBUG_PORT') || process.debugPort || 5757,
                'host_v4' : getEnvVar('GINA_HOST_V4') || '127.0.0.1',
               ...
!local.options.isRenderingCustomError
                && typeof(data.page.data.status) != 'undefined'
                && !/^2/.test(data.page.data.status)
                && typeof(data.page.data.error) != 'undefined'
typeof(errors[name]) == 'undefined' && /(form\-item\-error|form\-item\-warning)/.test($parent.className) || typeof(errors[name]) != 'undefined' && errors[name].count() == 0 && /(form\-item\-error|form\-item\-warning)/.test($parent.className)
str += '"'+attr+'": "' + obj[attr]
                            .replace(/\'/g, "\\'")
                            .replace(/\"/g, '\\"') +'"'
constructor = constructor
                    .splice(constructor.length-1,1)
                    .toString()
console.warn('Dependency bundle config not found for `'+ app +'/'+ env +'`: trying to load on the fly from src')
path = (isRenderingCustomError) ? _(file) : _(localOptions.template.html +'/'+ localOptions.namespace + '/' + file)
newContent[app][env].bundlesPath = bundlesPath = appSrcPath.replace( new RegExp('/'+ app), '' )
function () { // getting rid of the middleware context

                        var Middleware = require(_(filename, true));
                        // TODO - loop on a defined SuperController property like SuperController._allowedForExport


                        // Exporting config & common methods
                        Middleware.prototype.checkBundleStatus      = controller.checkBundleStatus;
                        Middleware.prototype.getConfig              = controller.getConfig;
                        Middleware.prototype.getFormsRules          = controller.getFormsRules;
                        Middleware.prototype.getLocales             = controller.getLocales;
                        Middleware.prototype.isCacheless            = controller.isCacheless;
                        Middleware.prototype.isHaltedRequest        = controller.isHaltedRequest;
                        Middleware.prototype.isWithCredentials      = controller.isWithCredentials;
                    ...
