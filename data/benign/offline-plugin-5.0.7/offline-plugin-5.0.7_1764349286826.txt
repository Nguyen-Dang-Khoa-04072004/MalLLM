deleting = Promise.all(requests.map(function (request) {
        return cache['delete'](request)['catch'](function () {});
      }))
cache['delete'](request)['catch'](function () {})
Promise.all(requests.map(function (request) {
      if (bustValue) {
        request = applyCacheBust(request, bustValue);
      }

      return fetch(request, requestInit).then(fixRedirectedResponse).then(function (response) {
        if (!response.ok) {
          return { error: true };
        }

        return { response: response };
      }, function () {
        return { error: true };
      });
    })).then(function (responses) {
      if (failAll && responses.some(function (data) {
        return data.error;
      })) {
        return Promise.reject(new Error('Wrong response status'));
      }

      if (!failAll) {
        responses = responses.filter(function (data, i) {
          if (!data.error) {
            return true;
          }

          requests.splice(i, 1);
          return false;
        });
      }

      return deleting.then(function () {
        var addAll = responses.map(function (_ref, i) {
          var response = _ref.response;

          return cache.p...
request = applyCacheBust(request, bustValue)
_tmp_18.push({
    key: 'resolveToolPaths',
    value: function resolveToolPaths(tool, key, compiler) {
      // Tool much implement:
      //
      // tool.output
      // tool.publicPath
      // tool.basePath
      // tool.location
      // tool.pathRewrite

      if (!this.relativePaths && !this.publicPath) {
        throw new Error('OfflinePlugin: Cannot generate base path for ' + key);
      }

      var isDirectory = tool.output[tool.output.length - 1] === '/';

      if (this.relativePaths) {
        var compilerOutput = (compiler.options.output || { path: process.cwd() }).path;
        var absoluteOutput = _path3['default'].resolve(compilerOutput, tool.output);

        var relativeBase = undefined;

        if (isDirectory) {
          relativeBase = _path3['default'].relative(absoluteOutput, compilerOutput);
        } else {
          relativeBase = _path3['default'].relative(_path3['default'].dirname(absoluteOutput), compilerOutput);
        }

        relativeBase = (0, _slash2['def...)
_tmp_83.key = "resolveToolPaths"
_tmp_56.response = response
function (responses) {
      if (failAll && responses.some(function (data) {
        return data.error;
      })) {
        return Promise.reject(new Error('Wrong response status'));
      }

      if (!failAll) {
        responses = responses.filter(function (data, i) {
          if (!data.error) {
            return true;
          }

          requests.splice(i, 1);
          return false;
        });
      }

      return deleting.then(function () {
        var addAll = responses.map(function (_ref, i) {
          var response = _ref.response;

          return cache.put(requests[i], response);
        });

        return Promise.all(addAll);
      });
    }
var addAll = responses.map(function (_ref, i) {
          var response = _ref.response;

          return cache.put(requests[i], response);
        })
relativeBase = (0, _slash2['default'])(relativeBase)
cache.put(requests[i], response)
caches.match(request, {
    cacheName: cacheName
  }).then(function (response) {
    if (isNotRedirectedResponse(response)) {
      return response;
    }

    // Fix already cached redirected responses
    return fixRedirectedResponse(response).then(function (fixedResponse) {
      return caches.open(cacheName).then(function (cache) {
        return cache.put(request, fixedResponse);
      }).then(function () {
        return fixedResponse;
      });
    });
  })
  // Return void if error happened (cache not found)
  ['catch'](function () {})
function (response) {
    if (isNotRedirectedResponse(response)) {
      return response;
    }

    // Fix already cached redirected responses
    return fixRedirectedResponse(response).then(function (fixedResponse) {
      return caches.open(cacheName).then(function (cache) {
        return cache.put(request, fixedResponse);
      }).then(function () {
        return fixedResponse;
      });
    });
  }
isNotRedirectedResponse(response)
fixRedirectedResponse(response).then(function (fixedResponse) {
      return caches.open(cacheName).then(function (cache) {
        return cache.put(request, fixedResponse);
      }).then(function () {
        return fixedResponse;
      });
    })
cache.put(request, fixedResponse)
