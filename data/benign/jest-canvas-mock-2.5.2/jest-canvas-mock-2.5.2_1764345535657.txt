const getContext2D = jest.fn(function getContext2d(type) {
    if (type === '2d') {
      /**
       * Contexts must be idempotent. Once they are generated, they should be returned when
       * getContext() is called on the same canvas object multiple times.
       */
      if (generatedContexts.has(this)) return generatedContexts.get(this);
      const ctx = new CanvasRenderingContext2D(this);
      generatedContexts.set(this, ctx);
      return ctx;
    }
    try {
      if (!this.dataset.internalRequireTest) require('canvas');
    } catch (_unused) {
      return null;
    }
    return getContext2D.internal.call(this, type);
  })
borrowedFromCanvas.forEach(key => {
      this[key] = jest.fn(_CanvasRenderingContext2D.default.prototype[key].bind(this));
    })
throw new RangeError('The height is zero or not a number.');
!jest.isMockFunction(htmlCanvasElementPrototype.getContext)
const toBlobOverride = jest.fn(function toBlobOverride(callback, mimetype) {
    if (arguments.length < 1) throw new TypeError("Failed to execute 'toBlob' on 'HTMLCanvasElement': 1 argument required, but only 0 present.");
    if (typeof callback !== 'function') throw new TypeError("Failed to execute 'toBlob' on 'HTMLCanvasElement': The callback provided as parameter 1 is not a function.");

    /**
     * Mime type must be image/jpeg or image/webp exactly for the browser to accept it, otherwise
     * it's image/png.
     */
    switch (mimetype) {
      case 'image/webp':
        break;
      case 'image/jpeg':
        break;
      default:
        mimetype = 'image/png';
    }

    /**
     * This section creates a blob of size width * height * 4. This is not actually valid, because
     * jpeg size is variable, and so is png. TODO: Is there a better way to do this?
     */
    const length = this.width * this.height * 4;
    const data = new Uint8Array(length);
    const blob = new wi...
const length = this.width * this.height * 4
const data = new Uint8Array(length)
const blob = new window.Blob([data], {
      type: mimetype
    })
setTimeout(() => callback(blob), 0)
