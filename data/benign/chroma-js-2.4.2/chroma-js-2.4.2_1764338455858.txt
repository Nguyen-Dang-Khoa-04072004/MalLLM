['lch','hcl'].forEach(m => input.autodetect.push({
    p: 2,
    test: (...args) => {
        args = unpack(args, m);
        if (type(args) === 'array' && args.length === 3) {
            return m;
        }
    }
}))
const bezier = function(colors) {
    let I, lab0, lab1, lab2;
    colors = colors.map(c => new Color(c));
    if (colors.length === 2) {
        // linear interpolation
        [lab0, lab1] = colors.map(c => c.lab());
        I = function(t) {
            const lab = ([0, 1, 2].map((i) => lab0[i] + (t * (lab1[i] - lab0[i]))));
            return new Color(lab, 'lab');
        };
    } else if (colors.length === 3) {
        // quadratic bezier interpolation
        [lab0, lab1, lab2] = colors.map(c => c.lab());
        I = function(t) {
            const lab = ([0, 1, 2].map((i) => ((1-t)*(1-t) * lab0[i]) + (2 * (1-t) * t * lab1[i]) + (t * t * lab2[i])));
            return new Color(lab, 'lab');
        };
    } else if (colors.length === 4) {
        // cubic bezier interpolation
        let lab3;
        [lab0, lab1, lab2, lab3] = colors.map(c => c.lab());
        I = function(t) {
            const lab = ([0, 1, 2].map((i) => ((1-t)*(1-t)*(1-t) * lab0[i]) + (3 * (1-t) * (1-t) * t * l...
_tmp_0.BuGn = ['#f7fcfd', '#e5f5f9', '#ccece6', '#99d8c9', '#66c2a4', '#41ae76', '#238b45', '#006d2c', '#00441b']
_tmp_0.YlOrBr = ['#ffffe5', '#fff7bc', '#fee391', '#fec44f', '#fe9929', '#ec7014', '#cc4c02', '#993404', '#662506']
input.autodetect.push({
    p: 3,
    test: (...args) => {
        args = unpack(args, 'rgba');
        if (type(args) === 'array' && (args.length === 3 ||
            args.length === 4 && type(args[3]) == 'number' && args[3] >= 0 && args[3] <= 1)) {
            return 'rgb';
        }
    }
})
_tmp_0.YlOrRd = ['#ffffcc', '#ffeda0', '#fed976', '#feb24c', '#fd8d3c', '#fc4e2a', '#e31a1c', '#bd0026', '#800026']
chroma.cubehelix = require('./src/generator/cubehelix')
chroma.mix = chroma.interpolate = require('./src/generator/mix')
I = function (t) {
            const u = 1 - t;
            const lab = ([0, 1, 2].map((i) => labs.reduce((sum, el, j) => (sum + row[j] * u ** (n - j) * t ** j * el[i]), 0)))
            return new Color(lab, 'lab');
        }
_tmp_0.Accent = ['#7fc97f', '#beaed4', '#fdc086', '#ffff99', '#386cb0', '#f0027f', '#bf5b17', '#666666']
_tmp_0.Set3 = ['#8dd3c7', '#ffffb3', '#bebada', '#fb8072', '#80b1d3', '#fdb462', '#b3de69', '#fccde5', '#d9d9d9', '#bc80bd', '#ccebc5', '#ffed6f']
f.lightness = function(h) {
        if ((h == null)) { return lightness; }
        if (type(h) === 'array') {
            lightness = h;
            dl = h[1] - h[0];
        } else {
            lightness = [h,h];
            dl = 0;
        }
        return f;
    }
var xyz = first.get(mode)
xyz[i] = (xyz[i] || 0) * weights[0]
cnt.push(isNaN(xyz[i]) ? 0 : weights[0])
mode.charAt(i) === 'h' && !isNaN(xyz[i])
var A = xyz[i] / 180 * PI$1
var xyz2 = c.get(mode)
var A$1 = atan2$1(dy / cnt[i$1], dx / cnt[i$1]) / PI$1 * 180
A$1 += 360
A$1 >= 360
xyz[i$1] = A$1
xyz[i$1] = xyz[i$1]/cnt[i$1]
(new Color$6(xyz, mode)).alpha(alpha > 0.99999 ? 1 : alpha, true)
