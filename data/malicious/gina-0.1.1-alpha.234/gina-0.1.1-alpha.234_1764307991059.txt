resetContext = function() {
        setPath('gina.root', getEnvVar('GINA_DIR'));
        var frameworkPath = getEnvVar('GINA_FRAMEWORK_DIR');
        setPath('framework', frameworkPath);
        setPath('gina.core', getEnvVar('GINA_CORE'));
        setPath('gina.lib', _(frameworkPath +'/lib'));
        setPath('gina.helpers', _(frameworkPath +'/helpers'));
        setPath( 'node', _(process.argv[0]), true);
        var projects    = require( _(getEnvVar('GINA_HOMEDIR') + '/projects.json', true) );
        var projectName = getContext('projectName');
        var root        = projects[projectName].path;
        setPath('project', root);
        var env         = getContext('env');
        var isDev       = (env === projects[projectName]['dev_env']) ? true: false;
        var bundlesPath = projects[projectName]['path'] + '/bundles'; // by default
        var isProductionScope = ('production' === projects[projectName]['def_scope']) ? true: false;
        if (isDev) {
            bundle...
var getConfigSync = function(bundle, i) {
        var i = i || 0;

        var configuration = null;
        var env = null, conf = null, connectors = null;
        if ( typeof (_config) != 'undefined' ) {
            configuration = _config;
            env = _config.env;
            conf = _config;
            connectors = _config.content.connectors;
        } else {
            configuration = config.getInstance(bundle);
            env = configuration.Env.current;
            conf = configuration.Env.getConf(bundle, env);
        }
        console.debug('[ MODEL ][ ' + _connector + ' ] env ', conf.env);
        console.debug('[ MODEL ][ ' + _connector + ' ] configuration modelsPath ', conf.modelsPath);
        console.debug('[ MODEL ][ ' + _connector + ' ] connectors ', connectors);

        // try {

        //     var locals = _locals = configLib.getSync('gina', 'locals.json')
        // } catch (err) {
        //     console.emerg('[ MODEL ][ ' + _connector +' ] Error while calli...
client.on('data', (data) => {

            //console.log('['+ mqId +']  (data): ' + data.toString());
            payloads = data.toString();

            // from speakers
            if ( /^(\{\"|\[\{\")/.test(payloads) ) {
                payloads = payloads.split(/\r\n/g);
                i = -1;
                while(i < payloads.length) {
                    i++;
                    let payload = payloads[i];
                    if (
                        /^\{/.test(payload) && /\}$/.test(payload)
                        || /^\[\{/.test(payload) && /\}\]$/.test(payload)
                    ) {
                        let pl = null;
                        try {
                            pl = JSON.parse(payload);
                        } catch(plErr) {
                            process.stdout.write( '['+ mqId +'] (exception) '+ payload +'\n' );
                            continue;
                        }


                        if (!pl.content) {
                    ...
CouchbaseStore.prototype.touch = function (sid, sess, fn) {
        if ('function' !== typeof fn) { fn = noop; }

        var sid = this.prefix + sid
            , maxAge = sess.cookie.maxAge
            , ttl = this.ttl || ('number' == typeof maxAge
                ? maxAge / 1000 | 0
                : oneDay)
            , currentDate = new Date()
            , lastModified = sess.lastModified ? new Date(sess.lastModified).getTime() : 0;

        // if the given options has a touchAfter property, check if the
        // current timestamp - lastModified timestamp is bigger than
        // the specified, if it's not, don't touch the session
        if (ttl > 0 && lastModified > 0) {

            var timeElapsed = currentDate.getTime() - lastModified;

            if (timeElapsed > ttl) {
                sess.lastModified = currentDate;
            }
        }

        sess = JSON.stringify(sess);
        this.client.upsert(sid, sess, {expiry:ttl}, function(err){
            err || d...
entities[entityName].prototype[name] = function() {
                    var self = this;
                    var key     = null
                        , index = null
                        , i     = null
                        , len   = null
                        , args  = Array.prototype.slice.call(arguments)
                        , _mainCallback = null;

                    if ( params && params.length != args.length && !/function/.test(typeof(args[args.length-1])) ) {
                        throw new Error('[N1QL][ ' + entityName+'#'+name+'() ] arguments must match parameters length. Please refer to [ '+ source +' ]\nFound in param list: ('+ params.join(', ') +') !')
                    } else if ( /function/.test( typeof(args[args.length-1]) ) ) {
                        // to hande Nodejs Util.promisify
                        _mainCallback = args[args.length-1]
                    }

                    var sdkVersion = conn.sdk.version || 2;
                    var qu...
this.emit = function(c) {
    if (c <= 0xFFFF) {
      string += String.fromCharCode(c);
    } else {
      c -= 0x10000;
      string += String.fromCharCode(0xD800 + ((c >> 10) & 0x3ff));
      string += String.fromCharCode(0xDC00 + (c & 0x3ff));
    }
  }
var getFormById = function(formId) {
        var $form = null, _id = formId;

        if ( !instance['$forms'] )
            throw new Error('`$forms` collection not found');

        if ( typeof(_id) == 'undefined') {
            throw new Error('[ FormValidator::getFormById(formId) ] `formId` is missing')
        }

        _id = _id.replace(/\#/, '');

        // in case form is created on the fly and is not yet registered
        if (document.getElementById(_id) != null && typeof (instance['$forms'][_id]) == 'undefined') {
            initForm( document.getElementById(_id) );
        }

        if ( typeof(instance.$forms[_id]) != 'undefined' ) {
            instance['$forms'][_id].withUserBindings = true;

            if ( typeof(this.$forms) != 'undefined' && typeof(this.$forms[_id]) == 'undefined' ) {
                $form = this.$forms[_id] = instance['$forms'][_id];
            } else {
                $form = instance.$forms[_id];
            }
        }

        if (!$form) {...
var processList = function(method, files, target, zipInstance, options, i, len, err) {

                if (i >= len || err) {

                    if (!err && zipInstance) {

                        zipInstance
                            .generateNodeStream({ compression: 'DEFLATE', compressionOptions : {level: options.level } })
                            .pipe(outputStream);

                        outputStream
                            .once('err', function(){
                                outputStream.close();
                                self.emit('archiver-'+ method +'#complete', err, null);
                            })
                            .once('finish', function(){
                                outputStream.close();
                                self.emit('archiver-'+ method +'#complete', false, this.path);
                            })

                    } else {
                        self.emit('archiver-'+ method +'#complete', err, null);
        ...
console.log('Project [ '+ self.projectName +' ] has been added')
var init = function(dbString) {

        var err = false;
        try {
            dbString        = merge(dbString, local.options);
            local.options   = dbString;
            local.bundle    = getConfig().bundle;

            console.info('[ CONNECTOR ][ ' + local.bundle +' ][ ' + dbString.connector +' ][ ' + dbString.database +' ] authenticating to couchbase cluster @'+ dbString.protocol + dbString.host);

            try {
                self.cluster = new couchbase.Cluster(dbString.protocol + dbString.host);
                // version 5.x
                if ( typeof(self.cluster.authenticate) != 'undefined' )
                    self.cluster.authenticate(dbString.username, dbString.password);
            } catch(_err) {
                console.error('[ CONNECTOR ][ ' + local.bundle +' ] could not authenticate to couchbase @`'+ dbString.protocol + dbString.host +'`\n'+ (_err.stack || _err.message || _err) );
            }

            console.info('[ CONNECTOR ][ ' + local...
var dismiss = function(pid, signal){
        if (pid == undefined) {
            pid = self.PID;
        }
        var index       = null
            , mountPath = null
        ;
        try {
            //console.debug('[ PROC ] => '+ JSON.stringify(process.list, null, 4));

            for (let p in process.list) {
                if ( typeof(process.list[p]) == 'undefined' || process.list[p] == null )
                    continue;


                if ( process.list[p].pid == pid &&  !/^gina\-/.test(process.list[p].name) ) {
                    index       = p;

                    try {
                        // console.debug('removePidFileSync: ['+ process.list[p].pid +']');
                        removePidFileSync(process.list[p].pid);
                        if ( typeof(process.isMinion) == 'undefined' ) {
                            mountPath   =  _(getPath('mountPath') + '/' + process.list[p].name);
                            if ( fs.existsSync(mountPath) )
                ...
typeof(bundleSettings.server.scheme) != 'undefined'
                                        && schemes.indexOf(bundleSettings.server.scheme) < 0
var setTimezone = function(timezone) {
        // save to ~/.gina/main.json
        mainConf['def_timezone'][GINA_SHORT_VERSION] = timezone;
        lib.generator.createFileFromDataSync(mainConf, mainConfPath);
        // save to ~/.gina/{GINA_VERSION_SHORT}/settings.json
        process['gina']['timezone'] = timezone;
        mainSettingsConf['timezone'] = timezone;
        lib.generator.createFileFromDataSync(mainSettingsConf, mainSettingsPath);
    }
