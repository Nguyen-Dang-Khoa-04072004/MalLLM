// File: tmp/tmpvatgfkq3/chalk-template/package/index.js
// ======================================================================
Line 2: var chalkStderr = require("chalk").chalkStderr
Line 9: _tmp_10.push(_0xba16ef[_0x29ad9a(0x69b)])
Line 12: new Map([
	['n', '\n'],
	['r', '\r'],
	['t', '\t'],
	['b', '\b'],
	['f', '\f'],
	['v', '\v'],
	['0', '\0'],
	['\\', '\\'],
	['e', '\u001B'],
	['a', '\u0007'],
])
Line 13: _tmp_57.push(['n', '\n'])
Line 14: _tmp_57.push(['r', '\r'])
Line 15: _tmp_57.push(['t', '\t'])
Line 16: _tmp_57.push(['b', '\b'])
Line 17: _tmp_57.push(['f', '\f'])
Line 18: _tmp_57.push(['v', '\v'])
Line 19: _tmp_57.push(['0', '\0'])
Line 20: _tmp_57.push(['\\', '\\'])
Line 21: _tmp_57.push(['e', '\u001B'])
Line 22: _tmp_57.push(['a', '\u0007'])
Line 25: function unescape = function unescape(c) {
	const u = c[0] === 'u';
	const bracket = c[1] === '{';

	if ((u && !bracket && c.length === 5) || (c[0] === 'x' && c.length === 3)) {
		return String.fromCodePoint(Number.parseInt(c.slice(1), 16));
	}

	if (u && bracket) {
		return String.fromCodePoint(Number.parseInt(c.slice(2, -1), 16));
	}

	return ESCAPES.get(c) || c;
}
Line 26: const u = c[0] === 'u'
Line 27: const bracket = c[1] === '{'
Line 30: Number.parseInt(c.slice(1), 16)
Line 34: Number.parseInt(c.slice(2, -1), 16)
Line 40: {
	const results = [];
	const chunks = arguments_.trim().split(/\s*,\s*/g);
	let matches;

	for (const chunk of chunks) {
		const number = Number(chunk);
		if (!Number.isNaN(number)) {
			results.push(number);
		} else if ((matches = chunk.match(STRING_REGEX))) {
			results.push(matches[2].replace(ESCAPE_REGEX, (_, escape, character) => escape ? unescape(escape) : character));
		} else {
			throw new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name}')`);
		}
	}

	return results;
}
Line 41: const results = []
Line 42: arguments_.trim()
Line 45: _iterator_4.next()
Line 48: results.push(number)
Line 49: {
			results.push(matches[2].replace(ESCAPE_REGEX, (_, escape, character) => escape ? unescape(escape) : character));
		}
Line 50: results.push(matches[2].replace(ESCAPE_REGEX, (_, escape, character) => escape ? unescape(escape) : character))
Line 60: Number.parseInt(hex, 16)
Line 63: _tmp_48.push((n >> 16) & 0xFF)
Line 65: _tmp_48.push((n >> 8) & 0xFF)
Line 67: _tmp_48.push(n & 0xFF)
Line 71: {
	STYLE_REGEX.lastIndex = 0;

	const results = [];
	let matches;

	while ((matches = STYLE_REGEX.exec(style)) !== null) {
		const name = matches[1];

		if (matches[2]) {
			results.push([name, ...parseArguments(name, matches[2])]);
		} else if (matches[3] || matches[4]) {
			if (matches[3]) {
				results.push(['rgb', ...parseHex(matches[3])]);
			}

			if (matches[4]) {
				results.push(['bgRgb', ...parseHex(matches[4])]);
			}
		} else {
			results.push([name]);
		}
	}

	return results;
}
Line 74: const results = []
Line 77: {
		const name = matches[1];

		if (matches[2]) {
			results.push([name, ...parseArguments(name, matches[2])]);
		} else if (matches[3] || matches[4]) {
			if (matches[3]) {
				results.push(['rgb', ...parseHex(matches[3])]);
			}

			if (matches[4]) {
				results.push(['bgRgb', ...parseHex(matches[4])]);
			}
		} else {
			results.push([name]);
		}
	}
Line 78: const name = matches[1]
Line 80: {
			results.push([name, ...parseArguments(name, matches[2])]);
		}
Line 81: results.push([name, ...parseArguments(name, matches[2])])
Line 83: {
				results.push(['rgb', ...parseHex(matches[3])]);
			}
Line 84: results.push(['rgb', ...parseHex(matches[3])])
Line 87: {
				results.push(['bgRgb', ...parseHex(matches[4])]);
			}
Line 88: results.push(['bgRgb', ...parseHex(matches[4])])
Line 90: {
			results.push([name]);
		}
Line 91: results.push([name])
Line 102: _iterator_5.next()
Line 103: for (const style of layer.styles) {
				enabled[style[0]] = layer.inverse ? null : style.slice(1);
			}
Line 104: enabled[style[0]] = layer.inverse ? null : style.slice(1)
Line 109: for (const [styleName, styles] of Object.entries(enabled)) {
			if (!Array.isArray(styles)) {
				continue;
			}

			if (!(styleName in current)) {
				throw new Error(`Unknown Chalk style: ${styleName}`);
			}

			current = styles.length > 0 ? current[styleName](...styles) : current[styleName];
		}
Line 118: current = styles.length > 0 ? current[styleName](...styles) : current[styleName]
Line 124: {
		const styles = [];
		const chunks = [];
		let chunk = [];

		// eslint-disable-next-line max-params
		string.replace(TEMPLATE_REGEX, (_, escapeCharacter, inverse, style, close, character) => {
			if (escapeCharacter) {
				chunk.push(unescape(escapeCharacter));
			} else if (style) {
				const string = chunk.join('');
				chunk = [];
				chunks.push(styles.length === 0 ? string : buildStyle(styles)(string));
				styles.push({inverse, styles: parseStyle(style)});
			} else if (close) {
				if (styles.length === 0) {
					throw new Error('Found extraneous } in Chalk template literal');
				}

				chunks.push(buildStyle(styles)(chunk.join('')));
				chunk = [];
				styles.pop();
			} else {
				chunk.push(character);
			}
		});

		chunks.push(chunk.join(''));

		if (styles.length > 0) {
			throw new Error(`Chalk template literal is missing ${styles.length} closing bracket${styles.length === 1 ? '' : 's'} (\`}\`)`);
		}

		return chunks.join('');
	}
Line 125: const styles = []
Line 126: const chunks = []
Line 127: let chunk = []
Line 132: chunk.push(unescape(escapeCharacter))
Line 133: {
				const string = chunk.join('');
				chunk = [];
				chunks.push(styles.length === 0 ? string : buildStyle(styles)(string));
				styles.push({inverse, styles: parseStyle(style)});
			}
Line 134: chunk.join('')
Line 135: chunk = []
Line 136: chunks.push(styles.length === 0 ? string : buildStyle(styles)(string))
Line 137: styles.push({inverse, styles: parseStyle(style)})
Line 138: {
				if (styles.length === 0) {
					throw new Error('Found extraneous } in Chalk template literal');
				}

				chunks.push(buildStyle(styles)(chunk.join('')));
				chunk = [];
				styles.pop();
			}
Line 143: chunks.push(buildStyle(styles)(chunk.join('')))
Line 144: chunk = []
Line 147: chunk.push(character)
Line 151: chunks.push(chunk.join(''))
Line 157: chunks.join('')
Line 164: {
		if (!Array.isArray(firstString) || !Array.isArray(firstString.raw)) {
			// If chalkTemplate() was called by itself or with a string
			throw new TypeError('A tagged template literal must be provided');
		}

		const parts = [firstString.raw[0]];

		for (let index = 1; index < firstString.raw.length; index++) {
			parts.push(
				String(arguments_[index - 1]).replace(/[{}\\]/g, '\\$&'),
				String(firstString.raw[index]),
			);
		}

		return template(parts.join(''));
	}
Line 170: const parts = [firstString.raw[0]]
Line 172: {
			parts.push(
				String(arguments_[index - 1]).replace(/[{}\\]/g, '\\$&'),
				String(firstString.raw[index]),
			);
		}
Line 173: parts.push(
				String(arguments_[index - 1]).replace(/[{}\\]/g, '\\$&'),
				String(firstString.raw[index]),
			)
Line 174: String(arguments_[index - 1]).replace(/[{}\\]/g, '\\$&')
Line 175: String(firstString.raw[index])
Line 179: template(parts.join(''))
Line 185: makeTemplate(chalkInstance)
Line 187: makeTemplate(chalk)
Line 190: makeTemplate(chalkStderr)
