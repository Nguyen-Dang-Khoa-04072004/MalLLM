jasmine.jasmine.getEnv().addReporter({
    specDone: function(result) {
      if (screenshotHelper.shouldTakeScreenshot(result.status)) {
        if (booleanHelper.isTruthy(process.env['chimp.saveScreenshotsToDisk'])) {
          const affix = result.status !== 'passed' ? ' (failed)' : '';
          const fileName = result.fullName + affix;
          screenshotHelper.saveScreenshotsToDisk(fileName, projectDir);
        }
      }
    }
  })
request.post(
    {
      url,
      json: true,
      body: data,
    },
    (error, response, body) => {
      if (!error && response.statusCode === 200) {
        log.debug('[chimp][simian-reporter]', 'received data', body);
      } else {
        if (body) {
          log.error('[chimp][simian-reporter] Error from Simian:', body.error);
        } else {
          log.error('[chimp][simian-reporter]', 'Error while sending result to Simian:', error);
        }
      }
      SimianReporter.reportCallback(error);
    }
  )
booleanHelper.isTruthy(process.env['chimp.saveScreenshotsToDisk'])
install = (callback) => {
    const ProgressBar = require('progress');
    let bar;
    let firstProgress = true;
    Selenium.installCallback = callback;

    if (this.options.offline) {
      log.debug('[chimp][selenium]', 'Offline mode enabled, Chimp will not attempt to install Selenium & Drivers');
      callback();
      return;
    }

    log.debug('[chimp][selenium]', 'Installing Selenium + drivers if needed');

    this.seleniumStandaloneOptions.progressCb = progressCb;

    selenium.install(this.seleniumStandaloneOptions, (e, r) => {
      if (e && e.message.match(/Error: getaddrinfo ENOTFOUND/)) {
        log.debug('[chimp][selenium]', e.message);
        log.info('[chimp][selenium] Detected a connection error in selenium-standalone. Are you offline?');
        log.info('[chimp][selenium] Consider using the --offline option to explicitly skip installing Selenium & drivers.');
        log.info('[chimp][selenium] Attempting to continue...');
        Selenium.installCallback(...
this.cucumberChild = cp.fork(path.join(__dirname, 'cucumber-wrapper.js'), args, opts)
TestingBotSessionManager.prototype.killCurrentSession = function (callback) {

  this._getJobs(function (err, jobs) {
    if (jobs && jobs.length) {
      var job = jobs[0];

      // This will stop the session, causing a 'User terminated' error.
      // If we don't manually stop the session, we get a timed-out error.
      var options = {
        url: this.options.testingbotBaseUrl + '/tests/' + job.id + '/stop',
        method: 'PUT'
      };

      request(options, function (error, response) {
        if (!error && response.statusCode === 200) {
          log.debug('[chimp][testingbot-session-manager]', 'stopped session');
          callback();
        } else {
          log.error('[chimp][testingbot-session-manager]', 'received error', error);
          callback(error);
        }
      });

      // This will set the session to passing or else it will show as Errored out
      // even though we stop it.
      options = {
        url: this.options.testingbotBaseUrl + '/tests/' +...
BrowserStackSessionManager.prototype._getSessions = function (buildId, callback) {
  var hub = this.options.browserStackUrl + '/automate/builds/' + buildId + '/sessions.json?status=running';

  log.debug('[chimp][browserstack-session-manager]', 'requesting sessions from', hub);

  request(hub, function (error, response, body) {
    if (!error && response.statusCode === 200) {
      log.debug('[chimp][browserstack-session-manager]', 'received data', body);
      callback(null, JSON.parse(body));
    } else {
      log.error('[chimp][browserstack-session-manager]', 'received error', error);
      callback(error);
    }
  });
}
SessionManager.prototype.remote = function (webdriverOptions, callback) {
  this._configureRemote(webdriverOptions, this.webdriver.remote, callback);
}
