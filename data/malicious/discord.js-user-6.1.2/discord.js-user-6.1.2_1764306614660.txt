overwrites = overwrites.map(overwrite => {
      const role = this.guild.roles.resolve(overwrite.id);
      if (role) {
        overwrite.id = role.id;
        overwrite.type = 'role';
      } else {
        overwrite.id = this.client.users.resolveID(overwrite.id);
        overwrite.type = 'member';
      }

      return {
        allow: Permissions.resolve(overwrite.allowed || 0),
        deny: Permissions.resolve(overwrite.denied || 0),
        type: overwrite.type,
        id: overwrite.id,
      };
    })
PermissionOverwrites = package\src\structures\PermissionOverwrites.js::program:PermissionOverwrites:<init>
function buildRoute = function buildRoute(manager) {
  const route = [''];
  const handler = {
    get(target, name) {
      if (reflectors.includes(name)) return () => route.join('/');
      if (methods.includes(name)) {
        return options => manager.request(name, route.join('/'), Object.assign({
          versioned: manager.versioned,
          route: route.map((r, i) => {
            if (/\d{16,19}/g.test(r)) return /channels|guilds/.test(route[i - 1]) ? r : ':id';
            return r;
          }).join('/'),
        }, options));
      }
      route.push(name);
      return new Proxy(noop, handler);
    },
    apply(target, _, args) {
      route.push(...args.filter(x => x != null)); // eslint-disable-line eqeqeq
      return new Proxy(noop, handler);
    },
  };
  return new Proxy(noop, handler);
}
GuildMemberRoleStore = package\src\stores\GuildMemberRoleStore.js::program:GuildMemberRoleStore:<init>
module.exports = async function createMessage(channel, options) {
  const User = require('../User');
  const GuildMember = require('../GuildMember');
  const Webhook = require('../Webhook');
  const WebhookClient = require('../../client/WebhookClient');

  const webhook = channel instanceof Webhook || channel instanceof WebhookClient;

  if (typeof options.nonce !== 'undefined') {
    options.nonce = parseInt(options.nonce);
    if (isNaN(options.nonce) || options.nonce < 0) throw new RangeError('MESSAGE_NONCE_TYPE');
  }

  let { content, reply } = options;
  if (options instanceof MessageEmbed) options = webhook ? { embeds: [options] } : { embed: options };
  if (options instanceof MessageAttachment) options = { files: [options.file] };

  if (content instanceof Array || options instanceof Array) {
    const which = content instanceof Array ? content : options;
    const attachments = which.filter(item => item instanceof MessageAttachment);
    const embeds = which.filter(item => ...
function makeDiscordjsError = function makeDiscordjsError(Base) {
  return class DiscordjsError extends Base {
    constructor(key, ...args) {
      super(message(key, args));
      this[kCode] = key;
      if (Error.captureStackTrace) Error.captureStackTrace(this, DiscordjsError);
    }

    get name() {
      return `${super.name} [${this[kCode]}]`;
    }

    get code() {
      return this[kCode];
    }
  };
}
<operator>.formatString("The ", this.constructor.name, " class may not be instantiated.")
WebSocketPacketManager = package\src\client\websocket\packets\WebSocketPacketManager.js::program:WebSocketPacketManager:<init>
manager.request(name, route.join('/'), Object.assign({
          versioned: manager.versioned,
          route: route.map((r, i) => {
            if (/\d{16,19}/g.test(r)) return /channels|guilds/.test(route[i - 1]) ? r : ':id';
            return r;
          }).join('/'),
        }, options))
super.add(data, cache, { id: data.emoji.id || data.emoji.name, extras: [this.message] })
_tmp_2.route = route.map((r, i) => {
            if (/\d{16,19}/g.test(r)) return /channels|guilds/.test(route[i - 1]) ? r : ':id';
            return r;
          }).join('/')
const queryString = (querystring.stringify(options.query).match(/[^=&?]+=[^=&?]+/g) || []).join('&')
_tmp_1.SHARDING_REQUIRED = "This session would have handled too many guilds - Sharding is required."
const applicationID = activity && (activity.application ? activity.application.id || activity.application : null)
VoiceBroadcast = package\src\client\voice\VoiceBroadcast.js::program:VoiceBroadcast:<init>
(async () => {
  for (const libName of Object.keys(libs)) {
    try {
      const lib = require(libName);
      if (libName === 'libsodium-wrappers' && lib.ready) await lib.ready; // eslint-disable-line no-await-in-loop
      exports.methods = libs[libName](lib);
      break;
    } catch (err) {} // eslint-disable-line no-empty
  }
})()
exports.unpack = data => {
  if (!erlpack || data[0] === '{') return JSON.parse(data);
  if (!(data instanceof Buffer)) data = Buffer.from(new Uint8Array(data));
  return erlpack.unpack(data);
}
client.users.add({
        id: '1',
        username: 'Clyde',
        discriminator: '0000',
        avatar: 'https://discordapp.com/assets/f78426a064bc9dd24847519259bc42af.png',
        bot: true,
        status: 'online',
        activity: null,
        verified: true,
      })
const Targets = {
  ALL: 'ALL',
  GUILD: 'GUILD',
  CHANNEL: 'CHANNEL',
  USER: 'USER',
  ROLE: 'ROLE',
  INVITE: 'INVITE',
  WEBHOOK: 'WEBHOOK',
  EMOJI: 'EMOJI',
  MESSAGE: 'MESSAGE',
  UNKNOWN: 'UNKNOWN',
}
const data = await this.client.api.channels[message.channel.id].messages[message.id]
      .reactions[this.reaction.emoji.identifier]
      .get({ query: { limit, before, after } })
Object.defineProperty(this, '_keyArray', { value: null, writable: true, configurable: true })
lru.remove = item => {
        const index = lru.indexOf(item);
        if (index > -1) lru.splice(index, 1);
      }
exports.create = (gateway, query = {}, ...args) => {
  const [g, q] = gateway.split('?');
  query.encoding = exports.encoding;
  if (q) query = Object.assign(querystring.parse(q), query);
  const ws = new exports.WebSocket(`${g}?${querystring.stringify(query)}`, ...args);
  if (browser) ws.binaryType = 'arraybuffer';
  return ws;
}
TypingData = package\src\client\websocket\packets\handlers\TypingStart.js::program:TypingData:<init>
options = Util.mergeDefault({
      totalShards: 'auto',
      respawn: true,
      shardArgs: [],
      token: null,
    }, options)
StreamDispatcher = package\src\client\voice\dispatcher\StreamDispatcher.js::program:StreamDispatcher:<init>
_tmp_12.game = activity ? {
        type: activity.type,
        name: activity.name,
        url: activity.url,
        details: activity.details || undefined,
        state: activity.state || undefined,
        assets: activity.assets ? {
          large_text: activity.assets.largeText || undefined,
          small_text: activity.assets.smallText || undefined,
          large_image: assets.get(activity.assets.largeImage) || activity.assets.largeImage,
          small_image: assets.get(activity.assets.smallImage) || activity.assets.smallImage,
        } : undefined,
        timestamps: activity.timestamps || undefined,
        party: activity.party || undefined,
        application_id: applicationID || undefined,
        secrets: activity.secrets || undefined,
        instance: activity.instance || undefined,
      } : null
new Promise((resolve, reject) => {
      const finish = timeout => {
        if (timeout || this.limited) {
          if (!timeout) {
            timeout = this.resetTime - Date.now() + this.client.options.restTimeOffset;
          }
          if (!this.manager.globalTimeout && this.manager.globallyRateLimited) {
            this.manager.globalTimeout = setTimeout(() => {
              this.manager.globalTimeout = undefined;
              this.manager.globallyRateLimited = false;
              this.busy = false;
              this.handle();
            }, timeout);
            reject({ });
          } else {
            reject({ timeout });
          }
          if (this.client.listenerCount(RATE_LIMIT)) {
            /**
             * Emitted when the client hits a rate limit while making a request
             * @event Client#rateLimit
             * @param {Object} rateLimitInfo Object containing the rate limit info
             * @param {number} rateLimitInfo.timeout Timeout in...
this.client.api.users('@me').patch({ data })
      .then(newData => {
        this.client.token = newData.token;
        return this.client.actions.UserUpdate.handle(newData).updated;
      })
_tmp_1.VOICE_INVALID_HEARTBEAT = "Tried to set voice heartbeat but no valid interval was specified."
this.client.api.gateway.get().then(async res => {
      if (this.client.options.presence != null) { // eslint-disable-line eqeqeq
        const presence = await this.client.presence._parse(this.client.options.presence);
        this.client.options.ws.presence = presence;
        this.client.presence.patch(presence);
      }
      const gateway = `${res.url}/`;
      this.client.emit(Events.DEBUG, `Using gateway ${gateway}`);
      this.client.ws.connect(gateway);
      this.client.ws.connection.once('error', reject);
      this.client.ws.connection.once('close', event => {
        if (event.code === 4004) reject(new Error('TOKEN_INVALID'));
        if (event.code === 4010) reject(new Error('SHARDING_INVALID'));
        if (event.code === 4011) reject(new Error('SHARDING_REQUIRED'));
      });
      this.client.once(Events.READY, () => {
        resolve(token);
        this.client.clearTimeout(timeout);
      });
    }, reject)
channel.client.setTimeout(() => {
    channel.client.emit(Events.TYPING_STOP, channel, user, channel._typing.get(user.id));
    channel._typing.delete(user.id);
  }, 6000)
this.env = Object.assign({}, process.env, {
      SHARDING_MANAGER: true,
      SHARD_ID: this.id,
      SHARD_COUNT: this.manager.totalShards,
      CLIENT_TOKEN: this.manager.token,
    })
Object.getOwnPropertyNames(Collection.prototype)
      .concat(Object.getOwnPropertyNames(Map.prototype)).forEach(prop => {
        if (ignored.includes(prop)) return;
        if (prop === 'size') {
          Object.defineProperty(store.prototype, prop, {
            get: function() {
              return this._filtered[prop];
            },
          });
          return;
        }
        const func = Collection.prototype[prop];
        if (prop === 'constructor' || typeof func !== 'function') return;
        store.prototype[prop] = function(...args) {
          return func.apply(this._filtered, args);
        };
      })
const old = this._speaking.get(user_id)
const func = Collection.prototype[prop]
this.client.api.guilds(this.id).regions.get().then(res => {
      const regions = new Collection();
      for (const region of res) regions.set(region.id, new VoiceRegion(region));
      return regions;
    })
new Promise(resolve => {
        this.client.setTimeout(() => {
          resolve(this.delete({ reason }));
        }, timeout);
      })
const inviteItems = await this.client.api.channels(this.id).invites.get()
