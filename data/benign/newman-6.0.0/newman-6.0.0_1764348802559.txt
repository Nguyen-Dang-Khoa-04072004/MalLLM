(_tmp_10 = program
    .command('run <collection>')
    .description('Initiate a Postman Collection run from a given URL or path')
    .usage('<collection> [options]')
    .option('-e, --environment <path>', 'Specify a URL or path to a Postman Environment')
    .option('-g, --globals <path>', 'Specify a URL or path to a file containing Postman Globals')
    .option('-r, --reporters [reporters]', 'Specify the reporters to use for this run', util.cast.csvParse, ['cli'])
    .option('-n, --iteration-count <n>', 'Define the number of iterations to run', util.cast.integer)
    .option('-d, --iteration-data <path>', 'Specify a data file to use for iterations (either JSON or CSV)')
    .option('--folder <path>',
        'Specify the folder to run from a collection. Can be specified multiple times to run multiple folders',
        util.cast.memoize, [])
    .option('--global-var <value>',
        'Allows the specification of global variables via the command line, in a key=value format',
        util.c...).option
module.exports.load = (callback) => {
    var iswin = (/^win/).test(process.platform),
        home = iswin ? process.env.USERPROFILE : process.env.HOME,

        configFiles = [];

    !iswin && configFiles.push(join('/etc', POSTMAN_CONFIG_DIR, FILE_NAME));
    home && configFiles.push(join(home, '.' + POSTMAN_CONFIG_DIR, FILE_NAME));
    configFiles.push(join(process.cwd(), '.' + FILE_NAME));

    async.mapSeries(configFiles, (path, cb) => {
        fs.readFile(path, (err, data) => {
            if (err) {
                return cb(null, {}); // err masked to avoid overpopulating terminal with missing .newmanrc messages
            }
            data && data.toString && (data = data.toString(util.detectEncoding(data)).trim());
            try {
                return cb(null, liquidJSON.parse(data));
            }
            catch (e) {
                return cb(_.set(e, 'help', `The file at ${path} contains invalid data.`));
            }
        });
    }, (err, files) => {
   ...
