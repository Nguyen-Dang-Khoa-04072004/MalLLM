defineGetter(req, 'subdomains', function subdomains() {
    var hostname = this.hostname;

    if (!hostname) {
        return [];
    }

    var offset = this.app.get('subdomain offset');
    var domains = !isIP(hostname) ? hostname.split('.').reverse() : [hostname];

    return domains.slice(offset);
})
var hostname = this.hostname
dest[field] = value
var offset = this.app.get('subdomain offset')
mockResponse.writeHead = function(statusCode, statusMessage, headers) {

        if (_endCalled) {
            throw new Error('The end() method has already been called.');
        }

        if (mockResponse.headersSent) {
            // Node docs: "This method must only be called once on a message"
            // but it doesn't error if you do call it after first chunk of body is sent
            // so we shouldn't throw here either (although it's a bug in the code).
            // We return without updating since in real life it's just possible the double call didn't
            // completely corrupt the response (for example not using chunked encoding due to HTTP/1.0 client)
            // and in this case the client will see the _original_ headers.
            return this;
        }

        mockResponse.statusCode = statusCode;

        // resolve statusMessage and headers as optional
        if (Object.prototype.toString.call(statusMessage) === '[object Object]') {
          ...
domains.slice(offset)
defineGetter(req, 'path', function path() {
    return parse(this).pathname;
})
defineGetter(req, 'hostname', function hostname() {
    var host = this.get('X-Forwarded-Host');

    if (!host) {
        host = this.get('Host');
    }

    if (!host) {
        return undefined;
    }

    var offset = host[0] === '[' ? host.indexOf(']') + 1 : 0;
    var index = host.indexOf(':', offset);

    return ~index ? host.substring(0, index) : host;
})
var host = this.get('X-Forwarded-Host')
!host
host = this.get('Host')
mockRequest.get =
    mockRequest.getHeader =
    mockRequest.header = function(name) {
        name = name.toLowerCase();
        switch (name) {
            case 'referer':
            case 'referrer':
                return mockRequest.headers.referrer || mockRequest.headers.referer;
            default:
                return mockRequest.headers[name];
        }
    }
var offset = host[0] === '[' ? host.indexOf(']') + 1 : 0
var index = host.indexOf(':', offset)
mockRequest.headers.referrer || mockRequest.headers.referer
defineGetter(req, 'host', function host() {
    return this.hostname;
})
defineGetter(req, 'fresh', function(){
    var method = this.method;
    var statusCode = this.res.statusCode;

    if (method !== 'GET' && method !== 'HEAD') {
        return false;
    }

    if (statusCode >= 200 && statusCode < 300 || statusCode === 304) {
        return fresh(this.headers, this.res._headers || {});
    }

    return false;
})
defineGetter(req, 'stale', function stale() {
    return !this.fresh;
})
defineGetter(req, 'xhr', function xhr() {
    var val = this.get('X-Requested-With') || '';
    return val.toLowerCase() === 'xmlhttprequest';
})
var val = this.get('X-Requested-With') || ''
