this.#channel.request('producer.close', this.#internal)
            .catch(() => { })
const consumer = new Consumer_1.Consumer({
            internal,
            data,
            channel: this.channel,
            payloadChannel: this.payloadChannel,
            appData,
            paused: status.paused,
            producerPaused: status.producerPaused
        })
function validateRtpParameters = function validateRtpParameters(params) {
    if (typeof params !== 'object')
        throw new TypeError('params is not an object');
    // mid is optional.
    if (params.mid && typeof params.mid !== 'string')
        throw new TypeError('params.mid is not a string');
    // codecs is mandatory.
    if (!Array.isArray(params.codecs))
        throw new TypeError('missing params.codecs');
    for (const codec of params.codecs) {
        validateRtpCodecParameters(codec);
    }
    // headerExtensions is optional. If unset, fill with an empty array.
    if (params.headerExtensions && !Array.isArray(params.headerExtensions))
        throw new TypeError('params.headerExtensions is not an array');
    else if (!params.headerExtensions)
        params.headerExtensions = [];
    for (const ext of params.headerExtensions) {
        validateRtpHeaderExtensionParameters(ext);
    }
    // encodings is optional. If unset, fill with an empty array.
    if (params.encodings ...
_tmp_2.push({
            kind: 'audio',
            mimeType: 'audio/CN',
            preferredPayloadType: 13,
            clockRate: 16000
        })
consumer.on('@close', () => this.consumers.delete(consumer.id))
this.#producerSocket.write(Buffer.from(Uint32Array.of(Buffer.byteLength(request)).buffer))
_tmp_62.rtcpFeedback = [
                { type: 'nack' },
                { type: 'nack', parameter: 'pli' },
                { type: 'ccm', parameter: 'fir' },
                { type: 'goog-remb' },
                { type: 'transport-cc' }
            ]
const transport = new WebRtcTransport_1.WebRtcTransport({
            internal,
            data,
            channel: this.#channel,
            payloadChannel: this.#payloadChannel,
            appData,
            getRouterRtpCapabilities: () => this.#data.rtpCapabilities,
            getProducerById: (producerId) => (this.#producers.get(producerId)),
            getDataProducerById: (dataProducerId) => (this.#dataProducers.get(dataProducerId))
        })
_tmp_20 = await this.#channel.request('dataConsumer.getBufferedAmount', this.#internal)
this.#transports.set(transport.id, transport)
logger.error('received response is not accepted nor rejected [method:%s, id:%s]', sent.method, sent.id)
transport.on('@newproducer', (producer) => this.#producers.set(producer.id, producer))
transport.on('@producerclose', (producer) => this.#producers.delete(producer.id))
_tmp_69.rtcpFeedback = [
                { type: 'nack' },
                { type: 'nack', parameter: 'pli' },
                { type: 'ccm', parameter: 'fir' },
                { type: 'goog-remb' },
                { type: 'transport-cc' }
            ]
transport.on('@dataproducerclose', (dataProducer) => (this.#dataProducers.delete(dataProducer.id)))
const data = await this.#channel.request('router.createPlainTransport', internal, reqData)
const transport = new PlainTransport_1.PlainTransport({
            internal,
            data,
            channel: this.#channel,
            payloadChannel: this.#payloadChannel,
            appData,
            getRouterRtpCapabilities: () => this.#data.rtpCapabilities,
            getProducerById: (producerId) => (this.#producers.get(producerId)),
            getDataProducerById: (dataProducerId) => (this.#dataProducers.get(dataProducerId))
        })
rtpParameters.encodings.length === 0
!this.#cnameForProducers && rtpParameters.rtcp && rtpParameters.rtcp.cname
_tmp_85.push({
			kind             : 'video',
			uri              : 'http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01',
			preferredId      : 3,
			preferredEncrypt : false,
			direction        : 'sendrecv'
		})
transport.on('@newproducer', (producer) => this.#producers.set(producer.id, producer))
_tmp_90.uri = "http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01"
transport.on('@newdataproducer', (dataProducer) => (this.#dataProducers.set(dataProducer.id, dataProducer)))
transport.on('@dataproducerclose', (dataProducer) => (this.#dataProducers.delete(dataProducer.id)))
const status = await this.channel.request('transport.produce', internal, reqData)
const data = {
            kind,
            rtpParameters,
            type: status.type,
            consumableRtpParameters
        }
_tmp_93.uri = "urn:ietf:params:rtp-hdrext:sdes:rtp-stream-id"
const producer = new Producer_1.Producer({
            internal,
            data,
            channel: this.channel,
            payloadChannel: this.payloadChannel,
            appData,
            paused
        })
_tmp_85.push({
			kind             : 'video',
			uri              : 'urn:ietf:params:rtp-hdrext:sdes:repaired-rtp-stream-id',
			preferredId      : 5,
			preferredEncrypt : false,
			direction        : 'recvonly'
		})
throw new TypeError('invalid encoding.scalabilityMode');
producer.on('@close', () => {
            this.#producers.delete(producer.id);
            this.emit('@producerclose', producer);
        })
_tmp_85.push({
			kind             : 'video',
			uri              : 'http://tools.ietf.org/html/draft-ietf-avtext-framemarking-07',
			preferredId      : 7,
			preferredEncrypt : false,
			direction        : 'sendrecv'
		})
const data = await this.#channel.request('router.createPipeTransport', internal, reqData)
const transport = new PipeTransport_1.PipeTransport({
            internal,
            data,
            channel: this.#channel,
            payloadChannel: this.#payloadChannel,
            appData,
            getRouterRtpCapabilities: () => this.#data.rtpCapabilities,
            getProducerById: (producerId) => (this.#producers.get(producerId)),
            getDataProducerById: (dataProducerId) => (this.#dataProducers.get(dataProducerId))
        })
throw new TypeError('if given, appData must be an object');
!caps.numStreams || typeof caps.numStreams !== 'object'
const rtpParameters = ortc.getConsumerRtpParameters(producer.consumableRtpParameters, rtpCapabilities, pipe)
_tmp_85.push({
			kind             : 'audio',
			uri              : 'http://www.webrtc.org/experiments/rtp-hdrext/abs-capture-time',
			preferredId      : 10,
			preferredEncrypt : false,
			direction        : 'sendrecv'
		})
transport.on('@producerclose', (producer) => this.#producers.delete(producer.id))
transport.on('@newdataproducer', (dataProducer) => (this.#dataProducers.set(dataProducer.id, dataProducer)))
transport.on('@dataproducerclose', (dataProducer) => (this.#dataProducers.delete(dataProducer.id)))
const data = await this.#channel.request('router.createDirectTransport', internal, reqData)
const transport = new DirectTransport_1.DirectTransport({
            internal,
            data,
            channel: this.#channel,
            payloadChannel: this.#payloadChannel,
            appData,
            getRouterRtpCapabilities: () => this.#data.rtpCapabilities,
            getProducerById: (producerId) => (this.#producers.get(producerId)),
            getDataProducerById: (dataProducerId) => (this.#dataProducers.get(dataProducerId))
        })
_tmp_62.paused = paused
this.#payloadChannel.on(this.#internal.consumerId, (event, data, payload) => {
            switch (event) {
                case 'rtp':
                    {
                        if (this.#closed)
                            break;
                        const packet = payload;
                        this.safeEmit('rtp', packet);
                        break;
                    }
                default:
                    {
                        logger.error('ignoring unknown event "%s"', event);
                    }
            }
        })
this.#transports.set(transport.id, transport)
const consumer = new Consumer_1.Consumer({
            internal,
            data,
            channel: this.channel,
            payloadChannel: this.payloadChannel,
            appData,
            paused: status.paused,
            producerPaused: status.producerPaused,
            score: status.score,
            preferredLayers: status.preferredLayers
        })
transport.on('@newproducer', (producer) => this.#producers.set(producer.id, producer))
transport.on('@producerclose', (producer) => this.#producers.delete(producer.id))
transport.on('@newdataproducer', (dataProducer) => (this.#dataProducers.set(dataProducer.id, dataProducer)))
transport.on('@dataproducerclose', (dataProducer) => (this.#dataProducers.delete(dataProducer.id)))
logger.error('ignoring unknown event "%s"', event)
exports.validateSctpParameters = validateSctpParameters
consumer.on('@close', () => this.consumers.delete(consumer.id))
consumer.on('@producerclose', () => this.consumers.delete(consumer.id))
_tmp_114.push(router.createPipeTransport({ listenIp, enableSctp, numSctpStreams, enableRtx, enableSrtp }))
const dataProducer = new DataProducer_1.DataProducer({
            internal,
            data,
            channel: this.channel,
            payloadChannel: this.payloadChannel,
            appData
        })
function generateRouterRtpCapabilities = function generateRouterRtpCapabilities(mediaCodecs = []) {
    // Normalize supported RTP capabilities.
    validateRtpCapabilities(supportedRtpCapabilities_1.supportedRtpCapabilities);
    if (!Array.isArray(mediaCodecs))
        throw new TypeError('mediaCodecs must be an Array');
    const clonedSupportedRtpCapabilities = utils.clone(supportedRtpCapabilities_1.supportedRtpCapabilities);
    const dynamicPayloadTypes = utils.clone(DynamicPayloadTypes);
    const caps = {
        codecs: [],
        headerExtensions: clonedSupportedRtpCapabilities.headerExtensions
    };
    for (const mediaCodec of mediaCodecs) {
        // This may throw.
        validateRtpCodecCapability(mediaCodec);
        const matchedSupportedCodec = clonedSupportedRtpCapabilities
            .codecs
            .find((supportedCodec) => (matchCodecs(mediaCodec, supportedCodec, { strict: false })));
        if (!matchedSupportedCodec) {
            throw new errors_1.UnsupportedError(`medi...
_tmp_117.push(localPipeTransport.connect({
                            ip: remotePipeTransport.tuple.localIp,
                            port: remotePipeTransport.tuple.localPort,
                            srtpParameters: remotePipeTransport.srtpParameters
                        }))
dataProducer.on('@close', () => {
            this.dataProducers.delete(dataProducer.id);
            this.emit('@dataproducerclose', dataProducer);
        })
const caps = {
        codecs: [],
        headerExtensions: clonedSupportedRtpCapabilities.headerExtensions
    }
const data = await this.channel.request('transport.consumeData', internal, reqData)
const dataConsumer = new DataConsumer_1.DataConsumer({
            internal,
            data,
            channel: this.channel,
            payloadChannel: this.payloadChannel,
            appData
        })
_tmp_92.data = data
this.dataConsumers.set(dataConsumer.id, dataConsumer)
dataConsumer.on('@close', () => {
            this.dataConsumers.delete(dataConsumer.id);
            if (this.#sctpStreamIds)
                this.#sctpStreamIds[sctpStreamId] = 0;
        })
this.dataConsumers.delete(dataConsumer.id)
dataConsumer.on('@dataproducerclose', () => {
            this.dataConsumers.delete(dataConsumer.id);
            if (this.#sctpStreamIds)
                this.#sctpStreamIds[sctpStreamId] = 0;
        })
this.dataConsumers.delete(dataConsumer.id)
