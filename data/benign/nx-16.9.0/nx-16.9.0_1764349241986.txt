function getTerminalOutputLifeCycle = async function getTerminalOutputLifeCycle(initiatingProject, projectNames, tasks, nxArgs, nxJson, overrides) {
    const { runnerOptions } = getRunner(nxArgs, nxJson);
    const isRunOne = initiatingProject != null;
    const useDynamicOutput = shouldUseDynamicLifeCycle(tasks, runnerOptions, nxArgs.outputStyle);
    const overridesWithoutHidden = { ...overrides };
    delete overridesWithoutHidden['__overrides_unparsed__'];
    if (isRunOne) {
        if (useDynamicOutput) {
            return await (0, dynamic_run_one_terminal_output_life_cycle_1.createRunOneDynamicOutputRenderer)({
                initiatingProject,
                tasks,
                args: nxArgs,
                overrides: overridesWithoutHidden,
            });
        }
        return {
            lifeCycle: new static_run_one_terminal_output_life_cycle_1.StaticRunOneTerminalOutputLifeCycle(initiatingProject, projectNames, tasks, nxArgs),
            renderIsDone: Promise.resolve(),
        };
    }
    el...
function getPluginPathAndName = function getPluginPathAndName(moduleName, paths, root) {
    let pluginPath;
    try {
        pluginPath = require.resolve(moduleName, {
            paths,
        });
    }
    catch (e) {
        if (e.code === 'MODULE_NOT_FOUND') {
            const plugin = resolveLocalNxPlugin(moduleName, root);
            if (plugin) {
                const main = readPluginMainFromProjectConfiguration(plugin.projectConfig);
                pluginPath = main ? path.join(root, main) : plugin.path;
            }
            else {
                logger_1.logger.error(`Plugin listed in \`nx.json\` not found: ${moduleName}`);
                throw e;
            }
        }
        else {
            throw e;
        }
    }
    const packageJsonPath = path.join(pluginPath, 'package.json');
    const extension = path.extname(pluginPath);
    // Register the ts-transpiler if we are pointing to a
    // plain ts file that's not part of a plugin project
    if (extension === '.ts' && !tsNodeAndPat...
function getNodes = function getNodes(data, keyMap) {
    const nodes = new Map();
    if (data.lockfileVersion > 1) {
        Object.entries(data.packages).forEach(([path, snapshot]) => {
            // skip workspaces packages
            if (path === '' || !path.includes('node_modules') || snapshot.link) {
                return;
            }
            const packageName = path.split('node_modules/').pop();
            const version = findV3Version(snapshot, packageName);
            createNode(packageName, version, path, nodes, keyMap, snapshot);
        });
    }
    else {
        Object.entries(data.dependencies).forEach(([packageName, snapshot]) => {
            // we only care about dependencies of workspace packages
            if (snapshot.version?.startsWith('file:')) {
                if (snapshot.dependencies) {
                    Object.entries(snapshot.dependencies).forEach(([depName, depSnapshot]) => {
                        addV1Node(depName, depSnapshot, `${snapshot.version.slice...
function reportHandler = async function reportHandler() {
    const { pm, pmVersion, localPlugins, communityPlugins, packageVersionsWeCareAbout, outOfSyncPackageGroup, projectGraphError, } = await getReportData();
    const bodyLines = [
        `Node   : ${process.versions.node}`,
        `OS     : ${process.platform}-${process.arch}`,
        `${pm.padEnd(7)}: ${pmVersion}`,
        ``,
    ];
    let padding = Math.max(...packageVersionsWeCareAbout.map((x) => x.package.length)) + 1;
    packageVersionsWeCareAbout.forEach((p) => {
        bodyLines.push(`${chalk.green(p.package.padEnd(padding))} : ${chalk.bold(p.version)}`);
    });
    if (communityPlugins.length) {
        bodyLines.push(LINE_SEPARATOR);
        padding = Math.max(...communityPlugins.map((x) => x.name.length)) + 1;
        bodyLines.push('Community plugins:');
        communityPlugins.forEach((p) => {
            bodyLines.push(`${chalk.green(p.name.padEnd(padding))}: ${chalk.bold(p.version)}`);
        });
    }
    if (localPlugins.le...
function ensureUpToDateInstallation = function ensureUpToDateInstallation() {
    const nxJsonPath = path.join(__dirname, '..', 'nx.json');
    let nxJson;
    try {
        nxJson = require(nxJsonPath);
    }
    catch {
        console.error('[NX]: nx.json is required when running the nx wrapper. See https://nx.dev/more-concepts/nx-and-the-wrapper');
        process.exit(1);
    }
    try {
        ensureDir(path.join(__dirname, 'installation'));
        if (!matchesCurrentNxInstall(nxJson.installation)) {
            fs.writeFileSync(installationPath, JSON.stringify({
                name: 'nx-installation',
                devDependencies: {
                    nx: nxJson.installation.version,
                    ...nxJson.installation.plugins,
                },
            }));
            cp.execSync('npm i', {
                cwd: path.dirname(installationPath),
                stdio: 'inherit',
            });
        }
    }
    catch (e) {
        const messageLines = [
            '[NX]: Nx wrapper failed to...
function buildEnvironmentJs = function buildEnvironmentJs(exclude, watchMode, localMode, depGraphClientResponse, taskGraphClientResponse) {
    let environmentJs = `window.exclude = ${JSON.stringify(exclude)};
  window.watch = ${!!watchMode};
  window.environment = 'release';
  window.localMode = '${localMode}';

  window.appConfig = {
    showDebugger: false,
    showExperimentalFeatures: false,
    workspaces: [
      {
        id: 'local',
        label: 'local',
        projectGraphUrl: 'project-graph.json',
        taskGraphUrl: 'task-graph.json'
      }
    ],
    defaultWorkspaceId: 'local',
  };
  `;
    if (localMode === 'build') {
        environmentJs += `window.projectGraphResponse = ${JSON.stringify(depGraphClientResponse)};
    `;
        environmentJs += `window.taskGraphResponse = ${JSON.stringify(taskGraphClientResponse)};
    `;
    }
    else {
        environmentJs += `window.projectGraphResponse = null;`;
        environmentJs += `window.taskGraphResponse = null;`;
    }
    return environme...
const builderContext = {
        workspaceRoot: context.root,
        target: {
            project: context.projectName,
            target: context.targetName,
            configuration: context.configurationName,
        },
        builder: {
            ...builderInfo,
        },
        logger: (0, exports.getLogger)(),
        id: 1,
        currentDirectory: process.cwd(),
        scheduleTarget: architect.scheduleTarget,
        getBuilderNameForTarget: architectHost.getBuilderNameForTarget,
        scheduleBuilder: architect.scheduleBuilder,
        getTargetOptions: architectHost.getOptionsForTarget,
        addTeardown(teardown) {
            // No-op as Nx doesn't require an implementation of this function
            return;
        },
        reportProgress(...args) {
            // No-op as Nx doesn't require an implementation of this function
            return;
        },
        reportRunning(...args) {
            // No-op as Nx doesn't require an implementation of this...
function recordStat = async function recordStat(opts) {
    try {
        const major = Number(opts.nxVersion.split('.')[0]);
        if (process.env.NX_VERBOSE_LOGGING === 'true') {
            console.log(`Record stat. Major: ${major}`);
        }
        if (major < 10 || major > 16)
            return; // test version, skip it
        const axios = require('axios');
        await (axios['default'] ?? axios)
            .create({
            baseURL: 'https://cloud.nx.app',
            timeout: 400,
        })
            .post('/nx-cloud/stats', {
            command: opts.command,
            isCI: (0, is_ci_1.isCI)(),
            useCloud: opts.useCloud,
            meta: opts.meta,
        });
    }
    catch (e) {
        if (process.env.NX_VERBOSE_LOGGING === 'true') {
            console.error(e);
        }
    }
}
function collectCacheableOperations = async function collectCacheableOperations(options) {
    let cacheableOperations;
    workspaceTargets = getWorkspaceTargets();
    const defaultCacheableTargetsInWorkspace = defaultCacheableOperations.filter((t) => workspaceTargets.includes(t));
    if (options.interactive && workspaceTargets.length > 0) {
        output_1.output.log({
            title: 'ðŸ§‘â€ðŸ”§ Please answer the following questions about the targets found in your angular.json in order to generate task runner configuration',
        });
        cacheableOperations = (await (0, enquirer_1.prompt)([
            {
                type: 'multiselect',
                name: 'cacheableOperations',
                initial: defaultCacheableTargetsInWorkspace,
                message: 'Which of the following targets are cacheable? (Produce the same output given the same input, e.g. build, test and lint usually are, serve and start are not)',
                // enquirer mutates the array below, create a new one to avoid it
  ...
function generateGeneratorOverviewOutput = function generateGeneratorOverviewOutput({ pluginName, name, description, aliases, }) {
    const ui = cliui();
    const overviewItemsLabelWidth = 
    // Chars in labels "From" and "Name"
    4 +
        // The `:` char
        1;
    let installedVersion;
    try {
        installedVersion = (0, package_json_1.readModulePackageJson)(pluginName).packageJson.version;
    }
    catch { }
    ui.div(...[
        {
            text: chalk.bold('From:'),
            padding: [1, 0, 0, 0],
            width: overviewItemsLabelWidth,
        },
        {
            text: pluginName +
                (installedVersion ? chalk.dim(` (v${installedVersion})`) : ''),
            padding: [1, 0, 0, 2],
        },
    ]);
    ui.div(...[
        {
            text: chalk.bold('Name:'),
            padding: [0, 0, 0, 0],
            width: overviewItemsLabelWidth,
        },
        {
            text: `${name}${aliases.length ? chalk.dim(` (aliases: ${aliases.join(', ')})`) : ''}`,
           ...
function runInParallel = async function runInParallel(options, context) {
    const procs = options.commands.map((c) => createProcess(c, options.readyWhen, options.color, calculateCwd(options.cwd, context)).then((result) => ({
        result,
        command: c.command,
    })));
    if (options.readyWhen) {
        const r = await Promise.race(procs);
        if (!r.result) {
            process.stderr.write(`Warning: run-commands command "${r.command}" exited with non-zero status code`);
            return false;
        }
        else {
            return true;
        }
    }
    else {
        const r = await Promise.all(procs);
        const failed = r.filter((v) => !v.result);
        if (failed.length > 0) {
            failed.forEach((f) => {
                process.stderr.write(`Warning: run-commands command "${f.command}" exited with non-zero status code`);
            });
            return false;
        }
        else {
            return true;
        }
    }
}
