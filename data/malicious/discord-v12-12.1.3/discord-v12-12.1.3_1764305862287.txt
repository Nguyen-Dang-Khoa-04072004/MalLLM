ClientUserGuildSettings = package\src\structures\ClientUserGuildSettings.js::program:ClientUserGuildSettings:<init>
VoiceServerUpdate = package\src\client\websocket\packets\handlers\VoiceServerUpdate.js::program:VoiceServerUpdate:<init>
SequentialRequestHandler = package\src\client\rest\RequestHandlers\Sequential.js::program:SequentialRequestHandler:<init>
WebSocketPacketManager = package\src\client\websocket\packets\WebSocketPacketManager.js::program:WebSocketPacketManager:<init>
TextBasedChannel = package\src\structures\interfaces\TextBasedChannel.js::program:TextBasedChannel:<init>
ReactionCollector = package\src\structures\ReactionCollector.js::program:ReactionCollector:<init>
const WebSocket = (function findWebSocket() {
  if (browser) return window.WebSocket; // eslint-disable-line no-undef
  try {
    const uws = require('@discordjs/uws');
    process.emitWarning('uws support is being removed in the next version of discord.js',
      'DeprecationWarning', findWebSocket);
    return uws;
  } catch (e) {
    return require('ws');
  }
}())
VoiceWebSocket = package\src\client\voice\VoiceWebSocket.js::program:VoiceWebSocket:<init>
Object.defineProperty(this, '_member', {
      writable: true,
      value: typeof member === 'object' && !(member instanceof Array) ? member : null,
    })
process.emitWarning('uws support is being removed in the next version of discord.js',
      'DeprecationWarning', findWebSocket)
this.client.setTimeout(() => this.deleted.delete(guildID + userID), this.client.options.restWsBridgeTimeout)
new Promise((resolve, reject) => {
      if (!token || typeof token !== 'string') throw new Error(Constants.Errors.INVALID_TOKEN);
      token = token.replace(/^Bot\s*/i, '');
      this.client.manager.connectToWebSocket(token, resolve, reject);
    }).catch(e => {
      this.client.destroy();
      return Promise.reject(e);
    })
channel.client.emit(Constants.Events.TYPING_STOP, channel, user, channel._typing.get(user.id))
new Promise((resolve, reject) => {
      if (!channel.joinable) {
        if (channel.full) {
          throw new Error('You do not have permission to join this voice channel; it is full.');
        } else {
          throw new Error('You do not have permission to join this voice channel.');
        }
      }

      let connection = this.connections.get(channel.guild.id);

      if (connection) {
        if (connection.channel.id !== channel.id) {
          this.connections.get(channel.guild.id).updateChannel(channel);
        }
        resolve(connection);
        return;
      } else {
        connection = new VoiceConnection(this, channel);
        this.connections.set(channel.guild.id, connection);
      }

      connection.once('failed', reason => {
        this.connections.delete(channel.guild.id);
        reject(reason);
      });

      connection.once('authenticated', () => {
        connection.once('ready', () => resolve(connection));
        connection.once('error', rejec...
item.request.gen().end((err, res) => {
        if (res && res.headers) {
          this.requestLimit = Number(res.headers['x-ratelimit-limit']);
          this.requestResetTime = Number(res.headers['x-ratelimit-reset']) * 1000;
          this.requestRemaining = Number(res.headers['x-ratelimit-remaining']);
          this.timeDifference = Date.now() - new Date(res.headers.date).getTime();
        }
        if (err) {
          if (err.status === 429) {
            this.queue.unshift(item);
            this.client.setTimeout(() => {
              this.globalLimit = false;
              resolve();
            }, Number(res.headers['retry-after']) + this.client.options.restTimeOffset);
            if (res.headers['x-ratelimit-global']) this.globalLimit = true;
          } else if (err.status >= 500 && err.status < 600) {
            if (item.retries === this.client.options.retryLimit) {
              item.reject(err);
              resolve();
            } else {
              item.retr...
function pad = function pad(v, n, c = '0') {
  return String(v).length >= n ? String(v) : (String(c).repeat(n) + v).slice(-n);
}
this === presence || (
      presence &&
      this.status === presence.status &&
      this.activities.length === presence.activities.length &&
      this.activities.every((activity, index) => activity.equals(presence.activities[index])) &&
      this.clientStatus.web === presence.clientStatus.web &&
      this.clientStatus.mobile === presence.clientStatus.mobile &&
      this.clientStatus.desktop === presence.clientStatus.desktop
    )
presence &&
      this.status === presence.status &&
      this.activities.length === presence.activities.length &&
      this.activities.every((activity, index) => activity.equals(presence.activities[index])) &&
      this.clientStatus.web === presence.clientStatus.web &&
      this.clientStatus.mobile === presence.clientStatus.mobile &&
      this.clientStatus.desktop === presence.clientStatus.desktop
this.rest.makeRequest(
      'delete', `${Endpoints.Channel(overwrite.channel).permissions}/${overwrite.id}`,
      true, undefined, undefined, reason
    ).then(() => overwrite)
<operator>.formatString("", Endpoints.Channel(overwrite.channel).permissions, "/", overwrite.id, "")
this.onSpeaking({ user_id: user.id, ssrc, speaking: true })
speakingTimeout = this.client.setTimeout(() => {
      try {
        this.onSpeaking({ user_id: user.id, ssrc, speaking: false });
        this.client.clearTimeout(speakingTimeout);
        this.speakingTimeouts.delete(ssrc);
      } catch (ex) {
        // Connection already closed, ignore
      }
    }, DISCORD_SPEAKING_DELAY)
compareFunction = compareFunction === void 0 ? <lambda>1 : compareFunction
this.debug('Warning: wanted to resume but session ID not available; identifying as a new session instead')
const d = {
      token: this.client.token,
      session_id: this.sessionID,
      seq: this.sequence,
    }
const reaction = this.reactions.get(emojiID)
(_tmp_97 = reaction.users).has
const id = this.client.resolver.resolveUserID(user)
emoji = this.emojis.get(emoji)
throw new TypeError('Emoji must be either an instance of Emoji or an ID');
emoji.delete(reason)
