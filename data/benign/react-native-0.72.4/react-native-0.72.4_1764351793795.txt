React.forwardRef((props: TextProps, forwardedRef) => {
  const {
    accessible,
    accessibilityLabel,
    accessibilityRole,
    accessibilityState,
    allowFontScaling,
    'aria-busy': ariaBusy,
    'aria-checked': ariaChecked,
    'aria-disabled': ariaDisabled,
    'aria-expanded': ariaExpanded,
    'aria-label': ariaLabel,
    'aria-selected': ariaSelected,
    ellipsizeMode,
    id,
    nativeID,
    onLongPress,
    onPress,
    onPressIn,
    onPressOut,
    onResponderGrant,
    onResponderMove,
    onResponderRelease,
    onResponderTerminate,
    onResponderTerminationRequest,
    onStartShouldSetResponder,
    pressRetentionOffset,
    role,
    suppressHighlighting,
    ...restProps
  } = props;

  const [isHighlighted, setHighlighted] = useState(false);

  let _accessibilityState;
  if (
    accessibilityState != null ||
    ariaBusy != null ||
    ariaChecked != null ||
    ariaDisabled != null ||
    ariaExpanded != null ||
    ariaSelected != null
  ) {
    _acce...
function getReactTree = function getReactTree() {
  // TODO(sema): Reenable tree dumps using the Fiber tree structure. #15945684
  return (
    'React tree dumps have been temporarily disabled while React is ' +
    'upgraded to Fiber.'
  );
  /*
  let output = '';
  const rootIds = Object.getOwnPropertyNames(ReactNativeMount._instancesByContainerID);
  for (const rootId of rootIds) {
    const instance = ReactNativeMount._instancesByContainerID[rootId];
    output += `============ Root ID: ${rootId} ============\n`;
    output += dumpNode(instance, 0);
    output += `============ End root ID: ${rootId} ============\n`;
  }
  return output;
*/
}
const ToastAndroid = {
  // Toast duration constants
  SHORT: (ToastAndroidConstants.SHORT: number),
  LONG: (ToastAndroidConstants.LONG: number),
  // Toast gravity constants
  TOP: (ToastAndroidConstants.TOP: number),
  BOTTOM: (ToastAndroidConstants.BOTTOM: number),
  CENTER: (ToastAndroidConstants.CENTER: number),

  show: function (message: string, duration: number): void {
    NativeToastAndroid.show(message, duration);
  },

  showWithGravity: function (
    message: string,
    duration: number,
    gravity: number,
  ): void {
    NativeToastAndroid.showWithGravity(message, duration, gravity);
  },

  showWithGravityAndOffset: function (
    message: string,
    duration: number,
    gravity: number,
    xOffset: number,
    yOffset: number,
  ): void {
    NativeToastAndroid.showWithGravityAndOffset(
      message,
      duration,
      gravity,
      xOffset,
      yOffset,
    );
  },
}
Object.keys(this.props).forEach(prop => {
          // We can't just assign props on top of defaultProps
          // because React treats undefined as special and different from null.
          // If a prop is specified but set to undefined it is ignored and the
          // default prop is used instead. If it is set to null, then the
          // null value overwrites the default value.
          if (this.props[prop] !== undefined) {
            props[prop] = this.props[prop];
          }
        })
function parseErrorStack = function parseErrorStack(errorStack?: string): Array<StackFrame> {
  if (errorStack == null) {
    return [];
  }

  const stacktraceParser = require('stacktrace-parser');
  const parsedStack = Array.isArray(errorStack)
    ? errorStack
    : global.HermesInternal
    ? convertHermesStack(parseHermesStack(errorStack))
    : stacktraceParser.parse(errorStack).map((frame): StackFrame => ({
        ...frame,
        column: frame.column != null ? frame.column - 1 : null,
      }));

  return parsedStack;
}
function invokeGuardedCallbackAndCatchFirstError = function invokeGuardedCallbackAndCatchFirstError(
  name,
  func,
  context,
  a,
  b,
  c,
  d,
  e,
  f
) {
  invokeGuardedCallback.apply(this, arguments);
  if (hasError) {
    if (hasError) {
      var error = caughtError;
      hasError = !1;
      caughtError = null;
    } else
      throw Error(
        "clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue."
      );
    hasRethrowError || ((hasRethrowError = !0), (rethrowError = error));
  }
}
function CountBadge = function CountBadge(props: {count: number, level: 'error' | 'warn'}) {
  return (
    <View style={countStyles.outside}>
      {/* $FlowFixMe[incompatible-type] (>=0.114.0) This suppression was added
       * when fixing the type of `StyleSheet.create`. Remove this comment to
       * see the error. */}
      <View style={[countStyles.inside, countStyles[props.level]]}>
        <Text style={countStyles.text}>
          {props.count <= 1 ? '!' : props.count}
        </Text>
      </View>
    </View>
  );
}
