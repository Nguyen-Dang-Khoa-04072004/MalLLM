overwrites = overwrites.map(overwrite => {
      const role = this.client.resolver.resolveRole(guild, overwrite.id);
      if (role) {
        overwrite.id = role.id;
        overwrite.type = "role";
      } else {
        overwrite.id = this.client.resolver.resolveUserID(overwrite.id);
        overwrite.type = "member";
      }

      return {
        allow: Permissions.resolve(overwrite.allow || overwrite.allowed || 0),
        deny: Permissions.resolve(overwrite.deny || overwrite.denied || 0),
        type: overwrite.type,
        id: overwrite.id
      };
    })
const ffmpegArguments = [
  '-analyzeduration', '0',
  '-loglevel', '0',
  '-f', 's16le',
  '-ar', '48000',
  '-ac', '2',
]
ClientUserGuildSettings = package\src\structures\ClientUserGuildSettings.js::program:ClientUserGuildSettings:<init>
this.build({
      url: url || this.constructor.DFEAULT.url,
      version: version || this.constructor.DEFAULT.version
    })
VoiceConnectionUDPClient = package\src\client\voice\VoiceUDPClient.js::program:VoiceConnectionUDPClient:<init>
VoiceServerUpdate = package\src\client\websocket\packets\handlers\VoiceServerUpdate.js::program:VoiceServerUpdate:<init>
this.message =
      error.message && flattened
        ? `${error.message}\n${flattened}`
        : error.message || flattened
WebSocketPacketManager = package\src\client\websocket\packets\WebSocketPacketManager.js::program:WebSocketPacketManager:<init>
SequentialRequestHandler = package\src\client\rest\RequestHandlers\Sequential.js::program:SequentialRequestHandler:<init>
permissions =
      typeof member === "object" && !(member instanceof Array)
        ? permissions
        : member
const WebSocket = (function findWebSocket() {
  if (browser) return window.WebSocket; // eslint-disable-line no-undef
  try {
    return require('@discordjs/uws');
  } catch (e) {
    return require('ws');
  }
}())
VoiceWebSocket = package\src\client\voice\VoiceWebSocket.js::program:VoiceWebSocket:<init>
Object.defineProperty(this, "_array", {
      value: null,
      writable: true,
      configurable: true
    })
messages[i] = channel._cacheMessage(
            new Message(channel, data[i], client)
          )
const startInd = route.includes("/channels/")
        ? route.indexOf("/channels/")
        : route.indexOf("/guilds/")
exports.fetch = engineOptions => {
  for (const encoder of list) {
    const fetched = fetch(encoder, engineOptions);
    if (fetched) return fetched;
  }

  throw new Error('Couldn\'t find an Opus engine.');
}
this.register(Constants.WSEvents.GUILD_UPDATE, require('./handlers/GuildUpdate'))
const Targets = {
  ALL: 'ALL',
  GUILD: 'GUILD',
  CHANNEL: 'CHANNEL',
  USER: 'USER',
  ROLE: 'ROLE',
  INVITE: 'INVITE',
  WEBHOOK: 'WEBHOOK',
  EMOJI: 'EMOJI',
  MESSAGE: 'MESSAGE',
}
handler.push({
        request: apiRequest,
        resolve,
        reject,
        retries: 0
      })
item.request.gen().end((err, res) => {
      if (res && res.headers) {
        this.limit = Number(res.headers["x-ratelimit-limit"]);
        this.resetTime = Number(res.headers["x-ratelimit-reset"]) * 1000;
        this.remaining = Number(res.headers["x-ratelimit-remaining"]);
        this.timeDifference = Date.now() - new Date(res.headers.date).getTime();
      }
      if (err) {
        if (err.status === 429) {
          this.queue.unshift(item);
          if (res.headers["x-ratelimit-global"]) this.globalLimit = true;
          if (this.resetTimeout) return;
          this.resetTimeout = this.client.setTimeout(() => {
            this.remaining = this.limit;
            this.globalLimit = false;
            this.handle();
            this.resetTimeout = null;
          }, Number(res.headers["retry-after"]) + this.client.options.restTimeOffset);
        } else if (err.status >= 500 && err.status < 600) {
          if (item.retries === this.client.options.retryLimit) {
          ...
new Promise((resolve, reject) => {
      const listener = message => {
        if (!message || message._sFetchProp !== prop) return;
        process.removeListener("message", listener);
        if (!message._error) resolve(message._result);
        else reject(Util.makeError(message._error));
      };
      process.on("message", listener);

      this.send({ _sFetchProp: prop }).catch(err => {
        process.removeListener("message", listener);
        reject(err);
      });
    })
new Promise((resolve, reject) => {
      if (!token) throw new Error("A token must be provided.");
      snekfetch
        .get(
          `${ConstantsHttp.host}/api/v${ConstantsHttp.version}${Constants.Endpoints.gateway.bot}`
        )
        .set("Authorization", `Bot ${token.replace(/^Bot\s*/i, "")}`)
        .end((err, res) => {
          if (err) reject(err);
          resolve(res.body.shards * (1000 / guildsPerShard));
        });
    })
snekfetch
        .get(
          `${ConstantsHttp.host}/api/v${ConstantsHttp.version}${Constants.Endpoints.gateway.bot}`
        )
        .set("Authorization", `Bot ${token.replace(/^Bot\s*/i, "")}`)
        .end((err, res) => {
          if (err) reject(err);
          resolve(res.body.shards * (1000 / guildsPerShard));
        })
const Actions = {
  ALL: null,
  GUILD_UPDATE: 1,
  CHANNEL_CREATE: 10,
  CHANNEL_UPDATE: 11,
  CHANNEL_DELETE: 12,
  CHANNEL_OVERWRITE_CREATE: 13,
  CHANNEL_OVERWRITE_UPDATE: 14,
  CHANNEL_OVERWRITE_DELETE: 15,
  MEMBER_KICK: 20,
  MEMBER_PRUNE: 21,
  MEMBER_BAN_ADD: 22,
  MEMBER_BAN_REMOVE: 23,
  MEMBER_UPDATE: 24,
  MEMBER_ROLE_UPDATE: 25,
  ROLE_CREATE: 30,
  ROLE_UPDATE: 31,
  ROLE_DELETE: 32,
  INVITE_CREATE: 40,
  INVITE_UPDATE: 41,
  INVITE_DELETE: 42,
  WEBHOOK_CREATE: 50,
  WEBHOOK_UPDATE: 51,
  WEBHOOK_DELETE: 52,
  EMOJI_CREATE: 60,
  EMOJI_UPDATE: 61,
  EMOJI_DELETE: 62,
  MESSAGE_DELETE: 72,
}
_tmp_12.d = {
          protocol: 'udp',
          data: {
            address: packet.address,
            port: packet.port,
            mode: 'xsalsa20_poly1305',
          },
        }
this.send({ _sEval: script }).catch(err => {
        process.removeListener("message", listener);
        reject(err);
      })
_tmp_13.data = {
            address: packet.address,
            port: packet.port,
            mode: 'xsalsa20_poly1305',
          }
dispatcher.once('end', () => this.unregisterDispatcher(dispatcher))
dispatcher.on('volumeChange', (o, n) => {
        this.unregisterDispatcher(dispatcher, o);
        if (!this._dispatchers.has(n)) {
          this._dispatchers.set(n, new Set());
          this._encoders.set(n, OpusEncoders.fetch());
        }
        this._dispatchers.get(n).add(dispatcher);
      })
setTimeout(
        () =>
          reject(
            new Error(
              `Shard ${this.id}'s Client took too long to become ready.`
            )
          ),
        30000
      )
new Promise((resolve, reject) => {
      if (this.ended) {
        reject(this.collected);
        return;
      }

      const cleanup = () => {
        this.removeListener('collect', onCollect);
        this.removeListener('end', onEnd);
      };

      const onCollect = item => {
        cleanup();
        resolve(item);
      };

      const onEnd = () => {
        cleanup();
        reject(this.collected); // eslint-disable-line prefer-promise-reject-errors
      };

      this.on('collect', onCollect);
      this.on('end', onEnd);
    })
content = Util.escapeMarkdown(
            this.client.resolver.resolveString(content),
            true
          )
transcoder.on('error', e => {
      this.destroyCurrentStream();
      if (this.listenerCount('error') > 0) this.emit('error', e);
      this.emit('warn', `prism transcoder error - ${e}`);
    })
function parseLocalPacket = function parseLocalPacket(message) {
  try {
    const packet = Buffer.from(message);
    let address = '';
    for (let i = 4; i < packet.indexOf(0, i); i++) address += String.fromCharCode(packet[i]);
    const port = parseInt(packet.readUIntLE(packet.length - 2, 2).toString(10), 10);
    return { address, port };
  } catch (error) {
    return { error };
  }
}
this.mentions = new Mentions(
      this,
      'mentions' in data ? data.mentions : this.mentions.users,
      'mentions_roles' in data ? data.mentions_roles : this.mentions.roles,
      'mention_everyone' in data ? data.mention_everyone : this.mentions.everyone
    )
const listener = message => {
        if (!message || message._eval !== script) return;
        this.process.removeListener("message", listener);
        this._evals.delete(script);
        if (!message._error) resolve(message._result);
        else reject(Util.makeError(message._error));
      }
channel._typing.has(this.id) ? channel._typing.get(this.id).elapsedTime : -1
this.opusEncoders.set(user.id, OpusEncoders.fetch())
_tmp_46 = VoiceReceiver._tryDecode(this.opusEncoders.get(user.id), data)
this.fetchMessages({ limit: 1, around: messageID }).then(messages => {
        const msg = messages.get(messageID);
        if (!msg) throw new Error('Message not found.');
        return msg;
      })
this.ws.connection ? this.ws.connection.status : Constants.Status.IDLE
this.sendBuffer(null, data.sequence, data.timestamp, packet)
(_tmp_14 = [
      Actions.CHANNEL_DELETE,
      Actions.CHANNEL_OVERWRITE_DELETE,
      Actions.MEMBER_KICK,
      Actions.MEMBER_PRUNE,
      Actions.MEMBER_BAN_ADD,
      Actions.ROLE_DELETE,
      Actions.INVITE_DELETE,
      Actions.WEBHOOK_DELETE,
      Actions.EMOJI_DELETE,
      Actions.MESSAGE_DELETE,
    ]).includes
_tmp_7.OAUTH2 = {
    Application: appID => {
      const base = `/oauth2/applications/${appID}`;
      return {
        toString: () => base,
        resetSecret: `${base}/reset`,
        resetToken: `${base}/bot/reset`
      };
    },
    App: appID => `/oauth2/authorize?client_id=${appID}`
  }
this.content
      .replace(/@(everyone|here)/g, '@\u200b$1')
      .replace(/<@!?[0-9]+>/g, input => {
        const id = input.replace(/<|!|>|@/g, '');
        if (this.channel.type === 'dm' || this.channel.type === 'group') {
          return this.client.users.has(id) ? `@${this.client.users.get(id).username}` : input;
        }

        const member = this.channel.guild.members.get(id);
        if (member) {
          if (member.nickname) return `@${member.nickname}`;
          return `@${member.user.username}`;
        } else {
          const user = this.client.users.get(id);
          if (user) return `@${user.username}`;
          return input;
        }
      })
      .replace(/<#[0-9]+>/g, input => {
        const channel = this.client.channels.get(input.replace(/<|#|>/g, ''));
        if (channel) return `#${channel.name}`;
        return input;
      })
      .replace(/<@&[0-9]+>/g, input => {
        if (this.channel.type === 'dm' || this.channel.type === 'group') retur...
this.client.rest.methods.getChannelMessages(this, options).then(data => {
      const messages = new Collection();
      for (const message of data) {
        const msg = new Message(this, message, this.client);
        messages.set(message.id, msg);
        this._cacheMessage(msg);
      }
      return messages;
    })
this.client.resolver.resolveFile(file.attachment).then(resource => {
            file.file = resource;
            return file;
          })
this.rest
      .makeRequest("delete", Endpoints.Message(message), true)
      .then(
        () =>
          this.client.actions.MessageDelete.handle({
            id: message.id,
            channel_id: message.channel.id
          }).message
      )
this.sendPacket({ op: Constants.VoiceOPCodes.HEARTBEAT, d: null }).catch(() => {
      this.emit('warn', 'Tried to send heartbeat, but connection is not open');
      this.clearHeartbeat();
    })
other.id === this.id &&
        other.name === this.name &&
        other.managed === this.managed &&
        other.requiresColons === this.requiresColons
TextBasedChannel.applyToClass(GroupDMChannel, true, ['bulkDelete'])
MessageEmbedProvider = package\src\structures\MessageEmbed.js::program:MessageEmbedProvider:<init>
this.fields.length >= 1 ? this.fields.reduce((prev, curr) =>
        prev + curr.name.length + curr.value.length, 0) : 0
this.manager
          .fetchClientValues(message._sFetchProp)
          .then(
            results =>
              this.send({ _sFetchProp: message._sFetchProp, _result: results }),
            err =>
              this.send({
                _sFetchProp: message._sFetchProp,
                _error: Util.makePlainError(err)
              })
          )
const channel = this.client.channels.get(input.replace(/<|#|>/g, ''))
payload.deny &= ~(Permissions.FLAGS[perm] || 0)
snekfetch.get(resource).then(res => res.body instanceof Buffer ? res.body : Buffer.from(res.text))
Permissions.FLAGS = {
  CREATE_INSTANT_INVITE: 1 << 0,
  KICK_MEMBERS: 1 << 1,
  BAN_MEMBERS: 1 << 2,
  ADMINISTRATOR: 1 << 3,
  MANAGE_CHANNELS: 1 << 4,
  MANAGE_GUILD: 1 << 5,
  ADD_REACTIONS: 1 << 6,
  VIEW_AUDIT_LOG: 1 << 7,
  PRIORITY_SPEAKER: 1 << 8,

  VIEW_CHANNEL: 1 << 10,
  READ_MESSAGES: 1 << 10,
  SEND_MESSAGES: 1 << 11,
  SEND_TTS_MESSAGES: 1 << 12,
  MANAGE_MESSAGES: 1 << 13,
  EMBED_LINKS: 1 << 14,
  ATTACH_FILES: 1 << 15,
  READ_MESSAGE_HISTORY: 1 << 16,
  MENTION_EVERYONE: 1 << 17,
  EXTERNAL_EMOJIS: 1 << 18,
  USE_EXTERNAL_EMOJIS: 1 << 18,

  CONNECT: 1 << 20,
  SPEAK: 1 << 21,
  MUTE_MEMBERS: 1 << 22,
  DEAFEN_MEMBERS: 1 << 23,
  MOVE_MEMBERS: 1 << 24,
  USE_VAD: 1 << 25,

  CHANGE_NICKNAME: 1 << 26,
  MANAGE_NICKNAMES: 1 << 27,
  MANAGE_ROLES: 1 << 28,
  MANAGE_ROLES_OR_PERMISSIONS: 1 << 28,
  MANAGE_WEBHOOKS: 1 << 29,
  MANAGE_EMOJIS: 1 << 30
}
this.send({
                _sFetchProp: message._sFetchProp,
                _error: Util.makePlainError(err)
              })
fs.stat(file, (err, stats) => {
          if (err) return reject(err);
          if (!stats || !stats.isFile()) return reject(new Error(`The file could not be found: ${file}`));
          fs.readFile(file, (err2, data) => {
            if (err2) reject(err2);
            else resolve(data);
          });
          return null;
        })
_iterator_1 = <operator>.iterator(roles.values())
const messages = body.messages.map(x =>
          x.map(
            m =>
              new Message(
                this.client.channels.get(m.channel_id),
                m,
                this.client
              )
          )
        )
x.map(
            m =>
              new Message(
                this.client.channels.get(m.channel_id),
                m,
                this.client
              )
          )
_iterator_4 = <operator>.iterator(this.channels.values())
new Message(
                this.client.channels.get(m.channel_id),
                m,
                this.client
              )
this.client.rest.methods.createChannelInvite(this, options, reason)
!this.find((value, key) => {
      const testVal = collection.get(key);
      return (
        testVal !== value || (testVal === undefined && !collection.has(key))
      );
    })
throw new TypeError('The messages must be an Array, Collection, or number.');
!options
testVal !== value || (testVal === undefined && !collection.has(key))
this.rest
        .makeRequest("post", Endpoints.guilds, true, options)
        .then(data => {
          if (this.client.guilds.has(data.id))
            return resolve(this.client.guilds.get(data.id));

          const handleGuild = guild => {
            if (guild.id === data.id) {
              this.client.removeListener(
                Constants.Events.GUILD_CREATE,
                handleGuild
              );
              this.client.clearTimeout(timeout);
              resolve(guild);
            }
          };
          this.client.on(Constants.Events.GUILD_CREATE, handleGuild);

          const timeout = this.client.setTimeout(() => {
            this.client.removeListener(
              Constants.Events.GUILD_CREATE,
              handleGuild
            );
            reject(new Error("Took too long to receive guild data."));
          }, 10000);
          return undefined;
        }, reject)
process.emitWarning(
      "Collection#findKey: pass a function instead",
      "DeprecationWarning"
    )
(_tmp_134 = this.client.guilds).has
this.client.rest.methods.kickGuildMember(this.guild, this, reason)
const voiceState = this._rawVoiceStates.get(member.user.id)
this.client.channels.has(voiceState.channel_id)
this.client.channels.get(voiceState.channel_id).members.set(member.user.id, member)
data.map(
          m =>
            new Message(this.client.channels.get(m.channel_id), m, this.client)
        )
m =>
            new Message(this.client.channels.get(m.channel_id), m, this.client)
new Message(this.client.channels.get(m.channel_id), m, this.client)
_tmp_161.get = util.deprecate(function defaultChannel() {
    return this.channels.get(this.id);
  }, 'Guild#defaultChannel: This property is obsolete, will be removed in v12.0.0, and may not function as expected.')
(_tmp_162 = this.channels).get
