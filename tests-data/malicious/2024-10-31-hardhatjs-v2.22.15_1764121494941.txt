await this._mutex.use(async () => {
      const isCompilerDownloaded = await this.isCompilerDownloaded(version);

      if (isCompilerDownloaded === true) {
        return;
      }

      await downloadStartedCb(isCompilerDownloaded);

      let build = await this._getCompilerBuild(version);

      if (build === undefined && (await this._shouldDownloadCompilerList())) {
        try {
          await this._downloadCompilerList();
        } catch (e: any) {
          throw new HardhatError(
            ERRORS.SOLC.VERSION_LIST_DOWNLOAD_FAILED,
            {},
            e
          );
        }

        build = await this._getCompilerBuild(version);
      }

      if (build === undefined) {
        throw new HardhatError(ERRORS.SOLC.INVALID_VERSION, { version });
      }

      let downloadPath: string;
      try {
        downloadPath = await this._downloadCompiler(build);
      } catch (e: any) {
        throw new HardhatError(
          ERRORS.SOLC.DOWNLOAD_FAILED,
          {
   ...
(0, config_env_1.subtask)(task_names_1.TASK_COMPILE_SOLIDITY_GET_COMPILATION_JOB_FOR_FILE)
    .addParam("dependencyGraph", undefined, undefined, config_env_1.types.any)
    .addParam("file", undefined, undefined, config_env_1.types.any)
    .addOptionalParam("solidityFilesCache", undefined, undefined, config_env_1.types.any)
    .setAction(async ({ dependencyGraph, file, }, { config }) => {
    return (0, compilation_job_1.createCompilationJobFromFile)(dependencyGraph, file, config.solidity);
})
function printAlreadySetKeys = function printAlreadySetKeys(varsManagerSetup) {
    const requiredKeysAlreadySet = varsManagerSetup.getRequiredVarsAlreadySet();
    const optionalKeysAlreadySet = varsManagerSetup.getOptionalVarsAlreadySet();
    const envVars = varsManagerSetup.getEnvVars();
    if (requiredKeysAlreadySet.length === 0 &&
        optionalKeysAlreadySet.length === 0 &&
        envVars.length === 0) {
        return;
    }
    console.log(`${chalk_1.default.bold(`${(0, emoji_1.emoji)("✔️  ")}Configuration variables already set:`)}`);
    console.log();
    if (requiredKeysAlreadySet.length > 0) {
        console.log("  Mandatory:");
        console.log(requiredKeysAlreadySet.map((x) => `    ${x}`).join("\n"));
        console.log();
    }
    if (optionalKeysAlreadySet.length > 0) {
        console.log("  Optional:");
        console.log(optionalKeysAlreadySet.map((x) => `    ${x}`).join("\n"));
        console.log();
    }
    if (envVars.length > 0) {
        console.log("  Set via environment var...
function edrTracingMessageResultToMinimalEVMResult = function edrTracingMessageResultToMinimalEVMResult(tracingMessageResult) {
    const { result, contractAddress } = tracingMessageResult.executionResult;
    // only SuccessResult has logs
    const success = "logs" in result;
    const minimalEVMResult = {
        execResult: {
            executionGasUsed: result.gasUsed,
            success,
        },
    };
    // only success and exceptional halt have reason
    if ("reason" in result) {
        minimalEVMResult.execResult.reason = result.reason;
    }
    if ("output" in result) {
        const { output } = result;
        if (Buffer.isBuffer(output)) {
            minimalEVMResult.execResult.output = output;
        }
        else {
            minimalEVMResult.execResult.output = output.returnValue;
        }
    }
    if (contractAddress !== undefined) {
        minimalEVMResult.execResult.contractAddress = new ethereumjs_util_1.Address(contractAddress);
    }
    return minimalEVMResult;
}
exports.float = {
    name: "float",
    parse: (argName, strValue) => {
        const decimalPattern = /^(?:\d+(?:\.\d*)?|\.\d+)(?:[eE]\d+)?$/;
        const hexPattern = /^0[xX][\dABCDEabcde]+$/;
        if (strValue.match(decimalPattern) === null &&
            strValue.match(hexPattern) === null) {
            throw new errors_1.HardhatError(errors_list_1.ERRORS.ARGUMENTS.INVALID_VALUE_FOR_TYPE, {
                value: strValue,
                name: argName,
                type: exports.float.name,
            });
        }
        return Number(strValue);
    },
    /**
     * Check if argument value is of type "float".
     * Both decimal and integer number values are valid.
     *
     * @param argName {string} argument's name - used for context in case of error.
     * @param value {any} argument's value to validate.
     *
     * @throws HH301 if value is not of type "number"
     */
    validate: (argName, value) => {
        const isFloatOrInteger = typeof value === "n...
assertHardhatInvariant(
        scopeDefinition !== undefined,
        "It shouldn't be possible to create a task in a scope that doesn't exist"
      )
function includesOwnPackageName = async function includesOwnPackageName(
  sourceName: string
): Promise<boolean> {
  const packageName = await getPackageName(sourceName);
  if (packageName !== "") {
    return sourceName.startsWith(`${packageName}/`);
  }
  return false;
}
function arePreviousMtimesCorrect = function arePreviousMtimesCorrect(mtimes) {
    try {
        return Object.entries(mtimes).every(([file, mtime]) => fs.statSync(file).mtime.valueOf() === mtime);
    }
    catch {
        return false;
    }
}
function isHdAccountsConfig = function isHdAccountsConfig(
  accounts: HttpNetworkAccountsUserConfig
): accounts is HDAccountsUserConfig {
  return typeof accounts === "object" && !Array.isArray(accounts);
}
function resolveCompiler = function resolveCompiler(compiler) {
    const resolved = {
        version: compiler.version,
        settings: compiler.settings ?? {},
    };
    if (semver_1.default.gte(resolved.version, "0.8.20")) {
        resolved.settings.evmVersion = compiler.settings?.evmVersion ?? "paris";
    }
    resolved.settings.optimizer = {
        enabled: false,
        runs: 200,
        ...resolved.settings.optimizer,
    };
    if (resolved.settings.outputSelection === undefined) {
        resolved.settings.outputSelection = {};
    }
    for (const [file, contractSelection] of Object.entries(default_config_1.defaultSolcOutputSelection)) {
        if (resolved.settings.outputSelection[file] === undefined) {
            resolved.settings.outputSelection[file] = {};
        }
        for (const [contract, outputs] of Object.entries(contractSelection)) {
            if (resolved.settings.outputSelection[file][contract] === undefined) {
                resolved.settings.outputSelection[file][cont...
