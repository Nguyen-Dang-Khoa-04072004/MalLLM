// File: tmp/tmphgan29bg/grpc-js-repository/package/index.js
// ======================================================================
Line 29: _tmp_50.push("double")
Line 30: _tmp_50.push("sfixed64")
Line 31: _tmp_50.push("string")
Line 59: GRPC_NAME_REGEX.test(value)
Line 75: SEMVER_REGEX.test(value)
Line 137: {
        const arrCopy = [];
        for (let i = 0; i < obj.length; i++) {
            arrCopy[i] = _cloneDeep(obj[i]); // Recursive call
        }
        return arrCopy;
    }
Line 138: const arrCopy = []
Line 139: {
            arrCopy[i] = _cloneDeep(obj[i]); // Recursive call
        }
Line 140: arrCopy[i] = _cloneDeep(obj[i])
Line 147: _iterator_0.next()
Line 149: {
            objCopy[key] = _cloneDeep(obj[key]); // Recursive call
        }
Line 150: objCopy[key] = _cloneDeep(obj[key])
Line 173: {
         const partA = partsA[i] || 0; // Treat missing parts as 0
         const partB = partsB[i] || 0; // Treat missing parts as 0

         if (partA < partB) {
             return -1;
         }
         if (partA > partB) {
             return 1;
         }
     }
Line 174: const partA = partsA[i] || 0
Line 175: const partB = partsB[i] || 0
Line 195: {
    _isPlainObject(field, `field definition in message "${messageName}"`);

    // Validate required properties
    const requiredProps = ['name', 'type', 'number'];
    for (const prop of requiredProps) {
        if (!Object.prototype.hasOwnProperty.call(field, prop)) {
            throw new Error(`Field in message "${messageName}" is missing required property "${prop}".`);
        }
    }

    // Validate 'name'
    _isValidGrpcName(field.name, `field name in message "${messageName}"`);

    // Validate 'type'
    _isNonEmptyString(field.type, `field type "${field.name}" in message "${messageName}"`);
    const fieldType = field.type;
    // Check if it's a scalar type or a defined message type
    if (!SCALAR_TYPES.has(fieldType) && !definedMessageTypes.has(fieldType)) {
        throw new Error(`Field type "${fieldType}" for field "${field.name}" in message "${messageName}" is neither a scalar type nor a defined message type within this definition.`);
    }

    // Validate 'nu...
Line 199: const requiredProps = ['name', 'type', 'number']
Line 200: _iterator_1 = <operator>.iterator(requiredProps)
Line 201: Object.prototype.hasOwnProperty.call(field, prop)
Line 225: Object.prototype.hasOwnProperty.call(field, 'repeated')
Line 245: Object.prototype.hasOwnProperty.call(messageDefinition, 'fields')
Line 256: {
        const field = fields[i];
        try {
            _validateField(field, messageName, definedMessageTypes);

            // Check for duplicate field numbers or names within this message
            if (fieldNumbers.has(field.number)) {
                throw new Error(`Duplicate field number ${field.number} found for field "${field.name}" in message "${messageName}".`);
            }
            fieldNumbers.add(field.number);

            if (fieldNames.has(field.name)) {
                 throw new Error(`Duplicate field name "${field.name}" found in message "${messageName}".`);
            }
            fieldNames.add(field.name);

        } catch (error) {
            // Re-throw with more context
            throw new Error(`Invalid field definition at index ${i} in message "${messageName}": ${error.message}`);
        }
    }
Line 257: const field = fields[i]
Line 291: Object.keys(messages)
Line 299: _iterator_2.next()
Line 300: {
            _isValidGrpcName(messageName, `message name "${messageName}"`);
            const messageDefinition = messages[messageName];
            _validateMessageType(messageName, messageDefinition, definedMessageTypes);
        }
Line 302: const messageDefinition = messages[messageName]
Line 318: {
    _isPlainObject(method, `method definition in service "${serviceName}"`);

    // Validate required properties
    const requiredProps = ['name', 'requestType', 'responseType'];
    for (const prop of requiredProps) {
        if (!Object.prototype.hasOwnProperty.call(method, prop)) {
            throw new Error(`Method in service "${serviceName}" is missing required property "${prop}".`);
        }
    }

    // Validate 'name'
    _isValidGrpcName(method.name, `method name in service "${serviceName}"`);

    // Validate 'requestType' and 'responseType'
    const requestType = method.requestType;
    const responseType = method.responseType;

    _isNonEmptyString(requestType, `requestType for method "${method.name}" in service "${serviceName}"`);
    _isNonEmptyString(responseType, `responseType for method "${method.name}" in service "${serviceName}"`);

    // Check if request/response types are defined messages or scalar types
    if (!SCALAR_TYPES.has(requestType) && !defin...
Line 322: const requiredProps = ['name', 'requestType', 'responseType']
Line 323: _iterator_3 = <operator>.iterator(requiredProps)
Line 324: Object.prototype.hasOwnProperty.call(method, prop)
Line 348: Object.prototype.hasOwnProperty.call(method, 'requestStream')
Line 353: Object.prototype.hasOwnProperty.call(method, 'responseStream')
Line 367: {
    _isPlainObject(service, 'service section');

    // Validate required properties
     const requiredProps = ['name', 'methods'];
     for (const prop of requiredProps) {
         if (!Object.prototype.hasOwnProperty.call(service, prop)) {
             throw new Error(`Service section is missing required property "${prop}".`);
         }
     }

    // Validate 'name'
    _isValidGrpcName(service.name, 'service name');

    // Validate 'methods' property
    const methods = service.methods;
    _isArray(methods, `methods property in service "${service.name}"`);

    const methodNames = new Set();
    for (let i = 0; i < methods.length; i++) {
        const method = methods[i];
        try {
            _validateMethod(method, service.name, definedMessageTypes);
            // Check for duplicate method names within this service
            if (methodNames.has(method.name)) {
                 throw new Error(`Duplicate method name "${method.name}" found in service "${service.nam...
Line 371: const requiredProps = ['name', 'methods']
Line 372: _iterator_4 = <operator>.iterator(requiredProps)
Line 373: Object.prototype.hasOwnProperty.call(service, prop)
Line 386: {
        const method = methods[i];
        try {
            _validateMethod(method, service.name, definedMessageTypes);
            // Check for duplicate method names within this service
            if (methodNames.has(method.name)) {
                 throw new Error(`Duplicate method name "${method.name}" found in service "${service.name}".`);
            }
            methodNames.add(method.name);
        } catch (error) {
            // Re-throw with more context
            throw new Error(`Invalid method definition at index ${i} in service "${service.name}": ${error.message}`);
        }
    }
Line 387: const method = methods[i]
Line 409: {
    _isPlainObject(definition, 'definition object');

    // Validate required top-level properties
    const requiredProps = ['service', 'messages'];
    for (const prop of requiredProps) {
        if (!Object.prototype.hasOwnProperty.call(definition, prop)) {
            throw new Error(`Definition object is missing required top-level property "${prop}".`);
        }
    }

    // First, validate messages to get the set of defined types,
    // which is needed for validating service method types.
    _validateMessagesStructure(definition.messages);
    const definedMessageTypes = new Set(Object.keys(definition.messages));

    // Now validate the service structure using the defined message types.
    _validateServiceStructure(definition.service, definedMessageTypes);

    // Add validation for other potential top-level properties (e.g., 'enums', 'options', 'package')
    // if they were part of the expected structure.
}
Line 413: const requiredProps = ['service', 'messages']
Line 414: _iterator_5 = <operator>.iterator(requiredProps)
Line 415: Object.prototype.hasOwnProperty.call(definition, prop)
Line 423: Object.keys(definition.messages)
Line 458: _iterator_6.next()
Line 460: {
                    const versions = initialData[serviceName];
                    _isPlainObject(versions, `initialData['${serviceName}']`);

                    for (const version in versions) {
                        if (Object.prototype.hasOwnProperty.call(versions, version)) {
                            const definition = versions[version];
                            try {
                                // Use the public addDefinition method to ensure validation is applied
                                this.addDefinition(serviceName, version, definition);
                            } catch (error) {
                                // If initial data is invalid, decide whether to throw or warn.
                                // Throwing makes the constructor fail if initial data is bad.
                                // Warning allows partial loading but might hide issues.
                                // Let's throw for strictness.
                                t...
Line 461: const versions = initialData[serviceName]
Line 462: _isPlainObject(versions, `initialData['${serviceName}']`)
Line 464: _iterator_7.next()
Line 465: {
                            const definition = versions[version];
                            try {
                                // Use the public addDefinition method to ensure validation is applied
                                this.addDefinition(serviceName, version, definition);
                            } catch (error) {
                                // If initial data is invalid, decide whether to throw or warn.
                                // Throwing makes the constructor fail if initial data is bad.
                                // Warning allows partial loading but might hide issues.
                                // Let's throw for strictness.
                                throw new Error(`Failed to load initial definition for service "${serviceName}" version "${version}": ${error.message}`);
                            }
                        }
Line 466: const definition = versions[version]
Line 545: {
        _isValidGrpcName(name, 'service name');

        const serviceVersions = this._definitions.get(name);
        if (!serviceVersions || serviceVersions.size === 0) {
            return undefined;
        }

        const versions = Array.from(serviceVersions.keys());
        if (versions.length === 0) {
            return undefined; // Should not happen if serviceVersions is not empty, but for safety
        }

        // Find the latest version string
        let latestVersion = versions[0];
        for (let i = 1; i < versions.length; i++) {
            if (_compareVersions(versions[i], latestVersion) > 0) {
                latestVersion = versions[i];
            }
        }

        // Retrieve and return the definition for the latest version
        return this.getDefinition(name, latestVersion);
    }
Line 553: Array.from(serviceVersions.keys())
Line 559: let latestVersion = versions[0]
Line 561: {
                latestVersion = versions[i];
            }
Line 562: latestVersion = versions[i]
Line 642: Array.from(this._definitions.keys())
Line 660: Array.from(serviceVersions.keys())
Line 662: versions.sort(_compareVersions)
Line 684: _iterator_8.next()
Line 696: {
        const allDefs = [];
        for (const [serviceName, versionsMap] of this._definitions.entries()) {
            for (const [version, definition] of versionsMap.entries()) {
                allDefs.push({
                    name: serviceName,
                    version: version,
                    definition: _cloneDeep(definition) // Return a deep copy
                });
            }
        }
        return allDefs;
    }
Line 697: const allDefs = []
Line 698: _iterator_9.next()
Line 699: _iterator_10.next()
Line 700: allDefs.push({
                    name: serviceName,
                    version: version,
                    definition: _cloneDeep(definition) // Return a deep copy
                })
Line 721: {
         _isNonEmptyString(query, 'search query');
         const lowerQuery = query.toLowerCase();
         const results = [];

         for (const [serviceName, versionsMap] of this._definitions.entries()) {
             const lowerServiceName = serviceName.toLowerCase();

             for (const [version, definition] of versionsMap.entries()) {
                 // Search in Service Name
                 if (lowerServiceName.includes(lowerQuery)) {
                      results.push({
                         name: serviceName,
                         version: version,
                         match: 'service',
                         detail: `Service name "${serviceName}"`
                      });
                 }

                 // Search in Service Methods
                 if (definition.service && Array.isArray(definition.service.methods)) {
                     for (const method of definition.service.methods) {
                         if (method.name && typeof meth...
Line 724: const results = []
Line 726: _iterator_11.next()
Line 729: _iterator_12.next()
Line 731: lowerServiceName.includes(lowerQuery)
Line 732: results.push({
                         name: serviceName,
                         version: version,
                         match: 'service',
                         detail: `Service name "${serviceName}"`
                      })
Line 742: _iterator_13.next()
Line 743: method.name.toLowerCase().includes(lowerQuery)
Line 744: results.push({
                                 name: serviceName,
                                 version: version,
                                 match: 'method',
                                 detail: `Method "${method.name}" in service "${serviceName}"`
                             })
Line 752: method.requestType.toLowerCase().includes(lowerQuery)
Line 753: results.push({
                                  name: serviceName,
                                  version: version,
                                  match: 'method_request_type',
                                  detail: `Request type "${method.requestType}" for method "${method.name}" in service "${serviceName}"`
                              })
Line 760: method.responseType.toLowerCase().includes(lowerQuery)
Line 761: results.push({
                                  name: serviceName,
                                  version: version,
                                  match: 'method_response_type',
                                  detail: `Response type "${method.responseType}" for method "${method.name}" in service "${serviceName}"`
                              })
Line 773: _iterator_14.next()
Line 774: {
                             const lowerMessageName = messageName.toLowerCase();
                             const message = definition.messages[messageName];

                             // Search in Message Name
                             if (lowerMessageName.includes(lowerQuery)) {
                                 results.push({
                                     name: serviceName,
                                     version: version,
                                     match: 'message',
                                     detail: `Message name "${messageName}"`
                                 });
                             }

                             // Search in Message Fields
                             if (message && Array.isArray(message.fields)) {
                                 for (const field of message.fields) {
                                     if (field.name && typeof field.name === 'string' && field.name.toLowerCase().includes(lowerQuery)) {
  ...
Line 776: const message = definition.messages[messageName]
Line 779: lowerMessageName.includes(lowerQuery)
Line 780: results.push({
                                     name: serviceName,
                                     version: version,
                                     match: 'message',
                                     detail: `Message name "${messageName}"`
                                 })
Line 790: _iterator_15.next()
Line 791: field.name.toLowerCase().includes(lowerQuery)
Line 792: results.push({
                                             name: serviceName,
                                             version: version,
                                             match: 'field',
                                             detail: `Field "${field.name}" in message "${messageName}"`
                                         })
Line 800: field.type.toLowerCase().includes(lowerQuery)
Line 801: results.push({
                                              name: serviceName,
                                              version: version,
                                              match: 'field_type',
                                              detail: `Field type "${field.type}" for field "${field.name}" in message "${messageName}"`
                                          })
Line 818: const uniqueResults = Array.from(new Set(results.map(JSON.stringify))).map(JSON.parse)
Line 837: _iterator_16.next()
Line 858: for (const [serviceName, versionsMap] of this._definitions.entries()) {
            obj[serviceName] = {};
             for (const [version, definition] of versionsMap.entries()) {
                obj[serviceName][version] = _cloneDeep(definition); // Include deep copy
             }
        }
Line 859: obj[serviceName] = {}
Line 860: for (const [version, definition] of versionsMap.entries()) {
                obj[serviceName][version] = _cloneDeep(definition); // Include deep copy
             }
Line 861: obj[serviceName][version] = _cloneDeep(definition)
Line 942: /^[a-zA-Z0-9_\-\/.]+$/.test(value)
Line 946: value.includes('//')
