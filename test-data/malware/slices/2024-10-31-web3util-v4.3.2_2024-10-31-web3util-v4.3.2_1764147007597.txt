__awaiter(this, void 0, void 0, function* () {
            const data = yield this.request(toPayload({
                method: 'eth_chainId',
                params: [],
            }));
            return (_a = data === null || data === void 0 ? void 0 : data.result) !== null && _a !== void 0 ? _a : '';
        })
const findSchemaByDataPath = (schema, dataPath, oneOfPath = []) => {
    let result = Object.assign({}, schema);
    let previousDataPath;
    for (const dataPart of dataPath) {
        if (result.oneOf && previousDataPath) {
            const currentDataPath = previousDataPath;
            const path = oneOfPath.find(([key]) => key === currentDataPath);
            if (path && path[0] === previousDataPath) {
                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access
                result = result.oneOf[path[1]];
            }
        }
        if (!result.properties && !result.items) {
            return undefined;
        }
        if (result.properties) {
            result = result.properties[dataPart];
        }
        else if (result.items && result.items.properties) {
            const node = result.items.properties;
            result = node[dataPart];
        }
        else if (result.items && (0, web3_validat...
__awaiter(this, void 0, void 0, function* () {
        let timeoutId;
        const result = yield Promise.race([
            awaitable instanceof Promise ? awaitable : awaitable(),
            new Promise((resolve, reject) => {
                timeoutId = setTimeout(() => (error ? reject(error) : resolve(undefined)), timeout);
            }),
        ]);
        if (timeoutId) {
            clearTimeout(timeoutId);
        }
        if (result instanceof Error) {
            throw result;
        }
        return result;
    })
const isResponseWithNotification = (response) => !Array.isArray(response) &&
    !!response &&
    response.jsonrpc === '2.0' &&
    !(0, web3_validator_1.isNullish)(response.params) &&
    !(0, web3_validator_1.isNullish)(response.method)
const thUnitMap = {
	noether: BigInt(0),
	wei: BigInt(1),
	kwei: BigInt(1000),
	Kwei: BigInt(1000),
	babbage: BigInt(1000),
	femtoether: BigInt(1000),
	mwei: BigInt(1000000),
	Mwei: BigInt(1000000),
	lovelace: BigInt(1000000),
	picoether: BigInt(1000000),
	gwei: BigInt(1000000000),
	Gwei: BigInt(1000000000),
	shannon: BigInt(1000000000),
	nanoether: BigInt(1000000000),
	nano: BigInt(1000000000),
	szabo: BigInt(1000000000000),
	microether: BigInt(1000000000000),
	micro: BigInt(1000000000000),
	finney: BigInt(1000000000000000),
	milliether: BigInt(1000000000000000),
	milli: BigInt(1000000000000000),
	ether: BigInt('1000000000000000000'),
	kether: BigInt('1000000000000000000000'),
	grand: BigInt('1000000000000000000000'),
	mether: BigInt('1000000000000000000000000'),
	gether: BigInt('1000000000000000000000000000'),
	tether: BigInt('1000000000000000000000000000000'),
};
_tmp_0.push(new Promise((resolve, reject) => {
                timeoutId = setTimeout(() => (error ? reject(error) : resolve(undefined)), timeout);
            }))
function waitWithTimeout2 = async function waitWithTimeout<T>(
	awaitable: Promise<T> | AsyncFunction<T>,
	timeout: number,
	error?: Error,
): Promise<T | undefined> {
	let timeoutId: Timeout | undefined;
	const result = await Promise.race([
		awaitable instanceof Promise ? awaitable : awaitable(),
		new Promise<undefined | Error>((resolve, reject) => {
			timeoutId = setTimeout(() => (error ? reject(error) : resolve(undefined)), timeout);
		}),
	]);
	if (timeoutId) {
		clearTimeout(timeoutId);
	}
	if (result instanceof Error) {
		throw result;
	}
	return result;
}
dechunkedData.forEach(_chunkData => {
			// prepend the last chunk
			let chunkData = _chunkData;
			if (this.lastChunk) {
				chunkData = this.lastChunk + chunkData;
			}

			let result;

			try {
				result = JSON.parse(chunkData) as unknown as JsonRpcResponse;
			} catch (e) {
				this.lastChunk = chunkData;

				// start timeout to cancel all requests
				if (this.lastChunkTimeout) {
					clearTimeout(this.lastChunkTimeout);
				}

				this.lastChunkTimeout = setTimeout(() => {
					if (this.autoReconnect) return;
					this.clearQueues();
					this.eventEmitter.emit(
						'error',
						new InvalidResponseError({
							id: 1,
							jsonrpc: '2.0',
							error: { code: 2, message: 'Chunk timeout' },
						}),
					);
				}, this.chunkTimeout);
				return;
			}

			// cancel timeout and set chunk to null
			clearTimeout(this.lastChunkTimeout);
			this.lastChunk = undefined;

			if (result) returnValues.push(result);
		})
