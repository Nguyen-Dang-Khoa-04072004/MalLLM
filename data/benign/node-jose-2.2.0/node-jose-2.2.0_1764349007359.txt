sigList = sigList.map(function(s) {
        var header = clone(s.header || {});
        var protect = s.protected ?
                      JSON.parse(base64url.decode(s.protected, "utf8")) :
                      {};
        header = merge(header, protect);
        var signature = base64url.decode(s.signature);

        // process allowed algorithims
        if (!algSpec.match(header.alg)) {
          return Promise.reject(new Error("Algorithm not allowed: " + header.alg));
        }

        // process "crit" first
        var crit = protect.crit;
        if (crit) {
          if (!Array.isArray(crit)) {
            return Promise.reject(new Error("Invalid 'crit' header"));
          }
          for (var idx = 0; crit.length > idx; idx++) {
            if (-1 === handlerKeys.indexOf(crit[idx])) {
              return Promise.reject(new Error(
                  "Critical extension is not supported: " + crit[idx]
              ));
            }
          }
        }
        protect = ...
var webcrypto = function(key, props) {
    key = key || {};
    props = props || {};

    var keyLen = props.length || 0,
        algParams = merge(clone(alg), {
          namedCurve: key.crv
        });

    // assume {key} is privateKey
    if (!keyLen) {
      // calculate key length from private key size
      keyLen = key.d.length;
    }
    var privKey = ecUtil.convertToJWK(key, false);
    privKey = helpers.subtleCrypto.importKey("jwk",
                                             privKey,
                                             algParams,
                                             false,
                                             [ "deriveBits" ]);

    // assume {props.public} is publicKey
    var pubKey = validatePublic(props.public, "jwk");
    pubKey = pubKey.then(function(pubKey) {
      // {pubKey} is "jwk"
      return helpers.subtleCrypto.importKey("jwk",
                                            pubKey,
                                            algParams,
 ...
promise = promise.then(function(pdata) {
      var name = "AES-" + size + "-CBC";
      var cipher = helpers.nodeCrypto.createCipheriv(name, encKey, iv);
      var cdata = Buffer.concat([
        cipher.update(pdata),
        cipher.final()
      ]);
      return cdata;
    })
Promise.reject(new Error("Algorithm not allowed: " + header.alg))
promise = promise.then(function(rcptList) {
        if (input.protected) {
          protect = base64url.decode(input.protected).toString("utf8");
          protect = JSON.parse(protect);

          // verify "crit" field first
          var crit = protect.crit;
          if (crit) {
            if (!Array.isArray(crit)) {
              return Promise.reject(new Error("Invalid 'crit' header"));
            }
            for (var idx = 0; crit.length > idx; idx++) {
              if (-1 === handlerKeys.indexOf(crit[idx])) {
                return Promise.reject(new Error(
                    "Critical extension is not supported: " + crit[idx]
                ));
              }
            }
          }

          fields = protect;
          protect = Object.keys(protect);
        } else {
          fields = {};
          protect = [];
        }
        fields = merge(input.unprotected || {}, fields);

        rcptList = rcptList.map(function(r) {
          var promise = Promise.reso...
Object.defineProperty(this, "update", {
    value: function(data, encoding) {
      if (finalized) {
        throw new Error("already final");
      }
      if (data != null) {
        data = util.asBuffer(data, encoding);
        if (content.length) {
          content = Buffer.concat([content, data],
                      content.length + data.length);
        } else {
          content = data;
        }
      }

      return this;
    }
  })
var webcrypto = function(key, pdata, mac) {
    key = rsaUtil.convertToJWK(key, true);
    var promise;
    promise = helpers.subtleCrypto.importKey("jwk", key, alg, true, ["verify"]);
    promise = promise.then(function(key) {
      return helpers.subtleCrypto.verify(alg, key, mac, pdata);
    });
    promise = promise.then(function(result) {
      if (!result) {
        return Promise.reject(new Error("verification failed"));
      }

      return {
        data: pdata,
        mac: mac,
        valid: true
      };
    });

    return promise;
  }
sigs = sigs.map(function(s) {
          // prepare protected
          var protect = {},
              lenProtect = 0,
              unprotect = clone(s.header),
              lenUnprotect = Object.keys(unprotect).length;
          s.protected.forEach(function(h) {
            if (!(h in unprotect)) {
              return;
            }
            protect[h] = unprotect[h];
            lenProtect++;
            delete unprotect[h];
            lenUnprotect--;
          });
          if (lenProtect > 0) {
            protect = JSON.stringify(protect);
            protect = util.base64url.encode(protect);
          } else {
            protect = "";
          }

          // signit!
          var data = Buffer.from(protect + "." + content, "ascii");
          s = s.key.sign(s.header.alg, data, s.header);
          s = s.then(function(result) {
            var sig = {};
            if (0 < lenProtect) {
              sig.protected = protect;
            }
            if (0 < lenUnprot...
var node = function(key, pdata) {
    try {
      commonChecks(key, pdata);
    } catch (err) {
      return Promise.reject(err);
    }

    // split input into chunks
    var R = split(pdata, 8),
        iv = Buffer.alloc(16);
    var A,
        B,
        count;
    A = A0;
    for (var jdx = 0; 6 > jdx; jdx++) {
      for (var idx = 0; R.length > idx; idx++) {
        count = (R.length * jdx) + idx + 1;
        B = Buffer.concat([A, R[idx]]);
        var cipher = helpers.nodeCrypto.createCipheriv("AES" + size, key, iv);
        B = cipher.update(B);

        A = xor(B.slice(0, 8),
                longToBigEndian(count));
        R[idx] = B.slice(8, 16);
      }
    }
    R = [A].concat(R);
    var cdata = Buffer.concat(R);
    return Promise.resolve({
      data: cdata
    });
  }
promise = promise.then(function(sigList) {
        return new Promise(function(resolve, reject) {
          var processSig = function() {
            var sig = sigList.shift();
            if (!sig) {
              reject(new Error("no key found"));
              return;
            }

            sig = merge({}, sig, {
              payload: input.payload
            });
            var p = Promise.resolve(sig);
            // find the key
            p = p.then(function(sig) {
              var algKey;
              // TODO: resolve jku, x5c, x5u
              if (opts.allowEmbeddedKey && sig.header.jwk) {
                algKey = JWK.asKey(sig.header.jwk);
              } else if (opts.allowEmbeddedKey && sig.header.x5c) {
                algKey = sig.header.x5c[0];
                algKey = Buffer.from(algKey, "base64");
                // TODO: callback to validate chain
                algKey = JWK.asKey(algKey, "pkix");
              } else {
                algKey = Promise.r...
var validators = {
  oid: "1.2.840.113549.1.1.1",
  privateKey: {
    name: "RSAPrivateKey",
    tagClass: forge.asn1.Class.UNIVERSAL,
    type: forge.asn1.Type.SEQUENCE,
    constructed: true,
    value: [
      {
        // Version (INTEGER)
        name: "RSAPrivateKey.version",
        tagClass: forge.asn1.Class.UNIVERSAL,
        type: forge.asn1.Type.INTEGER,
        constructed: false,
        capture: "version"
      },
      {
        // modulus (n)
        name: "RSAPrivateKey.modulus",
        tagClass: forge.asn1.Class.UNIVERSAL,
        type: forge.asn1.Type.INTEGER,
        constructed: false,
        capture: "n"
      },
      {
        // publicExponent (e)
        name: "RSAPrivateKey.publicExponent",
        tagClass: forge.asn1.Class.UNIVERSAL,
        type: forge.asn1.Type.INTEGER,
        constructed: false,
        capture: "e"
      },
      {
        // privateExponent (d)
        name: "RSAPrivateKey.privateExponent",
        tagClass: forge.asn1.Class.UNIVERSA...
_tmp_33.push(forge.asn1.create(forge.asn1.Class.UNIVERSAL, forge.asn1.Type.OID, false, oid.bytes()))
p = p.then(function(sig) {
              var algKey;
              // TODO: resolve jku, x5c, x5u
              if (opts.allowEmbeddedKey && sig.header.jwk) {
                algKey = JWK.asKey(sig.header.jwk);
              } else if (opts.allowEmbeddedKey && sig.header.x5c) {
                algKey = sig.header.x5c[0];
                algKey = Buffer.from(algKey, "base64");
                // TODO: callback to validate chain
                algKey = JWK.asKey(algKey, "pkix");
              } else {
                algKey = Promise.resolve(assumedKey || keystore.get({
                  use: "sig",
                  alg: sig.header.alg,
                  kid: sig.header.kid
                }));
              }
              return algKey.then(function(k) {
                if (!k) {
                  return Promise.reject(new Error("key does not match"));
                }
                sig.key = k;
                return sig;
              });
            })
promise = promise.then(function () {
              return Promise.reject(new Error("Algorithm not allowed: " + header.enc));
            })
DataBuffer.prototype.bytes = function(count) {
  var rval;
  if (undefined === count) {
    count = this.length();
  } else if (count) {
    count = Math.min(count, this.length());
  }

  if (0 === count) {
    rval = "";
  } else {
    var begin = this.read,
        end = begin + count,
        data = this.data.slice(begin, end);
    rval = String.fromCharCode.apply(null, data);
  }

  return rval;
}
var nodejs = function(key, pdata, props) {
    var iv = props.iv,
        adata = props.aad || props.adata || Buffer.alloc(0);

    try {
      commonChecks(key, iv, adata);
    } catch (err) {
      return Promise.reject(err);
    }

    iv = iv || util.randomBytes(12);

    var alg = "aes-" + (key.length * 8) + "-gcm";
    var cipher;
    try {
      cipher = helpers.nodeCrypto.createCipheriv(alg, key, iv);
    } catch (err) {
      throw new Error("unsupported algorithm: " + alg);
    }
    if ("function" !== typeof cipher.setAAD) {
      throw new Error("unsupported algorithm: " + alg);
    }
    if (adata.length) {
      cipher.setAAD(adata);
    }

    var cdata = Buffer.concat([
      cipher.update(pdata),
      cipher.final()
    ]);
    var tag = cipher.getAuthTag();

    return prepareResults({
      data: cdata,
      iv: iv,
      tag: tag
    });
  }
_tmp_18.push({
          name: "Certificate.TBSCertificate.validity",
          tagClass: forge.asn1.Class.UNIVERSAL,
          type: forge.asn1.Type.SEQUENCE,
          constructed: true,
          // Note: UTC and generalized times may both appear so the capture
          // names are based on their detected order, the names used below
          // are only for the common case, which validity time really means
          // "notBefore" and which means "notAfter" will be determined by order
          value: [
            {
              // notBefore (Time) (UTC time case)
              name: "Certificate.TBSCertificate.validity.notBefore (utc)",
              tagClass: forge.asn1.Class.UNIVERSAL,
              type: forge.asn1.Type.UTCTIME,
              constructed: false,
              optional: true,
              capture: "certValidity1UTCTime"
            },
            {
              // notBefore (Time) (generalized time case)
              name: "Certificate.TBSCertificate.validity.notBe...)
_tmp_25.push({
        // privateExponent (d)
        name: "RSAPrivateKey.privateExponent",
        tagClass: forge.asn1.Class.UNIVERSAL,
        type: forge.asn1.Type.INTEGER,
        constructed: false,
        capture: "d"
      })
promise = promise.then(function(rcptList) {
        var jwe = {};
        return new Promise(function(resolve, reject) {
          var processKey = function() {
            var rcpt = rcptList.shift();
            if (!rcpt) {
              reject(new Error("no key found"));
              return;
            }

            var algPromise = Promise.resolve(rcpt);
            algPromise = algPromise.then(function(rcpt) {
              // try to unwrap encrypted key
              var prekey = kdata = rcpt.encrypted_key || "";
              prekey = base64url.decode(prekey);
              algKey = assumedKey || keystore.get({
                use: "enc",
                alg: rcpt.header.alg,
                kid: rcpt.header.kid
              });
              if (algKey) {
                return algKey.unwrap(rcpt.header.alg, prekey, rcpt.header);
              } else {
                return Promise.reject();
              }
            });
            algPromise = algPromise.then(funct...
ECPrivateKey.prototype.isValid = function() {
  var d = bin2bn(this.d),
      n1 = this.params.getN().subtract(BigInteger.ONE);

  return (d.compareTo(BigInteger.ONE) >= 0) &&
         (d.compareTo(n1) < 0);
}
var JWKOctetFactory = {
  kty: "oct",
  prepare: function(props) {
    // TODO: validate key properties
    var cfg = JWKOctetCfg;
    var p = Promise.resolve(props);
    p = p.then(function(json) {
      return JWK.helpers.thumbprint(cfg, json);
    });
    p = p.then(function(hash) {
      var prints = {};
      prints[JWK.helpers.INTERNALS.THUMBPRINT_HASH] = hash;
      props[JWK.helpers.INTERNALS.THUMBPRINT_KEY] = prints;
      return cfg;
    });
    return p;
  },
  generate: function(size) {
    // TODO: validate key sizes
    var key = util.randomBytes(size / 8);

    return Promise.resolve({
      k: key
    });
  }
}
nodejs = function(key, pdata, mac /* , props */) {
      if (curve !== key.crv) {
        return Promise.reject(new Error("invalid curve"));
      }

      var size;
      switch (nodeHash.slice(-3)) {
        case "384":
          size = 48;
          break;
        case "512":
          size = 66;
          break;
        default:
          size = 32;
      }

      var promise;
      promise = Promise.resolve(helpers.nodeCrypto.createVerify(nodeHash));
      promise = promise.then(function (verify) {
        verify.update(pdata);
        verify.end();
        return verify.verify(ecUtil.convertToPEM(key, false), ecUtil.concatToDer(mac, size));
      });
      promise = promise.then(function (result) {
        if (!result) {
          throw new Error("verification failed");
        }
        return {
          data: pdata,
          mac: mac,
          valid: true
        };
      });

      return promise;
    }
_tmp_18.embeddedPrivateKey = {
    // ECPrivateKey
    name: "ECPrivateKey",
    tagClass: forge.asn1.Class.UNIVERSAL,
    type: forge.asn1.Type.SEQUENCE,
    constructed: true,
    value: [
      {
        // EC version
        name: "ECPrivateKey.version",
        tagClass: forge.asn1.Class.UNIVERSAL,
        type: forge.asn1.Type.INTEGER,
        constructed: false
      },
      {
        // private value (d)
        name: "ECPrivateKey.private",
        tagClass: forge.asn1.Class.UNIVERSAL,
        type: forge.asn1.Type.OCTETSTRING,
        constructed: false,
        capture: "d"
      },
      {
        // publicKey
        name: "ECPrivateKey.publicKey",
        tagClass: forge.asn1.Class.CONTEXT_SPECIFIC,
        constructed: true,
        value: [
          {
            name: "ECPrivateKey.point",
            tagClass: forge.asn1.Class.UNIVERSAL,
            type: forge.asn1.Type.BITSTRING,
            constructed: false,
            capture: "point"
          }
        ]
      }
    ]
  }
promise = promise.then(function(shared) {
      // NOTE: blacklist items from {props} for ECDH
      return concat["CONCAT-" + hash].derive(shared, omit(props, params));
    })
var fallback = function(key, cdata, props) {
    var adata = props.aad || props.adata || Buffer.alloc(0),
        iv = props.iv || Buffer.alloc(0),
        tag = props.tag || props.mac || Buffer.alloc(0),
        cipher,
        pdata;

    // validate inputs
    try {
      commonChecks(key, iv, tag);
    } catch (err) {
      return Promise.reject(err);
    }

    // setup cipher
    cipher = GCM.createDecipher({
      key: key,
      iv: iv,
      additionalData: adata,
      tag: tag
    });
    // plaintext is the same length as ciphertext
    pdata = Buffer.alloc(cdata.length);

    var promise = new Promise(function(resolve, reject) {
      var amt = CONSTANTS.CHUNK_SIZE,
          plen = 0,
          coff = 0;

      (function doChunk() {
        var clen = Math.min(amt, cdata.length - coff);
        plen += cipher.update(cdata,
                              coff,
                              clen,
                              pdata,
                              plen);
      ...
promise = promise.then(function(cdata){
      var mdata = Buffer.concat([
        adata,
        iv,
        cdata,
        helpers.int64ToBuffer(adata.length * 8)
      ]);

      var promise;
      promise = HMAC["HS" + (size * 2)].sign(iKey, mdata, {
        length: size
      });
      promise = promise.then(function(result) {
        // TODO: move slice to hmac.js
        var tag = result.mac.slice(0, size / 8);
        return {
          data: cdata,
          tag: tag
        };
      });
      return promise;
    })
p = p.then(function(jws) {
              var processing = [];
              handlerKeys.forEach(function(h) {
                h = extraHandlers[h];
                var p;
                if ("object" === typeof h && "function" === typeof h.complete) {
                  p = h.complete(jws);
                }
                if (p) {
                  processing.push(Promise.resolve(p));
                }
              });
              return Promise.all(processing).then(function() {
                // don't actually care about individual handler results
                // assume {jws} is updated
                return jws;
              });
            })
_tmp_36.push({
        // publicExponent (e)
        name: "RSAPublicKey.exponent",
        tagClass: forge.asn1.Class.UNIVERSAL,
        type: forge.asn1.Type.INTEGER,
        constructed: false,
        capture: "e"
      })
_tmp_18.push({
          // subjectUniqueID (optional)
          name: "Certificate.TBSCertificate.subjectUniqueID",
          tagClass: forge.asn1.Class.CONTEXT_SPECIFIC,
          type: 2,
          constructed: true,
          optional: true,
          value: [
            {
              name: "Certificate.TBSCertificate.subjectUniqueID.id",
              tagClass: forge.asn1.Class.UNIVERSAL,
              type: forge.asn1.Type.BITSTRING,
              constructed: false,
              capture: "certSubjectUniqueId"
            }
          ]
        })
processing.push(Promise.resolve(p))
