block.type !== 'brace' && block.type !== 'root' && block.parent
block = block.parent
q.push(append(q.pop(), queue, enclose))
value === CHAR_RIGHT_SQUARE_BRACKET
value === CHAR_LEFT_SQUARE_BRACKET
braces.expand = (input, options = {}) => {
  if (typeof input === 'string') {
    input = braces.parse(input, options);
  }

  let result = expand(input, options);

  // filter out empty strings if specified
  if (options.noempty === true) {
    result = result.filter(Boolean);
  }

  // filter out duplicates if specified
  if (options.nodupes === true) {
    result = [...new Set(result)];
  }

  return result;
}
value === CHAR_LEFT_PARENTHESES
block = push({ type: 'paren', nodes: [] })
stack.push(block)
value === CHAR_RIGHT_PARENTHESES
block = stack.pop()
options.expand !== true ? braces.compile(input, options) : braces.expand(input, options)
value === CHAR_DOUBLE_QUOTE || value === CHAR_SINGLE_QUOTE || value === CHAR_BACKTICK
module.exports = braces
next === CHAR_BACKSLASH
next === open
value === CHAR_LEFT_CURLY_BRACE
let dollar = prev.value && prev.value.slice(-1) === '$' || block.dollar === true
let brace = {
        type: 'brace',
        open: true,
        close: false,
        dollar,
        depth,
        commas: 0,
        ranges: 0,
        nodes: []
      }
_tmp_19.dollar = dollar
block = push(brace)
push({ type: 'open', value })
value === CHAR_RIGHT_CURLY_BRACE
block = stack.pop()
value === CHAR_COMMA && depth > 0
block.nodes = [open, { type: 'text', value: stringify(block) }]
value === CHAR_DOT && depth > 0 && block.commas === 0
prev.value += value
before.value += prev.value + value
prev = before
