await Promise.all(triggers
            .filter((trigger) => !trigger.eventTrigger.eventFilters ||
            this.matchesAll(event, trigger.eventTrigger.eventFilters))
            .map((trigger) => registry_1.EmulatorRegistry.client(types_1.Emulators.FUNCTIONS)
            .request({
            method: "POST",
            path: `/functions/projects/${trigger.projectId}/triggers/${trigger.triggerName}`,
            body: JSON.stringify((0, eventarcEmulatorUtils_1.cloudEventFromProtoToJson)(event)),
            responseType: "stream",
            resolveOnHTTPError: true,
        })
            .then((res) => {
            if (res.status >= 400) {
                throw new error_1.FirebaseError(`Received non-200 status code: ${res.status}`);
            }
        })
            .catch((err) => {
            this.logger.log("ERROR", `Failed to trigger Functions emulator for ${trigger.triggerName}: ${err}`);
        })))
function checkInstanceNameAvailable = async function checkInstanceNameAvailable(projectId, instanceName, databaseType, location) {
    var _a, _b, _c;
    if (!location) {
        location = DatabaseLocation.US_CENTRAL1;
    }
    try {
        await apiClient.request({
            method: "POST",
            path: `/projects/${projectId}/locations/${location}/instances`,
            queryParams: { databaseId: instanceName, validateOnly: "true" },
            body: { type: databaseType },
            timeout: TIMEOUT_MILLIS,
        });
        return { available: true };
    }
    catch (err) {
        logger_1.logger.debug(`Invalid Realtime Database instance name: ${instanceName}.${err.message ? " " + err.message : ""}`);
        const errBody = err.context.body.error;
        if ((_c = (_b = (_a = errBody === null || errBody === void 0 ? void 0 : errBody.details) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.metadata) === null || _c === void 0 ? void 0 : _c.suggested_database_ids...
function removeFromManifest = function removeFromManifest(instanceId, config) {
    if (!instanceExists(instanceId, config)) {
        throw new error_1.FirebaseError(`Extension instance ${instanceId} not found in firebase.json.`);
    }
    const extensions = config.get("extensions", {});
    extensions[instanceId] = undefined;
    config.set("extensions", extensions);
    config.writeProjectFile("firebase.json", config.src);
    logger_1.logger.info(`Removed extension instance ${instanceId} from firebase.json`);
    config.deleteProjectFile(`extensions/${instanceId}.env`);
    logger_1.logger.info(`Removed extension instance environment config extensions/${instanceId}.env`);
    if (config.projectFileExists(`extensions/${instanceId}.env.local`)) {
        config.deleteProjectFile(`extensions/${instanceId}.env.local`);
        logger_1.logger.info(`Removed extension instance local environment config extensions/${instanceId}.env.local`);
    }
    if (config.projectFileExists(`extensions/${instanceId}.secret.loc...
function loginAdditionalAccount = async function loginAdditionalAccount(useLocalhost, email) {
    const result = await loginGoogle(useLocalhost, email);
    if (typeof result.user === "string") {
        throw new error_1.FirebaseError("Failed to parse auth response, see debug log.");
    }
    const resultEmail = result.user.email;
    if (email && resultEmail !== email) {
        utils.logWarning(`Chosen account ${resultEmail} does not match account hint ${email}`);
    }
    const allAccounts = getAllAccounts();
    const newAccount = {
        user: result.user,
        tokens: result.tokens,
    };
    const existingAccount = allAccounts.find((a) => a.user.email === resultEmail);
    if (existingAccount) {
        utils.logWarning(`Already logged in as ${resultEmail}.`);
        updateAccount(newAccount);
    }
    else {
        const additionalAccounts = getAdditionalAccounts();
        additionalAccounts.push(newAccount);
        configstore_1.configstore.set("additionalAccounts", additionalAccounts);
    }...
