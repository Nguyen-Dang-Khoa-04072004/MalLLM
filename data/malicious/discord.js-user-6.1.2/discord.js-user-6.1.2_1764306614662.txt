GuildMemberRemoveHandler = package\src\client\websocket\packets\handlers\GuildMemberRemove.js::program:GuildMemberRemoveHandler:<init>
overwrites = overwrites.map(overwrite => {
      const role = this.guild.roles.resolve(overwrite.id);
      if (role) {
        overwrite.id = role.id;
        overwrite.type = 'role';
      } else {
        overwrite.id = this.client.users.resolveID(overwrite.id);
        overwrite.type = 'member';
      }

      return {
        allow: Permissions.resolve(overwrite.allowed || 0),
        deny: Permissions.resolve(overwrite.denied || 0),
        type: overwrite.type,
        id: overwrite.id,
      };
    })
PermissionOverwrites = package\src\structures\PermissionOverwrites.js::program:PermissionOverwrites:<init>
function buildRoute = function buildRoute(manager) {
  const route = [''];
  const handler = {
    get(target, name) {
      if (reflectors.includes(name)) return () => route.join('/');
      if (methods.includes(name)) {
        return options => manager.request(name, route.join('/'), Object.assign({
          versioned: manager.versioned,
          route: route.map((r, i) => {
            if (/\d{16,19}/g.test(r)) return /channels|guilds/.test(route[i - 1]) ? r : ':id';
            return r;
          }).join('/'),
        }, options));
      }
      route.push(name);
      return new Proxy(noop, handler);
    },
    apply(target, _, args) {
      route.push(...args.filter(x => x != null)); // eslint-disable-line eqeqeq
      return new Proxy(noop, handler);
    },
  };
  return new Proxy(noop, handler);
}
module.exports = async function createMessage(channel, options) {
  const User = require('../User');
  const GuildMember = require('../GuildMember');
  const Webhook = require('../Webhook');
  const WebhookClient = require('../../client/WebhookClient');

  const webhook = channel instanceof Webhook || channel instanceof WebhookClient;

  if (typeof options.nonce !== 'undefined') {
    options.nonce = parseInt(options.nonce);
    if (isNaN(options.nonce) || options.nonce < 0) throw new RangeError('MESSAGE_NONCE_TYPE');
  }

  let { content, reply } = options;
  if (options instanceof MessageEmbed) options = webhook ? { embeds: [options] } : { embed: options };
  if (options instanceof MessageAttachment) options = { files: [options.file] };

  if (content instanceof Array || options instanceof Array) {
    const which = content instanceof Array ? content : options;
    const attachments = which.filter(item => item instanceof MessageAttachment);
    const embeds = which.filter(item => ...
function makeDiscordjsError = function makeDiscordjsError(Base) {
  return class DiscordjsError extends Base {
    constructor(key, ...args) {
      super(message(key, args));
      this[kCode] = key;
      if (Error.captureStackTrace) Error.captureStackTrace(this, DiscordjsError);
    }

    get name() {
      return `${super.name} [${this[kCode]}]`;
    }

    get code() {
      return this[kCode];
    }
  };
}
<operator>.formatString("The ", this.constructor.name, " class may not be instantiated.")
WebSocketPacketManager = package\src\client\websocket\packets\WebSocketPacketManager.js::program:WebSocketPacketManager:<init>
manager.request(name, route.join('/'), Object.assign({
          versioned: manager.versioned,
          route: route.map((r, i) => {
            if (/\d{16,19}/g.test(r)) return /channels|guilds/.test(route[i - 1]) ? r : ':id';
            return r;
          }).join('/'),
        }, options))
_tmp_1.SHARDING_REQUIRED = "This session would have handled too many guilds - Sharding is required."
function tooLate = function tooLate(channel, user) {
  return channel.client.setTimeout(() => {
    channel.client.emit(Events.TYPING_STOP, channel, user, channel._typing.get(user.id));
    channel._typing.delete(user.id);
  }, 6000);
}
channel.client.setTimeout(() => {
    channel.client.emit(Events.TYPING_STOP, channel, user, channel._typing.get(user.id));
    channel._typing.delete(user.id);
  }, 6000)
this.env = Object.assign({}, process.env, {
      SHARDING_MANAGER: true,
      SHARD_ID: this.id,
      SHARD_COUNT: this.manager.totalShards,
      CLIENT_TOKEN: this.manager.token,
    })
new Promise((resolve, reject) => {
      if (!channel.joinable) {
        throw new Error('VOICE_JOIN_CHANNEL', channel.full);
      }

      let connection = this.connections.get(channel.guild.id);

      if (connection) {
        if (connection.channel.id !== channel.id) {
          this.connections.get(channel.guild.id).updateChannel(channel);
        }
        resolve(connection);
        return;
      } else {
        connection = new VoiceConnection(this, channel);
        this.connections.set(channel.guild.id, connection);
      }

      connection.once('failed', reason => {
        this.connections.delete(channel.guild.id);
        reject(reason);
      });

      connection.once('authenticated', () => {
        connection.once('ready', () => resolve(connection));
        connection.once('error', reject);
        connection.once('disconnect', () => this.connections.delete(channel.guild.id));
      });
    })
options.split.prepend =
          `${options.split.prepend || ''}\`\`\`${typeof options.code !== 'boolean' ? options.code || '' : ''}\n`
const Actions = {
  ALL: null,
  GUILD_UPDATE: 1,
  CHANNEL_CREATE: 10,
  CHANNEL_UPDATE: 11,
  CHANNEL_DELETE: 12,
  CHANNEL_OVERWRITE_CREATE: 13,
  CHANNEL_OVERWRITE_UPDATE: 14,
  CHANNEL_OVERWRITE_DELETE: 15,
  MEMBER_KICK: 20,
  MEMBER_PRUNE: 21,
  MEMBER_BAN_ADD: 22,
  MEMBER_BAN_REMOVE: 23,
  MEMBER_UPDATE: 24,
  MEMBER_ROLE_UPDATE: 25,
  ROLE_CREATE: 30,
  ROLE_UPDATE: 31,
  ROLE_DELETE: 32,
  INVITE_CREATE: 40,
  INVITE_UPDATE: 41,
  INVITE_DELETE: 42,
  WEBHOOK_CREATE: 50,
  WEBHOOK_UPDATE: 51,
  WEBHOOK_DELETE: 52,
  EMOJI_CREATE: 60,
  EMOJI_UPDATE: 61,
  EMOJI_DELETE: 62,
  MESSAGE_DELETE: 72,
}
this.ratelimit = {
      queue: [],
      remaining: 120,
      total: 120,
      time: 60e3,
      resetTimer: null,
    }
!this.permissionOverwrites.find((value, key) => {
      const testVal = this.parent.permissionOverwrites.get(key);
      return testVal === undefined ||
        testVal.denied.bitfield !== value.denied.bitfield ||
        testVal.allowed.bitfield !== value.allowed.bitfield;
    })
