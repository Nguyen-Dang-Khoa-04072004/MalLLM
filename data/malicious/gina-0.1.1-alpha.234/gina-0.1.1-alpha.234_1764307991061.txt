params && params.length != args.length && !/function/.test(typeof(args[args.length-1]))
this.getInstance = function(bundle) {

        if ( typeof(Config.instance) == 'undefined' && typeof(getContext('gina')) != 'undefined' ) {
            Config.instance = merge( self, getContext('gina').config, true );
            self.envConf = Config.instance.envConf
        }

        var configuration = Config.instance.envConf;

        var env = self.env || Config.instance.env;

        Config.instance.Env.parent = Config.instance;

        if (env != 'undefined')
            Config.instance.Env.set(Config.instance.env);

        Config.instance.Host.parent = Config.instance;

        //Do some checking please.. like already has a PID ?.
        //if yes, join in case of standalone.. or create a new thread.
        Config.instance.Host.setMaster(bundle);

        self = Config.instance;

        if ( typeof(bundle) != 'undefined' && typeof(configuration) != 'undefined' ) {
            try {
                //return configuration[bundle][env];
                return Config.instan...
var search = function(filter, field, _content, matched, searchOptionRules) {
                var reValidCount = null, searchOptCount = null;
                if (filter === null && _content === null) { // null case

                    ++matched;

                } else if (
                    filter
                    && keywords.indexOf(localeLowerCase) > -1
                    && localeLowerCase == 'not null'
                    && typeof(_content) != 'undefined'
                    && typeof(_content) !== 'object'
                    && _content != 'null'
                    && _content != 'undefined'
                ) {

                    if (result.indexOf(_content) < 0) {
                        ++matched;
                    }

                } else if (
                    typeof(_content) != 'undefined'
                    && typeof(_content) !== 'object'
                    && /(<|>|=)/.test(filter)
                    && !/undefined|function/.test(typeof(_content))
     ...
pipe.on('finish', function() {
    if (error) {
      return;
    }
    // truncate log file to size 0
    fs.truncate(file, 0, function(err) {
      if (err) {
        cb && cb('error truncating file ' + file + ': ' + err.message);
        return;
      }
      cb && cb(null, true);
    })
  })
process.argv[2] == '-s' && isLoadedThroughCLI
        || process.argv[2] == '--start' && isLoadedThroughCLI
        //Avoid -h, -v  ....
        || !isLoadedThroughCLI && isPath && process.argv.length > 3
var makeBundle = async function(bundle, rewrite) {

        loadAssets();

        // if ( /^true$/i.test(rewrite) ) {
        //     fixPorts
        //     return
        // }

        setPorts(bundle, self.portsAvailable, function onPortsSet(err){
            if (err) {
                rollback(err);
                return;
            }

            if (!local.envFileSaved) {
                saveEnvFile(function doneSavingEnv(err){

                    if (err) rollback(err);

                    saveProjectFile( function doneSavingProject(err, content) {

                        if ( err ) {
                            rollback(err);
                            return;
                        }

                        if (rewrite) {
                            delete content.bundles[local.bundle]
                        }
                        createBundle()
                    })
                })

            } else { // importing
                console.log('Bundle [ '+ loca...
typeof(bundleSettings.server.scheme) != 'undefined'
                                        && schemes.indexOf(bundleSettings.server.scheme) < 0
var init = function(opt) {


        if ( typeof(ctx.initialized) != 'undefined' && ctx.initialized == true) {
            getInstance();
            // process.env.NODE_ENV
            if (opt.hierarchies[opt.hierarchy].indexOf( opt.levels['debug'].code) > -1) {
                emit(opt, 'debug', '`'+ opt.name +' `Logger instance already exists: reusing it ;)');
            }

            return self;
        }
        ctx.initialized = true;
        if (!homeDir) {
            homeDir =  ( typeof(getUserHome) != 'undefined' ) ? getUserHome() : process.env[(process.platform == 'win32') ? 'USERPROFILE' : 'HOME'];// jshint ignore:line
            homeDir += '/.gina';
        }
        // user main options & flows options
        var extPath = _(homeDir +'/user/extensions/logger', true)
        var optionsPath = _(extPath +'/default/config.json', true);
        if ( new _(optionsPath).existsSync() ) {
            userOptions = requireJSON(optionsPath);// jshint ignore:line
            if ...
var setTimezone = function(timezone) {
        // save to ~/.gina/main.json
        mainConf['def_timezone'][GINA_SHORT_VERSION] = timezone;
        lib.generator.createFileFromDataSync(mainConf, mainConfPath);
        // save to ~/.gina/{GINA_VERSION_SHORT}/settings.json
        process['gina']['timezone'] = timezone;
        mainSettingsConf['timezone'] = timezone;
        lib.generator.createFileFromDataSync(mainSettingsConf, mainSettingsPath);
    }
client.on('end', () => {
            console.warn('[MQTail] Disconnected from server');
            console.info('[MQTail] Waitting for `MQListener` to be started ...');
            var mqPort = null;
            nIntervId = setInterval(() => {
                try {
                    mqPort = ~~(fs.readFileSync(mqPortFile).toString());
                    if (mqPort) {
                        process.emit('gina#mqlistener-started', mqPort);
                    }
                } catch (fileErr) {}
            }, 100);
        })
var throwError = function(code, err, isFatal) {
        var router      = getContext('router');
        if (router) {
            var res                 = router.response
                , next              = router.next
                , hasViews          = router.hasViews
                , isUsingTemplate   = isUsingTemplate
            ;


            if (arguments.length < 2) {
                err = code;
                code = 500
            }

            if ( !hasViews || !isUsingTemplate ) {
                if (!res.headersSent) {
                    res.writeHead(code, { 'Content-Type': 'application/json'} );
                    res.end(JSON.stringify({
                        status: code,
                        error: 'Error '+ code +'. '+ err.stack
                    }))
                } else {
                    next()
                }

            } else {
                if (!res.headersSent) {
                    res.writeHead(code, { 'Content-Type': 'text/html'} ...
createContent(filename, gnaFolder, content, function(err){
                        fs.openSync(checksumFile, 'w');
                        setTimeout(function(){
                            callback(err)
                        }, 500)
                    })
this.client.upsert(sid, sess, {expiry:ttl})
                .then(function onResult(_result){
                    result = _result;
                    //fn && fn.apply(this, arguments);
                })
                .catch(function onError(_err) {
                    err = _err
                    // if(err)
                    //     debug('Session Set complete', err.stack || err.message || err);

                    //fn && fn.apply(this, arguments);
                })
CouchbaseStore.prototype.destroy = function(sid, fn){
        if ('function' !== typeof fn) { fn = noop; }
        sid = this.prefix + sid;
        //this.client.remove(sid, fn);
        this.client
                .remove(sid)
                .then(fn)
                .catch(fn)
    }
processSrc(method, files[i].input, files[i].output, zipInstance, options, function onSrcProcessed(err, zipInstance){
                    processList(method, src, target, zipInstance, options, i+1, len, err);
                })
var encodings = [
  {
    "encodings": [
      {
        "labels": [
          "unicode-1-1-utf-8",
          "utf-8",
          "utf8"
        ],
        "name": "utf-8"
      }
    ],
    "heading": "The Encoding"
  },
  {
    "encodings": [
      {
        "labels": [
          "864",
          "cp864",
          "csibm864",
          "ibm864"
        ],
        "name": "ibm864"
      },
      {
        "labels": [
          "866",
          "cp866",
          "csibm866",
          "ibm866"
        ],
        "name": "ibm866"
      },
      {
        "labels": [
          "csisolatin2",
          "iso-8859-2",
          "iso-ir-101",
          "iso8859-2",
          "iso88592",
          "iso_8859-2",
          "iso_8859-2:1987",
          "l2",
          "latin2"
        ],
        "name": "iso-8859-2"
      },
      {
        "labels": [
          "csisolatin3",
          "iso-8859-3",
          "iso-ir-109",
          "iso8859-3",
          "iso88593",
          "iso_8859-3",
    ...
var getDaysTo = function(date, dateTo, mask) {

        if ( dateTo instanceof Date) {
            var count       = countDaysTo(date, dateTo)
                , month     = date.getMonth()
                , year      = date.getFullYear()
                , day       = date.getDate() + 1
                , dateObj   = new Date(year, month, day)
                , days      = []
                , i         = 0;

            for (; i < count; ++i) {
                if ( typeof(mask) != 'undefined' ) {
                    days.push(new Date(dateObj).format(mask));
                } else {
                    days.push(new Date(dateObj));
                }

                dateObj.setDate(dateObj.getDate() + 1);
            }

            return days || [];
        } else {
            throw new Error('dateTo is not instance of Date() !')
        }
    }
var getRootDomain = function(urlOrHostname, jsonFormat) {
        if ( typeof(jsonFormat) == 'undefined' ) {
            jsonFormat = false
        }
        var isSLD = false
            , isRegisteredTldOrSld = false
            , rootDomain = urlOrHostname.replace(/^(.*)\:\/\/|\/(.*)/g, '')
            // we don't want sub domains: that's why the `.reverse()` is for
            , rootDomainArr = rootDomain.split(/\./g).reverse()
            // TLD by default
            , rootDomainIndex = (rootDomainArr.length) ? rootDomainArr.length-1 : 0
        ;

        var list = self.rawPSL
                // remove comments & empty lines
                .replace(/\/\/\s*(.*)\n|^\s*\n/gm, '')
                .split(/\n/)
                .filter( function onFiltered(item, i, iArr) {
                    // formating ^!, ^. & removing extra junk
                    // this is specific to the ginven extensions list
                    if ( /[^a-z 0-9.]+/.test(item) ) {
                        ite...
console.debug('Could not get server core configuration for <'+ bundle +'>:<'+ env +'>')
server.listen(listenOption, function() {
            // Server started.
            console.info('[MQListener] `'+ host +'`is waitting for speakers on port `'+ port +'`');
            if (cb) {
                cb(false);
            }
        })
var compressFile = function(method, input, output, zipInstance, isBatchProcessing, cb, isPackage) {

        var methodObject = null;
        isPackage = ( typeof(isPackage) == 'undefined' ) ? false: isPackage;

        if ( isBatchProcessing ) {

            zipInstance.file(output, fs.createReadStream(input));

            cb(false, output, zipInstance);
            return
        }

        switch (method) {
            case 'gzip':
                methodObject = zlib.createGzip();
                break;

            default:
                methodObject = zlib.createGzip();
                break;
        }


        if ( /\/\.(.*)$/.test(input.path) ) {

            if (isPackage) {
                cb(false, input)
            } else {
                cb(false, input.path)
            }
            return
        } else {
            input
                .pipe(methodObject)
                .pipe(output);
        }


        output
            .once('error', function onCompressionEr...
data.bundles[local.bundle] = {
            "_comment" : "Your comment goes here.",
            "version"   : version,
            "tag" : ( version.split('.') ).join(''),
            "src" : "src/" + local.bundle,
            "link"      : "bundles/"+ local.bundle,
            "releases" : {}
        }
gna.getProjectConfiguration = function (callback){

    var modulesPackage = _(root + '/manifest.json');
    var project     = {}
        , bundles   = [];

    //console.debug('modulesPackage ', modulesPackage, fs.existsSync(modulesPackage));
    //Merging with existing;
    if ( fs.existsSync(modulesPackage) ) {
        try {

            var dep = require(modulesPackage);
            //console.log('ENV: ', env );
            //console.log('PROCESS: ', process.argv );
            //console.log(" now loading....", modulesPackage);
            //console.log('content ', dep);
            if ( typeof(dep['bundles']) == "undefined") {
                dep['bundles'] = {};
            }

            if (
                typeof(dep['bundles']) != "undefined"
                && typeof(project['bundles']) != "undefined"
            ) {

                for (var d in dep) {

                    if (d == 'bundles') {
                        for (var p in dep[d]) {
                            ...
output
            .once('error', function onCompressionError(err) {
                cb(err, null)
            })
            .once('finish', function onCompressionFinished(){
                if (isPackage) {
                    cb(false, this, zipInstance)
                } else {
                    cb(false, this.path, zipInstance)
                }
            })
typeof(mainConfig['def_arch']) != 'undefined'
            && typeof(mainConfig['def_arch'][self.release]) != 'undefined'
            && mainConfig.archs[self.release].indexOf(mainConfig['def_arch'][self.release]) < 0
self[l] = function(){// jshint ignore:line

                    let group = opt.name || defaultOptions.name; // by default
                    if ( process.title != 'node' && !/(\\|\/)*node$/.test(process.title) ) {
                        group = process.title.replace(/^gina\:\s*/, '');
                        if ( typeof(group) == 'undefined' || /^gina\-/.test(group) ) {
                            group = 'gina'
                        }
                    }

                    //self.log('--> '+ group + ' '+ process.env.LOG_GROUP +' '+ process.title);
                    if ( typeof(loggers[group]) == 'undefined' ) {
                        setupNewGroup(group)
                    }
                    loggers[group][l].apply(self[l], arguments)
                }
fs.stat(this.value, function(err, stats) {
                var canWrite = false;
                if (!err && stats.mode & (fs.constants.S_IRUSR | fs.constants.S_IRGRP | fs.constants.S_IROTH)) {
                    canWrite = true;
                }
                callback( canWrite )
            })
_tmp_37.labels = [
          "csisolatin4",
          "iso-8859-4",
          "iso-ir-110",
          "iso8859-4",
          "iso88594",
          "iso_8859-4",
          "iso_8859-4:1988",
          "l4",
          "latin4"
        ]
typeof(self.selectedDebugPorts) != 'undefined'
                            && typeof(self.selectedDebugPorts[_bundle]) != 'undefined'
fs.exists(path, function(exists){
            //delete when exists.
            if (exists) {
                //console.log("yeah about to delete main folder: ", p.toString());
                //Delete ans die here..
                p.rm(function(err, path){
                    //console.log("receives ", err, path);
                    if (err) {
                        //logger.error('gina', 'LIB:CONFIG:ERR:8', err, __stack);
                        console.error(err.stack||err.message);
                        callback(err)
                    } else {
                        //logger.info('gina', 'LIB:CONFIG:INFO:1', path +': deleted with success !');
                        console.info( path +': deleted with success !');
                        callback(false)
                    }
                })
            }
        })
_tmp_37.pingTimeout = options.ioServer.pingTimeout || options.ioServer.timeout
fs.lstat(p, function(err, stats) {
            if (err) callback(err);

            if ( !stats.isDirectory() ) {
                callback(new Error(p +' is not a directory'))
            } else {
                fs.readdir(p, function(err, files) {
                    for(var f=0; f<files.length; ++f) {
                        if (search == files[f]) {
                            callback(false, true)
                            break
                        }
                    }
                })
            }
        })
this.reloadModels = function(conf, cb) {

        if ( typeof(conf.content['connectors']) != 'undefined' && conf.content['connectors'] != null ) {

            var models              = conf.content.connectors
                , conn              = null
                , foundInitError    = false
                , connectorPath     = null
                , entitiesManager   = null
                , modelPath         = null
                , entitiesPath      = null
                , modelConnectors   = null;


            // end - now, loading entities for each `loaded` model
            for (var bundle in self.models) {

                for (var name in self.models[bundle]) { //name as connector name

                    self.models[bundle][name] = {};

                    if ( typeof(self.models[bundle][name]['_connection']) == 'undefined' ) {
                        self.models[bundle][name]['_connection'] = getContext('modelConnectors')[bundle][name].conn
                    }

 ...
fs.readdir(p, function(err, files) {
                    for(var f=0; f<files.length; ++f) {
                        if (search == files[f]) {
                            callback(false, true)
                            break
                        }
                    }
                })
var isWritableSync = function(path) {
        var canWrite = false;
        if ( typeof(fs.accessSync) != 'undefined' ) {
            try {
                fs.accessSync(path, fs.constants.W_OK);
                canWrite = true;
            } catch (err) {
                canWrite = false;
            }
        } else { // support for old version of nodejs

            try {
                canWrite = (fs.statSync(path).mode & (fs.constants.S_IRUSR | fs.constants.S_IRGRP | fs.constants.S_IROTH));
            } catch (err) {
                canWrite = false
            }
        }

        return canWrite
    }
var listBundleOnly = function() {

        var protocols   = self.protocols
            , schemes   = self.schemes
            , found     = false
            , str       = ''
            , re        = null
        ;

        var jsonCollection =  new Collection([]);
        for (let i = 0, len = protocols.length; i < len; ++i) {
            let protocol = protocols[i];
            str += '[ '+ protocol +' ]\n\r';
            for (let s = 0, sLen = schemes.length; s < sLen; ++s) {
                let scheme = schemes[s];
                let bundle = self.name;
                found = false;
                // re = new RegExp('^' + bundle + '\@', '');// searching by bundle name
                re = new RegExp('^' + bundle + '\@' + self.projectName + '\/', '');// searching by projectName
                for (let port in self.portsData[protocol][scheme]) {

                    let bundleEnv = self.portsData[protocol][scheme][port].replace(re, '\:').split(/\:/);
                    let _bun...
typeof(result.error) != 'undefined' && /^5/.test(result.status)
var addEnvToProject = function() {
        var e = 0
            , newEnvs = self.envs
            , projects = JSON.clone(self.projects)
            , envs = projects[self.projectName].envs
        ;
        // to ~/.gina/projects.json
        for (; e < newEnvs.length; ++e) {
            if (envs.indexOf(newEnvs[e]) < 0 ) {
                modified = true;
                envs.push(newEnvs[e])
            }
        }
        //writing
        lib.generator.createFileFromDataSync(
            projects,
            self.projectsPath
        );
        self.projectDataWrote = true
    }
canWrite = (fs.statSync(path).mode & (fs.constants.S_IRUSR | fs.constants.S_IRGRP | fs.constants.S_IROTH))
sample.cp(target, function done(err, destination) {

            if (err) {
                rollback(err);
                return;
            }

            // Browse, parse and replace keys
            local.source        = target;
            local.isInstalled   = false;

            // check installed bundle
            browse(local.source);

            if (local.isInstalled) {

                // remove files we don't want yet
                new _(destination + '/config/templates.json', true).rmSync();

                // if first bundle of th project, modify webroot
                if (self.bundlesByProject[self.projectName].count() == 1) {
                    var settingsServerPath = _(destination + '/config/settings.server.json', true);
                    var serverSettings = fs.readFileSync(settingsServerPath).toString();
                    serverSettings = serverSettings.replace('"webroot": "/{bundle}"', '"webroot": "/"');
                    lib.generator.createFileFr...
