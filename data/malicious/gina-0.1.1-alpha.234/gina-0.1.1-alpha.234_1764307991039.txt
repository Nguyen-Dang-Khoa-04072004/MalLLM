e.once('server#started', function(conf){


                // open default browser for dev env only
                // if ( isDev) {
                //     var payload = JSON.stringify({
                //         code    : 200,
                //         command  : "open"
                //     });

                //     if (self.ioClient) { // if client has already made connexion
                //         payload.command = "reload"
                //     } else {
                //         // get default home
                //         // helper/task::run() should be triggered from ioClient
                //         //run('open', [conf.hostname + conf.server.webroot])
                //     }
                // }

                // will start watchers from here
                callback()
            })
lib.generator.createFileFromDataSync(ports, self.portsPath)
_tmp_28.push({
        "labels": [
          "cp1257",
          "windows-1257",
          "x-cp1257"
        ],
        "name": "windows-1257"
      })
fs.stat(p, function(err, stats) {
                if (err) {
                    callback(err)
                } else {

                    if (stats.isDirectory()) {
                        callback(false, d)
                    } else {
                        callback(new Error('[ ' + d + ' ] is not a directory'))
                    }
                }
            })
_tmp_28.push({
        "labels": [
          "x-mac-cyrillic",
          "x-mac-ukrainian"
        ],
        "name": "x-mac-cyrillic"
      })
var rollback = function(err) {
        console.error('[ CLI ] could not complete protocol creation: ', (err.stack||err.message));
        console.info('[ CLI ] rolling back...');

        var writeFiles = function() {

            //restore env.json
            if ( typeof(local.envDataWrote) == 'undefined' ) {
                lib.generator.createFileFromDataSync(self.envData, self.envPath);
            }
            //restore project.json
            if ( typeof(local.projectDataWrote) == 'undefined' ) {
                if ( typeof(self.projectData.bundles[local.bundle]) != 'undefined') {
                    delete self.projectData.bundles[local.bundle];
                }
                lib.generator.createFileFromDataSync(self.projectData, self.projectConfigPath);
            }

            //restore ports.json
            if ( typeof(local.portsDataWrote) == 'undefined' ) {
                lib.generator.createFileFromDataSync(self.portsData, self.portsPath);
            }

         ...
instance['or'] = function () {
        arguments[arguments.length] = true;
        ++arguments.length;

        return instance.find.apply(this, arguments);
    }
_tmp_22.push({
    "encodings": [
      {
        "labels": [
          "chinese",
          "csgb2312",
          "csiso58gb231280",
          "gb2312",
          "gb_2312",
          "gb_2312-80",
          "gbk",
          "iso-ir-58",
          "x-gbk"
        ],
        "name": "gbk"
      },
      {
        "labels": [
          "gb18030"
        ],
        "name": "gb18030"
      },
      {
        "labels": [
          "hz-gb-2312"
        ],
        "name": "hz-gb-2312"
      }
    ],
    "heading": "Legacy multi-byte Chinese (simplified) encodings"
  })
e.on('error', function(err, request, response, next) {

                callback(err, request, response, next)
            })
_.prototype.renameSync = function(destination) {
        var self = this;
        var source = self.value;

        if ( !existsSync(source) ) {
            throw new Error('Cannot complete rename from `'+ source +'`: the path does not exist.');
        }

        try {
            fs.renameSync(source, destination);
        } catch (err) {
            throw err
        }
    }
let section = fNameWithNoExt.replace(/(^settings\.|^settings$)/, '').replace(new RegExp('\.'+ env +'$'), '').replace(new RegExp('\.json$'), '')
self.setLevel = function(level, group) {
        if ( typeof(group) == 'undefined' || /^gina\-/.test(group) ) {
            group = 'gina'
        }

        var opt = loggers[group]._options;
        level = level.toLowerCase();
        if ( typeof(opt.hierarchies[level]) == 'undefined' ) {
            console.warn('`'+ level +'` is not a valid level: swithcing to `info`');
            level = 'info';
        }

        opt.name = group;
        process.env.LOG_GROUP = group;
        opt.hierarchy = level;
        process.env.LOG_LEVEL = level;

        setColors(group);
        setDefaultLevels(group);


        self.debug('Log level set for `'+ group +'`: '+ level);

        return
    }
gna.getMountedBundles = process.getMountedBundles = function(callback) {
            fs.readdir(bundlesPath, function onRead(err, files) {
                callback(err, files)
            })
        }
err = output = ( typeof(messageOnly) != 'undefined' && /^true$/i.test(messageOnly) ) ? output.message : (output.stack||output.message)
register(trigger, queryOptions, onQueryCallback, _mainCallback)
setTimeout((trigger, queryParams, onQueryCallback) => {
                                if (!self._isRegisteredFromProto) {
                                    // needed when used as a synchrone method
                                    register(trigger, queryParams, onQueryCallback);
                                }
                            }, 0, trigger, queryParams, onQueryCallback)
self.resumeReporting = function(group) {

        //  [ duplicate output fix ]
        // if (group && loggers[group]._options) {
        //     self.warn('[logger]['+ group +'] now resuming ('+ group +')\n');
        //     loggers[group]._options.isFlushing = false;
        // }

        loggers[ctx._options.name]._options.isReporting = true;



    }
throw new Error('Log directory found but not writable: need permissions for `'+ logDir +'`');
cmd.defaultScheme = (cmd.projectName != null && typeof(cmd.projects[cmd.projectName]) != 'undefined' && typeof(cmd.projects[cmd.projectName]['def_scheme']) != 'undefined' ) ? cmd.projects[cmd.projectName]['def_scheme'] :Â cmd.mainConfig['def_scheme'][ GINA_SHORT_VERSION ]
_tmp_100.push({
        "labels": [
          "csiso2022jp",
          "iso-2022-jp"
        ],
        "name": "iso-2022-jp"
      })
instance['notIn'] =  function(){

        var arrayToFilter           = null // [] those that we don't want in the result
            , key                   = null //  string comparison key
            , result                = null
            , filters               = null
            , uuidSearchModeEnabled = true
        ;

        if ( typeof(arguments[arguments.length-1]) == 'string' ) {
            key = arguments[arguments.length - 1];
            delete arguments[arguments.length - 1];
            --arguments.length;
        }

        if ( typeof(arguments[arguments.length-1]) == 'boolean' ) {
            uuidSearchModeEnabled = arguments[arguments.length - 1]
            delete arguments[arguments.length - 1];
            --arguments.length;
        }

        if (arguments.length > 0) {
            filters = arguments;
        }


        if ( typeof(filters) == 'undefined' || !filters || typeof(filters) != 'object' ) {
            throw new Error('[ Collection ][ notIn...
self.checkIfCertificatesDir = function(done) {
        var certsDir = new _( getEnvVar('GINA_HOMEDIR') + '/certificates', true);
        var theRSARootCertsDir = new _(certsDir.toString() + '/RSARootCerts', true);
        var scopesDir = new _(certsDir.toString() + '/scopes', true);

        if ( !certsDir.existsSync() ) {
            certsDir.mkdirSync()
        }
        if ( !theRSARootCertsDir.existsSync() ) {
            theRSARootCertsDir.mkdirSync()
        }
        if ( !scopesDir.existsSync() ) {
            scopesDir.mkdirSync()
        }

        var mainConfig = require( _(self.opt.homedir + '/main.json', true) );
        var scopes = mainConfig.scopes[self.release];

        for (let i = 0, len = scopes.length; i < len; i++) {
            let scopeDir = new _( scopesDir.toString() +'/'+ scopes[i], true);
            if ( !scopeDir.existsSync() ) {
                scopeDir.mkdirSync()
            }
        }

        done()
    }
self.throwError(local.res, 500, new Error('template compilation exception encoutered: [ '+path+' ]\n'+(err.stack||err.message)))
var staticProps = {
            firstLevel  : '/'+ url.split(/\//g)[1] + '/',
            isFile      :  /^\/[A-Za-z0-9_-]+\.(.*)$/.test(url)
        }
var scopesDir = new _(certsDir.toString() + '/scopes', true)
throw new Error('Cannot complete copy from `'+ source +'`: the path does not exist.');
typeof(params.param[key]) != 'undefined' &&
                typeof(params.requirements) != 'undefined' &&
                typeof(params.requirements[key]) != 'undefined' &&
                typeof(request.params) != 'undefined' &&
                tested
self.log = function() {
        var opt = self.getOptions();
        var args = arguments, content = '';

        //To handle logs with coma separated arguments.
        for (let i=0; i<args.length; ++i) {

            if (args[i] instanceof Object) {
                //console.log("\n...", args[i], args[i].toString());
                content += JSON.stringify(args[i], null, '\t');
            } else {
                content += args[i];

                // In case of formated entries - eg.: spawned server that is already returning formated logs
                // if ( /(\[|\[\s+)debug/.test(args[i]) ) {
                //     // args[i] = args[i].replace(/\n$/, '');
                //     // self.debug(args[i].replace(/^.*\[debug.*\]\s+/, '').replace(/\n$/, ''));

                // emit(opt, 'log', content.replace(/\n$/, ''), true);
                // return;

                    // emit(opt, 'debug', content.replace(/\n$/, ''), true);

                    // for (let p=0, pLen=op...
_tmp_109.labels = [
          "cseuckr",
          "csksc56011987",
          "euc-kr",
          "iso-ir-149",
          "korean",
          "ks_c_5601-1987",
          "ks_c_5601-1989",
          "ksc5601",
          "ksc_5601",
          "windows-949"
        ]
section = section.replace(/-([a-z])/g, function(g) { return g[1].toUpperCase(); })
throw new Error('[ Collection ][ notIn ] `filters` argument must be defined: Array or Filter Object(s) expected');
typeof($formOrFormId) == 'undefined' && typeof(this.id) != 'undefined'
bundleConf = self.conf[altConf.split(/\@/)[1]][bundleConf.env]
var Controller = require(_(GINA_FRAMEWORK_DIR +'/core/controller/controller.js'), true)
var controller = new Controller(controllerOptions)
filename = (bundleConf.staticResources.indexOf(path) > -1) ? bundleConf.content.statics[path] + url.replace(backedupPath, '/') : bundleConf.content.statics[staticProps.firstLevel] + url.replace(staticProps.firstLevel, '/')
filename = (bundleConf.staticResources.indexOf(path) > -1) ? bundleConf.content.statics[path] + url.replace(path, '/') : bundleConf.content.statics[staticProps.firstLevel] + url.replace(staticProps.firstLevel, '/')
_tmp_22.push({
    "encodings": [
      {
        "labels": [
          "csiso2022kr",
          "iso-2022-cn",
            "iso-2022-cn-ext",
            "iso-2022-kr"
        ],
        "name": "replacement"
      },
      {
        "labels": [
          "utf-16be"
        ],
        "name": "utf-16be"
      },
      {
        "labels": [
          "utf-16",
          "utf-16le"
        ],
        "name": "utf-16le"
      },
      {
        "labels": [
          "x-user-defined"
        ],
        "name": "x-user-defined"
      }
    ],
    "heading": "Legacy miscellaneous encodings"
  })
_tmp_111.encodings = [
      {
        "labels": [
          "csiso2022kr",
          "iso-2022-cn",
            "iso-2022-cn-ext",
            "iso-2022-kr"
        ],
        "name": "replacement"
      },
      {
        "labels": [
          "utf-16be"
        ],
        "name": "utf-16be"
      },
      {
        "labels": [
          "utf-16",
          "utf-16le"
        ],
        "name": "utf-16le"
      },
      {
        "labels": [
          "x-user-defined"
        ],
        "name": "x-user-defined"
      }
    ]
cmd.bundlesByProject[project][bundle].protocols = cmd.projects[project].protocols
cmd.bundlesByProject[project][bundle].def_protocol = cmd.defaultProtocol
