Object.defineProperty(exports, "injectInitialization", {
  enumerable: true,
  get: function () {
    return _misc.injectInitialization;
  }
})
function takeDecorators = function takeDecorators(node) {
  let result;
  if (node.decorators && node.decorators.length > 0) {
    result = _core.types.arrayExpression(node.decorators.map(decorator => decorator.expression));
  }
  node.decorators = undefined;
  return result;
}
_tmp_36.ReferencedIdentifier = ReferencedIdentifier
file.set(looseLowPriorityKey, file.get(looseLowPriorityKey) | feature)
scope.hasOwnBinding(path.node.name)
file.set(looseLowPriorityKey, file.get(looseLowPriorityKey) | feature)
path.replaceWith(_core.types.sequenceExpression([throwNode, path.node]))
const privateFieldsAsSymbols = api.assumption("privateFieldsAsSymbols")
initNodes.push(_core.template.statement.ast`var ${id} = ${init}`)
const properties = [prop("kind", _core.types.stringLiteral(_core.types.isClassMethod(node) ? node.kind : "field")), prop("decorators", takeDecorators(node)), prop("static", node.static && _core.types.booleanLiteral(true)), prop("key", getKey(node))].filter(Boolean)
console.warn(`[${name}]: You are using the "loose: true" option and you are` + ` explicitly setting a value for the ${explicit.join(" and ")}` + ` assumption${explicit.length > 1 ? "s" : ""}. The "loose" option` + ` can cause incompatibilities with the other class features` + ` plugins, so it's recommended that you replace it with the` + ` following top-level option:\n` + `\t"assumptions": {\n` + `\t\t"setPublicClassFields": true,\n` + `\t\t"privateFieldsAsSymbols": true\n` + `\t}`)
const state = {
    classBinding: path.node.id && path.scope.getBinding(path.node.id.name),
    file
  }
_tmp_21.classBinding = path.node.id && path.scope.getBinding(path.node.id.name)
decoratorPath = el.get("decorators.0")
throw path.buildCodeFrameError("Class fields are not enabled. " + "Please add `@babel/plugin-transform-class-properties` to your configuration.");
_iterator_0 = <operator>.iterator(body.get("body"))
