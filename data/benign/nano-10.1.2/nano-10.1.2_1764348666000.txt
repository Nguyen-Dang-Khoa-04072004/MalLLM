callback(null, body, responseHeaders)
data && data.last_seq && data.last_seq !== self.since
self.since = data.last_seq
self.ee.emit(EVENT_SEQ, self.since)
self.stopOnEmptyChanges && data && typeof data.results !== 'undefined' && data.results.length === 0
data && data.results && data.results.length > 0
_iterator_0 = <operator>.iterator(data.results)
errors.statusCode = statusCode
self.ee.emit(EVENT_BATCH, data.results)
self.ee.emit(EVENT_ERROR, err)
await self.sleep(delay)
self.ee.emit('end', self.since)
self.request(req)
      .pipe(lin)
      .pipe(cp)
      .on('finish', (lastSeq) => {
        // the 'end' event was triggering before the last data event
        setTimeout(() => {
          self.ee.emit('end', cp.lastSeq)
        }, 10)
      })
      .on(EVENT_ERROR, (e) => {
        self.ee.emit(EVENT_ERROR, e)
      })
(e) => {
        self.ee.emit(EVENT_ERROR, e)
      }
const isJar = opts.jar || cfg.jar || (cfg.requestDefaults && cfg.requestDefaults.jar)
