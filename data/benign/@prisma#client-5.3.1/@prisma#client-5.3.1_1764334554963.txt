new Promise(async(t,r)=>{if(await new Promise(n=>process.nextTick(n)),this.stopPromise&&await this.stopPromise,this.engineEndpoint){try{this.connection.open(this.engineEndpoint),await(0,xw.default)(()=>this.connection.get("/status"),{retries:10})}catch(n){return r(n)}return t()}try{(this.child?.connected||this.child&&!this.child?.killed)&&AA("There is a child that still runs and we want to start again"),this.lastError=void 0,qs("startin & resettin"),this.globalKillSignalReceived=void 0,AA({cwd:this.cwd});let n=await Fl("binary",this.config),i=this.allowTriggerPanic?["--debug"]:[],s=["--enable-raw-queries","--enable-metrics","--enable-open-telemetry",...this.flags,...i];s.push("--port","0"),s.push("--engine-protocol","json"),AA({flags:s});let o=this.getEngineEnvVars();if(this.child=(0,Sw.spawn)(n,s,{env:o,cwd:this.cwd,windowsHide:!0,stdio:["ignore","pipe","pipe"]}),Ji(this.child.stderr).on("data",a=>{let c=String(a);AA("stderr",c);try{let g=JSON.parse(c);if(typeof g.is_panic<"u"&&(AA...
this.child.on("exit",a=>{if(qs("removing startPromise"),this.startPromise=void 0,this.engineStopDeferred){this.engineStopDeferred.resolve(a);return}if(this.connection.close(),a!==0&&this.engineStartDeferred&&this.startCount===1){let c,g=this.stderrLogs;this.lastError&&(g=Fn(this.lastError)),a!==null?(c=new ae(`Query engine exited with code ${a}
`+g,this.clientVersion),c.retryable=!0):this.child?.signalCode?(c=new ae(`Query engine process killed with signal ${this.child.signalCode} for unknown reason.
Make sure that the engine binary at ${n} is not corrupt.
`+g,this.clientVersion),c.retryable=!0):c=new ae(g,this.clientVersion),this.engineStartDeferred.reject(c)}this.child&&(this.lastError||a===126&&this.setError({timestamp:new Date,target:"binary engine process exit",level:"error",fields:{message:`Couldn't start query engine as it's not executable on this operating system.
You very likely have the wrong "binaryTarget" defined in the schema.prisma file.`}}))})
function to = async function to(e,A){if(e.ok)return;let t={clientVersion:A,response:e},r=await QG(e);if(r.type==="QueryEngineError")throw new Ue(r.body.message,{code:r.body.error_code,clientVersion:A});if(r.type==="DataProxyError"){if(r.body==="InternalDataProxyError")throw new mi(t,"Internal Data Proxy error");if("EngineNotStarted"in r.body){if(r.body.EngineNotStarted.reason==="SchemaMissing")return new zr(t);if(r.body.EngineNotStarted.reason==="EngineVersionNotSupported")throw new js(t);if("EngineStartupError"in r.body.EngineNotStarted.reason){let{msg:n,logs:i}=r.body.EngineNotStarted.reason.EngineStartupError;throw new Ks(t,n,i)}if("KnownEngineStartupError"in r.body.EngineNotStarted.reason){let{msg:n,error_code:i}=r.body.EngineNotStarted.reason.KnownEngineStartupError;throw new ae(n,A,i)}if("HealthcheckTimeout"in r.body.EngineNotStarted.reason){let{logs:n}=r.body.EngineNotStarted.reason.HealthcheckTimeout;throw new _s(t,n)}}if("InteractiveTransactionMisrouted"in r.body){let n={IDParseError:"Co...
