var end = function (output, type, messageOnly) {
        var err = false;
        if ( typeof(output) != 'undefined') {
            if ( output instanceof Error ) {
                err = output = ( typeof(messageOnly) != 'undefined' && /^true$/i.test(messageOnly) ) ? output.message : (output.stack||output.message);
            }
            if ( typeof(type) != 'undefined' ) {
                console[type](output)
            } else {
                console.log(output);
            }
        }

        process.exit( err ? 1:0 )
    }
var addBundlePorts = function(b) {
        loadAssets();

        if (b > self.bundles.length-1) { // writing to files on complete

            hasPastProtocolAndSchemeCheck(self.defaultProtocol, self.defaultScheme, true);

            //console.debug('self.protocols ...', self.protocols);
            // get user protocols list
            var protocols = JSON.clone(self.protocols);
            // get user schemes list
            var schemes = JSON.clone(self.schemes);
            var projectConfig   = JSON.clone(self.projects);

            //console.debug('about to update project ports conf\n\rBundles: '+ JSON.stringify(self.projectData, null, 4));
            var ports               = JSON.clone(self.portsData) // cloning
                , portsReverse      = JSON.clone(self.portsReverseData) // cloning
                , portsList         = local.ports
                , isPortUsed        = false
                , envs              = self.envs
                , i                 = 0
...
var setListener = function() {
        arguments = arguments[0];

        var args = Array.prototype.slice.call(arguments);
        var trigger = args.splice(0, 1)[0];

        if ( !/\#/.test(trigger) ) {
            throw new Error('trigger name not properly set: use `#` between the entity name and the method reference');
            process.exit(1)
        } else {
            if ( self._triggers.indexOf(trigger) < 0 ) {
                self._triggers.push(trigger);

                ++self._maxListeners;
                self.setMaxListeners(self._maxListeners);

                var alias       = trigger.split(/\#/)[1]
                    , method    = alias.replace(/[0-9]/g, '')
                    , events    = null
                    , i         = 0
                    ;

                self._listeners.push({
                    shortName   : trigger,
                    method      : method,
                    entityName  : self.name
                });

                events ...
var removePidFileSync = function(pid) {
        var files = fs.readdirSync( GINA_RUNDIR );
        var pidPath = null;
        for ( let i=0, len=files.length; i<len; i++) {
            let file = files[i];
            if (!/\.pid$/.test(file)) {
                continue;
            }
            let id = fs.readFileSync( _(GINA_RUNDIR +'/'+ files[i], true) ).toString().trim();
            if (~~id == pid) {
                pidPath = _(GINA_RUNDIR +'/'+ files[i], true);
                break;
            }
        }
        if (pidPath) {
            fs.unlinkSync( pidPath );
        }
    }
fs.lstat(path, function(err, stats){
                    if (err) console.error(err.stack);

                    if ( stats.isSymbolicLink() ) fs.unlink(path, function(err){
                        if (err) {
                            console.error(err.stack);
                            callback(err)
                        } else {
                            //Trigger.
                            onSymlinkRemoved(self.paths, function(err){
                                if (err) console.error(err.stack);

                                callback(false)
                            })
                        }
                    })
                })
process.emit('logger#'+self.name, JSON.stringify({
                group       : group,
                level       : 'error',
                // Raw content !
                content     : new Error('['+ mqId +'] No filename found!')
            }))
self.models[bundle][connector]['getConnection'] = function() {
                                            return self.models[bundle][connector]['_connection']
                                        }
