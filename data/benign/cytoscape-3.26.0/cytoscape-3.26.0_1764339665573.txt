const rgb2tuple = rgb => {
  let ret;

  let m = new RegExp( '^' + regex.rgba + '$' ).exec( rgb );
  if( m ){
    ret = [];

    let isPct = [];
    for( let i = 1; i <= 3; i++ ){
      let channel = m[ i ];

      if( channel[ channel.length - 1 ] === '%' ){
        isPct[ i ] = true;
      }
      channel = parseFloat( channel );

      if( isPct[ i ] ){
        channel = channel / 100 * 255; // normalise to [0, 255]
      }

      if( channel < 0 || channel > 255 ){ return; } // invalid channel value

      ret.push( Math.floor( channel ) );
    }

    let atLeastOneIsPct = isPct[1] || isPct[2] || isPct[3];
    let allArePct = isPct[1] && isPct[2] && isPct[3];
    if( atLeastOneIsPct && !allArePct ){ return; } // must all be percent values if one is

    let alpha = m[4];
    if( alpha !== undefined ){
      alpha = parseFloat( alpha );

      if( alpha < 0 || alpha > 1 ){ return; } // invalid alpha value

      ret.push( alpha );
    }
  }

  return ret;
}
var func = function(){
    for( var i = 0; i < handlers.length; i++ )
      handlers[ i ]( value );                                  /*  [Promises/A+ 2.2.5]  */
  }
ele.pstyle('events').value === 'yes'
    && ele.pstyle('visibility').value === 'visible'
    && eleTakesUpSpace( ele )
r.registerBinding( r.container, 'mousedown', function mousedownHandler( e ){
    if( !eventInContainer(e) ){ return; }

    e.preventDefault();

    blurActiveDomElement();

    r.hoverData.capture = true;
    r.hoverData.which = e.which;

    var cy = r.cy;
    var gpos = [ e.clientX, e.clientY ];
    var pos = r.projectIntoViewport( gpos[0], gpos[1] );
    var select = r.selection;
    var nears = r.findNearestElements( pos[0], pos[1], true, false );
    var near = nears[0];
    var draggedElements = r.dragData.possibleDragElements;

    r.hoverData.mdownPos = pos;
    r.hoverData.mdownGPos = gpos;

    var checkForTaphold = function(){
      r.hoverData.tapholdCancelled = false;

      clearTimeout( r.hoverData.tapholdTimeout );

      r.hoverData.tapholdTimeout = setTimeout( function(){

        if( r.hoverData.tapholdCancelled ){
          return;
        } else {
          var ele = r.hoverData.down;

          if( ele ){
            ele.emit( {
              originalEvent: e,...
edgeArrow.push( { name, type, triggersBounds } )
cmpt.forEach(node => {
        node.connectedEdges().forEach(e => { // connectedEdges() usually cached
          if( self.has(e) && cmpt.has(e.source()) && cmpt.has(e.target()) ){ // has() is cheap
            cmpt.merge(e); // forEach() only considers nodes -- sets N at call time
          }
        });
      })
