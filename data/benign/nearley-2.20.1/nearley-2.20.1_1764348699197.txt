function Compile = function Compile(structure, opts) {
        var unique = uniquer();
        if (!opts.alreadycompiled) {
            opts.alreadycompiled = [];
        }

        var result = {
            rules: [],
            body: [], // @directives list
            customTokens: [], // %tokens
            config: {}, // @config value
            macros: {},
            start: '',
            version: opts.version || 'unknown'
        };

        for (var i = 0; i < structure.length; i++) {
            var productionRule = structure[i];
            if (productionRule.body) {
                // This isn't a rule, it's an @directive.
                if (!opts.nojs) {
                    result.body.push(productionRule.body);
                }
            } else if (productionRule.include) {
                // Include file
                var path;
                if (!productionRule.builtin) {
                    path = require('path').resolve(
                        opts.args[0] ? require('path...
opts.version(version, '-v, --version')
    .arguments('<file.js>')
    .option('-s, --start [name]', 'An optional start symbol (if not provided then use the parser start symbol)', false)
    .option('-n, --count [n]', 'The number of samples to generate (separated by \\n).', 1)
    .option('-d, --depth [n]', 'The depth bound of each sample. Defaults to -1, which means "unbounded".', -1)
    .option('-o, --out [filename]', 'File to output to (defaults to stdout)')
    .parse(process.argv)
function genRandom = function genRandom(grammar, start) {
        // The first-generation generator. It just spews out stuff randomly, and is
        // not at all guaranteed to terminate. However, it is extremely performant.

        var output = "";

        var stack = [start];

        while (stack.length > 0) {
            var currentname = stack.pop();
            if (typeof(currentname) === 'string') {
                var goodrules = grammar.rules.filter(function(x) {
                    return x.name === currentname;
                });
                if (goodrules.length > 0) {
                    var chosen = goodrules[
                        Math.floor(Math.random()*goodrules.length)
                    ];
                    for (var i=chosen.symbols.length-1; i>=0; i--) {
                        stack.push(chosen.symbols[i]);
                    }
                } else {
                    throw new Error("Nothing matches rule: "+currentname+"!");
                ...
var result = {
            rules: [],
            body: [], // @directives list
            customTokens: [], // %tokens
            config: {}, // @config value
            macros: {},
            start: '',
            version: opts.version || 'unknown'
        }
opts.version(version, '-v, --version')
    .arguments('<file.ne>')
    .option('-o, --out [filename.svg]', 'File to output to (default stdout).', false)
    .parse(process.argv)
Rule.prototype.toString = function(withCursorAt) {
        var symbolSequence = (typeof withCursorAt === "undefined")
                             ? this.symbols.map(getSymbolShortDisplay).join(' ')
                             : (   this.symbols.slice(0, withCursorAt).map(getSymbolShortDisplay).join(' ')
                                 + " ● "
                                 + this.symbols.slice(withCursorAt).map(getSymbolShortDisplay).join(' ')     );
        return this.name + " → " + symbolSequence;
    }
this.symbols.slice(0, withCursorAt).map(getSymbolShortDisplay).join(' ')
                                 + " ● "
                                 + this.symbols.slice(withCursorAt).map(getSymbolShortDisplay).join(' ')
var goodrules = grammar.rules.filter(function(x) {
                    return x.name === currentname;
                })
