jasmine.jasmine.getEnv().addReporter({
    specDone: function(result) {
      if (screenshotHelper.shouldTakeScreenshot(result.status)) {
        if (booleanHelper.isTruthy(process.env['chimp.saveScreenshotsToDisk'])) {
          const affix = result.status !== 'passed' ? ' (failed)' : '';
          const fileName = result.fullName + affix;
          screenshotHelper.saveScreenshotsToDisk(fileName, projectDir);
        }
      }
    }
  })
request.post(
    {
      url,
      json: true,
      body: data,
    },
    (error, response, body) => {
      if (!error && response.statusCode === 200) {
        log.debug('[chimp][simian-reporter]', 'received data', body);
      } else {
        if (body) {
          log.error('[chimp][simian-reporter] Error from Simian:', body.error);
        } else {
          log.error('[chimp][simian-reporter]', 'Error while sending result to Simian:', error);
        }
      }
      SimianReporter.reportCallback(error);
    }
  )
this.cucumberChild = cp.fork(path.join(__dirname, 'cucumber-wrapper.js'), args, opts)
this.cucumberChild.on('close', (code) => {
      log.debug('[chimp][cucumber] Closed with code', code);

      if (!this.cucumberChild.stopping) {
        log.debug('[chimp][cucumber] Cucumber not in a stopping state');

        if (this.options.jsonOutput && jsonResults && JSON.parse(jsonResults).length) {
          const dir = path.dirname(this.options.jsonOutput);
          log.debug('[chimp][cucumber] Ensuring directory exists', dir);
          fs.mkdirsSync(dir);
          log.debug('[chimp][cucumber] Writing json results to', this.options.jsonOutput);
          fs.writeFileSync(this.options.jsonOutput, jsonResults);
          log.debug('[chimp][cucumber] Finished writing results');
        }

        const failWhenNoTestsRun = booleanHelper.isTruthy(this.options['fail-when-no-tests-run']);
        const noTestsFound = jsonResults === null || JSON.parse(jsonResults).length === 0;

        callback(code !== 0 || (code === 0 && noTestsFound && failWhenNoTestsRun) ? 'Cucumber step...
process.on('unhandledRejection', (reason, promise) => {
    log.error('[chimp] Detected an unhandledRejection:'.red);

    try {
      if (reason.type === 'CommandError' && reason.message === 'Promise never resolved with an truthy value') {
        reason.type += 'WebdriverIO CommandError (Promise never resolved with an truthy value)';
        reason.message = 'This usually happens when WebdriverIO assertions fail or timeout.';
        let hint = 'HINT: Check the step AFTER [' + lastStep.getKeyword() + lastStep.getName() + ']';
        let uri = lastStep.getUri();
        uri = uri.substring(process.cwd().length, uri.length);
        hint += ' (' + uri + ': >' + lastStep.getLine() + ')';
        log.error('[chimp][hooks] Reason:'.red);
        log.error('[chimp][hooks]'.red, reason.type.red);
        log.error('[chimp][hooks]'.red, reason.message.red);
        log.error(hint.yellow);
        reason.message += '\n' + hint;
      } else {
        log.error('[chimp][hooks]'.red, reason...
_tmp_5.ie = {
        // check for more recent versions of internet explorer driver here:
        // http://selenium-release.storage.googleapis.com/index.html
        version: '3.0.0',
        arch: 'ia32',
        baseURL: 'https://selenium-release.storage.googleapis.com'
      }
var waitForProcessToDie = setInterval(function () {
      try {
        if (retries-- < 0) {
          throw new Error('Process took too long to die');
        }
        log.debug('[chimp][' + options.prefix + ']', 'waiting for process to die (' + attempt++ + '/' + totalRetries + ')');
        process.kill(options.child.pid, 0);
      } catch (e) {
        clearInterval(waitForProcessToDie);
        if (e.code === 'ESRCH') {
          log.debug('[chimp][' + options.prefix + ']', 'process is dead');
          options.child = null;
          callback();
        } else {
          callback(e);
        }
      }
    }, delay)
_tmp_8.user = parseNullableString(process.env['chimp.user'] || process.env.SAUCE_USERNAME)
self.child.on('close', (code) => {
    log.debug('[chimp][jasmine] Closed with code', code);
    const failWhenNoTestsRun = booleanHelper.isTruthy(self.options['fail-when-no-tests-run']);
    if (!self.child.stopping) {
      log.debug('[chimp][jasmine] Jasmine not in a stopping state');
      callback(code !== 0 || (code === 0 && noTestsFound && failWhenNoTestsRun) ? 'Jasmine failed' : null, result);
    }
  })
_tmp_5.firefox = {
        // check for more recent versions of gecko  driver here:
        // https://github.com/mozilla/geckodriver/releases
        version: '0.19.1',
        arch: process.arch,
        baseURL: 'https://github.com/mozilla/geckodriver/releases/download'
      }
