const responseInterceptorId = axios.interceptors.response.use(null, async (error) => {
    const { config } = error;

    // If we have no information to retry the request
    if (!config) {
      return Promise.reject(error);
    }

    const {
      retries = 3,
      retryCondition = isNetworkOrIdempotentRequestError,
      retryDelay = noDelay,
      shouldResetTimeout = false,
      onRetry = () => {}
    } = getRequestOptions(config, defaultOptions);

    const currentState = getCurrentState(config);

    if (await shouldRetry(retries, retryCondition, currentState, error)) {
      currentState.retryCount += 1;
      const delay = retryDelay(currentState.retryCount, error);

      // Axios fails merging this configuration to the default configuration because it has an issue
      // with circular structures: https://github.com/mzabriskie/axios/issues/370
      fixConfig(axios, config);

      if (!shouldResetTimeout && config.timeout && currentState.lastRequestTime) {
        const l...
config = _tmp_7.config
!config
_tmp_8 = getRequestOptions(config, defaultOptions)
retries = _tmp_8.retries === void 0 ? 3 : _tmp_8.retries
var requestInterceptorId = axios.interceptors.request.use(config => {
    var currentState = getCurrentState(config);
    currentState.lastRequestTime = Date.now();
    return config;
  })
await shouldRetry(retries, retryCondition, currentState, error)
var _ref = _asyncToGenerator(function* (error) {
      var {
        config
      } = error; // If we have no information to retry the request

      if (!config) {
        return Promise.reject(error);
      }

      var {
        retries = 3,
        retryCondition = isNetworkOrIdempotentRequestError,
        retryDelay = noDelay,
        shouldResetTimeout = false,
        onRetry = () => {}
      } = getRequestOptions(config, defaultOptions);
      var currentState = getCurrentState(config);

      if (yield shouldRetry(retries, retryCondition, currentState, error)) {
        currentState.retryCount += 1;
        var delay = retryDelay(currentState.retryCount, error); // Axios fails merging this configuration to the default configuration because it has an issue
        // with circular structures: https://github.com/mzabriskie/axios/issues/370

        fixConfig(axios, config);

        if (!shouldResetTimeout && config.timeout && currentState.lastRequestTime) {
          var lastRe...
_regenerator.default.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            shouldRetryOrPromise = currentState.retryCount < retries && retryCondition(error); // This could be a promise

            if (!((0, _typeof2.default)(shouldRetryOrPromise) === 'object')) {
              _context2.next = 12;
              break;
            }

            _context2.prev = 2;
            _context2.next = 5;
            return shouldRetryOrPromise;

          case 5:
            shouldRetryPromiseResult = _context2.sent;
            return _context2.abrupt("return", shouldRetryPromiseResult !== false);

          case 9:
            _context2.prev = 9;
            _context2.t0 = _context2["catch"](2);
            return _context2.abrupt("return", false);

          case 12:
            return _context2.abrupt("return", shouldRetryOrPromise);

          case 13:
          case "end":
            return _context2.st...
!shouldResetTimeout && config.timeout && currentState.lastRequestTime
const lastRequestDuration = Date.now() - currentState.lastRequestTime
shouldRetryOrPromise = currentState.retryCount < retries && retryCondition(error)
new Promise((resolve) => setTimeout(() => resolve(axios(config)), delay))
new Promise(resolve => setTimeout(() => resolve(axios(config)), delay))
_regenerator.default.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              config = error.config; // If we have no information to retry the request

              if (config) {
                _context.next = 3;
                break;
              }

              return _context.abrupt("return", Promise.reject(error));

            case 3:
              _getRequestOptions = getRequestOptions(config, defaultOptions), _getRequestOptions$re = _getRequestOptions.retries, retries = _getRequestOptions$re === void 0 ? 3 : _getRequestOptions$re, _getRequestOptions$re2 = _getRequestOptions.retryCondition, retryCondition = _getRequestOptions$re2 === void 0 ? isNetworkOrIdempotentRequestError : _getRequestOptions$re2, _getRequestOptions$re3 = _getRequestOptions.retryDelay, retryDelay = _getRequestOptions$re3 === void 0 ? noDelay : _getRequestOptions$re3, _getRequestOptions$sh = _getRequestOptions.shouldRese...
delay = retryDelay(currentState.retryCount, error)
fixConfig(axios, config)
!(!shouldResetTimeout && config.timeout && currentState.lastRequestTime)
lastRequestDuration = Date.now() - currentState.lastRequestTime
timeout = config.timeout - lastRequestDuration - delay
_context.abrupt("return", new Promise(function (resolve) {
                return setTimeout(function () {
                  return resolve(axios(config));
                }, delay);
              }))
setTimeout(function () {
                  return resolve(axios(config));
                }, delay)
resolve(axios(config))
delay
