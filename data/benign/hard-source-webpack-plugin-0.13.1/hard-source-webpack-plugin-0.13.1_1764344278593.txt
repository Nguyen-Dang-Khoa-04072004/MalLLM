store = (archetype, id, item, extra) => {
        const cache = archetypeCaches[archetype];
        if (item) {
          const frozen = cache.get(id);
          const newFrozen = freeze(archetype, frozen, item, extra);
          if (
            (frozen && newFrozen && newFrozen !== frozen) ||
            (!frozen && newFrozen)
          ) {
            cache.set(id, newFrozen);
            return newFrozen;
          } else if (frozen) {
            return frozen;
          }
        } else {
          cache.set(id, null);
        }
      }
exports.hardSourceVersionChanged = compiler => {
  const loggerCore = logCore(compiler);
  loggerCore.warn(
    {
      id: 'environment--hardsource-changed',
    },
    'Installed HardSource version does not match the saved ' +
      'cache.\nHardSourceWebpackPlugin will reset the cache and store ' +
      'a fresh one.',
  );
}
const _closeLog = _this => {
  if (_this._fd === null) {
    return Promise.resolve();
  } else {
    return Promise.resolve()
      .then(() => {
        if (_this._writeBuffer) {
          return write(_this._fd, _this._writeBuffer, 0, _this._writeOffset);
        }
      })
      .then(() => close(_this._fd))
      .then(() => {
        _this._fd = null;
        _this._writeBuffer = null;
        _this._writeOffset = 0;
      });
  }
}
const parityCacheFromCache = (name, parityRoot, cache) => {
  const parityCache = parityRoot.add(name);
  if (cache.__hardSource_parityToken_root) {
    const rootCompilation = parseIfString(cache.__hardSource_parityToken_root);
    parityCache.add(rootCompilation);
    rootCompilation.ids.forEach(id => {
      if (cache[`__hardSource_parityToken_${id}`]) {
        parityCache.add(parseIfString(cache[`__hardSource_parityToken_${id}`]));
      }
    });
  }
}
'Installed HardSource version does not match the saved ' +
      'cache.\nHardSourceWebpackPlugin will reset the cache and store ' +
      'a fresh one.'
contextNormalRequest = param1_0.contextNormalRequest
