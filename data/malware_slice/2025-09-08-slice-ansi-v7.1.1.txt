// File: tmp/tmpulhn53ls/slice-ansi/package/index.js
// ======================================================================
Line 1: var ansiStyles = require("ansi-styles")
Line 2: var isFullwidthCodePoint = require("is-fullwidth-code-point")
Line 5: _tmp_10.push(_0xba16ef[_0x29ad9a(0x69b)])
Line 8: _tmp_51.push(155)
Line 15: _iterator_5.next()
Line 16: ansiStyles.color.ansi(end)
Line 17: ansiStyles.color.ansi(start)
Line 30: {
		code = code[0] + '0';
	}
Line 31: code = code[0] + '0'
Line 34: Number.parseInt(code, 10)
Line 36: ansiStyles.color.ansi(returnValue)
Line 66: {
	const returnValue = [];

	let index = 0;
	let visibleCount = 0;
	while (index < string.length) {
		const codePoint = string.codePointAt(index);

		if (ESCAPES.has(codePoint)) {
			const code = parseAnsiCode(string, index);
			if (code) {
				returnValue.push({
					type: 'ansi',
					code,
					endCode: getEndCode(code),
				});
				index += code.length;
				continue;
			}
		}

		const isFullWidth = isFullwidthCodePoint(codePoint);
		const character = String.fromCodePoint(codePoint);

		returnValue.push({
			type: 'character',
			value: character,
			isFullWidth,
		});

		index += character.length;
		visibleCount += isFullWidth ? 2 : character.length;

		if (visibleCount >= endCharacter) {
			break;
		}
	}

	return returnValue;
}
Line 67: const returnValue = []
Line 77: returnValue.push({
					type: 'ansi',
					code,
					endCode: getEndCode(code),
				})
Line 87: isFullwidthCodePoint(codePoint)
Line 90: returnValue.push({
			type: 'character',
			value: character,
			isFullWidth,
		})
Line 107: {
	let returnValue = [];

	for (const code of codes) {
		if (code.code === ansiStyles.reset.open) {
			// Reset code, disable all codes
			returnValue = [];
		} else if (endCodesSet.has(code.code)) {
			// This is an end code, disable all matching start codes
			returnValue = returnValue.filter(returnValueCode => returnValueCode.endCode !== code.code);
		} else {
			// This is a start code. Disable all styles this "overrides", then enable it
			returnValue = returnValue.filter(returnValueCode => returnValueCode.endCode !== code.endCode);
			returnValue.push(code);
		}
	}

	return returnValue;
}
Line 108: let returnValue = []
Line 110: _iterator_4.next()
Line 111: {
			// Reset code, disable all codes
			returnValue = [];
		}
Line 113: returnValue = []
Line 120: returnValue.push(code)
Line 130: endCodes.reverse().join('')
Line 133: {
	const tokens = tokenize(string, end);
	let activeCodes = [];
	let position = 0;
	let returnValue = '';
	let include = false;

	for (const token of tokens) {
		if (end !== undefined && position >= end) {
			break;
		}

		if (token.type === 'ansi') {
			activeCodes.push(token);
			if (include) {
				returnValue += token.code;
			}
		} else {
			// Character
			if (!include && position >= start) {
				include = true;
				// Simplify active codes
				activeCodes = reduceAnsiCodes(activeCodes);
				returnValue = activeCodes.map(({code}) => code).join('');
			}

			if (include) {
				returnValue += token.value;
			}

			position += token.isFullWidth ? 2 : token.value.length;
		}
	}

	// Disable active codes at the end
	returnValue += undoAnsiCodes(activeCodes);
	return returnValue;
}
Line 134: tokenize(string, end)
Line 135: let activeCodes = []
Line 140: _iterator_6.next()
Line 146: activeCodes.push(token)
Line 156: activeCodes.map(({code}) => code).join('')
