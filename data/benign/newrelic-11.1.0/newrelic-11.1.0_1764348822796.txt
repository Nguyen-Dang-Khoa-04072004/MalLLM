function parseProcCPUInfo = function parseProcCPUInfo(data) {
  const relevantAttributes = [PROCESSOR, PHYSICAL_ID, CPU_CORES, CORE_ID]

  let processorStats = {
    logical: null,
    cores: null,
    packages: null
  }

  // In some rare cases the OS may be locked down so that you cannot retrieve this info.
  if (!data) {
    logger.debug('No CPU data to parse, returning empty stats.')
    return processorStats
  }

  // separate the processors
  let splitData = data.split('\n').map(function formatAttribute(attr) {
    return attr.split(':').map(function eliminateExtraWhitespace(s) {
      return s.replace(/\\r|\\t| {2,}/g, '').trim()
    })
  })

  const validData = splitData.filter(function checkForValidAttrs(a) {
    return a.length === 2 && relevantAttributes.indexOf(a[0]) !== -1
  })
  if (validData.length === 0) {
    logger.debug('No applicable cpu attributes found')
    return processorStats
  }

  splitData = collapseMultilineValues(splitData)

  const processors = separateProcessors(splitData)

  p...
const LASP_MAP = {
  // LASP key
  record_sql: {
    // full path to corresponding config key
    path: 'transaction_tracer.record_sql',
    // Mapping from policy enabled status to usable config value
    // policy.enabled: false === off, policy.enabled: true === 'obfuscated'
    allowedValues: ['off', 'obfuscated'],
    // Tracks the precedent of settings controlled by LASP.
    filter: function mostSecureRecordSQL(first, second) {
      // Ordered from least to most secure
      const recordSQLSettings = ['obfuscated', 'off']
      const firstIdx = recordSQLSettings.indexOf(first)
      const secondIdx = recordSQLSettings.indexOf(second)
      if (firstIdx < 0 && secondIdx < 0) {
        // Return the most secure possible
        return recordSQLSettings[recordSQLSettings.length - 1]
      }
      return firstIdx < secondIdx ? second : first
    },
    // Invokes agent method to drop any corresponding data
    clearData: function resetCollectedData(agent) {
      agent._resetQueries()
...
_tmp_0.record_sql = {
    // full path to corresponding config key
    path: 'transaction_tracer.record_sql',
    // Mapping from policy enabled status to usable config value
    // policy.enabled: false === off, policy.enabled: true === 'obfuscated'
    allowedValues: ['off', 'obfuscated'],
    // Tracks the precedent of settings controlled by LASP.
    filter: function mostSecureRecordSQL(first, second) {
      // Ordered from least to most secure
      const recordSQLSettings = ['obfuscated', 'off']
      const firstIdx = recordSQLSettings.indexOf(first)
      const secondIdx = recordSQLSettings.indexOf(second)
      if (firstIdx < 0 && secondIdx < 0) {
        // Return the most secure possible
        return recordSQLSettings[recordSQLSettings.length - 1]
      }
      return firstIdx < secondIdx ? second : first
    },
    // Invokes agent method to drop any corresponding data
    clearData: function resetCollectedData(agent) {
      agent._resetQueries()
    }
  }
defaultConfig.definition = () => ({
  newrelic_home: {
    env: 'NEW_RELIC_HOME',
    default: null
  },

  /**
   * Array of application names.
   */
  app_name: {
    formatter(val) {
      return val.split(/;|,/).map((k) => k.trim())
    },
    default: []
  },
  /**
   * The user's license key. Must be set by per-app configuration file.
   */
  license_key: '',
  /**
   *
   * Enables/Disables security policies.  Paste your security policies
   * token from the New Relic Admin below.
   */
  security_policies_token: '',
  /**
   * Hostname for the New Relic collector proxy.
   *
   * You shouldn't need to change this.
   */
  host: '',
  /**
   * Endpoint to send OpenTelemetry spans to.
   *
   * This should be automatically deduced from your region and other
   * settings, but if desired, you can override it.
   */
  otlp_endpoint: '',
  /**
   * The port on which the collector proxy will be listening.
   *
   * You shouldn't need to change this.
   */
  port: {
    formatter: ...
const CORE_INSTRUMENTATION = {
  child_process: {
    type: MODULE_TYPE.GENERIC,
    file: 'child_process.js'
  },
  crypto: {
    type: MODULE_TYPE.GENERIC,
    file: 'crypto.js'
  },
  // domain: {                     // XXX Do not include domains in this list! The
  //   type: MODULE_TYPE.GENERIC,  // core instrumentations are run at startup by
  //   file: 'domain.js'           // requiring each of their modules. Loading
  // },                            // `domain` has side effects that we try to avoid.
  dns: {
    type: MODULE_TYPE.GENERIC,
    file: 'dns.js'
  },
  fs: {
    type: MODULE_TYPE.GENERIC,
    file: 'fs.js'
  },
  http: {
    type: MODULE_TYPE.TRANSACTION,
    file: 'http.js'
  },
  https: {
    type: MODULE_TYPE.TRANSACTION,
    file: 'http.js'
  },
  inspector: {
    type: MODULE_TYPE.GENERIC,
    file: 'inspector.js'
  },
  net: {
    type: MODULE_TYPE.GENERIC,
    file: 'net.js'
  },
  timers: {
    type: MODULE_TYPE.GENERIC,
    file: 'timers.js'
  },
  zlib: {
 ...
function instrumentClientCommand = function instrumentClientCommand(shim, client, cmd) {
  const { agent } = shim

  shim.recordOperation(client, cmd, function wrapCommand(_shim, _fn, _fnName, args) {
    const [key, value] = args
    const parameters = Object.assign({}, client[opts])
    // If selecting a database, subsequent commands
    // will be using said database, update the clientOptions
    // but not the current parameters(feature parity with v3)
    if (cmd.toLowerCase() === 'select') {
      client[opts].database_name = key
    }
    if (agent.config.attributes.enabled) {
      if (key) {
        parameters.key = JSON.stringify(key)
      }
      if (value) {
        parameters.value = JSON.stringify(value)
      }
    }

    return {
      name: (cmd && cmd.toLowerCase()) || 'other',
      parameters,
      promise: true
    }
  })
}
