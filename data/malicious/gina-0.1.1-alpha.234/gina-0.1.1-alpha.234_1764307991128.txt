var setPID = function(bundle, PID, proc) {

        if ( !/^gina\-/.test(bundle) ) {
            proc.title = 'gina: '+ bundle;
        } else {
            proc.title = bundle;
        }

        //Set event.
        setDefaultEvents(bundle, PID, proc);
    }
self.getUrl = function (route, params, base) {

        //var ctx = SwigFilters().getConfig();
        //var ctx = self.options;
        if (typeof(params) == 'undefined') {
            params = {}
        }
        var ctx  = SwigFilters.instance._options || self.options;

        var config              = null
            , hostname          = null
            , wroot             = null
            , wrootRe           = null
            , isStandalone      = null
            , isMaster          = null
            , isProxyHost       = ctx.isProxyHost
            , routingRules      = null
            , rule              = null
            , url               = NaN
            , urlStr            = null
            , method            = 'GET'
        ;

        if (ctx.options.method != 'undefined') {
            method = ctx.options.method
        }

        // if no route, returns current route
        if ( !route || typeof(route) == 'undefined') {
            route = ctx.options...
var end = function(err) {
        console.debug('GINA_ENV_IS_DEV ', GINA_ENV_IS_DEV);
        if (err) {
            if (GINA_ENV_IS_DEV) {
                console.error(err.stack);
            } else {
                console.error(err.message);
            }

            return process.exit(1);
        }
        var env = local.env;
        console.log('Environment [ '+env+' ] removed with success');

        return process.exit(0)
    }
var makeObject = function(obj, value, args, len, i) {

        if (i >= len) {
            return false
        }

        var key     = args[i];
        var nextKey = ( i < len-1 && typeof(args[i+1]) != 'undefined' ) ?  args[i+1] : null;

        if ( typeof(obj[key]) == 'undefined' ) {
            if (nextKey && /^\d+$/.test(nextKey)) {
                nextKey = parseInt(nextKey);
                obj[key] = []
            } else {
                obj[key] = {}
            }
        }

        for (var o in obj) {

            if ( typeof(obj[o]) == 'object' ) {

                if ( Array.isArray(obj[o]) ) {

                    if (o === key) {

                        var _args = JSON.clone(args);
                        _args.splice(0, 1);

                        for (var a = i, aLen = _args.length; a < aLen; ++a) {
                            key = parseInt(_args[a])
                            obj[o][key] = {};

                            if (a == aLen-1) {
                    ...
gina.onError(function(err, req, res, next){
                // (code)   message
                // (16)     Generic network failure. Enable detailed error codes (via LCB_CNTL_DETAILED_ERRCODES, or via `detailed_errcodes` in the connection string) and/or enable logging to get more information
                // (23)     Client-Side timeout exceeded for operation. Inspect network conditions or increase the timeout
                //          cannot perform operations on a shutdown bucket
                //          err instanceof CouchbaseError

                if (!self.instance.connected) {
                    self.instance.reconnected = false;
                    self.instance.reconnecting = false;
                }

                if (
                    err instanceof couchbase.Error && err.code == 16 && !self.reconnected
                    //||Â err instanceof couchbase.Error && err.code == 23 && !self.reconnecting
                    || /cannot perform operations on a shutdow...
request.login =
            request.logIn = function(user, options, done) {
                if (typeof options == 'function') {
                    done = options;
                    options = {};
                }
                options = options || {};

                var property = 'user';
                if (this._passport && this._passport.instance) {
                    property = this._passport.instance._userProperty || 'user';
                }
                var session = (options.session === undefined) ? true : options.session;

                this[property] = user;

                if (session) {
                    if (!this._passport) { throw new Error('passport.initialize() middleware not in use'); }
                    if (typeof done != 'function') { throw new Error('req#login requires a callback function'); }

                    var self = this;
                    this._passport.instance._sm.logIn(this, user, function(err) {
                    if (err) {
   ...
self.respond = function(sessionId, payload) {
        //process.stdout.write(  '[MQListener] sending `'+ sessionId +'` '+ JSON.stringify(payload) +'\n' );
        sessions[sessionId].write( JSON.stringify(payload) +'\r\n');
    }
this.client.get(sid, function(err, data){
            //Handle Key Not Found error
            if (err && err.code == 13) {
                return fn();
            }
            if (err) return fn(err);
            if (!data || !data.value) return fn();
            var result;
            data = data.value.toString();
            debug('GOT %s', data);
            try {
                result = JSON.parse(data);
            } catch (err) {
                return fn(err);
            }
            return fn(null, result);
        })
var addBundlePorts = function(b) {
        loadAssets();

        if (b > self.bundles.length-1) { // writing to files on complete

            hasPastProtocolAndSchemeCheck(self.defaultProtocol, self.defaultScheme, true);

            //console.debug('self.protocols ...', self.protocols);
            // get user protocols list
            var protocols = JSON.clone(self.protocols);
            // get user schemes list
            var schemes = JSON.clone(self.schemes);
            var projectConfig   = JSON.clone(self.projects);

            //console.debug('about to update project ports conf\n\rBundles: '+ JSON.stringify(self.projectData, null, 4));
            var ports               = JSON.clone(self.portsData) // cloning
                , portsReverse      = JSON.clone(self.portsReverseData) // cloning
                , portsList         = local.ports
                , isPortUsed        = false
                , envs              = self.envs
                , i                 = 0
...
