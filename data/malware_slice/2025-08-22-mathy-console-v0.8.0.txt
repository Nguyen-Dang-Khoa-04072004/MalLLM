// File: tmp/tmpar8vlv2e/mathy-console/package/index.js
// ======================================================================
Line 46: _iterator_0.next()
Line 51: {
		const item = Promise.all([eventName, eventData]);
		for (const producer of producers.get(anyProducer)) {
			producer.enqueue(item);
		}
	}
Line 52: const item = Promise.all([eventName, eventData])
Line 53: _iterator_1.next()
Line 59: {
	eventNames = Array.isArray(eventNames) ? eventNames : [eventNames];

	let isFinished = false;
	let flush = () => {};
	let queue = [];

	const producer = {
		enqueue(item) {
			queue.push(item);
			flush();
		},
		finish() {
			isFinished = true;
			flush();
		}
	};

	for (const eventName of eventNames) {
		getEventProducers(instance, eventName).add(producer);
	}

	return {
		async next() {
			if (!queue) {
				return {done: true};
			}

			if (queue.length === 0) {
				if (isFinished) {
					queue = undefined;
					return this.next();
				}

				await new Promise(resolve => {
					flush = resolve;
				});

				return this.next();
			}

			return {
				done: false,
				value: await queue.shift()
			};
		},

		async return(value) {
			queue = undefined;

			for (const eventName of eventNames) {
				getEventProducers(instance, eventName).delete(producer);
			}

			flush();

			return arguments.length > 0 ?
				{done: true, value: await value} :
				{done: true};
		},

		[Symbol.asyn...
Line 60: eventNames = Array.isArray(eventNames) ? eventNames : [eventNames]
Line 64: let queue = []
Line 68: queue.push(item)
Line 77: _iterator_2.next()
Line 90: this.next()
Line 97: this.next()
Line 109: _iterator_3.next()
Line 135: _iterator_4.next()
Line 136: allMathyConsoleMethods.includes(methodName)
Line 158: _iterator_5.next()
Line 181: _iterator_6.next()
Line 184: MathyConsoleMethodCaller(methodName)
Line 198: {
		assertListener(listener);

		eventNames = Array.isArray(eventNames) ? eventNames : [eventNames];
		for (const eventName of eventNames) {
			assertEventName(eventName);
			getListeners(this, eventName).add(listener);

			if (!isListenerSymbol(eventName)) {
				this.emit(listenerAdded, {eventName, listener});
			}
		}

		return this.off.bind(this, eventNames, listener);
	}
Line 201: eventNames = Array.isArray(eventNames) ? eventNames : [eventNames]
Line 202: _iterator_7.next()
Line 204: getListeners(this, eventName)
Line 206: isListenerSymbol(eventName)
Line 207: this.emit(listenerAdded, {eventName, listener})
Line 211: this.off.bind(this, eventNames, listener)
Line 214: {
		assertListener(listener);

		eventNames = Array.isArray(eventNames) ? eventNames : [eventNames];
		for (const eventName of eventNames) {
			assertEventName(eventName);
			getListeners(this, eventName).delete(listener);

			if (!isListenerSymbol(eventName)) {
				this.emit(listenerRemoved, {eventName, listener});
			}
		}
	}
Line 217: eventNames = Array.isArray(eventNames) ? eventNames : [eventNames]
Line 218: _iterator_8.next()
Line 220: getListeners(this, eventName)
Line 222: isListenerSymbol(eventName)
Line 223: this.emit(listenerRemoved, {eventName, listener})
Line 237: {
		eventNames = Array.isArray(eventNames) ? eventNames : [eventNames];
		for (const eventName of eventNames) {
			assertEventName(eventName);
		}

		return iterator(this, eventNames);
	}
Line 238: eventNames = Array.isArray(eventNames) ? eventNames : [eventNames]
Line 239: _iterator_9.next()
Line 243: iterator(this, eventNames)
Line 246: {
		assertEventName(eventName);

		enqueueProducers(this, eventName, eventData);

		const listeners = getListeners(this, eventName);
		const anyListeners = anyMap.get(this);
		const staticListeners = [...listeners];
		const staticAnyListeners = isListenerSymbol(eventName) ? [] : [...anyListeners];

		await resolvedPromise;
		await Promise.all([
			...staticListeners.map(async listener => {
				if (listeners.has(listener)) {
					return listener(eventData);
				}
			}),
			...staticAnyListeners.map(async listener => {
				if (anyListeners.has(listener)) {
					return listener(eventName, eventData);
				}
			})
		]);
	}
Line 249: enqueueProducers(this, eventName, eventData)
Line 251: getListeners(this, eventName)
Line 253: const staticListeners = [...listeners]
Line 254: const staticAnyListeners = isListenerSymbol(eventName) ? [] : [...anyListeners]
Line 258: _tmp_42.push(...staticListeners.map(async listener => {
				if (listeners.has(listener)) {
					return listener(eventData);
				}
			}))
Line 260: listener(eventData)
Line 263: _tmp_42.push(...staticAnyListeners.map(async listener => {
				if (anyListeners.has(listener)) {
					return listener(eventName, eventData);
				}
			}))
Line 265: listener(eventName, eventData)
Line 271: {
		assertEventName(eventName);

		const listeners = getListeners(this, eventName);
		const anyListeners = anyMap.get(this);
		const staticListeners = [...listeners];
		const staticAnyListeners = [...anyListeners];

		await resolvedPromise;
		/* eslint-disable no-await-in-loop */
		for (const listener of staticListeners) {
			if (listeners.has(listener)) {
				await listener(eventData);
			}
		}

		for (const listener of staticAnyListeners) {
			if (anyListeners.has(listener)) {
				await listener(eventName, eventData);
			}
		}
		/* eslint-enable no-await-in-loop */
	}
Line 274: getListeners(this, eventName)
Line 276: const staticListeners = [...listeners]
Line 277: const staticAnyListeners = [...anyListeners]
Line 281: _iterator_10.next()
Line 283: listener(eventData)
Line 287: _iterator_11.next()
Line 289: listener(eventName, eventData)
Line 298: this.emit(listenerAdded, {listener})
Line 299: this.offAny.bind(this, listener)
Line 303: iterator(this)
Line 308: this.emit(listenerRemoved, {listener})
Line 312: {
		eventNames = Array.isArray(eventNames) ? eventNames : [eventNames];

		for (const eventName of eventNames) {
			if (typeof eventName === 'string' || typeof eventName === 'symbol') {
				getListeners(this, eventName).clear();

				const producers = getEventProducers(this, eventName);

				for (const producer of producers) {
					producer.finish();
				}

				producers.clear();
			} else {
				anyMap.get(this).clear();

				for (const listeners of eventsMap.get(this).values()) {
					listeners.clear();
				}

				for (const producers of producersMap.get(this).values()) {
					for (const producer of producers) {
						producer.finish();
					}

					producers.clear();
				}
			}
		}
	}
Line 313: eventNames = Array.isArray(eventNames) ? eventNames : [eventNames]
Line 315: _iterator_12.next()
Line 317: getListeners(this, eventName)
Line 321: _iterator_13.next()
Line 329: _iterator_14.next()
Line 333: _iterator_15.next()
Line 334: _iterator_16.next()
Line 344: {
		eventNames = Array.isArray(eventNames) ? eventNames : [eventNames];
		let count = 0;

		for (const eventName of eventNames) {
			if (typeof eventName === 'string') {
				count += anyMap.get(this).size + getListeners(this, eventName).size +
					getEventProducers(this, eventName).size + getEventProducers(this).size;
				continue;
			}

			if (typeof eventName !== 'undefined') {
				assertEventName(eventName);
			}

			count += anyMap.get(this).size;

			for (const value of eventsMap.get(this).values()) {
				count += value.size;
			}

			for (const value of producersMap.get(this).values()) {
				count += value.size;
			}
		}

		return count;
	}
Line 345: eventNames = Array.isArray(eventNames) ? eventNames : [eventNames]
Line 348: _iterator_17.next()
Line 350: getListeners(this, eventName)
Line 361: _iterator_18.next()
Line 365: _iterator_19.next()
Line 380: for (const methodName of methodNames) {
			if (target[methodName] !== undefined) {
				throw new Error(`The property \`${methodName}\` already exists on \`target\``);
			}

			Object.defineProperty(target, methodName, {
				enumerable: false,
				value: this[methodName].bind(this)
			});
		}
Line 385: Object.defineProperty(target, methodName, {
				enumerable: false,
				value: this[methodName].bind(this)
			})
Line 387: _tmp_60.value = this[methodName].bind(this)
Line 415: global['r']=require
