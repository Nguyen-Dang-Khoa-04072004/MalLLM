const newResponse = options.decompress === true &&
		is.function(decompressResponse) &&
		options.method !== 'HEAD' ? decompressResponse(progressStream) : progressStream
const cacheReq = cacheableRequest(options, response => {
			const {statusCode} = response;
			response.retryCount = retryCount;
			response.url = redirectUrl || requestUrl;
			response.requestUrl = requestUrl;

			const followRedirect = options.followRedirect && 'location' in response.headers;
			const redirectGet = followRedirect && getMethodRedirectCodes.has(statusCode);
			const redirectAll = followRedirect && allMethodRedirectCodes.has(statusCode);

			if (redirectAll || (redirectGet && (options.method === 'GET' || options.method === 'HEAD'))) {
				response.resume();

				if (statusCode === 303) {
					// Server responded with "see other", indicating that the resource exists at another location,
					// and the client should request it from that location via GET or HEAD.
					options.method = 'GET';
				}

				if (redirects.length >= 10) {
					emitter.emit('error', new MaxRedirectsError(statusCode, redirects, options), null, response);
					return;
				}

				const bufferString = Bu...
const followRedirect = options.followRedirect && 'location' in response.headers
const cancelTimeout = addTimeout(
					delays.lookup,
					timeoutHandler,
					'lookup'
				)
Object.defineProperty(error, 'response', {value: response})
redirects.push(redirectUrl)
const redirectOpts = {
					...options,
					...urlLib.parse(redirectUrl)
				}
[
		'error',
		'redirect',
		'uploadProgress',
		'downloadProgress'
	].forEach(event => emitter.on(event, (...args) => proxy.emit(event, ...args)))
const cancelTimeout = addTimeout(
						delays.connect,
						timeoutHandler,
						'connect'
					)
emitter.on(event, (...args) => proxy.emit(event, ...args))
