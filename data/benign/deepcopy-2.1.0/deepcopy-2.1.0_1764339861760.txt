function copy = function copy(value, type = null, customizer = noop) {
  if (arguments.length === 2 && typeof type === 'function') {
    customizer = type;
    type = null;
  }

  const valueType = type || detectType(value);
  const copyFunction = copyMap.get(valueType);

  if (valueType === 'Object') {
    const result = customizer(value, valueType);

    if (result !== undefined) {
      return result;
    }
  }

  // NOTE: TypedArray needs pass type to argument
  return copyFunction ? copyFunction(value, valueType) : value;
}
function _arrayLikeToArray = function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function detectType = function detectType(value) {
  // NOTE: isBuffer must execute before type-detect,
  // because type-detect returns 'Uint8Array'.
  if ((0, _buffer.isBuffer)(value)) {
    return 'Buffer';
  }

  return (0, _typeDetect.default)(value);
}
function (global, factory) {
		 module.exports = factory() ;
	}(commonjsGlobal, (function () {
	/* !
	 * type-detect
	 * Copyright(c) 2013 jake luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */
	var promiseExists = typeof Promise === 'function';

	/* eslint-disable no-undef */
	var globalObject = typeof self === 'object' ? self : commonjsGlobal; // eslint-disable-line id-blacklist

	var symbolExists = typeof Symbol !== 'undefined';
	var mapExists = typeof Map !== 'undefined';
	var setExists = typeof Set !== 'undefined';
	var weakMapExists = typeof WeakMap !== 'undefined';
	var weakSetExists = typeof WeakSet !== 'undefined';
	var dataViewExists = typeof DataView !== 'undefined';
	var symbolIteratorExists = symbolExists && typeof Symbol.iterator !== 'undefined';
	var symbolToStringTagExists = symbolExists && typeof Symbol.toStringTag !== 'undefined';
	var setEntriesExists = setExists && typeof Set.prototype.entries === 'function';
	var mapEntriesExists = mapExists && typeof Map.pr...
const copyFunction = copyMap.get(valueType)
function copy = function copy(value, type = null, customizer = noop) {
  if (arguments.length === 2 && typeof type === 'function') {
    customizer = type;
    type = null;
  }

  const valueType = type || (0, _detector.detectType)(value);

  const copyFunction = _copy_map.default.get(valueType);

  if (valueType === 'Object') {
    const result = customizer(value, valueType);

    if (result !== undefined) {
      return result;
    }
  } // NOTE: TypedArray needs pass type to argument


  return copyFunction ? copyFunction(value, valueType) : value;
}
function copyBoolean = function copyBoolean(value) {
  return new Boolean(value.valueOf());
}
var promiseExists = typeof Promise === 'function'
var globalObject = typeof self === 'object' ? self : commonjsGlobal
const copyFunction = _copy_map.default.get(valueType)
var stringIteratorPrototype = stringIteratorExists && Object.getPrototypeOf(''[Symbol.iterator]())
function isCollection = function isCollection(type) {
  return collectionTypeSet.has(type);
}
!isCollection(type)
const type = (0, _detector.detectType)(value)
function copyNumber = function copyNumber(value) {
  return new Number(value);
}
function copyDate = function copyDate(value) {
  return new Date(value.getTime());
}
const valueType = type || (0, _detector.detectType)(collection)
keys.push(...Object.getOwnPropertySymbols(value))
keys = Object.keys(value)
keys.push(...Object.getOwnPropertySymbols(value))
_iterator_0 = <operator>.iterator(keys)
const collectionValue = get(value, collectionKey, type)
function copyString = function copyString(value) {
  return new String(value);
}
set(clone, collectionKey, references.get(collectionValue), type)
function copyRegExp = function copyRegExp(value) {
  return new RegExp(value.source, value.flags);
}
const copiedCollectionValue = copy(collectionValue, collectionValueType)
var _iterator = _createForOfIteratorHelper(keys)
references.set(collectionValue, copiedCollectionValue)
!(_step = _iterator.n()).done
set(
        clone,
        collectionKey,
        recursiveCopy(
          collectionValue,
          copiedCollectionValue,
          references,
          visited,
          customizer
        ),
        type
      )
const collectionValue = (0, _collection.get)(value, collectionKey, type)
function copyString = function copyString(value) {
  return new String(value);
}
recursiveCopy(
          collectionValue,
          copiedCollectionValue,
          references,
          visited,
          customizer
        )
(0, _collection.set)(clone, collectionKey, references.get(collectionValue), type)
{
        const collectionValueType = (0, _detector.detectType)(collectionValue);
        const copiedCollectionValue = (0, _copier.copy)(collectionValue, collectionValueType); // save reference if value is collection

        if ((0, _collection.isCollection)(collectionValueType)) {
          references.set(collectionValue, copiedCollectionValue);
          visited.add(collectionValue);
        }

        (0, _collection.set)(clone, collectionKey, recursiveCopy(collectionValue, copiedCollectionValue, references, visited, customizer), type);
      }
const collectionValueType = (0, _detector.detectType)(collectionValue)
const copiedCollectionValue = (0, _copier.copy)(collectionValue, collectionValueType)
(0, _collection.isCollection)(collectionValueType)
references.set(collectionValue, copiedCollectionValue)
(0, _collection.set)(clone, collectionKey, recursiveCopy(collectionValue, copiedCollectionValue, references, visited, customizer), type)
function copy$1 = function copy$1(value, type = null, customizer = noop) {
	  if (arguments.length === 2 && typeof type === 'function') {
	    customizer = type;
	    type = null;
	  }

	  const valueType = type || detectType(value);
	  const copyFunction = copyMap.get(valueType);

	  if (valueType === 'Object') {
	    const result = customizer(value, valueType);

	    if (result !== undefined) {
	      return result;
	    }
	  }

	  // NOTE: TypedArray needs pass type to argument
	  return copyFunction ? copyFunction(value, valueType) : value;
	}
arguments.length === 2 && typeof type === 'function'
type = null
const valueType = type || detectType(value)
const copyFunction = copyMap.get(valueType)
const type = detectType(value)
const copiedValue = copy$1(value, type)
!isCollection(type)
keys = Object.keys(value)
keys.push(...Object.getOwnPropertySymbols(value))
_iterator_0 = <operator>.iterator(keys)
const collectionValue = get(value, collectionKey, type)
visited.has(collectionValue)
set(clone, collectionKey, references.get(collectionValue), type)
const collectionValueType = detectType(collectionValue)
const copiedCollectionValue = copy$1(collectionValue, collectionValueType)
isCollection(collectionValueType)
references.set(collectionValue, copiedCollectionValue)
set(
	        clone,
	        collectionKey,
	        recursiveCopy(
	          collectionValue,
	          copiedCollectionValue,
	          references,
	          visited),
	        type
	      )
clone
recursiveCopy(
	          collectionValue,
	          copiedCollectionValue,
	          references,
	          visited)
references
type
