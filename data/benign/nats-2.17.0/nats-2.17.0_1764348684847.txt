__awaiter(this, void 0, void 0, function* () {
            (0, jsutil_1.validateStreamName)(stream);
            // if doing a last_by_subj request, we append the subject
            // this allows last_by_subj to be subject to permissions (KV)
            let qq = query;
            const { last_by_subj } = qq;
            if (last_by_subj) {
                qq = null;
            }
            const payload = qq ? this.jc.encode(qq) : encoders_1.Empty;
            const pre = this.opts.apiPrefix || "$JS.API";
            const subj = last_by_subj
                ? `${pre}.DIRECT.GET.${stream}.${last_by_subj}`
                : `${pre}.DIRECT.GET.${stream}`;
            const r = yield this.nc.request(subj, payload);
            // response is not a JS.API response
            const err = (0, jsutil_1.checkJsError)(r);
            if (err) {
                return Promise.reject(err);
            }
            const dm = new DirectMsgImpl(r);
            return Promise.resolve(dm);...
function parseInfo = function parseInfo(s) {
    const tokens = s.split(".");
    if (tokens.length === 9) {
        tokens.splice(2, 0, "_", "");
    }
    if ((tokens.length < 11) || tokens[0] !== "$JS" || tokens[1] !== "ACK") {
        throw new Error(`not js message`);
    }
    // old
    // "$JS.ACK.<stream>.<consumer>.<redeliveryCount><streamSeq><deliverySequence>.<timestamp>.<pending>"
    // new
    // $JS.ACK.<domain>.<accounthash>.<stream>.<consumer>.<redeliveryCount>.<streamSeq>.<deliverySequence>.<timestamp>.<pending>.<random>
    const di = {};
    // if domain is "_", replace with blank
    di.domain = tokens[2] === "_" ? "" : tokens[2];
    di.account_hash = tokens[3];
    di.stream = tokens[4];
    di.consumer = tokens[5];
    di.redeliveryCount = parseInt(tokens[6], 10);
    di.redelivered = di.redeliveryCount > 1;
    di.streamSequence = parseInt(tokens[7], 10);
    di.deliverySequence = parseInt(tokens[8], 10);
    di.timestampNanos = parseInt(tokens[9], 10);
    di.pending = parseIn...
function buildAuthenticator = function buildAuthenticator(opts) {
    const buf = [];
    // jwtAuthenticator is created by the user, since it
    // will require possibly reading files which
    // some of the clients are simply unable to do
    if (typeof opts.authenticator === "function") {
        buf.push(opts.authenticator);
    }
    if (Array.isArray(opts.authenticator)) {
        buf.push(...opts.authenticator);
    }
    if (opts.token) {
        buf.push((0, authenticator_1.tokenAuthenticator)(opts.token));
    }
    if (opts.user) {
        buf.push((0, authenticator_1.usernamePasswordAuthenticator)(opts.user, opts.pass));
    }
    return buf.length === 0 ? (0, authenticator_1.noAuthFn)() : (0, authenticator_1.multiAuthenticator)(buf);
}
(function (ConsumerEvents) {
    /**
     * Notification that heartbeats were missed. This notification is informational.
     * The `data` portion of the status, is a number indicating the number of missed heartbeats.
     * Note that when a client disconnects, heartbeat tracking is paused while
     * the client is disconnected.
     */
    ConsumerEvents["HeartbeatsMissed"] = "heartbeats_missed";
})(ConsumerEvents || (exports.ConsumerEvents = ConsumerEvents = {}))
__awaiter(this, void 0, void 0, function* () {
            opts = opts || {};
            opts.timeout = this.timeout;
            let a = encoders_1.Empty;
            if (data) {
                a = this.jc.encode(data);
            }
            const m = yield this.nc.request(subj, a, opts);
            return this.parseJsResponse(m);
        })
(function (ConsumerDebugEvents) {
    /**
     * DebugEvents are effectively statuses returned by the server that were ignored
     * by the client. The `data` portion of the
     * status is just a string indicating the code/message of the status.
     */
    ConsumerDebugEvents["DebugEvent"] = "debug";
    /**
     * Requests for messages can be terminated by the server, these notifications
     * provide information on the number of messages and/or bytes that couldn't
     * be satisfied by the consumer request. The `data` portion of the status will
     * have the format of `{msgsLeft: number, bytesLeft: number}`.
     */
    ConsumerDebugEvents["Discard"] = "discard";
    /**
     * Notifies whenever there's a request for additional messages from the server.
     * This notification telegraphs the request options, which should be treated as
     * read-only. This notification is only useful for debugging. Data is PullOptions.
     */
    ConsumerDebugEvents["Next"] = "next";
})...
__asyncGenerator(this, arguments, function* iterate_1() {
            if (this.noIterator) {
                throw new core_1.NatsError("unsupported iterator", core_1.ErrorCode.ApiError);
            }
            try {
                while (true) {
                    if (this.yields.length === 0) {
                        yield __await(this.signal);
                    }
                    if (this.err) {
                        throw this.err;
                    }
                    const yields = this.yields;
                    this.inflight = yields.length;
                    this.yields = [];
                    for (let i = 0; i < yields.length; i++) {
                        if (typeof yields[i] === "function") {
                            const fn = yields[i];
                            try {
                                fn();
                            }
                            catch (err) {
                                // failed on the invocation - fail...
__awaiter(this, void 0, void 0, function* () {
            if (typeof name === "object") {
                return this.ordered(stream, name);
            }
            // check we have support for pending msgs and header notifications
            yield this.checkVersion();
            return this.api.info(stream, name)
                .then((ci) => {
                if (ci.config.deliver_subject !== undefined) {
                    return Promise.reject(new Error("push consumer not supported"));
                }
                return new consumer_1.PullConsumerImpl(this.api, ci);
            })
                .catch((err) => {
                return Promise.reject(err);
            });
        })
__awaiter(this, void 0, void 0, function* () {
            opts = opts || {};
            opts.expect = opts.expect || {};
            const mh = (opts === null || opts === void 0 ? void 0 : opts.headers) || (0, headers_1.headers)();
            if (opts) {
                if (opts.msgID) {
                    mh.set(PubHeaders.MsgIdHdr, opts.msgID);
                }
                if (opts.expect.lastMsgID) {
                    mh.set(PubHeaders.ExpectedLastMsgIdHdr, opts.expect.lastMsgID);
                }
                if (opts.expect.streamName) {
                    mh.set(PubHeaders.ExpectedStreamHdr, opts.expect.streamName);
                }
                if (typeof opts.expect.lastSequence === "number") {
                    mh.set(PubHeaders.ExpectedLastSeqHdr, `${opts.expect.lastSequence}`);
                }
                if (typeof opts.expect.lastSubjectSequence === "number") {
                    mh.set(PubHeaders.ExpectedLastSubjectSequenceHdr, `${opts.expe...
Object.defineProperty(exports, "Events", { enumerable: true, get: function () { return core_1.Events; } })
cfg.durable_name ? <operator>.formatString("", this.prefix, ".CONSUMER.DURABLE.CREATE.", stream, ".", cfg.durable_name, "") : <operator>.formatString("", this.prefix, ".CONSUMER.CREATE.", stream, "")
function credsAuthenticator = function credsAuthenticator(creds) {
    const fn = typeof creds !== "function" ? () => creds : creds;
    const parse = () => {
        const CREDS = /\s*(?:(?:[-]{3,}[^\n]*[-]{3,}\n)(.+)(?:\n\s*[-]{3,}[^\n]*[-]{3,}\n))/ig;
        const s = encoders_1.TD.decode(fn());
        // get the JWT
        let m = CREDS.exec(s);
        if (!m) {
            throw core_1.NatsError.errorForCode(core_1.ErrorCode.BadCreds);
        }
        const jwt = m[1].trim();
        // get the nkey
        m = CREDS.exec(s);
        if (!m) {
            throw core_1.NatsError.errorForCode(core_1.ErrorCode.BadCreds);
        }
        if (!m) {
            throw core_1.NatsError.errorForCode(core_1.ErrorCode.BadCreds);
        }
        const seed = encoders_1.TE.encode(m[1].trim());
        return { jwt, seed };
    };
    const jwtFn = () => {
        const { jwt } = parse();
        return jwt;
    };
    const nkeyFn = () => {
        const { seed } = parse();
        return seed;
    };
    retu...
Object.defineProperty(exports, "isNatsError", { enumerable: true, get: function () { return core_3.isNatsError; } })
this.callback = (err, msg) => {
                const { ingest } = ingestion(msg);
                if (!ingest) {
                    return;
                }
                if (filter(msg)) {
                    uc(err, msg);
                    dispatched(msg);
                }
            }
this.nc.subscribe(`$JS.EVENT.ADVISORY.>`, {
            callback: (err, msg) => {
                if (err) {
                    throw err;
                }
                try {
                    const d = this.parseJsResponse(msg);
                    const chunks = d.type.split(".");
                    const kind = chunks[chunks.length - 1];
                    iter.push({ kind: kind, data: d });
                }
                catch (err) {
                    iter.stop(err);
                }
            },
        })
this.sub = c.api.nc.subscribe(this.inbox, {
            callback: (err, msg) => {
                var _a, _b, _c, _d;
                if (err) {
                    // this is possibly only a permissions error which means
                    // that the server rejected (eliminating the sub)
                    // or the client never had permissions to begin with
                    // so this is terminal
                    this.stop();
                    return;
                }
                (_a = this.monitor) === null || _a === void 0 ? void 0 : _a.work();
                const isProtocol = msg.subject === this.inbox;
                if (isProtocol) {
                    if ((0, jsutil_1.isHeartbeatMsg)(msg)) {
                        return;
                    }
                    const code = (_b = msg.headers) === null || _b === void 0 ? void 0 : _b.code;
                    const description = ((_d = (_c = msg.headers) === null || _c === void 0 ? void 0 : _c.descriptio...
function validSubjectName = function validSubjectName(context, subj) {
    if (subj === "") {
        throw new Error(`${context} cannot be empty`);
    }
    if (subj.indexOf(" ") !== -1) {
        throw new Error(`${context} cannot contain spaces: '${subj}'`);
    }
    const tokens = subj.split(".");
    tokens.forEach((v, idx) => {
        if (v === ">" && idx !== tokens.length - 1) {
            throw new Error(`${context} cannot have internal '>': '${subj}'`);
        }
    });
}
(function (Js409Errors) {
    Js409Errors["MaxBatchExceeded"] = "exceeded maxrequestbatch of";
    Js409Errors["MaxExpiresExceeded"] = "exceeded maxrequestexpires of";
    Js409Errors["MaxBytesExceeded"] = "exceeded maxrequestmaxbytes of";
    Js409Errors["MaxMessageSizeExceeded"] = "message size exceeds maxbytes";
    Js409Errors["PushConsumer"] = "consumer is push based";
    Js409Errors["MaxWaitingExceeded"] = "exceeded maxwaiting";
    Js409Errors["IdleHeartbeatMissed"] = "idle heartbeats missed";
    Js409Errors["ConsumerDeleted"] = "consumer deleted";
    // FIXME: consumer deleted - instead of no responder (terminal error)
    //   leadership changed -
})(Js409Errors || (exports.Js409Errors = Js409Errors = {}))
Js409Errors["MaxMessageSizeExceeded"] = "message size exceeds maxbytes"
__awaiter(this, void 0, void 0, function* () {
            validateBucket(name);
            const jsm = yield js.jetstreamManager();
            const bucket = new Bucket(name, js, jsm);
            yield bucket.init(opts);
            return bucket;
        })
__awaiter(this, void 0, void 0, function* () {
            (0, jsutil_1.validateStreamName)(stream);
            (0, jsutil_1.validateDurableName)(durable);
            let timeout = this.timeout;
            if (expires > timeout) {
                timeout = expires;
            }
            expires = expires < 0 ? 0 : (0, jsutil_1.nanos)(expires);
            const pullOpts = {
                batch: 1,
                no_wait: expires === 0,
                expires,
            };
            const msg = yield this.nc.request(`${this.prefix}.CONSUMER.MSG.NEXT.${stream}.${durable}`, this.jc.encode(pullOpts), { noMux: true, timeout });
            const err = (0, jsutil_1.checkJsError)(msg);
            if (err) {
                throw err;
            }
            return (0, jsmsg_1.toJsMsg)(msg);
        })
(0, jsutil_1.validateStreamName)(stream)
ServiceImpl = package/lib/nats-base-client/service.js::program:ServiceImpl:<init>
function dtoi = function dtoi(s) {
    let i = 0;
    let n = 0;
    for (i = 0; i < s.length && ASCII0 <= s.charCodeAt(i) && s.charCodeAt(i) <= ASCII9; i++) {
        n = n * 10 + (s.charCodeAt(i) - ASCII0);
        if (n >= big) {
            return { n: big, c: i, ok: false };
        }
    }
    if (i === 0) {
        return { n: 0, c: 0, ok: false };
    }
    return { n: n, c: i, ok: true };
}
const toErr = () => {
                            const err = new core_1.NatsError(description, `${code}`);
                            err.stack += `\n\n${this.stack}`;
                            return err;
                        }
(function (RequestStrategy) {
    RequestStrategy["Timer"] = "timer";
    RequestStrategy["Count"] = "count";
    RequestStrategy["JitterTimer"] = "jitterTimer";
    RequestStrategy["SentinelMsg"] = "sentinelMsg";
})(RequestStrategy || (exports.RequestStrategy = RequestStrategy = {}))
function isTerminal409 = function isTerminal409(err) {
    if (err.code !== core_1.ErrorCode.JetStream409) {
        return false;
    }
    const fatal = [
        Js409Errors.MaxBatchExceeded,
        Js409Errors.MaxExpiresExceeded,
        Js409Errors.MaxBytesExceeded,
        Js409Errors.MaxMessageSizeExceeded,
        Js409Errors.PushConsumer,
        Js409Errors.IdleHeartbeatMissed,
        Js409Errors.ConsumerDeleted,
    ];
    if (MAX_WAITING_FAIL) {
        fatal.push(Js409Errors.MaxWaitingExceeded);
    }
    return fatal.find((s) => {
        return err.message.indexOf(s) !== -1;
    }) !== undefined;
}
match = match === void 0 ? core_1.Match.Exact : match
const arg = this.argBuf
                                ? this.argBuf.bytes()
                                : buf.subarray(this.as, i - this.drop)
const job = (() => __awaiter(this, void 0, void 0, function* () {
                    if (this.asyncRequests) {
                        this.perf.mark("reqStart");
                        const a = [];
                        for (let i = 0; i < this.msgs; i++) {
                            a.push(this.nc.request(this.subject, this.payload, { timeout: 20000 }));
                        }
                        yield Promise.all(a);
                        this.perf.mark("reqStop");
                        this.perf.measure("req", "reqStart", "reqStop");
                    }
                    else {
                        this.perf.mark("reqStart");
                        for (let i = 0; i < this.msgs; i++) {
                            yield this.nc.request(this.subject);
                        }
                        this.perf.mark("reqStop");
                        this.perf.measure("req", "reqStart", "reqStop");
                    }
                }))()
qi.getPending() === 1 && m.info.pending === 0 || wants === received ||
                    (max_bytes > 0 && receivedBytes >= max_bytes)
this.servers.forEach((s, index) => {
            const u = s.listen;
            if (s.gossiped && this.currentServer.listen !== u &&
                discovered.get(u) === undefined) {
                // server was removed
                toDelete.push(index);
            }
            // remove this entry from reported
            discovered.delete(u);
        })
__awaiter(this, void 0, void 0, function* () {
            let info = yield this._si();
            if (info === null) {
                return Promise.reject(new Error("object store not found"));
            }
            info.config.sealed = true;
            info = yield this.jsm.streams.update(this.stream, info.config);
            return Promise.resolve(new ObjectStoreStatusImpl(info));
        })
const job = (() => __awaiter(this, void 0, void 0, function* () {
                    if (this.asyncRequests) {
                        this.perf.mark("reqStart");
                        const a = [];
                        for (let i = 0; i < this.msgs; i++) {
                            a.push(this.nc.request(this.subject, this.payload, { timeout: 20000 }));
                        }
                        yield Promise.all(a);
                        this.perf.mark("reqStop");
                        this.perf.measure("req", "reqStart", "reqStop");
                    }
                    else {
                        this.perf.mark("reqStart");
                        for (let i = 0; i < this.msgs; i++) {
                            yield this.nc.request(this.subject);
                        }
                        this.perf.mark("reqStop");
                        this.perf.measure("req", "reqStart", "reqStop");
                    }
                }))()
h0 = tmp + (h1 & h2 ^ h3 & (h1 ^ h2)) + (h1 >>> 2 ^ h1 >>> 13 ^ h1 >>> 22 ^ h1 << 30 ^ h1 << 19 ^ h1 << 10) | 0
__awaiter(this, void 0, void 0, function* () {
            this.connected = false;
            if (!this.isClosed()) {
                // if the transport gave an error use that, otherwise
                // we may have received a protocol error
                yield this.disconnected(this.transport.closeError || this.lastError);
                return;
            }
        })
const discard = {
            msgsLeft: 0,
            bytesLeft: 0,
        }
