(0, rxjs_1.from)(this.records()).pipe((0, rxjs_1.concatMap)((record) => {
            switch (record.kind) {
                case 'delete':
                    return host.delete(record.path);
                case 'rename':
                    return host.rename(record.from, record.to);
                case 'create':
                    return host.exists(record.path).pipe((0, rxjs_1.switchMap)((exists) => {
                        if (exists && !force) {
                            return (0, rxjs_1.throwError)(new exception_1.FileAlreadyExistException(record.path));
                        }
                        else {
                            return host.write(record.path, record.content);
                        }
                    }));
                case 'overwrite':
                    return host.exists(record.path).pipe((0, rxjs_1.switchMap)((exists) => {
                        if (!exists && !force) {
                            return (0, rxjs_1.throwError)(new ...
maybeWatcher.forEach((watcher) => {
                const [options, subject] = watcher;
                subject.next({ path, time, type });
                if (!options.persistent && type == 2 /* HostWatchEventType.Deleted */) {
                    subject.complete();
                    this._watchers.delete(currentPath);
                }
            })
const adjustedSchema = (0, utils_1.isJsonArray)(propertySchemas) &&
                    propertySchemas.find((s) => {
                        if (!(0, utils_1.isJsonObject)(s)) {
                            return false;
                        }
                        const schemaType = (0, utility_1.getTypesOfSchema)(s);
                        if (schemaType.size === 1 && schemaType.has('object') && (0, utils_1.isJsonObject)(s.properties)) {
                            const properties = Object.keys(s.properties);
                            return allProperties.every((key) => properties.includes(key));
                        }
                        return false;
                    })
host.exists(record.path).pipe((0, rxjs_1.switchMap)((exists) => {
                        if (exists && !force) {
                            return (0, rxjs_1.throwError)(new exception_1.FileAlreadyExistException(record.path));
                        }
                        else {
                            return host.write(record.path, record.content);
                        }
                    }))
watcher
                .on('change', (path) => {
                obs.next({
                    path: (0, src_1.normalize)(path),
                    time: new Date(),
                    type: 0 /* virtualFs.HostWatchEventType.Changed */,
                });
            })
                .on('add', (path) => {
                obs.next({
                    path: (0, src_1.normalize)(path),
                    time: new Date(),
                    type: 1 /* virtualFs.HostWatchEventType.Created */,
                });
            })
                .on('unlink', (path) => {
                obs.next({
                    path: (0, src_1.normalize)(path),
                    time: new Date(),
                    type: 2 /* virtualFs.HostWatchEventType.Deleted */,
                });
            })
(0, rxjs_1.concat)(this.exists(to), this.exists(from)).pipe((0, rxjs_1.toArray)(), (0, rxjs_1.switchMap)(([existTo, existFrom]) => {
            if (!existFrom) {
                return (0, rxjs_1.throwError)(new exception_1.FileDoesNotExistException(from));
            }
            if (from === to) {
                return rxjs_1.EMPTY;
            }
            if (existTo) {
                return (0, rxjs_1.throwError)(new exception_1.FileAlreadyExistException(to));
            }
            // If we're renaming a file that's been created, shortcircuit to creating the `to` path.
            if (this._filesToCreate.has(from)) {
                this._filesToCreate.delete(from);
                this._filesToCreate.add(to);
                return super.rename(from, to);
            }
            if (this._filesToOverwrite.has(from)) {
                this._filesToOverwrite.delete(from);
                // Recursively call this function. This is so we don't repeat the bottom logic. ...
(_tmp_70 = this._filesToCreate).has
(_tmp_49 = Buffer.from(code.map.toString())).toString
_iterator_6 = <operator>.iterator(this._cache.keys())
p.startsWith(path_1.NormalizedSep) && p !== path_1.NormalizedRoot
const validate = await this._compile(schema)
(_tmp_75 = this._filesToOverwrite).delete
(0, rxjs_1.concat)(this.rename(from, to), new rxjs_1.Observable((x) => {
                    this._filesToOverwrite.add(to);
                    x.complete();
                }))
const maybeTo1 = this._filesToRenameRevert.get(from)
(_tmp_84 = this._filesToRename).delete
validator = await this._ajv.compileAsync(schema)
(_tmp_86 = this._filesToRename).set
this._currentCompilationSchemaInfo = undefined
const fn = Function('module', source)
const validationOptions = {
                withPrompts: true,
                applyPostTransforms: true,
                applyPreTransforms: true,
                ...options,
            }
this._back.read(from).pipe((0, rxjs_1.switchMap)((content) => super.write(to, content)))
