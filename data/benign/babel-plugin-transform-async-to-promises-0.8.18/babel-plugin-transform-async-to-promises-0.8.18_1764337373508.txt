const init = statement.get("init")
init.isVariableDeclaration() && init.node.declarations.length === 1
(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject)
const test = statement.get("test")
test.isBinaryExpression()
const right = test.get("right")
shouldContinue.then(_resumeAfterTest).then(void 0, reject)
update.isUpdateExpression() &&
                                update.node.operator == "++" &&
                                types.isIdentifier(update.node.argument) &&
                                update.node.argument.name === i.name
const updateArgument = update.get("argument")
result.then(_resumeAfterBody).then(void 0, reject)
left.isVariableDeclaration()
left = left.get("declarations")[0].get("id")
let body = path.get("body")
body.isBlockStatement()
statements = body.get("body")
body.isReturnStatement()
const argument = body.get("argument")
argument.isCallExpression() &&
                            invokeTypeOfExpression(argument) &&
                            argument.get("arguments").length === 1
invokeTypeOfExpression(argument)
argument.get("arguments").length === 1
const firstArgument = argument.get("arguments")[0]
function _switch = function _switch(discriminant, cases) {
	var dispatchIndex = -1;
	var awaitBody;
	outer: {
		for (var i = 0; i < cases.length; i++) {
			var test = cases[i][0];
			if (test) {
				var testValue = test();
				if (testValue && testValue.then) {
					break outer;
				}
				if (testValue === discriminant) {
					dispatchIndex = i;
					break;
				}
			} else {
				// Found the default case, set it as the pending dispatch case
				dispatchIndex = i;
			}
		}
		if (dispatchIndex !== -1) {
			do {
				var body = cases[dispatchIndex][1];
				while (!body) {
					dispatchIndex++;
					body = cases[dispatchIndex][1];
				}
				var result = body();
				if (result && result.then) {
					awaitBody = true;
					break outer;
				}
				var fallthroughCheck = cases[dispatchIndex][2];
				dispatchIndex++;
			} while (fallthroughCheck && !fallthroughCheck());
			return result;
		}
	}
	const pact = new _Pact();
	const reject = _settle.bind(null, pact, 2);
	(awaitBody ? result.then(_resumeAfterBody) : t...
body = statements[0]
body.isIfStatement() && !body.node.alternate
const test = body.get("test")
test.isCallExpression() && test.node.arguments.length === 2
const args = test.get("arguments")
const callee = test.get("callee")
callee.isMemberExpression() && propertyNameOfMemberExpression(callee.node) === "call"
let method = callee.get("object")
method.isMemberExpression() &&
                                    propertyNameOfMemberExpression(method.node) === "hasOwnProperty"
propertyNameOfMemberExpression(method.node) === "hasOwnProperty"
let target = method.get("object")
target.isObjectExpression() && target.node.properties.length === 0
body.get("consequent")
target.isMemberExpression() &&
                                        propertyNameOfMemberExpression(target.node) === "prototype"
propertyNameOfMemberExpression(target.node) === "prototype"
const reject = _settle.bind(null, pact, 2)
function _resumeAfterTest = function _resumeAfterTest(value) {
		for (;;) {
			if (value === discriminant) {
				dispatchIndex = i;
				break;
			}
			if (++i === cases.length) {
				if (dispatchIndex !== -1) {
					break;
				} else {
					_settle(pact, 1, result);
					return;
				}
			}
			test = cases[i][0];
			if (test) {
				value = test();
				if (value && value.then) {
					value.then(_resumeAfterTest).then(void 0, reject);
					return;
				}
			} else {
				dispatchIndex = i;
			}
		}
		do {
			var body = cases[dispatchIndex][1];
			while (!body) {
				dispatchIndex++;
				body = cases[dispatchIndex][1];
			}
			var result = body();
			if (result && result.then) {
				result.then(_resumeAfterBody).then(void 0, reject);
				return;
			}
			var fallthroughCheck = cases[dispatchIndex][2];
			dispatchIndex++;
		} while (fallthroughCheck && !fallthroughCheck());
		_settle(pact, 1, result);
	}
path.parentPath.get("left") === path
clearDeclarationData(path)
path.parentPath.isForStatement() && path.parentPath.get("init") === path
path.get("properties").every((property) => {
                if (property.isObjectProperty()) {
                    if (!property.node.computed ||
                        isExpressionOfLiterals(property.get("key"), literalNames)) {
                        return isExpressionOfLiterals(property.get("value"), literalNames);
                    }
                }
                else {
                    return true;
                }
            })
property.isObjectProperty()
isExpressionOfLiterals(property.get("key"), literalNames)
isExpressionOfLiterals(property.get("value"), literalNames)
isExpressionOfLiterals(path.get("argument"), literalNames)
isExpressionOfLiterals(path.get("left"), literalNames) &&
                isExpressionOfLiterals(path.get("right"), literalNames)
isExpressionOfLiterals(path.get("right"), literalNames)
isExpressionOfLiterals(path.get("left"), literalNames) &&
                isExpressionOfLiterals(path.get("right"), literalNames)
isExpressionOfLiterals(path.get("right"), literalNames)
isExpressionOfLiterals(path.get("test"), literalNames) &&
                isExpressionOfLiterals(path.get("consequent"), literalNames) &&
                isExpressionOfLiterals(path.get("alternate"), literalNames)
isExpressionOfLiterals(path.get("consequent"), literalNames)
isExpressionOfLiterals(path.get("alternate"), literalNames)
const reusingExistingId = reusingExisting ? reusingExisting.get("id") : undefined
const existingIdentifier = reusingExistingId && (reusingExistingId.isIdentifier() || reusingExistingId.isPattern())
            ? reusingExistingId.node
            : undefined
const argument = originalAwaitPath.get("argument")
argument.isExpression()
resultIdentifier = existingIdentifier || generateIdentifierForPath(argument)
originalAwaitPath.replaceWith(types.isIdentifier(resultIdentifier) ? resultIdentifier : types.numericLiteral(0))
const isYield = originalAwaitPath.isYieldExpression()
let directExpression = booleanLiteral(false, readConfigKey(state.opts, "minify"))
const parent = awaitPath.parentPath
parent.isVariableDeclarator()
const sibling = parent.getSibling(key)
sibling.isVariableDeclarator()
const init = sibling.get("init")
!skipLiterals || (init && !isExpressionOfLiterals(init, additionalConstantNames))
parent.isLogicalExpression()
const left = parent.get("left")
awaitPath !== left
!isYield && !isExpressionOfLiterals(left, additionalConstantNames)
const leftIdentifier = generateIdentifierForPath(left)
declarations.unshift(types.variableDeclarator(leftIdentifier, left.node))
left.replaceWith(leftIdentifier)
awaitExpression = (isOr ? logicalOr : logicalAnd)(left.node, awaitExpression)
directExpression = logicalOrLoose(isOr ? left.node : logicalNot(left.node), directExpression, readConfigKey(state.opts, "minify"))
awaitPath === originalAwaitPath
parent.replaceWith(resultIdentifier)
existingIdentifier || generateIdentifierForPath(originalAwaitPath.get("argument"))
awaitPath = parent
parent.isBinaryExpression()
const left = parent.get("left")
awaitPath !== left
!isExpressionOfLiterals(left, additionalConstantNames) && left.node.type !== "PrivateName"
const leftIdentifier = generateIdentifierForPath(left)
declarations.unshift(types.variableDeclarator(leftIdentifier, left.node))
parent.isSequenceExpression()
const children = parent.get("expressions")
const position = children.indexOf(awaitPath)
const expression = children[i]
!isExpressionOfLiterals(expression, additionalConstantNames)
const sequenceIdentifier = generateIdentifierForPath(expression)
declarations.unshift(types.variableDeclarator(sequenceIdentifier, expression.node))
parent.isConditionalExpression()
const test = parent.get("test")
awaitPath !== test
let testNode = test.node
const consequent = parent.get("consequent")
const alternate = parent.get("alternate")
const other = consequent === awaitPath ? alternate : consequent
const otherAwaitPath = findAwaitOrYieldPath(other)
const isBoth = consequent === awaitPath && otherAwaitPath === alternate
!(isBoth && awaitPath === originalAwaitPath) &&
                        !isExpressionOfLiterals(test, additionalConstantNames)
!isExpressionOfLiterals(test, additionalConstantNames)
declarations.unshift(types.variableDeclarator(testIdentifier, testNode))
test.replaceWith(testIdentifier)
testNode = testIdentifier
awaitExpression = conditionalExpression(testNode, awaitExpression, otherAwaitPath.node.argument || types.identifier("undefined"))
!resultIdentifier
resultIdentifier =
                                existingIdentifier || generateIdentifierForPath(originalAwaitPath.get("argument"))
existingIdentifier || generateIdentifierForPath(originalAwaitPath.get("argument"))
alternate.replaceWith(resultIdentifier)
parent.replaceWith(resultIdentifier)
directExpression = logicalOrLoose(consequent !== awaitPath ? testNode : logicalNot(testNode), directExpression, readConfigKey(state.opts, "minify"))
awaitExpression =
                                consequent !== awaitPath
                                    ? conditionalExpression(testNode, types.numericLiteral(0), awaitExpression)
                                    : conditionalExpression(testNode, awaitExpression, types.numericLiteral(0))
consequent !== awaitPath ? conditionalExpression(testNode, types.numericLiteral(0), awaitExpression) : conditionalExpression(testNode, awaitExpression, types.numericLiteral(0))
conditionalExpression(testNode, types.numericLiteral(0), awaitExpression)
conditionalExpression(testNode, awaitExpression, types.numericLiteral(0))
awaitExpression =
                                consequent !== awaitPath
                                    ? conditionalExpression(testNode, other.node, awaitExpression)
                                    : conditionalExpression(testNode, awaitExpression, other.node)
consequent !== awaitPath ? conditionalExpression(testNode, other.node, awaitExpression) : conditionalExpression(testNode, awaitExpression, other.node)
conditionalExpression(testNode, other.node, awaitExpression)
conditionalExpression(testNode, awaitExpression, other.node)
!resultIdentifier
resultIdentifier =
                                    existingIdentifier || generateIdentifierForPath(originalAwaitPath.get("argument"))
existingIdentifier || generateIdentifierForPath(originalAwaitPath.get("argument"))
awaitPath === originalAwaitPath
parent.replaceWith(resultIdentifier)
awaitPath = parent
other.replaceWith(resultIdentifier)
parent.isCallExpression()
const callee = parent.get("callee")
callee !== awaitPath
_iterator_8 = <operator>.iterator(parent.get("arguments"))
const spreadArg = unwrapSpreadElement(arg)
spreadArg === awaitPath || arg === awaitPath
spreadArg.isExpression() && !isExpressionOfLiterals(spreadArg, additionalConstantNames)
declarations.unshift(types.variableDeclarator(argIdentifier, spreadArg.node))
!isExpressionOfLiterals(callee, additionalConstantNames) &&
                        typeof promiseCallExpressionType(parent.node) === "undefined"
callee.isMemberExpression()
const object = callee.get("object")
const property = callee.get("property")
object.isIdentifier() &&
                                Object.hasOwnProperty.call(constantStaticMethods, object.node.name) &&
                                !callee.scope.getBinding(object.node.name)
isExpressionOfLiterals(object, additionalConstantNames)
const objectIdentifier = generateIdentifierForPath(object)
objectDeclarator = types.variableDeclarator(objectIdentifier, object.node)
property.isIdentifier()
const calleeIdentifier = generateIdentifierForPath(property)
parent.replaceWith(types.callExpression(types.memberExpression(calleeIdentifier, types.identifier("call")), newArguments))
declarations.unshift(types.variableDeclarator(calleeIdentifier, calleeNode))
declarations.unshift(types.variableDeclarator(calleeIdentifier, discardingIntrinsics(calleeNode)))
parent.isArrayExpression()
_iterator_9 = <operator>.iterator(parent.get("elements"))
const spreadElement = unwrapSpreadElement(element)
element === awaitPath || spreadElement === awaitPath
spreadElement.isExpression() &&
                        !isExpressionOfLiterals(spreadElement, additionalConstantNames)
!isExpressionOfLiterals(spreadElement, additionalConstantNames)
declarations.unshift(types.variableDeclarator(elementIdentifier, spreadElement.node))
parent.isObjectExpression()
_iterator_10 = <operator>.iterator(parent.get("properties"))
prop === awaitPath
prop.isObjectProperty()
const propKey = prop.get("key")
propKey === awaitPath
propKey.isExpression() && !isExpressionOfLiterals(propKey, additionalConstantNames)
const keyIdentifier = generateIdentifierForPath(propKey)
declarations.unshift(types.variableDeclarator(keyIdentifier, propKey.node))
const propValue = prop.get("value")
propValue === awaitPath
propValue.isExpression() && !isExpressionOfLiterals(propValue, additionalConstantNames)
const propIdentifier = generateIdentifierForPath(propValue)
declarations.unshift(types.variableDeclarator(propIdentifier, propValue.node))
parent.isStatement()
awaitPath = parent
current && !current.isFunction()
current.isLoop() || current.isSwitchStatement()
const breaks = pathsBreak(current)
current.isLabeledStatement()
const refs = namedLabelReferences(current, path)
_tmp_146.identifier = breakIdentifierForPath(current.get("body"))
current = current.parentPath
const left = rewritePath.get("left")
left.isAwaitExpression()
awaitPath = left.get("argument")
left.isSpreadElement()
awaitPath = unwrapSpreadElement(left)
let targetPath = awaitPath
targetPath !== path
const parent = targetPath.parentPath
parent == null
!parent.isSwitchCase() && !parent.isBlockStatement()
const explicitExits = pathsReturnOrThrow(parent)
!explicitExits.all && explicitExits.any && (parent.isLoop() || exitsInTail(parent))
state.exitIdentifier = targetPath.scope.generateUidIdentifier("exit")
exitIdentifier = state.exitIdentifier
paths.push({
                        targetPath,
                        explicitExits,
                        parent,
                        exitIdentifier,
                    })
_tmp_150.explicitExits = explicitExits
_tmp_150.exitIdentifier = exitIdentifier
targetPath = parent
_iterator_16 = <operator>.iterator(paths)
const parent = item.parent
parent.isForStatement() ||
                parent.isWhileStatement() ||
                parent.isDoWhileStatement() ||
                parent.isForInStatement() ||
                parent.isForOfStatement() ||
                isForAwaitStatement(parent) ||
                parent.isLabeledStatement()
parent.isWhileStatement()
parent.isDoWhileStatement()
parent.isForInStatement()
parent.isForOfStatement()
isForAwaitStatement(parent)
parent.isLabeledStatement()
breakIdentifiers = item.breakIdentifiers = replaceReturnsAndBreaks(pluginState, parent.get("body"), item.exitIdentifier, breakIdentifiers)
item.forToIdentifiers = identifiersInForToLengthStatement(parent)
addConstantNames(additionalConstantNames, item.forToIdentifiers.i)
breakIdentifiers = breakIdentifiers.slice()
item.cases = item.parent.get("cases").map((casePath) => {
                    const caseExits = pathsReturnOrThrow(casePath);
                    const caseBreaks = pathsBreak(casePath);
                    const caseBreakIdentifiers = (item.breakIdentifiers = replaceReturnsAndBreaks(pluginState, casePath, item.exitIdentifier, breakIdentifiers));
                    for (const breakItem of caseBreakIdentifiers) {
                        if (!breakIdentifiers.find((existing) => existing.identifier.name === breakItem.identifier.name)) {
                            breakIdentifiers.push(breakItem);
                        }
                    }
                    return {
                        casePath,
                        caseExits,
                        caseBreaks,
                        breakIdentifiers: caseBreakIdentifiers,
                        test: casePath.node.test,
                    };
                })
breakIdentifiers = item.breakIdentifiers = replaceReturnsAndBreaks(pluginState, parent, item.exitIdentifier, breakIdentifiers)
relocateTail(state.generatorState, targetPath.isYieldExpression()
                    ? yieldOnExpression(state.generatorState, targetPath.node.argument || types.identifier("undefined"))
                    : targetPath.node.argument, undefined, parent, additionalConstantNames, undefined, undefined, targetPath.isYieldExpression()
                    ? undefined
                    : booleanLiteral(false, readConfigKey(pluginState.opts, "minify")), state.skipReturns)
yieldOnExpression(state.generatorState, targetPath.node.argument || types.identifier("undefined"))
targetPath.isYieldExpression() ? undefined : booleanLiteral(false, readConfigKey(pluginState.opts, "minify"))
booleanLiteral(false, readConfigKey(pluginState.opts, "minify"))
const test = parent.get("test")
targetPath !== test
addConstantNames(additionalConstantNames, resultIdentifier)
const consequent = parent.get("consequent")
rewriteAsyncBlock(state.generatorState, consequent, additionalConstantNames, exitIdentifier)
const alternate = parent.get("alternate")
alternate.isStatement()
rewriteAsyncBlock(state.generatorState, alternate, additionalConstantNames, exitIdentifier)
const fn = functionize(pluginState, [], blockStatement([parent.node]), targetPath)
relocateTail(state.generatorState, types.callExpression(fn, []), undefined, parent, additionalConstantNames, resultIdentifier, exitIdentifier, undefined, state.skipReturns)
const temporary = explicitExits.any && !explicitExits.all ? path.scope.generateUidIdentifier("result") : undefined
const exitCheck = buildBreakExitCheck(pluginState, explicitExits.any && !explicitExits.all ? exitIdentifier : undefined, breakIdentifiers)
let expression = rewriteAsyncNode(state.generatorState, parent, parent.node.block, additionalConstantNames, exitIdentifier)
param !== undefined
param.type !== "Identifier" ||
                            parent.get("handler").scope.getBinding(param.name).referencePaths.length !== 0
parent.get("handler").scope.getBinding(param.name).referencePaths.length !== 0
rewriteAsyncNode(state.generatorState, parent, functionize(pluginState, paramIsUsed && param != null ? [param] : [], catchClause.body, targetPath), additionalConstantNames, exitIdentifier)
emptyFunction(pluginState, parent)
expression = types.callExpression(helperReference(pluginState, path, state.generatorState.generatorIdentifier ? "_catchInGenerator" : "_catch"), [
                        unwrapReturnCallWithEmptyArguments(functionize(pluginState, [], expression, targetPath), path.scope, additionalConstantNames),
                        fn,
                    ])
_tmp_162.push(unwrapReturnCallWithEmptyArguments(functionize(pluginState, [], expression, targetPath), path.scope, additionalConstantNames))
!pathsReturnOrThrow(parent.get("finalizer")).all
const resultIdentifier = temporary || path.scope.generateUidIdentifier("result")
addConstantNames(additionalConstantNames, resultIdentifier)
addConstantNames(additionalConstantNames, wasThrownIdentifier)
readConfigKey(pluginState.opts, "inlineHelpers")
finallyBody = finallyBody.concat(returnStatement(types.callExpression(helperReference(pluginState, parent, "_rethrow"), [
                                wasThrownIdentifier,
                                resultIdentifier,
                            ])))
const fn = functionize(pluginState, finallyArgs, blockStatement(finallyBody), targetPath)
const rewritten = rewriteAsyncNode(state.generatorState, parent, fn, additionalConstantNames, exitIdentifier)
expression = types.callExpression(helperReference(pluginState, parent, finallyName), [
                        unwrapReturnCallWithEmptyArguments(functionize(pluginState, [], expression, targetPath), path.scope, additionalConstantNames),
                        rewritten,
                    ])
_tmp_168.push(unwrapReturnCallWithEmptyArguments(functionize(pluginState, [], expression, targetPath), path.scope, additionalConstantNames))
_tmp_168.push(rewritten)
relocateTail(state.generatorState, types.isExpression(expression)
                    ? expression
                    : types.callExpression(functionize(pluginState, [], expression, targetPath), []), undefined, parent, additionalConstantNames, temporary, exitCheck, undefined, state.skipReturns)
types.callExpression(functionize(pluginState, [], expression, targetPath), [])
isForAwaitStatement(parent)
parent.isForInStatement() || parent.isForOfStatement() || isForAwaitStatement(parent)
const right = parent.get("right")
awaitPath !== right
const left = parent.get("left")
const loopIdentifier = left.isVariableDeclaration()
                            ? left.get("declarations")[0].get("id")
                            : left
(_tmp_170 = left.get("declarations")[0]).get
loopIdentifier.isIdentifier() || loopIdentifier.isPattern()
const forOwnBodyPath = parent.isForInStatement() && extractForOwnBodyPath(parent)
const bodyBlock = blockStatement((forOwnBodyPath || parent.get("body")).node)
const params = [
                                right.node,
                                rewriteAsyncNode(state.generatorState, parent, bodyBlock.body.length
                                    ? functionize(pluginState, [loopIdentifier.node], bodyBlock, targetPath)
                                    : emptyFunction(pluginState, parent), additionalConstantNames, exitIdentifier),
                            ]
_tmp_171.push(right.node)
_tmp_171.push(rewriteAsyncNode(state.generatorState, parent, bodyBlock.body.length
                                    ? functionize(pluginState, [loopIdentifier.node], bodyBlock, targetPath)
                                    : emptyFunction(pluginState, parent), additionalConstantNames, exitIdentifier))
functionize(pluginState, [loopIdentifier.node], bodyBlock, targetPath)
emptyFunction(pluginState, parent)
const exitCheck = buildBreakExitCheck(pluginState, exitIdentifier, breakIdentifiers)
params.push(functionize(pluginState, [], types.blockStatement([returnStatement(exitCheck)]), targetPath))
const loopCall = types.callExpression(helperReference(pluginState, parent, parent.isForInStatement()
                                ? forOwnBodyPath
                                    ? "_forOwn"
                                    : "_forIn"
                                : isForAwaitStatement(parent)
                                    ? "_forAwaitOf"
                                    : "_forOf"), params)
isForAwaitStatement(parent) ? "_forAwaitOf" : "_forOf"
"_forOf"
relocateTail(state.generatorState, loopCall, undefined, label && parent.parentPath.isStatement()
                                ? parent.parentPath
                                : parent, additionalConstantNames, resultIdentifier, exitIdentifier, undefined, state.skipReturns)
state.skipReturns
const breakExitCheck = buildBreakExitCheck(pluginState, exitIdentifier, breakIdentifiers)
testExpression && (!types.isBooleanLiteral(testExpression) || !testExpression.value) ? logicalAnd(inverted, testExpression, extractLooseBooleanValue) : inverted
logicalAnd(inverted, testExpression, extractLooseBooleanValue)
testExpression = rewriteAsyncNode(state.generatorState, parent, functionize(pluginState, [], testExpression, targetPath), additionalConstantNames, exitIdentifier, true)
const isDoWhile = parent.isDoWhileStatement()
_tmp_176.push(rewriteAsyncNode(state.generatorState, parent, functionize(pluginState, [forToIdentifiers.i], blockStatement(parent.node.body), targetPath), additionalConstantNames, exitIdentifier))
args.push(functionize(pluginState, [], breakExitCheck, targetPath))
loopCall = types.callExpression(helperReference(pluginState, parent, "_forTo"), args)
parent.isForStatement()
updateExpression = rewriteAsyncNode(state.generatorState, parent, functionize(pluginState, [], updateExpression, targetPath), additionalConstantNames, exitIdentifier, true)
const init = parent.get("init")
const initNode = init.node
initNode !== null && initNode !== undefined
reregisterDeclarations(parent.insertBefore(types.isExpression(initNode)
                                        ? types.expressionStatement(initNode)
                                        : initNode))
types.expressionStatement(initNode)
const bodyFunction = rewriteAsyncNode(state.generatorState, parent, functionize(pluginState, [], blockStatement(parent.node.body || []), targetPath), additionalConstantNames, exitIdentifier)
const testFunction = unwrapReturnCallWithEmptyArguments(testExpression || voidExpression(), path.scope, additionalConstantNames)
const updateFunction = unwrapReturnCallWithEmptyArguments(updateExpression || voidExpression(), path.scope, additionalConstantNames)
types.callExpression(helperReference(pluginState, parent, "_do"), [
                                bodyFunction,
                                testFunction,
                            ])
types.callExpression(helperReference(pluginState, parent, "_for"), [
                                testFunction,
                                updateFunction,
                                bodyFunction,
                            ])
let resultIdentifier = undefined
relocateTail(state.generatorState, loopCall, undefined, parent, additionalConstantNames, resultIdentifier, exitIdentifier, undefined, state.skipReturns)
parent.isSwitchStatement()
const discriminant = parent.get("discriminant")
const testPaths = parent.get("cases").map((casePath) => casePath.get("test"))
awaitPath !== discriminant &&
                    !(explicitExits.all &&
                        !testPaths.some((testPath) => testPath.node ? findAwaitOrYieldPath(testPath) !== undefined : false))
addConstantNames(additionalConstantNames, resultIdentifier)
cases ? cases.map((caseItem) => {
                            const args = [];
                            let consequent;
                            if (caseItem.casePath.node.consequent) {
                                const rewritten = rewriteAsyncNode(state.generatorState, parent, blockStatement(removeUnnecessaryReturnStatements(caseItem.casePath.node.consequent)), additionalConstantNames, exitIdentifier);
                                if (rewritten.body.length) {
                                    consequent = functionize(pluginState, [], rewritten, targetPath);
                                }
                            }
                            if (caseItem.casePath.node.test) {
                                args.push(rewriteAsyncNode(state.generatorState, parent, functionize(pluginState, [], caseItem.casePath.node.test, targetPath), additionalConstantNames));
                            }
                            else if (consequent) {
                              ... : __ecma.Array.factory()
cases.map((caseItem) => {
                            const args = [];
                            let consequent;
                            if (caseItem.casePath.node.consequent) {
                                const rewritten = rewriteAsyncNode(state.generatorState, parent, blockStatement(removeUnnecessaryReturnStatements(caseItem.casePath.node.consequent)), additionalConstantNames, exitIdentifier);
                                if (rewritten.body.length) {
                                    consequent = functionize(pluginState, [], rewritten, targetPath);
                                }
                            }
                            if (caseItem.casePath.node.test) {
                                args.push(rewriteAsyncNode(state.generatorState, parent, functionize(pluginState, [], caseItem.casePath.node.test, targetPath), additionalConstantNames));
                            }
                            else if (consequent) {
                              ...
const rewritten = rewriteAsyncNode(state.generatorState, parent, blockStatement(removeUnnecessaryReturnStatements(caseItem.casePath.node.consequent)), additionalConstantNames, exitIdentifier)
consequent = functionize(pluginState, [], rewritten, targetPath)
args.push(rewriteAsyncNode(state.generatorState, parent, functionize(pluginState, [], caseItem.casePath.node.test, targetPath), additionalConstantNames))
const breakCheck = buildBreakExitCheck(pluginState, caseItem.caseExits.any ? exitIdentifier : undefined, caseItem.breakIdentifiers)
args.push(functionize(pluginState, [], types.blockStatement([returnStatement(breakCheck)]), targetPath))
types.arrayExpression(args)
const switchCall = types.callExpression(helperReference(pluginState, parent, "_switch"), [
                        discriminant.node,
                        caseNodes,
                    ])
_tmp_185.push(discriminant.node)
_tmp_185.push(caseNodes)
relocateTail(state.generatorState, switchCall, undefined, label && parent.parentPath.isStatement() ? parent.parentPath : parent, additionalConstantNames, resultIdentifier, exitIdentifier, undefined, state.skipReturns)
resultIdentifier = path.scope.generateUidIdentifier("result")
addConstantNames(additionalConstantNames, resultIdentifier)
resultIdentifier || (breakIdentifiers && breakIdentifiers.length)
const fn = functionize(pluginState, [], blockStatement(parent.node.body), targetPath)
const rewritten = rewriteAsyncNode(state.generatorState, parent, fn, additionalConstantNames, exitIdentifier)
const exitCheck = buildBreakExitCheck(pluginState, explicitExits.any ? exitIdentifier : undefined, filteredBreakIdentifiers)
relocateTail(state.generatorState, types.callExpression(rewritten, []), undefined, parent, additionalConstantNames, resultIdentifier, exitCheck, undefined, state.skipReturns)
let parent = getStatementOrArrowBodyParent(awaitPath)
_tmp_188 = extractDeclarations(pluginState, awaitPath, originalArgument || types.identifier("undefined"), additionalConstantNames)
_iterator_19 = <operator>.iterator(declarations)
parent.replaceWith(blockStatement([
                            types.variableDeclaration(declarationKind, declarations),
                            types.isStatement(parent.node) ? parent.node : returnStatement(parent.node),
                        ]))
_tmp_190.push(types.variableDeclaration(declarationKind, declarations))
_tmp_190.push(types.isStatement(parent.node) ? parent.node : returnStatement(parent.node))
const body = parent.get("body")
reregisterDeclarations(body[0])
relocateTail(state.generatorState, awaitPath.isYieldExpression()
                    ? yieldOnExpression(state.generatorState, awaitExpression)
                    : awaitExpression, types.isStatement(parentNode) ? parentNode : types.returnStatement(parentNode), parent, additionalConstantNames, resultIdentifier, undefined, awaitPath.isYieldExpression() ? undefined : directExpression, state.skipReturns)
yieldOnExpression(state.generatorState, awaitExpression)
types.isStatement(parentNode) ? parentNode : types.returnStatement(parentNode)
const args = path.get("arguments")
unpromisify(args[0], pluginState)
const args = path.get("arguments")
const secondArg = args[1]
types.isExpression(secondArg.node) && isContinuation(secondArg.node)
secondArg.isIdentifier()
const binding = secondArg.scope.getBinding(secondArg.node.name)
binding && binding.path.isVariableDeclarator()
binding.path.get("init").traverse(unpromisifyVisitor, pluginState)
const args = path.get("arguments")
const firstArg = args[1]
types.isExpression(firstArg.node) && isContinuation(firstArg.node)
firstArg.isIdentifier()
const binding = firstArg.scope.getBinding(firstArg.node.name)
binding && binding.path.isVariableDeclarator()
binding.path.get("init").traverse(unpromisifyVisitor, pluginState)
const body = programPath.get("body")
const destinationPath = body.find((path) => !isHelperDefinitionSet.has(path.node) && !path.isImportDeclaration()) ||
            body.find(() => true)
body.find(() => true)
destinationPath.isVariableDeclaration()
const before = destinationPath
                .get("declarations")
                .filter((path) => isHelperDefinitionSet.has(path.node))
const after = destinationPath
                .get("declarations")
                .filter((path) => !isHelperDefinitionSet.has(path.node))
path.parentPath.get("callee") === path
const propertyName = propertyNameOfMemberExpression(path.node)
const object = path.get("object")
const argument = path.get("argument")
argument && argument.node
!((argument.isCallExpression() &&
                        (isAsyncCallExpression(argument) ||
                            typeof promiseCallExpressionType(argument.node) !== "undefined")) ||
                        (argument.isCallExpression() && isAsyncFunctionIdentifier(argument.get("callee"))))
isAsyncCallExpression(argument) ||
                            typeof promiseCallExpressionType(argument.node) !== "undefined"
typeof promiseCallExpressionType(argument.node) !== "undefined"
argument.isCallExpression() && isAsyncFunctionIdentifier(argument.get("callee"))
const params = targetPath.get("params")
const param = params[i]
param.isAssignmentPattern()
const init = param.get("right")
const left = param.get("left")
const body = path.get("body")
body.replaceWith(types.blockStatement([body.node]))
const target = body.get("body")[0]
rewriteThisArgumentsAndHoistFunctions(target, inlineHelpers ? target : body, true)
rewriteAsyncBlock({ state: this }, target, [])
const statements = target.get("body")
