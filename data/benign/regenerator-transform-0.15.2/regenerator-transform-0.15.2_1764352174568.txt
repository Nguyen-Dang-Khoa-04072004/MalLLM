_tmp_6.Function = {
    exit: util.wrapWithTypes(t, function(path, state) {
      let node = path.node;

      if (!shouldRegenerate(node, state)) return;

      // if this is an ObjectMethod, we need to convert it to an ObjectProperty
      path = replaceShorthandObjectMethod(path);
      node = path.node;

      let contextId = path.scope.generateUidIdentifier("context");
      let argsId = path.scope.generateUidIdentifier("args");

      path.ensureBlock();
      let bodyBlockPath = path.get("body");

      if (node.async) {
        bodyBlockPath.traverse(awaitVisitor);
      }

      bodyBlockPath.traverse(functionSentVisitor, {
        context: contextId
      });

      let outerBody = [];
      let innerBody = [];

      bodyBlockPath.get("body").forEach(function(childPath) {
        let node = childPath.node;
        if (t.isExpressionStatement(node) &&
            t.isStringLiteral(node.expression)) {
          // Babylon represents directives like "use strict" as elements
          // of a ...
function TryEntry = function TryEntry(firstLoc, catchEntry, finallyEntry) {
  Entry.call(this);
  var t = (0, _util2.getTypes)();
  t.assertLiteral(firstLoc);
  if (catchEntry) {
    _assert["default"].ok(catchEntry instanceof CatchEntry);
  } else {
    catchEntry = null;
  }
  if (finallyEntry) {
    _assert["default"].ok(finallyEntry instanceof FinallyEntry);
  } else {
    finallyEntry = null;
  }

  // Have to have one or the other (or both).
  _assert["default"].ok(catchEntry || finallyEntry);
  this.firstLoc = firstLoc;
  this.catchEntry = catchEntry;
  this.finallyEntry = finallyEntry;
}
bodyBlockPath.traverse(functionSentVisitor, {
          context: contextId
        })
bodyBlockPath.get("body").forEach(function (childPath) {
          var node = childPath.node;
          if (t.isExpressionStatement(node) && t.isStringLiteral(node.expression)) {
            // Babylon represents directives like "use strict" as elements
            // of a bodyBlockPath.node.directives array, but they could just
            // as easily be represented (by other parsers) as traditional
            // string-literal-valued expression statements, so we need to
            // handle that here. (#248)
            outerBody.push(node);
          } else if (node && node._blockHoist != null) {
            outerBody.push(node);
          } else {
            innerBody.push(node);
          }
        })
const functionExpression = t.functionExpression(
    null, // id
    parameters, // params
    t.cloneDeep(path.node.body), // body
    path.node.generator,
    path.node.async
  )
var opaqueTypes = {
  FunctionExpression: true,
  ArrowFunctionExpression: true
}
bodyBlockPath.traverse(functionSentVisitor, {
        context: contextId
      })
bodyBlockPath.get("body").forEach(function(childPath) {
        let node = childPath.node;
        if (t.isExpressionStatement(node) &&
            t.isStringLiteral(node.expression)) {
          // Babylon represents directives like "use strict" as elements
          // of a bodyBlockPath.node.directives array, but they could just
          // as easily be represented (by other parsers) as traditional
          // string-literal-valued expression statements, so we need to
          // handle that here. (#248)
          outerBody.push(node);
        } else if (node && node._blockHoist != null) {
          outerBody.push(node);
        } else {
          innerBody.push(node);
        }
      })
info.declPath = blockPath.get("body.0")
Ep.getDispatchLoop = function() {
  const self = this;
  const t = util.getTypes();
  let cases = [];
  let current;

  // If we encounter a break, continue, or return statement in a switch
  // case, we can skip the rest of the statements until the next case.
  let alreadyEnded = false;

  self.listing.forEach(function(stmt, i) {
    if (self.marked.hasOwnProperty(i)) {
      cases.push(t.switchCase(
        t.numericLiteral(i),
        current = []));
      alreadyEnded = false;
    }

    if (!alreadyEnded) {
      current.push(stmt);
      if (t.isCompletionStatement(stmt))
        alreadyEnded = true;
    }
  });

  // Now that we know how many statements there will be in this.listing,
  // we can finally resolve this.finalLoc.value.
  this.finalLoc.value = this.listing.length;

  cases.push(
    t.switchCase(this.finalLoc, [
      // Intentionally fall through to the "end" case...
    ]),

    // So that the runtime can jump to the final location without having
    // to know ...
throw new Error(node.type + " nodes should be handled by their parents");
Ep.getTryLocsList = function() {
  if (this.tryEntries.length === 0) {
    // To avoid adding a needless [] to the majority of runtime.wrap
    // argument lists, force the caller to handle this case specially.
    return null;
  }

  const t = util.getTypes();
  let lastLocValue = 0;

  return t.arrayExpression(
    this.tryEntries.map(function(tryEntry) {
      let thisLocValue = tryEntry.firstLoc.value;
      assert.ok(thisLocValue >= lastLocValue, "try entries out of order");
      lastLocValue = thisLocValue;

      let ce = tryEntry.catchEntry;
      let fe = tryEntry.finallyEntry;

      let locs = [
        tryEntry.firstLoc,
        // The null here makes a hole in the array.
        ce ? ce.firstLoc : null
      ];

      if (fe) {
        locs[2] = fe.firstLoc;
        locs[3] = fe.afterLoc;
      }

      return t.arrayExpression(locs.map(loc => loc && t.clone(loc)));
    })
  );
}
path.get("cases").forEach(function (casePath) {
          var i = casePath.key;
          self.mark(caseLocs[i]);
          casePath.get("consequent").forEach(function (path) {
            self.explodeStatement(path);
          });
        })
casePath.get("consequent").forEach(function (path) {
            self.explodeStatement(path);
          })
path.get("cases").forEach(function(casePath) {
          let i = casePath.key;
          self.mark(caseLocs[i]);

          casePath.get("consequent").forEach(function (path) {
            self.explodeStatement(path);
          });
        })
casePath.get("consequent").forEach(function (path) {
            self.explodeStatement(path);
          })
finish(t.memberExpression(self.explodeExpression(path.get("object")), expr.computed ? self.explodeViaTempVar(null, path.get("property"), hasLeapingChildren) : expr.property, expr.computed))
var calleePath = path.get("callee")
t.isMemberExpression(calleePath.node)
var newObject = self.explodeViaTempVar(
          // Assign the exploded callee.object expression to a temporary
          // variable so that we can use it twice without reevaluating it.
          self.makeTempVar(), calleePath.get("object"), hasLeapingChildren)
calleePath.get("object")
var newProperty = calleePath.node.computed ? self.explodeViaTempVar(null, calleePath.get("property"), hasLeapingChildren) : calleePath.node.property
finish(t.newExpression(self.explodeViaTempVar(null, path.get("callee"), hasLeapingChildren), path.get("arguments").map(function (argPath) {
        return self.explodeViaTempVar(null, argPath, hasLeapingChildren);
      })))
finish(t.objectExpression(path.get("properties").map(function (propPath) {
        if (propPath.isObjectProperty()) {
          return t.objectProperty(propPath.node.key, self.explodeViaTempVar(null, propPath.get("value"), hasLeapingChildren), propPath.node.computed);
        } else {
          return propPath.node;
        }
      })))
propPath.isObjectProperty()
t.objectProperty(propPath.node.key, self.explodeViaTempVar(null, propPath.get("value"), hasLeapingChildren), propPath.node.computed)
propPath.node
finish(t.arrayExpression(path.get("elements").map(function (elemPath) {
        if (!elemPath.node) {
          return null;
        }
        if (elemPath.isSpreadElement()) {
          return t.spreadElement(self.explodeViaTempVar(null, elemPath.get("argument"), hasLeapingChildren));
        } else {
          return self.explodeViaTempVar(null, elemPath, hasLeapingChildren);
        }
      })))
!elemPath.node
elemPath.isSpreadElement()
t.spreadElement(self.explodeViaTempVar(null, elemPath.get("argument"), hasLeapingChildren))
self.explodeViaTempVar(null, elemPath, hasLeapingChildren)
var left = self.explodeViaTempVar(result, path.get("left"), hasLeapingChildren)
self.jumpIfNot(left, after)
self.explodeViaTempVar(result, path.get("right"), hasLeapingChildren, ignoreResult)
var test = self.explodeExpression(path.get("test"))
let abruptArgs = [t.stringLiteral(record.type)]
record.type === "break" ||
      record.type === "continue"
self.explodeViaTempVar(result, path.get("consequent"), hasLeapingChildren, ignoreResult)
self.explodeViaTempVar(result, path.get("alternate"), hasLeapingChildren, ignoreResult)
finish(t.binaryExpression(expr.operator, self.explodeViaTempVar(null, path.get("left"), hasLeapingChildren), self.explodeViaTempVar(null, path.get("right"), hasLeapingChildren)))
path.get("body.body").forEach(function (member) {
    if (member.node.computed) {
      explodingChildren.push(member.get("key"));
    }
  })
Ep.updateContextPrevLoc = function(loc) {
  const t = util.getTypes();
  if (loc) {
    t.assertLiteral(loc);

    if (loc.value === PENDING_LOCATION) {
      // If an uninitialized location literal was passed in, set its value
      // to the current this.listing.length.
      loc.value = this.listing.length;
    } else {
      // Otherwise assert that the location matches the current offset.
      assert.strictEqual(loc.value, this.listing.length);
    }

  } else {
    loc = this.getUnmarkedCurrentLoc();
  }

  // Make sure context.prev is up to date in case we fell into this try
  // statement without jumping to it. TODO Consider avoiding this
  // assignment when we know control must have jumped here.
  this.emitAssign(this.contextProperty("prev"), loc);
}
self.explodeExpression(path.get("object"))
self.explodeViaTempVar(null, path.get("property"), hasLeapingChildren)
let calleePath = path.get("callee")
t.isMemberExpression(calleePath.node)
let newObject = self.explodeViaTempVar(
          // Assign the exploded callee.object expression to a temporary
          // variable so that we can use it twice without reevaluating it.
          self.makeTempVar(),
          calleePath.get("object"),
          hasLeapingChildren
        )
self.makeTempVar()
calleePath.get("object")
hasLeapingChildren
self.explodeViaTempVar(null, calleePath.get("property"), hasLeapingChildren)
self.explodeViaTempVar(null, path.get("callee"), hasLeapingChildren)
path.get("properties").map(function(propPath) {
        if (propPath.isObjectProperty()) {
          return t.objectProperty(
            propPath.node.key,
            self.explodeViaTempVar(null, propPath.get("value"), hasLeapingChildren),
            propPath.node.computed
          );
        } else {
          return propPath.node;
        }
      })
propPath.isObjectProperty()
t.objectProperty(
            propPath.node.key,
            self.explodeViaTempVar(null, propPath.get("value"), hasLeapingChildren),
            propPath.node.computed
          )
propPath.node.key
self.explodeViaTempVar(null, propPath.get("value"), hasLeapingChildren)
propPath.node
path.get("elements").map(function(elemPath) {
        if (!elemPath.node) {
          return null;
        } if (elemPath.isSpreadElement()) {
          return t.spreadElement(
            self.explodeViaTempVar(null, elemPath.get("argument"), hasLeapingChildren)
          );
        } else {
          return self.explodeViaTempVar(null, elemPath, hasLeapingChildren);
        }
      })
!elemPath.node
elemPath.isSpreadElement()
t.spreadElement(
            self.explodeViaTempVar(null, elemPath.get("argument"), hasLeapingChildren)
          )
self.explodeViaTempVar(null, elemPath.get("argument"), hasLeapingChildren)
self.explodeViaTempVar(null, elemPath, hasLeapingChildren)
let left = self.explodeViaTempVar(result, path.get("left"), hasLeapingChildren)
self.jumpIfNot(left, after)
self.explodeViaTempVar(result, path.get("right"), hasLeapingChildren, ignoreResult)
let test = self.explodeExpression(path.get("test"))
self.jumpIfNot(test, elseLoc)
result = self.makeTempVar()
self.explodeViaTempVar(result, path.get("consequent"), hasLeapingChildren, ignoreResult)
self.explodeViaTempVar(result, path.get("alternate"), hasLeapingChildren, ignoreResult)
self.explodeViaTempVar(null, path.get("left"), hasLeapingChildren)
self.explodeViaTempVar(null, path.get("right"), hasLeapingChildren)
path.get("body.body").forEach(member => {
    if (member.node.computed) {
      explodingChildren.push(member.get("key"));
    }
  })
explodingChildren.push(member.get("key"))
