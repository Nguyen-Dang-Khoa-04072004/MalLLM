Promise.resolve(util.exec(executable, args, stdioOptions)).catch(onSmokeTestError(smokeTestCommand, linuxWithDisplayEnv)).then(result => {
      // TODO: when execa > 1.1 is released
      // change this to `result.all` for both stderr and stdout
      // use lodash to be robust during tests against null result or missing stdout
      const smokeTestStdout = _.get(result, 'stdout', '');
      debug('smoke test stdout "%s"', smokeTestStdout);
      if (!util.stdoutLineMatches(String(random), smokeTestStdout)) {
        debug('Smoke test failed because could not find %d in:', random, result);
        const smokeTestStderr = _.get(result, 'stderr', '');
        const errorText = smokeTestStderr || smokeTestStdout;
        return throwFormErrorText(errors.smokeTestFailure(smokeTestCommand, false))(errorText);
      }
    })
cleanup().then(() => {
        debug('finished installation in', installDir);
        util.setTaskTitle(task, util.titleize(chalk.green('Finished Installation'), chalk.gray(installDir)), rendererOptions.renderer);
      })
state.clearBinaryStateAsync(binaryDir).then(() => {
        return Promise.all([runSmokeTest(binaryDir, options), Promise.resolve().delay(1500) // good user experience
        ]);
      }).then(() => {
        debug('write verified: true');
        return state.writeBinaryVerifiedAsync(true, binaryDir);
      }).then(() => {
        util.setTaskTitle(task, util.titleize(chalk.green('Verified Cypress!'), chalk.gray(binaryDir)), rendererOptions.renderer);
      })
_tmp_30.description = "Cypress failed to start."
new Promise((resolve, reject) => {
    const proxy = getProxyForUrlWithNpmConfig(url);
    debug('Downloading package', {
      url,
      proxy,
      downloadDestination
    });
    if (ca) {
      debug('using custom CA details from npm config');
    }
    const reqOptions = {
      uri: url,
      ...(proxy ? {
        proxy
      } : {}),
      ...(ca ? {
        agentOptions: {
          ca
        }
      } : {}),
      method: 'GET',
      followRedirect: false
    };
    const req = request(reqOptions);

    // closure
    let started = null;
    let expectedSize;
    let expectedChecksum;
    requestProgress(req, {
      throttle: progress.throttle
    }).on('response', response => {
      // we have computed checksum and filesize during test runner binary build
      // and have set it on the S3 object as user meta data, available via
      // these custom headers "x-amz-meta-..."
      // see https://github.com/cypress-io/cypress/pull/4092
      expectedSize = response.h...
require('./exec/versions').getVersions().then((versions = defaultVersions) => {
    if (opts !== null && opts !== void 0 && opts.component) {
      reportComponentVersion(opts.component, versions);
    } else {
      reportAllVersions(versions);
    }
    process.exit(0);
  }).catch(util.logErrorExit1)
function getEnvVarVersion = function getEnvVarVersion() {
  if (!util.getEnv('CYPRESS_INSTALL_BINARY')) return;

  // because passed file paths are often double quoted
  // and might have extra whitespace around, be robust and trim the string
  const trimAndRemoveDoubleQuotes = true;
  const envVarVersion = util.getEnv('CYPRESS_INSTALL_BINARY', trimAndRemoveDoubleQuotes);
  debug('using environment variable CYPRESS_INSTALL_BINARY "%s"', envVarVersion);
  return envVarVersion;
}
const start = async ({
  zipFilePath,
  installDir,
  progress
}) => {
  la(is.unemptyString(installDir), 'missing installDir');
  if (!progress) {
    progress = {
      onProgress: () => {
        return {};
      }
    };
  }
  try {
    const installDirExists = await fs.pathExists(installDir);
    if (installDirExists) {
      debug('removing existing unzipped binary', installDir);
      await fs.removeAsync(installDir);
    }
    await unzip({
      zipFilePath,
      installDir,
      progress
    });
  } catch (err) {
    const errorTemplate = isMaybeWindowsMaxPathLengthError(err) ? errors.failedUnzipWindowsMaxPathLength : errors.failedUnzip;
    await throwFormErrorText(errorTemplate)(err);
  }
}
