function normalizeHardhatNetworkAccountsConfig = function normalizeHardhatNetworkAccountsConfig(accountsConfig) {
    if (Array.isArray(accountsConfig)) {
        return accountsConfig;
    }
    const { bytesToHex } = require("@nomicfoundation/ethereumjs-util");
    return derivePrivateKeys(accountsConfig.mnemonic, accountsConfig.path, accountsConfig.initialIndex, accountsConfig.count, accountsConfig.passphrase).map((pk) => ({
        privateKey: bytesToHex(pk),
        balance: accountsConfig.accountsBalance ?? default_config_1.DEFAULT_HARDHAT_NETWORK_BALANCE,
    }));
}
function getSubprocessTransport = function getSubprocessTransport() {
    const { Status, Transports } = require("@sentry/node");
    class SubprocessTransport extends Transports.BaseTransport {
        async sendEvent(event) {
            const extra = event.extra ?? {};
            const { verbose = false, configPath } = extra;
            // don't send user's full config path for privacy reasons
            delete event.extra?.configPath;
            // we don't care about the verbose setting
            delete event.extra?.verbose;
            const serializedEvent = JSON.stringify(event);
            const env = {
                HARDHAT_SENTRY_EVENT: serializedEvent,
                HARDHAT_SENTRY_VERBOSE: verbose.toString(),
            };
            if (configPath !== undefined) {
                env.HARDHAT_SENTRY_CONFIG_PATH = configPath;
            }
            const subprocessPath = path.join(__dirname, "subprocess");
            const subprocess = (0, child_process_1.spawn)(process.execPath, [subproc...
exports.string = {
    name: "string",
    parse: (argName, strValue) => strValue,
    /**
     * Check if argument value is of type "string"
     *
     * @param argName {string} argument's name - used for context in case of error.
     * @param value {any} argument's value to validate.
     *
     * @throws HH301 if value is not of type "string"
     */
    validate: (argName, value) => {
        const isString = typeof value === "string";
        if (!isString) {
            throw new errors_1.HardhatError(errors_list_1.ERRORS.ARGUMENTS.INVALID_VALUE_FOR_TYPE, {
                value,
                name: argName,
                type: exports.string.name,
            });
        }
    },
}
function loadTsNode = function loadTsNode(tsConfigPath, shouldTypecheck = false) {
    try {
        require.resolve("typescript");
    }
    catch {
        throw new errors_1.HardhatError(errors_list_1.ERRORS.GENERAL.TYPESCRIPT_NOT_INSTALLED);
    }
    try {
        require.resolve("ts-node");
    }
    catch {
        throw new errors_1.HardhatError(errors_list_1.ERRORS.GENERAL.TS_NODE_NOT_INSTALLED);
    }
    // If we are running tests we just want to transpile
    if ((0, execution_mode_1.isRunningHardhatCoreTests)()) {
        // eslint-disable-next-line import/no-extraneous-dependencies
        require("ts-node/register/transpile-only");
        return;
    }
    if (tsConfigPath !== undefined) {
        process.env.TS_NODE_PROJECT = tsConfigPath;
    }
    // See: https://github.com/nomiclabs/hardhat/issues/265
    if (process.env.TS_NODE_FILES === undefined) {
        process.env.TS_NODE_FILES = "true";
    }
    let tsNodeRequirement = "ts-node/register";
    if (!shouldTypecheck) {
        t...
const CONSOLE_LOG_SIGNATURES: Record<number, string[]> = {
  0x51973ec9: [],
  0x2d5b6cb9: [Int256Ty],
  0xf82c50f1: [Uint256Ty],
  0x41304fac: [StringTy],
  0x32458eed: [BoolTy],
  0x2c2ecbc2: [AddressTy],
  0x0be77f56: [BytesTy],
  0x6e18a128: [Bytes1Ty],
  0xe9b62296: [Bytes2Ty],
  0x2d834926: [Bytes3Ty],
  0xe05f48d1: [Bytes4Ty],
  0xa684808d: [Bytes5Ty],
  0xae84a591: [Bytes6Ty],
  0x4ed57e28: [Bytes7Ty],
  0x4f84252e: [Bytes8Ty],
  0x90bd8cd0: [Bytes9Ty],
  0x013d178b: [Bytes10Ty],
  0x04004a2e: [Bytes11Ty],
  0x86a06abd: [Bytes12Ty],
  0x94529e34: [Bytes13Ty],
  0x9266f07f: [Bytes14Ty],
  0xda9574e0: [Bytes15Ty],
  0x665c6104: [Bytes16Ty],
  0x339f673a: [Bytes17Ty],
  0xc4d23d9a: [Bytes18Ty],
  0x5e6b5a33: [Bytes19Ty],
  0x5188e3e9: [Bytes20Ty],
  0xe9da3560: [Bytes21Ty],
  0xd5fae89c: [Bytes22Ty],
  0xaba1cf0d: [Bytes23Ty],
  0xf1b35b34: [Bytes24Ty],
  0x0b84bc58: [Bytes25Ty],
  0xf8b149f1: [Bytes26Ty],
  0x3a3757dd: [Bytes27Ty],
  0xc82aeaee: [Bytes28Ty],
  0x4b69c3d5: [Bytes29Ty...
const ERRORS = {
  GENERAL: {
    NOT_INSIDE_PROJECT: {
      number: 1,
      message: "You are not inside a Hardhat project.",
      title: "You are not inside a Hardhat project",
      description: `You are trying to run Hardhat outside of a Hardhat project.

You can learn how to use Hardhat by reading the [Getting Started guide](/hardhat-runner/docs/getting-started).`,
      shouldBeReported: false,
    },
    INVALID_NODE_VERSION: {
      number: 2,
      message:
        "Hardhat doesn't support your Node.js version. It should be %requirement%.",
      title: "Unsupported Node.js",
      description: `Hardhat doesn't support your Node.js version.

Please upgrade your version of Node.js and try again.`,
      shouldBeReported: false,
    },
    UNSUPPORTED_OPERATION: {
      number: 3,
      message: "%operation% is not supported in Hardhat.",
      title: "Unsupported operation",
      description: `You are trying to perform an unsupported operation.

Unless you are creating a task ...
(0, config_env_1.subtask)(task_names_1.TASK_NODE_GET_PROVIDER)
    .addOptionalParam("forkUrl", undefined, undefined, config_env_1.types.string)
    .addOptionalParam("forkBlockNumber", undefined, undefined, config_env_1.types.int)
    .setAction(async ({ forkBlockNumber: forkBlockNumberParam, forkUrl: forkUrlParam, }, { artifacts, config, network, userConfig }) => {
    let provider = network.provider;
    if (network.name !== constants_1.HARDHAT_NETWORK_NAME) {
        log(`Creating hardhat provider for JSON-RPC server`);
        provider = await (0, construction_1.createProvider)(config, constants_1.HARDHAT_NETWORK_NAME, artifacts);
    }
    const hardhatNetworkConfig = config.networks[constants_1.HARDHAT_NETWORK_NAME];
    const forkUrlConfig = hardhatNetworkConfig.forking?.url;
    const forkBlockNumberConfig = hardhatNetworkConfig.forking?.blockNumber;
    const forkUrl = forkUrlParam ?? forkUrlConfig;
    const forkBlockNumber = forkBlockNumberParam ?? forkBlockNumberConfig;...
function encodeSolidityStackTrace = function encodeSolidityStackTrace(
  fallbackMessage: string,
  stackTrace: SolidityStackTrace,
  previousStack?: NodeJS.CallSite[]
): SolidityError {
  if (Error.prepareStackTrace === undefined) {
    // Node 12 doesn't have a default Error.prepareStackTrace
    require("source-map-support/register");
  }

  const previousPrepareStackTrace = Error.prepareStackTrace;
  Error.prepareStackTrace = (error, stack) => {
    if (previousStack !== undefined) {
      stack = previousStack;
    } else {
      // We remove error management related stack traces
      stack.splice(0, 1);
    }

    for (const entry of stackTrace) {
      const callsite = encodeStackTraceEntry(entry);
      if (callsite === undefined) {
        continue;
      }

      stack.unshift(callsite);
    }

    return previousPrepareStackTrace!(error, stack);
  };

  const msg = getMessageFromLastStackTraceEntry(
    stackTrace[stackTrace.length - 1]
  );

  const solidityError = new SolidityError(
    msg !== undefined...
