"(?:^\\s*(?:到|至|\\-|\\–|\\~|\\〜)\\s*)" +
        "(?:" +
        "(今|明|前|大前|後|大後|聽|昨|尋|琴)(早|朝|晚)|" +
        "(上(?:午|晝)|朝(?:早)|早(?:上)|下(?:午|晝)|晏(?:晝)|晚(?:上)|夜(?:晚)?|中(?:午)|凌(?:晨))|" +
        "(今|明|前|大前|後|大後|聽|昨|尋|琴)(?:日|天)" +
        "(?:[\\s,，]*)" +
        "(?:(上(?:午|晝)|朝(?:早)|早(?:上)|下(?:午|晝)|晏(?:晝)|晚(?:上)|夜(?:晚)?|中(?:午)|凌(?:晨)))?" +
        ")?" +
        "(?:[\\s,，]*)" +
        "(?:(\\d+|[" +
        Object.keys(NUMBER).join("") +
        "]+)(?:\\s*)(?:點|時|:|：)" +
        "(?:\\s*)" +
        "(\\d+|半|正|整|[" +
        Object.keys(NUMBER).join("") +
        "]+)?(?:\\s*)(?:分|:|：)?" +
        "(?:\\s*)" +
        "(\\d+|[" +
        Object.keys(NUMBER).join("") +
        "]+)?(?:\\s*)(?:秒)?)" +
        "(?:\\s*(A.M.|P.M.|AM?|PM?))?"
function mergeDateTimeComponent = function mergeDateTimeComponent(
    dateComponent: ParsingComponents,
    timeComponent: ParsingComponents
): ParsingComponents {
    const dateTimeComponent = dateComponent.clone();

    if (timeComponent.isCertain("hour")) {
        dateTimeComponent.assign("hour", timeComponent.get("hour"));
        dateTimeComponent.assign("minute", timeComponent.get("minute"));

        if (timeComponent.isCertain("second")) {
            dateTimeComponent.assign("second", timeComponent.get("second"));

            if (timeComponent.isCertain("millisecond")) {
                dateTimeComponent.assign("millisecond", timeComponent.get("millisecond"));
            } else {
                dateTimeComponent.imply("millisecond", timeComponent.get("millisecond"));
            }
        } else {
            dateTimeComponent.imply("second", timeComponent.get("second"));
            dateTimeComponent.imply("millisecond", timeComponent.get("millisecond"));
        }
    } else {
        dateTimeCompone...
function createCasualConfiguration = function createCasualConfiguration(littleEndian = true): Configuration {
    const option = createConfiguration(false, littleEndian);
    option.parsers.push(new PTCasualDateParser());
    option.parsers.push(new PTCasualTimeParser());
    return option;
}
function createCasualConfiguration = function createCasualConfiguration(littleEndian = true): Configuration {
    const option = createConfiguration(false, littleEndian);
    option.parsers.push(new ESCasualDateParser());
    option.parsers.push(new ESCasualTimeParser());
    return option;
}
_tmp_0.CET = {
        timezoneOffsetDuringDst: 2 * 60,
        timezoneOffsetNonDst: 60,
        dstStart: (year: number) => getLastWeekdayOfMonth(year, Month.MARCH, Weekday.SUNDAY, 2),
        dstEnd: (year: number) => getLastWeekdayOfMonth(year, Month.OCTOBER, Weekday.SUNDAY, 3),
    }
function createConfiguration = function createConfiguration(strictMode = true, littleEndian = true): Configuration {
    return includeCommonConfiguration(
        {
            parsers: [
                new ISOFormatParser(),
                new SlashDateFormatParser(littleEndian),
                new DETimeExpressionParser(),
                new DESpecificTimeExpressionParser(),
                new DEMonthNameLittleEndianParser(),
                new DEWeekdayParser(),
                new DETimeUnitWithinFormatParser(),
            ],
            refiners: [new DEMergeDateRangeRefiner(), new DEMergeDateTimeRefiner()],
        },
        strictMode
    );
}
function zhStringToYear = function zhStringToYear(text: string) {
    let string = "";

    for (let i = 0; i < text.length; i++) {
        const char = text[i];
        string = string + NUMBER[char];
    }

    return parseInt(string);
}
function createCasualConfiguration = function createCasualConfiguration(littleEndian = true): Configuration {
    const option = createConfiguration(false, littleEndian);
    option.parsers.unshift(new NLCasualDateParser());
    option.parsers.unshift(new NLCasualTimeParser());
    option.parsers.unshift(new NLCasualDateTimeParser());
    option.parsers.unshift(new NLMonthNameParser());
    option.parsers.unshift(new NLRelativeDateFormatParser());
    option.parsers.unshift(new NLTimeUnitCasualRelativeFormatParser());
    return option;
}
const FULL_MONTH_NAME_DICTIONARY: { [word: string]: number } = {
    январь: 1,
    января: 1,
    январе: 1,
    февраль: 2,
    февраля: 2,
    феврале: 2,
    март: 3,
    марта: 3,
    марте: 3,
    апрель: 4,
    апреля: 4,
    апреле: 4,
    май: 5,
    мая: 5,
    мае: 5,
    июнь: 6,
    июня: 6,
    июне: 6,
    июль: 7,
    июля: 7,
    июле: 7,
    август: 8,
    августа: 8,
    августе: 8,
    сентябрь: 9,
    сентября: 9,
    сентябре: 9,
    октябрь: 10,
    октября: 10,
    октябре: 10,
    ноябрь: 11,
    ноября: 11,
    ноябре: 11,
    декабрь: 12,
    декабря: 12,
    декабре: 12,
}
const options = includeCommonConfiguration(
            {
                parsers: [
                    new SlashDateFormatParser(littleEndian),
                    new ENTimeUnitWithinFormatParser(strictMode),
                    new ENMonthNameLittleEndianParser(),
                    new ENMonthNameMiddleEndianParser(),
                    new ENWeekdayParser(),
                    new ENCasualYearMonthDayParser(),
                    new ENSlashMonthFormatParser(),
                    new ENTimeExpressionParser(strictMode),
                    new ENTimeUnitAgoFormatParser(strictMode),
                    new ENTimeUnitLaterFormatParser(strictMode),
                ],
                refiners: [new ENMergeRelativeDateRefiner(), new ENMergeDateTimeRefiner()],
            },
            strictMode
        )
const FULL_MONTH_NAME_DICTIONARY: { [word: string]: number } = {
    "січень": 1,
    "січня": 1,
    "січні": 1,
    "лютий": 2,
    "лютого": 2,
    "лютому": 2,
    "березень": 3,
    "березня": 3,
    "березні": 3,
    "квітень": 4,
    "квітня": 4,
    "квітні": 4,
    "травень": 5,
    "травня": 5,
    "травні": 5,
    "червень": 6,
    "червня": 6,
    "червні": 6,
    "липень": 7,
    "липня": 7,
    "липні": 7,
    "серпень": 8,
    "серпня": 8,
    "серпні": 8,
    "вересень": 9,
    "вересня": 9,
    "вересні": 9,
    "жовтень": 10,
    "жовтня": 10,
    "жовтні": 10,
    "листопад": 11,
    "листопада": 11,
    "листопаду": 11,
    "грудень": 12,
    "грудня": 12,
    "грудні": 12,
}
function createConfiguration = function createConfiguration(): Configuration {
    const configuration = includeCommonConfiguration({
        parsers: [
            new ZHHantDateParser(),
            new ZHHantRelationWeekdayParser(),
            new ZHHantWeekdayParser(),
            new ZHHantTimeExpressionParser(),
            new ZHHantDeadlineFormatParser(),
        ],
        refiners: [new ZHHantMergeDateRangeRefiner(), new ZHHantMergeDateTimeRefiner()],
    });

    // REMOVE ExtractTimezoneOffsetRefiner
    configuration.refiners = configuration.refiners.filter(
        (refiner) => !(refiner instanceof ExtractTimezoneOffsetRefiner)
    );

    return configuration;
}
function theDayAfter = function theDayAfter(reference: ReferenceWithTimezone, nDays: number): ParsingComponents {
    let targetDate = dayjs(reference.instant);
    const component = new ParsingComponents(reference, {});
    targetDate = targetDate.add(nDays, "day");
    assignSimilarDate(component, targetDate);
    implySimilarTime(component, targetDate);
    return component;
}
_tmp_6.parsers = [
                new SlashDateFormatParser(littleEndian),
                new ESWeekdayParser(),
                new ESTimeExpressionParser(),
                new ESMonthNameLittleEndianParser(),
                new ESTimeUnitWithinFormatParser(),
            ]
function createConfiguration = function createConfiguration(strictMode = true, littleEndian = true): Configuration {
    return includeCommonConfiguration(
        {
            parsers: [
                new SlashDateFormatParser(littleEndian),
                new FRMonthNameLittleEndianParser(),
                new FRTimeExpressionParser(),
                new FRSpecificTimeExpressionParser(),
                new FRTimeUnitAgoFormatParser(),
                new FRTimeUnitWithinFormatParser(),
                new FRWeekdayParser(),
            ],
            refiners: [new FRMergeDateTimeRefiner(), new FRMergeDateRangeRefiner()],
        },
        strictMode
    );
}
includeCommonConfiguration(
        {
            parsers: [
                new SlashDateFormatParser(littleEndian),
                new FRMonthNameLittleEndianParser(),
                new FRTimeExpressionParser(),
                new FRSpecificTimeExpressionParser(),
                new FRTimeUnitAgoFormatParser(),
                new FRTimeUnitWithinFormatParser(),
                new FRWeekdayParser(),
            ],
            refiners: [new FRMergeDateTimeRefiner(), new FRMergeDateRangeRefiner()],
        },
        strictMode
    )
result.start = DESpecificTimeExpressionParser.extractTimeComponent(result.start.clone(), match)
_tmp_8.parsers = [
                new SlashDateFormatParser(littleEndian),
                new FRMonthNameLittleEndianParser(),
                new FRTimeExpressionParser(),
                new FRSpecificTimeExpressionParser(),
                new FRTimeUnitAgoFormatParser(),
                new FRTimeUnitWithinFormatParser(),
                new FRWeekdayParser(),
            ]
_tmp_5.refiners = [new ZHHansMergeDateRangeRefiner(), new ZHHansMergeDateTimeRefiner()]
function createConfiguration = function createConfiguration(strictMode = true, littleEndian = true): Configuration {
    return includeCommonConfiguration(
        {
            parsers: [
                new SlashDateFormatParser(littleEndian),
                new NLTimeUnitWithinFormatParser(),
                new NLMonthNameMiddleEndianParser(),
                new NLMonthNameParser(),
                new NLWeekdayParser(),
                new NLCasualYearMonthDayParser(),
                new NLSlashMonthFormatParser(),
                new NLTimeExpressionParser(strictMode),
                new NLTimeUnitAgoFormatParser(strictMode),
                new NLTimeUnitLaterFormatParser(strictMode),
            ],
            refiners: [new NLMergeDateTimeRefiner(), new NLMergeDateRangeRefiner()],
        },
        strictMode
    );
}
includeCommonConfiguration(
        {
            parsers: [
                new SlashDateFormatParser(littleEndian),
                new NLTimeUnitWithinFormatParser(),
                new NLMonthNameMiddleEndianParser(),
                new NLMonthNameParser(),
                new NLWeekdayParser(),
                new NLCasualYearMonthDayParser(),
                new NLSlashMonthFormatParser(),
                new NLTimeExpressionParser(strictMode),
                new NLTimeUnitAgoFormatParser(strictMode),
                new NLTimeUnitLaterFormatParser(strictMode),
            ],
            refiners: [new NLMergeDateTimeRefiner(), new NLMergeDateRangeRefiner()],
        },
        strictMode
    )
_tmp_12.parsers = [
                new ISOFormatParser(),
                new SlashDateFormatParser(true),
                new UKTimeUnitWithinFormatParser(),
                new UKMonthNameLittleEndianParser(),
                new UKWeekdayParser(),
                new UKTimeExpressionParser(strictMode),
                new UKTimeUnitAgoFormatParser(),
            ]
function parseYear = function parseYear(match: string): number {
    if (match.match(/^[0-9]{1,4}$/)) {
        let yearNumber = parseInt(match);
        if (yearNumber < 100) {
            if (yearNumber > 50) {
                yearNumber = yearNumber + 1900;
            } else {
                yearNumber = yearNumber + 2000;
            }
        }
        return yearNumber;
    }

    if (match.match(/a\.?\s*c\.?/i)) {
        match = match.replace(/a\.?\s*c\.?/i, "");
        return -parseInt(match);
    }

    return parseInt(match);
}
const INTEGER_WORD_DICTIONARY: { [word: string]: number } = {
    "eins": 1,
    "eine": 1,
    "einem": 1,
    "einen": 1,
    "einer": 1,
    "zwei": 2,
    "drei": 3,
    "vier": 4,
    "fünf": 5,
    "fuenf": 5,
    "sechs": 6,
    "sieben": 7,
    "acht": 8,
    "neun": 9,
    "zehn": 10,
    "elf": 11,
    "zwölf": 12,
    "zwoelf": 12,
}
context.debug(() => {
                        console.log(`Forward yearly adjusted for ${result} (${result.start})`);
                    })
dateTimeComponent.get("meridiem") == Meridiem.PM && dateTimeComponent.get("hour") < 12
includeCommonConfiguration(
        {
            parsers: [
                new SlashDateFormatParser(true),
                new RUTimeUnitWithinFormatParser(),
                new RUMonthNameLittleEndianParser(),
                new RUWeekdayParser(),
                new RUTimeExpressionParser(strictMode),
                new RUTimeUnitAgoFormatParser(),
            ],
            refiners: [new RUMergeDateTimeRefiner(), new RUMergeDateRangeRefiner()],
        },
        strictMode
    )
_tmp_12.parsers = [
                new SlashDateFormatParser(true),
                new RUTimeUnitWithinFormatParser(),
                new RUMonthNameLittleEndianParser(),
                new RUWeekdayParser(),
                new RUTimeExpressionParser(strictMode),
                new RUTimeUnitAgoFormatParser(),
            ]
<operator>.formatString("(?:", matchAnyPattern(
    INTEGER_WORD_DICTIONARY
), "|[0-9]+|[0-9]+\\.[0-9]+|пол|несколько|пар(?:ы|у)|\\s{0,3})")
components.assign("hour", hour)
const ORDINAL_NUMBER_PATTERN = `(?:${matchAnyPattern(ORDINAL_WORD_DICTIONARY)}|[0-9]{1,2}(?:го|ого|е)?)`
<operator>.formatString("(?:[1-9][0-9]{0,3}", year, "\\s*(?:н.э.|до н.э.|н. э.|до н. э.)|[1-2][0-9]{3}", year, "|[5-9][0-9]", year, ")")
<operator>.formatString("(?:[1-9][0-9]{0,3}", year, "\\s*(?:н.е.|до н.е.|н. е.|до н. е.)|[1-2][0-9]{3}", year, "|[5-9][0-9]", year, ")")
function parseYearPattern = function parseYearPattern(match: string): number {
    if (/(рік|року|р|р.)/i.test(match)) {
        match = match.replace(/(рік|року|р|р.)/i, "");
    }

    if (/(до н.е.|до н. е.)/i.test(match)) {
        //Before Common Era
        match = match.replace(/(до н.е.|до н. е.)/i, "");
        return -parseInt(match);
    }

    if (/(н. е.|н.е.)/i.test(match)) {
        //Common Era
        match = match.replace(/(н. е.|н.е.)/i, "");
        return parseInt(match);
    }

    const rawYearNumber = parseInt(match);
    return findMostLikelyADYear(rawYearNumber);
}
<operator>.formatString("[ParsingResult {index: ", this.index, ", text: '", this.text, "', tags: ", JSON.stringify(tags), " ...}]")
dayjs(date).isAfter(matchedTimezone.dstStart(date.getFullYear())) &&
        !dayjs(date).isAfter(matchedTimezone.dstEnd(date.getFullYear()))
!dayjs(date).isAfter(matchedTimezone.dstEnd(date.getFullYear()))
