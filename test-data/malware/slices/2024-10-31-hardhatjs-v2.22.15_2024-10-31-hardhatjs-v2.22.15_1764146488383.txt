function edrRpcDebugTraceToHardhat = function edrRpcDebugTraceToHardhat(rpcDebugTrace) {
    const structLogs = rpcDebugTrace.structLogs.map((log) => {
        const result = {
            depth: Number(log.depth),
            gas: Number(log.gas),
            gasCost: Number(log.gasCost),
            op: log.opName,
            pc: Number(log.pc),
        };
        if (log.memory !== undefined) {
            result.memory = log.memory;
        }
        if (log.stack !== undefined) {
            // Remove 0x prefix which is required by EIP-3155, but not expected by Hardhat.
            result.stack = log.stack?.map((item) => item.slice(2));
        }
        if (log.storage !== undefined) {
            result.storage = Object.fromEntries(Object.entries(log.storage).map(([key, value]) => {
                return [key.slice(2), value.slice(2)];
            }));
        }
        if (log.error !== undefined) {
            result.error = {
                message: log.error,
            };
        }
        return result...
const structLogs = rpcDebugTrace.structLogs.map((log) => {
        const result = {
            depth: Number(log.depth),
            gas: Number(log.gas),
            gasCost: Number(log.gasCost),
            op: log.opName,
            pc: Number(log.pc),
        };
        if (log.memory !== undefined) {
            result.memory = log.memory;
        }
        if (log.stack !== undefined) {
            // Remove 0x prefix which is required by EIP-3155, but not expected by Hardhat.
            result.stack = log.stack?.map((item) => item.slice(2));
        }
        if (log.storage !== undefined) {
            result.storage = Object.fromEntries(Object.entries(log.storage).map(([key, value]) => {
                return [key.slice(2), value.slice(2)];
            }));
        }
        if (log.error !== undefined) {
            result.error = {
                message: log.error,
            };
        }
        return result;
    })
types.map((type, i) => {
      const position: number = i * 32;
      switch (types[i]) {
        case Uint256Ty:
          return bytesToBigInt(
            data.slice(position, position + REGISTER_SIZE)
          ).toString(10);

        case Int256Ty:
          return fromSigned(
            data.slice(position, position + REGISTER_SIZE)
          ).toString();

        case BoolTy:
          if (data[position + 31] !== 0) {
            return "true";
          }
          return "false";

        case StringTy:
          const sStart = bytesToInt(
            data.slice(position, position + REGISTER_SIZE)
          );
          const sLen = bytesToInt(data.slice(sStart, sStart + REGISTER_SIZE));
          return data
            .slice(sStart + REGISTER_SIZE, sStart + REGISTER_SIZE + sLen)
            .toString();

        case AddressTy:
          return bufferToHex(
            data.slice(position + 12, position + REGISTER_SIZE)
          );

        case BytesTy:
          co...
const bigint: CLIArgumentType<bigint> = {
  name: "bigint",
  parse: (argName, strValue) => {
    const decimalPattern = /^\d+(?:n)?$/;
    const hexPattern = /^0[xX][\dABCDEabcde]+$/;

    if (
      strValue.match(decimalPattern) === null &&
      strValue.match(hexPattern) === null
    ) {
      throw new HardhatError(ERRORS.ARGUMENTS.INVALID_VALUE_FOR_TYPE, {
        value: strValue,
        name: argName,
        type: bigint.name,
      });
    }

    return BigInt(strValue.replace("n", ""));
  },
  /**
   * Check if argument value is of type "bigint".
   *
   * @param argName {string} argument's name - used for context in case of error.
   * @param value {any} argument's value to validate.
   *
   * @throws HH301 if value is not of type "bigint"
   */
  validate: (argName: string, value: any): void => {
    const isBigInt = typeof value === "bigint";
    if (!isBigInt) {
      throw new HardhatError(ERRORS.ARGUMENTS.INVALID_VALUE_FOR_TYPE, {
        value,
        name: argName,
  ...
_tmp_15.LIB_IMPORTED_FROM_THE_CONFIG = {
      number: 9,
      message: `Error while loading Hardhat's configuration.

You probably tried to import the "hardhat" module from your config or a file imported from it.
This is not possible, as Hardhat can't be initialized while its config is being defined.

To learn more about how to access the Hardhat Runtime Environment from different contexts go to https://hardhat.org/hre`,
      title: "Failed to load config file",
      description: `There was an error while loading your config file.

The most common source of errors is trying to import the Hardhat Runtime Environment from your config or a file imported from it.
This is not possible, as Hardhat can't be initialized while its config is being defined.

You may also have accidentally imported \`hardhat\` instead of \`hardhat/config\`.

Please make sure your config file is correct.

To learn more about how to access the Hardhat Runtime Environment from different contexts go to https://hardhat.org/hre`,
      shouldBeReporte...
function resolveHardhatNetworkConfig = function resolveHardhatNetworkConfig(
  hardhatNetworkConfig: HardhatNetworkUserConfig = {}
): HardhatNetworkConfig {
  const cloneDeep = require("lodash/cloneDeep") as LoDashStatic["cloneDeep"];
  const clonedDefaultHardhatNetworkParams = cloneDeep(
    defaultHardhatNetworkParams
  );

  const accounts: HardhatNetworkAccountsConfig =
    hardhatNetworkConfig.accounts === undefined
      ? defaultHardhatNetworkHdAccountsConfigParams
      : Array.isArray(hardhatNetworkConfig.accounts)
      ? hardhatNetworkConfig.accounts.map(({ privateKey, balance }) => ({
          privateKey: normalizeHexString(privateKey),
          balance,
        }))
      : {
          ...defaultHardhatNetworkHdAccountsConfigParams,
          ...hardhatNetworkConfig.accounts,
        };

  const forking: HardhatNetworkForkingConfig | undefined =
    hardhatNetworkConfig.forking !== undefined
      ? {
          url: hardhatNetworkConfig.forking.url,
          enabled: hardhatNetworkConfig.forking.enabled ??...
(0, config_env_1.subtask)(task_names_1.TASK_COMPILE_SOLIDITY_GET_DEPENDENCY_GRAPH)
    .addOptionalParam("rootPath", undefined, undefined, config_env_1.types.string)
    .addParam("sourceNames", undefined, undefined, config_env_1.types.any)
    .addOptionalParam("solidityFilesCache", undefined, undefined, config_env_1.types.any)
    .setAction(async ({ rootPath, sourceNames, solidityFilesCache, }, { config, run }) => {
    const parser = new parse_1.Parser(solidityFilesCache);
    const remappings = await run(task_names_1.TASK_COMPILE_GET_REMAPPINGS);
    const resolver = new resolver_1.Resolver(rootPath ?? config.paths.root, parser, remappings, (absolutePath) => run(task_names_1.TASK_COMPILE_SOLIDITY_READ_FILE, { absolutePath }), (importName) => run(task_names_1.TASK_COMPILE_TRANSFORM_IMPORT_NAME, {
        importName,
        deprecationCheck: true,
    }));
    const resolvedFiles = await Promise.all(sourceNames.map((sn) => resolver.resolveSourceName(sn)));
    return dependencyG...
function resolveHttpNetworkConfig = function resolveHttpNetworkConfig(networkConfig) {
    const cloneDeep = require("lodash/cloneDeep");
    const accounts = networkConfig.accounts === undefined
        ? default_config_1.defaultHttpNetworkParams.accounts
        : isHdAccountsConfig(networkConfig.accounts)
            ? {
                ...default_config_1.defaultHdAccountsConfigParams,
                ...networkConfig.accounts,
            }
            : Array.isArray(networkConfig.accounts)
                ? networkConfig.accounts.map(normalizeHexString)
                : "remote";
    const url = networkConfig.url;
    (0, errors_1.assertHardhatInvariant)(url !== undefined, "Invalid http network config provided. URL missing.");
    return {
        ...cloneDeep(default_config_1.defaultHttpNetworkParams),
        ...networkConfig,
        accounts,
        url,
        gas: networkConfig.gas ?? default_config_1.defaultHttpNetworkParams.gas,
        gasPrice: networkConfig.gasPrice ?? default_config_1.defaultHttp...
Sentry.init({
      dsn: SENTRY_DSN,
      transport: getSubprocessTransport(),
      integrations: () => [linkedErrorsIntegration],
    })
(0, config_env_1.subtask)(task_names_1.TASK_COMPILE_SOLIDITY_GET_COMPILATION_JOB_FOR_FILE)
    .addParam("dependencyGraph", undefined, undefined, config_env_1.types.any)
    .addParam("file", undefined, undefined, config_env_1.types.any)
    .addOptionalParam("solidityFilesCache", undefined, undefined, config_env_1.types.any)
    .setAction(async ({ dependencyGraph, file, }, { config }) => {
    return (0, compilation_job_1.createCompilationJobFromFile)(dependencyGraph, file, config.solidity);
})
transaction = ethereumjs_tx_1.FeeMarketEIP1559Transaction.fromTxData({
                ...txData,
                accessList,
                gasPrice: undefined,
            }, { common })
function getAction = async function getAction(isEsm) {
    if (process.env.HARDHAT_CREATE_JAVASCRIPT_PROJECT_WITH_DEFAULTS !== undefined) {
        return Action.CREATE_JAVASCRIPT_PROJECT_ACTION;
    }
    else if (process.env.HARDHAT_CREATE_TYPESCRIPT_PROJECT_WITH_DEFAULTS !== undefined) {
        return Action.CREATE_TYPESCRIPT_PROJECT_ACTION;
    }
    else if (process.env.HARDHAT_CREATE_TYPESCRIPT_VIEM_PROJECT_WITH_DEFAULTS !==
        undefined) {
        return Action.CREATE_TYPESCRIPT_VIEM_PROJECT_ACTION;
    }
    const { default: enquirer } = await Promise.resolve().then(() => __importStar(require("enquirer")));
    try {
        const actionResponse = await enquirer.prompt([
            {
                name: "action",
                type: "select",
                message: "What do you want to do?",
                initial: 0,
                choices: Object.values(Action)
                    .filter((a) => {
                    if (isEsm && a === Action.CREATE_TYPESCRIPT_VIEM_PROJECT_ACTIO...
const actionResponse = await enquirer.prompt([
            {
                name: "action",
                type: "select",
                message: "What do you want to do?",
                initial: 0,
                choices: Object.values(Action)
                    .filter((a) => {
                    if (isEsm && a === Action.CREATE_TYPESCRIPT_VIEM_PROJECT_ACTION) {
                        // we omit the viem option for ESM projects to avoid showing
                        // two disabled options
                        return false;
                    }
                    return true;
                })
                    .map((a) => {
                    let message;
                    if (isEsm) {
                        if (a === Action.CREATE_EMPTY_HARDHAT_CONFIG_ACTION) {
                            message = a.replace(".js", ".cjs");
                        }
                        else if (a === Action.CREATE_TYPESCRIPT_PROJECT_ACTION) {
                            mes...
function getMessageFromLastStackTraceEntry = function getMessageFromLastStackTraceEntry(
  stackTraceEntry: SolidityStackTraceEntry
): string | undefined {
  switch (stackTraceEntry.type) {
    case StackTraceEntryType.PRECOMPILE_ERROR:
      return `Transaction reverted: call to precompile ${stackTraceEntry.precompile} failed`;

    case StackTraceEntryType.FUNCTION_NOT_PAYABLE_ERROR:
      return `Transaction reverted: non-payable function was called with value ${stackTraceEntry.value.toString(
        10
      )}`;

    case StackTraceEntryType.INVALID_PARAMS_ERROR:
      return `Transaction reverted: function was called with incorrect parameters`;

    case StackTraceEntryType.FALLBACK_NOT_PAYABLE_ERROR:
      return `Transaction reverted: fallback function is not payable and was called with value ${stackTraceEntry.value.toString(
        10
      )}`;

    case StackTraceEntryType.FALLBACK_NOT_PAYABLE_AND_NO_RECEIVE_ERROR:
      return `Transaction reverted: there's no receive function, fallback function is not payable an...
function getCompilerConfigForFile = function getCompilerConfigForFile(
  file: ResolvedFile,
  directDependencies: ResolvedFile[],
  transitiveDependencies: taskTypes.TransitiveDependency[],
  solidityConfig: SolidityConfig
): SolcConfig | CompilationJobCreationError {
  const transitiveDependenciesVersionPragmas = transitiveDependencies
    .map(({ dependency }) => dependency.content.versionPragmas)
    .flat();
  const versionRange = Array.from(
    new Set([
      ...file.content.versionPragmas,
      ...transitiveDependenciesVersionPragmas,
    ])
  ).join(" ");

  const overrides = solidityConfig.overrides ?? {};

  const overriddenCompiler = overrides[file.sourceName];

  // if there's an override, we only check that
  if (overriddenCompiler !== undefined) {
    if (!semver.satisfies(overriddenCompiler.version, versionRange)) {
      return getCompilationJobCreationError(
        file,
        directDependencies,
        transitiveDependencies,
        [overriddenCompiler.version],
        true
      );
    }

 ...
assertHardhatInvariant(
        scopeDefinition !== undefined,
        "It shouldn't be possible to create a task in a scope that doesn't exist"
      )
_tmp_16.ESM_PROJECT_WITHOUT_CJS_CONFIG = {
            number: 19,
            message: `Your project is an ESM project (you have "type": "module" set in your package.json) but your Hardhat config file uses the .js extension.

Rename the file to use the .cjs to fix this problem.`,
            title: "Hardhat config with .js extension in an ESM project",
            description: "Your project is an ESM project but your Hardhat config uses the .js extension. Hardhat config files cannot be an ES module. To fix this, rename your Hardhat config to use the .cjs extension.",
            shouldBeReported: false,
        }
function includesOwnPackageName = async function includesOwnPackageName(
  sourceName: string
): Promise<boolean> {
  const packageName = await getPackageName(sourceName);
  if (packageName !== "") {
    return sourceName.startsWith(`${packageName}/`);
  }
  return false;
}
throw new HardhatError(
          ERRORS.RESOLVER.INVALID_IMPORT_WRONG_CASING,
          {
            imported,
            from: from.sourceName,
          },
          error
        );
_tmp_16.ESM_TYPESCRIPT_PROJECT_CREATION = {
            number: 20,
            message: `Your project is an ESM project (you have "type": "module" set in your package.json) and you are trying to initialize a TypeScript project. This is not supported yet.`,
            title: "Initializing a TypeScript sample project in an ESM project",
            description: `Your project is an ESM project (you have "type": "module" set in your package.json) and you are trying to initialize a TypeScript project. This is not supported yet.`,
            shouldBeReported: false,
        }
const provider = await Provider.withConfig(
      getGlobalEdrContext(),
      {
        allowBlocksWithSameTimestamp:
          config.allowBlocksWithSameTimestamp ?? false,
        allowUnlimitedContractSize: config.allowUnlimitedContractSize,
        bailOnCallFailure: config.throwOnCallFailures,
        bailOnTransactionFailure: config.throwOnTransactionFailures,
        blockGasLimit: BigInt(config.blockGasLimit),
        chainId: BigInt(config.chainId),
        chains: Array.from(config.chains, ([chainId, hardforkConfig]) => {
          return {
            chainId: BigInt(chainId),
            hardforks: Array.from(
              hardforkConfig.hardforkHistory,
              ([hardfork, blockNumber]) => {
                return {
                  blockNumber: BigInt(blockNumber),
                  specId: ethereumsjsHardforkToEdrSpecId(
                    getHardforkName(hardfork)
                  ),
                };
              }
            ),
          };
        }),
    ...
_tmp_36.message = "Your project is an ESM project (you have "type": "module" set in your package.json) and you are trying to initialize a TypeScript project. This is not supported yet."
_tmp_33.description = "Some versions of NPM are affected [by a bug](https://github.com/npm/cli/issues/4828) that leads to corrupt lockfiles being generated.

This bug can only affect you if you, or someone at your team, installed the project without a lockfile, but with an existing node_modules.

To avoid it, please delete both your node_modules and package-lock.json, and reinstall your project.

Note that you don't need to do this every time you install a new dependency, but please make sure to delete your node_modules every time you delete your package-lock.json."
const response = (await this._wrappedProvider.request({
        method: "eth_feeHistory",
        params: [
          "0x1",
          "latest",
          [AutomaticGasPriceProvider.EIP1559_REWARD_PERCENTILE],
        ],
      })) as { baseFeePerGas: string[]; reward: string[][] }
runSuperFunction = async (
        _taskArguments: TaskArguments = taskArguments,
        _subtaskArguments: SubtaskArguments = subtaskArguments
      ) => {
        log("Running %s's super", taskDefinition.name);

        if (taskProfile === undefined) {
          return this._runTaskDefinition(
            taskDefinition.parentTaskDefinition,
            _taskArguments,
            _subtaskArguments
          );
        }

        const parentTaskProfile = createParentTaskProfile(taskProfile);
        taskProfile.children.push(parentTaskProfile);

        try {
          return await this._runTaskDefinition(
            taskDefinition.parentTaskDefinition,
            _taskArguments,
            _subtaskArguments,
            parentTaskProfile
          );
        } finally {
          completeTaskProfile(parentTaskProfile);
        }
      }
function getAction = async function getAction(isEsm: boolean): Promise<Action> {
  if (
    process.env.HARDHAT_CREATE_JAVASCRIPT_PROJECT_WITH_DEFAULTS !== undefined
  ) {
    return Action.CREATE_JAVASCRIPT_PROJECT_ACTION;
  } else if (
    process.env.HARDHAT_CREATE_TYPESCRIPT_PROJECT_WITH_DEFAULTS !== undefined
  ) {
    return Action.CREATE_TYPESCRIPT_PROJECT_ACTION;
  } else if (
    process.env.HARDHAT_CREATE_TYPESCRIPT_VIEM_PROJECT_WITH_DEFAULTS !==
    undefined
  ) {
    return Action.CREATE_TYPESCRIPT_VIEM_PROJECT_ACTION;
  }

  const { default: enquirer } = await import("enquirer");
  try {
    const actionResponse = await enquirer.prompt<{ action: string }>([
      {
        name: "action",
        type: "select",
        message: "What do you want to do?",
        initial: 0,
        choices: Object.values(Action)
          .filter((a: Action) => {
            if (isEsm && a === Action.CREATE_TYPESCRIPT_VIEM_PROJECT_ACTION) {
              // we omit the viem option for ESM projects to avoi...
function getAllWordMatches = function getAllWordMatches(errorMessage) {
    const matches = [];
    const re = /\p{Letter}+/gu;
    let match = re.exec(errorMessage);
    while (match !== null) {
        matches.push({
            word: match[0],
            index: match.index,
        });
        match = re.exec(errorMessage);
    }
    return matches;
}
(rpcQuantityToBigInt(response.baseFeePerGas[1]) *
            9n **
              (AutomaticGasPriceProvider.EIP1559_BASE_FEE_MAX_FULL_BLOCKS_PREFERENCE -
                1n)) /
          8n **
            (AutomaticGasPriceProvider.EIP1559_BASE_FEE_MAX_FULL_BLOCKS_PREFERENCE -
              1n)
function createProject = async function createProject() {
    printAsciiLogo();
    await printWelcomeMessage();
    let packageJson;
    if (await fs_extra_1.default.pathExists("package.json")) {
        packageJson = await fs_extra_1.default.readJson("package.json");
    }
    const isEsm = packageJson?.type === "module";
    const action = await getAction(isEsm);
    if (action === Action.QUIT_ACTION) {
        return;
    }
    if (isEsm && action === Action.CREATE_TYPESCRIPT_PROJECT_ACTION) {
        throw new errors_1.HardhatError(errors_list_1.ERRORS.GENERAL.ESM_TYPESCRIPT_PROJECT_CREATION);
    }
    if (packageJson === undefined) {
        await createPackageJson();
    }
    if (action === Action.CREATE_EMPTY_HARDHAT_CONFIG_ACTION) {
        await writeEmptyHardhatConfig(isEsm);
        console.log(`${(0, emoji_1.emoji)("✨ ")}${chalk_1.default.cyan(`Config file created`)}${(0, emoji_1.emoji)(" ✨")}`);
        if (!isInstalled(HARDHAT_PACKAGE_NAME)) {
            console.log("");
            consol...
_tmp_2.push({
        name: "action",
        type: "select",
        message: "What do you want to do?",
        initial: 0,
        choices: Object.values(Action)
          .filter((a: Action) => {
            if (isEsm && a === Action.CREATE_TYPESCRIPT_VIEM_PROJECT_ACTION) {
              // we omit the viem option for ESM projects to avoid showing
              // two disabled options
              return false;
            }

            return true;
          })
          .map((a: Action) => {
            let message: string;
            if (isEsm) {
              if (a === Action.CREATE_EMPTY_HARDHAT_CONFIG_ACTION) {
                message = a.replace(".js", ".cjs");
              } else if (a === Action.CREATE_TYPESCRIPT_PROJECT_ACTION) {
                message = `${a} (not available for ESM projects)`;
              } else {
                message = a;
              }
            } else {
              message = a;
            }

            return {
              name: a,
         ...)
_tmp_41.INVALID_GLOBAL_CHAIN_ID = {
            number: 101,
            message: "Hardhat was set to use chain id %configChainId%, but connected to a chain with id %connectionChainId%.",
            title: "Connected to the wrong network",
            description: `Your config specifies a chain id for the network you are trying to use, but Hardhat detected a different chain id.

Please make sure you are setting your config correctly.`,
            shouldBeReported: false,
        }
task(
  TASK_FLATTEN,
  "Flattens and prints contracts and their dependencies. If no file is passed, all the contracts in the project will be flattened."
)
  .addOptionalVariadicPositionalParam(
    "files",
    "The files to flatten",
    undefined,
    types.inputFile
  )
  .setAction(async ({ files }: { files: string[] | undefined }, { run }) => {
    const [flattenedFile, metadata]: [string, FlattenMetadata | null] =
      await run(TASK_FLATTEN_GET_FLATTENED_SOURCE_AND_METADATA, { files });

    console.log(flattenedFile);

    if (metadata === null) return;

    if (metadata.filesWithoutLicenses.length > 0) {
      console.warn(
        chalk.yellow(
          `\nThe following file(s) do NOT specify SPDX licenses: ${metadata.filesWithoutLicenses.join(
            ", "
          )}`
        )
      );
    }

    if (
      metadata.pragmaDirective !== "" &&
      metadata.filesWithoutPragmaDirectives.length > 0
    ) {
      console.warn(
        chalk.yellow(
          `\nPrag...
throw new HardhatError(
          ERRORS.RESOLVER.LIBRARY_NOT_INSTALLED,
          {
            library: libraryName,
          },
          error as Error
        );
(proxiedHre as any).adhocProfileSync = (_name: string, f: () => any) => {
        const adhocProfile = createTaskProfile(_name);
        taskProfile!.children.push(adhocProfile);
        try {
          return f();
        } finally {
          completeTaskProfile(adhocProfile);
        }
      }
console.warn(
        chalk.yellow(
          `\nThe flattened file is using the pragma abicoder directive '${
            metadata.pragmaDirective
          }' but these files have a different pragma abicoder directive: ${metadata.filesWithDifferentPragmaDirectives.join(
            ", "
          )}`
        )
      )
_tmp_41.INVALID_HD_PATH = {
            number: 106,
            message: "HD path %path% is invalid. Read about BIP32 to know about the valid forms.",
            title: "Invalid HD path",
            description: `An invalid HD/BIP32 derivation path was provided in your config.

Read the [documentation](https://hardhat.org/hardhat-runner/docs/config#hd-wallet-config) to learn how to define HD accounts correctly.`,
            shouldBeReported: false,
        }
SolidityCallSite = tmp\tmp4frov0qp\hardhatjs\package\src\internal\hardhat-network\stack-traces\solidity-errors.ts::program:SolidityCallSite:<init>
errors.push(
          getErrorMessage(
            `HardhatConfig.networks.${HARDHAT_NETWORK_NAME}`,
            hardhatNetwork,
            "HardhatNetworkConfig"
          )
        )
function isInstalled = function isInstalled(dep) {
    const packageJson = fs_extra_1.default.readJSONSync("package.json");
    const allDependencies = {
        ...packageJson.dependencies,
        ...packageJson.devDependencies,
        ...packageJson.optionalDependencies,
    };
    return dep in allDependencies;
}
this._node._vm.evm.events.emit(
                "afterMessage",
                edrTracingMessageResultToMinimalEVMResult(traceItem)
              )
await Reporter.close(1000)
