params = await getGraphQLParams(request)
const optionsData = await resolveOptions(params)
const validationRules = (_d = optionsData.validationRules) !== null && _d !== void 0 ? _d : []
const context = (_f = optionsData.context) !== null && _f !== void 0 ? _f : request
request.method !== 'GET' && request.method !== 'POST'
showGraphiQL = canDisplayGraphiQL(request, params) && graphiql !== false
const error = http_errors_1.default(400, 
        /* istanbul ignore next: Thrown by underlying library. */
        rawError instanceof Error ? rawError : String(rawError))
const validationErrors = validateFn(schema, documentAST, [
                ...graphql_1.specifiedRules,
                ...validationRules,
            ])
function decompressed = function decompressed(req, encoding) {
    switch (encoding) {
        case 'identity':
            return req;
        case 'deflate':
            return req.pipe(zlib_1.default.createInflate());
        case 'gzip':
            return req.pipe(zlib_1.default.createGunzip());
    }
    throw http_errors_1.default(415, `Unsupported content-encoding "${encoding}".`);
}
validationErrors.length > 0
throw http_errors_1.default(400, 'GraphQL validation error.', {
                    graphqlErrors: validationErrors,
                });
req.pipe(zlib_1.default.createInflate())
throw http_errors_1.default(405, `Can only perform a ${operationAST.operation} operation from a POST request.`, { headers: { Allow: 'POST' } });
throw http_errors_1.default(400, 'GraphQL execution context error.', {
                    graphqlErrors: [contextError],
                });
const error = http_errors_1.default(500, 
            /* istanbul ignore next: Thrown by underlying library. */
            rawError instanceof Error ? rawError : String(rawError))
error.graphqlErrors == null
const graphqlError = new graphql_1.GraphQLError(error.message, undefined, undefined, undefined, undefined, error)
result = { data: undefined, errors: [graphqlError] }
response.statusCode === 200 && result.data == null
const formattedResult = {
            ...result,
            errors: (_o = result.errors) === null || _o === void 0 ? void 0 : _o.map(formatErrorFn),
        }
...result
_tmp_21.errors = (_o = result.errors) === null || _o === void 0 ? void 0 : _o.map(formatErrorFn)
const payload = JSON.stringify(formattedResult, null, pretty ? 2 : 0)
