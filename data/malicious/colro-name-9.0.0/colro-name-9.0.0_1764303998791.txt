const newResponse = options.decompress === true &&
		is.function(decompressResponse) &&
		options.method !== 'HEAD' ? decompressResponse(progressStream) : progressStream
const cacheReq = cacheableRequest(options, response => {
			const {statusCode} = response;
			response.retryCount = retryCount;
			response.url = redirectUrl || requestUrl;
			response.requestUrl = requestUrl;

			const followRedirect = options.followRedirect && 'location' in response.headers;
			const redirectGet = followRedirect && getMethodRedirectCodes.has(statusCode);
			const redirectAll = followRedirect && allMethodRedirectCodes.has(statusCode);

			if (redirectAll || (redirectGet && (options.method === 'GET' || options.method === 'HEAD'))) {
				response.resume();

				if (statusCode === 303) {
					// Server responded with "see other", indicating that the resource exists at another location,
					// and the client should request it from that location via GET or HEAD.
					options.method = 'GET';
				}

				if (redirects.length >= 10) {
					emitter.emit('error', new MaxRedirectsError(statusCode, redirects, options), null, response);
					return;
				}

				const bufferString = Bu...
uploaded === lastUploaded || uploaded === uploadBodySize
const followRedirect = options.followRedirect && 'location' in response.headers
const redirectGet = followRedirect && getMethodRedirectCodes.has(statusCode)
const redirectAll = followRedirect && allMethodRedirectCodes.has(statusCode)
request.setTimeout(
			delays.socket,
			() => {
				timeoutHandler(delays.socket, 'socket');
			}
		)
emitter.emit('error', new MaxRedirectsError(statusCode, redirects, options), null, response)
const cancelTimeout = addTimeout(
					delays.lookup,
					timeoutHandler,
					'lookup'
				)
Object.defineProperty(error, 'response', {value: response})
redirects.push(redirectUrl)
const redirectOpts = {
					...options,
					...urlLib.parse(redirectUrl)
				}
[
		'error',
		'redirect',
		'uploadProgress',
		'downloadProgress'
	].forEach(event => emitter.on(event, (...args) => proxy.emit(event, ...args)))
const cancelTimeout = addTimeout(
						delays.connect,
						timeoutHandler,
						'connect'
					)
throw new TypeError('The `body` option must be an Object when the `form` option is used');
emitter.on(event, (...args) => proxy.emit(event, ...args))
cacheReq.on('error', error => {
			if (error instanceof CacheableRequest.RequestError) {
				emitter.emit('error', new RequestError(error, options));
			} else {
				emitter.emit('error', new CacheError(error, options));
			}
		})
headers['content-type'] = headers['content-type'] || 'application/x-www-form-urlencoded'
options.body = (new URLSearchParamsGlobal(body)).toString()
headers['content-type'] = headers['content-type'] || 'application/json'
cacheReq.once('request', request => {
			let aborted = false;
			request.once('abort', _ => {
				aborted = true;
			});

			request.once('error', error => {
				if (aborted) {
					return;
				}

				if (!(error instanceof GotError)) {
					error = new RequestError(error, options);
				}
				emitter.emit('retry', error, retried => {
					if (!retried) {
						emitter.emit('error', error);
					}
				});
			});

			progress.upload(request, emitter, uploadBodySize);

			if (options.gotTimeout) {
				timedOut(request, options);
			}

			emitter.emit('request', request);
		})
request.once('abort', _ => {
				aborted = true;
			})
request.once('error', error => {
				if (aborted) {
					return;
				}

				if (!(error instanceof GotError)) {
					error = new RequestError(error, options);
				}
				emitter.emit('retry', error, retried => {
					if (!retried) {
						emitter.emit('error', error);
					}
				});
			})
error = new RequestError(error, options)
emitter.emit('retry', error, retried => {
					if (!retried) {
						emitter.emit('error', error);
					}
				})
_tmp_25.socketPath = socketPath
progress.upload(request, emitter, uploadBodySize)
cancelers.push(cancelTimeout)
options.gotRetry = {...defaults.options.retry, retries: options.retry}
