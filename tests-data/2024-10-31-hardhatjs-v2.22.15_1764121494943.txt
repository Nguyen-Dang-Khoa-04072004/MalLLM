function readPackageJson = function readPackageJson(packageName, configPath) {
    const resolve = require("resolve");
    try {
        const packageJsonPath = resolve.sync(path_1.default.join(packageName, "package.json"), {
            basedir: path_1.default.dirname(configPath),
        });
        return require(packageJsonPath);
    }
    catch {
        return undefined;
    }
}
function getCompilationJobCreationError = function getCompilationJobCreationError(file, directDependencies, transitiveDependencies, compilerVersions, overriden) {
    const fileVersionRange = file.content.versionPragmas.join(" ");
    if (semver_1.default.maxSatisfying(compilerVersions, fileVersionRange) === null) {
        const reason = overriden
            ? builtin_tasks_1.CompilationJobCreationErrorReason.INCOMPATIBLE_OVERRIDEN_SOLC_VERSION
            : builtin_tasks_1.CompilationJobCreationErrorReason.NO_COMPATIBLE_SOLC_VERSION_FOUND;
        return { reason, file };
    }
    const incompatibleDirectImports = [];
    for (const dependency of directDependencies) {
        const dependencyVersionRange = dependency.content.versionPragmas.join(" ");
        if (!semver_1.default.intersects(fileVersionRange, dependencyVersionRange)) {
            incompatibleDirectImports.push(dependency);
        }
    }
    if (incompatibleDirectImports.length > 0) {
        return {
            reason: builtin_tasks_1.CompilationJobC...
function edrTracingMessageResultToMinimalEVMResult = function edrTracingMessageResultToMinimalEVMResult(tracingMessageResult) {
    const { result, contractAddress } = tracingMessageResult.executionResult;
    // only SuccessResult has logs
    const success = "logs" in result;
    const minimalEVMResult = {
        execResult: {
            executionGasUsed: result.gasUsed,
            success,
        },
    };
    // only success and exceptional halt have reason
    if ("reason" in result) {
        minimalEVMResult.execResult.reason = result.reason;
    }
    if ("output" in result) {
        const { output } = result;
        if (Buffer.isBuffer(output)) {
            minimalEVMResult.execResult.output = output;
        }
        else {
            minimalEVMResult.execResult.output = output.returnValue;
        }
    }
    if (contractAddress !== undefined) {
        minimalEVMResult.execResult.contractAddress = new ethereumjs_util_1.Address(contractAddress);
    }
    return minimalEVMResult;
}
function getCompletionData = async function getCompletionData() {
    const projectId = getProjectId();
    if (projectId === undefined) {
        return undefined;
    }
    const cachedCompletionData = await getCachedCompletionData(projectId);
    if (cachedCompletionData !== undefined) {
        if (arePreviousMtimesCorrect(cachedCompletionData.mtimes)) {
            return cachedCompletionData.completionData;
        }
    }
    const filesBeforeRequire = Object.keys(require.cache);
    let hre;
    try {
        process.env.TS_NODE_TRANSPILE_ONLY = "1";
        require("../../register");
        hre = global.hre;
    }
    catch {
        return undefined;
    }
    const filesAfterRequire = Object.keys(require.cache);
    const mtimes = getMtimes(filesBeforeRequire, filesAfterRequire);
    const networks = Object.keys(hre.config.networks);
    // we extract the tasks data explicitly to make sure everything
    // is serializable and to avoid saving unnecessary things from the HRE
    const tasks = (0, lan...
assertHardhatInvariant(
        scopeDefinition !== undefined,
        "It shouldn't be possible to create a task in a scope that doesn't exist"
      )
_tmp_15.INVALID_BIG_NUMBER = {
      number: 17,
      message: "The input value cannot be normalized to a BigInt: %message%",
      title: "Invalid big number",
      description:
        "Hardhat attempted to convert the input value to a BigInt, but no known conversion method was applicable to the given value.",
      shouldBeReported: false,
    }
console.warn(chalk_1.default.yellow(`Solidity remappings are not currently supported; you may experience unexpected compilation results. Remove any 'remappings' fields from your configuration to suppress this warning.

Learn more about compiler configuration at https://hardhat.org/config
`))
function includesOwnPackageName = async function includesOwnPackageName(
  sourceName: string
): Promise<boolean> {
  const packageName = await getPackageName(sourceName);
  if (packageName !== "") {
    return sourceName.startsWith(`${packageName}/`);
  }
  return false;
}
