var onAgentResponse = function(res) {

                    var data = '', err = false;

                    res.on('data', function (chunk) {
                        data += chunk;
                    });
                    res.on('error', function (error) {
                        err = 'Failed to get mail content';
                        if (error && typeof(error.stack) != 'undefined' ) {
                            err += error.stack;
                        } else if ( typeof(error) == 'string' ) {
                            err += '\n' + error;
                        }
                    });
                    res.on('end', function () {
                        if (/^\{/.test(data) ) {
                            try {
                                data = JSON.parse(data);
                                if (typeof(data.error) != 'undefined') {
                                    err = JSON.clone(data);
                                    data = null;
                      ...
copyFile(source, destination, i, function(err, i) {
                if (err) {
                    console.error(err.stack)
                }
                callback(err, i)
            })
typeof(gina.popin) != 'undefined'
                                && gina.hasPopinHandler
                                && typeof(result.location) != 'undefined'
                                && isXhrRedirect
var configFiles = fs.readdirSync(_(appPath + '/config'))
function SingleByteEncoder = function SingleByteEncoder(index, options) {
  var fatal = options.fatal;
  /**
   * @param {ByteOutputStream} output_byte_stream Output byte stream.
   * @param {CodePointInputStream} code_point_pointer Input stream.
   * @returns {number} The last byte emitted.
   */
  this.encode = function(output_byte_stream, code_point_pointer) {
    var code_point = code_point_pointer.get();
    if (code_point === EOF_code_point) {
      return EOF_byte;
    }
    code_point_pointer.offset(1);
    if (inRange(code_point, 0x0000, 0x007F)) {
      return output_byte_stream.emit(code_point);
    }
    var pointer = indexPointerFor(code_point, index);
    if (pointer === null) {
      encoderError(code_point);
    }
    return output_byte_stream.emit(pointer + 0x80);
  };
}
console.debug('Validator::Popin now redirecting [1-c]')
_iterator_3 = <operator>.iterator(resHeaders)
response.setHeader('content-type', 'text/plain' + '; charset='+ local.options.conf.encoding)
/^\./.test(fName) || new RegExp('\.'+ env +'\.json$').test(fName) || !/\.json$/.test(fName)
origin = allowedOrigin.replace(/\s+/g, '').replace(re, originHostReplacement)
encoding.getEncoder = function(options) {
        return new SingleByteEncoder(idx, options);
      }
tmp = fName.replace(/.json/, '.' + env + '.json')
exit = function(errorMessage) {
        // CMD Client exit
        if ( typeof(errorMessage) != 'undefined' ) {
            client.write(errorMessage + '\n');
        }
        client.end();
        if (errorMessage) {
            process.exit(1)
        } else {
            process.exit()
        }
    }
triggerEvent(gina, $target, 'error.' + id, result)
isOverridinMethod = ( typeof(arguments[arguments.length-1]) != 'boolean') ? false : arguments[arguments.length-1]
var removeFileSync = function(filename) {
        try {
            fs.unlinkSync(filename)
        } catch (err) {
            console.debug(err.stack); // always keep trace of the original stack
            throw new Error(err.message)
        }
    }
Array.isArray(jsonFile) && !Array.isArray(fileContent) && !Object.keys(fileContent).length
result.location = (!/^http/.test(result.location) && !/^\//.test(result.location) ) ? location.protocol +'//' + result.location : result.location
var browseRemoveSync = function(source, list, folders, i) {
        list = ( typeof(list) != 'undefined' ) ? list : [];
        folders = ( typeof(folders) != 'undefined' ) ? folders : [];
        i = ( typeof(i) != 'undefined' ) ? i : 0;
        var err = false;

        if (list.length === 0) {
            list.push(source)
        }

        if (source == undefined) {
            if (folders.length > 0) {
                removeFoldersSync(folders.reverse(), 0, 0)
            } else {
                return list[list.length -1]
            }
        } else {

            var stats = fs.lstatSync(source);

            if (stats instanceof Error)
                return stats;

            if ( stats.isSymbolicLink() ) {
                err = removeFileSync(source);
                if (err instanceof Error)
                    return err;

                ++i;
                browseRemoveSync(list[i], list, folders, i)
            } else if ( stats.isDirectory() ) {

                if (...
routing         = routing ||Â config.getRouting(bundle)
exists = fs.existsSync(_(filename, true))
reader.addEventListener('loadend', (e) => {

                                if ( /string/i.test(typeof(e.srcElement.result)) ) {
                                    blobError += e.srcElement.result;
                                    // try {
                                    //     result = merge( result, JSON.parse(blobError) )
                                    // } catch (err) {
                                    //     result = merge(result, err)
                                    // }

                                } else if ( typeof(e.srcElement.result) == 'object' ) {
                                    result = merge(result, e.srcElement.result)
                                } else {
                                    result.message += e.srcElement.result
                                }

                                // once ready
                                if ( /2/.test(reader.readyState) ) {

                                    if ( /^(\{|\[)/.test( b...
var url = (isWebroot) ? this._referrer : headers[':path']
typeof(a[columns[index]]) == 'boolean' || typeof (b[columns[index]]) == 'boolean'
code_point = pointer === null ? null :
          indexCodePointFor(pointer, indexes['gbk'])
var val         = local.data[this.name] = this.value
routing[rule].middleware = merge(commonMiddlewares.slice(), routing[rule].middleware)
_tmp_143.gina = getPath('gina').root
_tmp_143.frameworkDir = getEnvVar('GINA_FRAMEWORK_DIR')
var re = /(^(?!:[\w]\:|\\)(\/[a-zA-Z_\-\s0-9\.]+)+|^(?:[\w]\:|\\)(\\[a-z_\-\s0-9\.]+)+)/
var code_point = (pointer === null) ? null :
          indexCodePointFor(pointer, indexes['big5'])
var corePath = getPath('gina').core
var settingsPath = _(corePath +'/template/conf/settings.json', true)
var staticsPath = _(corePath +'/template/conf/statics.json', true)
var viewsPath = _(corePath +'/template/conf/templates.json', true)
typeof(flash) != 'undefined' && flash != ''
self['isValid'] = function() {
        return (self['getErrors']().count() > 0) ? false : true;
    }
files['templates'][section] = merge(files['templates'][section], defaultViews[section])
var hostname = (isProxyHost) ? ctx.config.envConf[bundle][env].hostname.replace(/\:\d+$/, '') : ctx.config.envConf[bundle][env].hostname
noneDefaultJs[t] = merge(url, noneDefaultJs[t])
Array.isArray(noneDefaultCss) && noneDefaultCss.length > 0
var state = {
    ASCII: 0,
    escape_start: 1,
    escape_middle: 2,
    escape_final: 3,
    lead: 4,
    trail: 5,
    Katakana: 6
  }
typeof(self[fieldName]) != 'undefined' && self[fieldName] && typeof(self[fieldName]['errors']) != 'undefined' && self[fieldName]['errors'].count() > 0
errors[fieldName] = self[fieldName]['errors']
header = {
                                    ':status': 200,
                                    'content-type': contentType + '; charset='+ bundleConf.encoding
                                }
noneDefaultJs   = (files['templates'][section].javascripts) ? JSON.clone(files['templates'][section].javascripts) : []
noneDefaultCss  = (files['templates'][section].stylesheets) ? JSON.clone(files['templates'][section].stylesheets) : []
Array.isArray(noneDefaultJs) && noneDefaultJs.length > 0
header  = completeHeaders(header, request, response)
typeof(url) == 'string'
noneDefaultJs[t] = merge(url, noneDefaultJs[t])
target = target.replace(new RegExp(keys[k], 'g'), fieldObj[local.keys[keys[k]]])
response.setHeader('content-length', fs.statSync(filename).size)
self['setErrorLabels'] = function (errorLabels) {
        if ( typeof(errorLabels) != 'undefined') {
            local.errorLabels = merge(errorLabels, local.errorLabels)
        }
    }
var error = new ApiError('Controller::redirect(...) exceptions: `inheritedData` reached 2000 chars limit', 424)
!(_result_15 = _iterator_15.next()).done
( typeof(module) !== 'undefined' ) && module.exports
noneDefaultCss[t] = merge(url, noneDefaultCss[t])
noneDefaultJs = merge.setKeyComparison('url')(files['templates']._common.javascripts, noneDefaultJs, true)
noneDefaultJs   = merge.setKeyComparison('url')(defaultViews._common.javascripts, noneDefaultJs)
noneDefaultCss = merge.setKeyComparison('url')(files['templates']._common.stylesheets, noneDefaultCss, true)
noneDefaultCss  = merge.setKeyComparison('url')(defaultViews._common.stylesheets, noneDefaultCss)
files['templates'][section][ref] = merge(files['templates'][section][ref], files['templates']._common[ref])
let allFilesCollection = new Collection(files['templates'][section][excludedStr.replace(/Excluded$/, '')])
let xhrOptions = {
                            url: url,
                            method: method,
                            isSynchrone: isSynchrone,
                            headers : {
                                // to upload, use `multipart/form-data` for `enctype`
                                'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8',
                                // cross domain is enabled by default, but you need to setup `Access-Control-Allow-Origin`
                                'X-Requested-With': 'XMLHttpRequest' // in case of cross domain origin
                            }
                        }
!Array.isArray(excluded) && !/^(\*|\*\*|all)$/i.test(files['templates'][section][excludedStr])
output_byte_stream.emit(0x1B, 0x28, 0x42)
this.getBundleStatus = function(req, res, next) {
        var conf = self.getConfig();
        self.renderJSON({
            status: 200,
            isAlive: true,
            message: 'I am alive !',
            // bundle: conf.bundle,
            // project: conf.projectName
        });
    }
currentCollection = new Collection(excluded)
var response = { isAlive: false }
currentCollectionRaw[e].url != excludedUrl[t]
currentCollection = currentCollection.delete({ 'url': excludedUrl }, 'url')
/^image/i.test(self.conf[self.appName][self.env].server.coreConfiguration.mime[ext.substr(1)])
