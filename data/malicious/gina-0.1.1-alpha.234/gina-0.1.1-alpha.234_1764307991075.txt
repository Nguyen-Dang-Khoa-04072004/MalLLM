getModel = function(bundle, model) {

        var ctx       = getContext();

        if (arguments.length == 1 || !bundle) {
            //console.debug(
            //    '\n[ 0 ] = '+ __stack[0].getFileName(),
            //    '\n[ 1 ] = '+ __stack[1].getFileName(),
            //    '\n[ 2 ] = '+ __stack[2].getFileName(),
            //    '\n[ 3 ] = '+ __stack[3].getFileName(),
            //    '\n[ 4 ] = '+ __stack[4].getFileName(),
            //    '\n[ 5 ] = '+ __stack[5].getFileName(),
            //    '\n[ 6 ] = '+ __stack[6].getFileName()
            //);


            // var model       = (arguments.length == 1) ? bundle : model
            //     , file      = ( !/node_modules/.test(__stack[1].getFileName()) ) ?  __stack[1].getFileName() : __stack[2].getFileName()
            //     , a         = file.replace('.js', '').split('/')
            //     , i         = a.length-1
            //     , bundle    = null;
            //
            // var conf        = getCont...
self.checkScope = function(done) {
        // ignored for framework:set
        var err     = null;
        var main    = require( self.opt.homedir + '/main.json' );
        //has registered scope ?
        var scope   = getEnvVar('GINA_SCOPE') || main['local_scope'][self.release]; // scope by default
        if ( main.scopes[self.release].indexOf(scope) < 0 ) {
            // console.error('Scope [ ' + scope + ' ] not registered. See [ man gina-scope ].');
            // process.exit(1)
            err = new Error('Scope [ ' + scope + ' ] not registered. See [ man gina-scope ].');
            return done(err)
        }


        // has local scope ?
        if (
            typeof(main['local_scope']) == 'undefined' ||
            typeof(main['local_scope']) != 'undefined' &&
            typeof(main['local_scope'][self.release]) != 'undefined' &&
            main.scopes[self.release].indexOf(main['local_scope'][self.release]) < 0
        ) {
            // console.error('the framew...
_.prototype.mkdir = function(permission, callback) {
        if ( typeof(permission) == "function") {
            callback = permission;
            permission = 0775
        }
        var self = this;
        self = cleanSlashes(self);

        //Enter dir & start rm.
        exists(self.value, function(found) {
            if (found) {
                callback(false, self.value)
            } else {
                var p = self.value;

                mkdir(self)
                    .onComplete( function(err, path){
                        //Avoid collisions.
                        if (err) {
                            console.crit("debug needed mkdir for targeted folder !! ", err);
                            process.exit(1)
                        } else {

                            if (p == path  && typeof(callback) != 'undefined' && typeof(self.created) == 'undefined' ) {
                                if (typeof(callback) != 'undefined') {
                               ...
typeof (target[a]) != 'undefined'
                            && !/null/i.test(target[a])
                            && typeof (target[a][localKeyComparison]) != 'undefined'
                            && typeof (options[a]) != 'undefined'
                            && typeof (options[a][localKeyComparison]) != 'undefined'
                            && target[a][localKeyComparison] == options[a][localKeyComparison]
_tmp_53.labels = [
          "iso-8859-14",
          "iso8859-14",
          "iso885914"
        ]
self.setMaster = function(bool){

        if ( typeof(bool) == 'undefined' ||Â bool == true) {
            self.master = true;
        } else {
            self.master = false;
        }
    }
xhr.onerror = function(event, err) {

                var error = 'Transaction error: might be due to the server CORS settings.\nPlease, check the console for more details.';
                var result = {
                    'status':  xhr.status, //500,
                    'error' : error
                };

                console.debug('query error [2] detected !! ', err, error);
                isOnException = true;
                result = this.responseText;
                    var contentType     = this.getResponseHeader("Content-Type");
                    if ( /\/json/.test( contentType ) ) {
                        result = JSON.parse(this.responseText);

                        if ( typeof(result.status) == 'undefined' )
                            result.status = this.status;

                        //triggerEvent(gina, $target, 'success.' + id, result);
                        return onResult(result)
                    } else {
                        result = { 'stat...
self.register = function(bundle, pid) {

        var processCollection = new Collection(process.list);
        var existingProcess = processCollection.findOne({ name: bundle, pid: pid });
        // cleanup if found;
        if (existingProcess) {
            process.list = processCollection.delete({ name: bundle, pid: pid }, 'pid').toRaw();
            dismiss(existingProcess.pid);
            console.debug('[ PROC ] Don\'t pannic ...');
            existingProcess = null;
            return;
        }



        if ( /^gina\-/.test(bundle) || !/^gina\-/.test(bundle) && self.bundles.indexOf(bundle) < 0 ) {
            console.debug('[ PROC ] Now registering `'+bundle+'` with PID `'+ pid +'`');


            var list = {};

            var processRegistration = function () {


                if (!/^gina\-/.test(bundle) && !existingProcess) {
                    self.bundles.push(bundle);
                }
                // save to ~/.gina/procs.json
                else if (/^gina...
