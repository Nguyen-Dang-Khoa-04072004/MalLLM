function samplize = function samplize(module_name) {
    var cmd1 = 'git clone https://github.com/pm2-hive/sample-module.git ' + module_name + '; cd ' + module_name + '; rm -rf .git';
    var cmd2 = 'cd ' + module_name + ' ; sed -i "s:sample-module:'+ module_name  +':g" package.json';
    var cmd3 = 'cd ' + module_name + ' ; npm install';

    Common.printOut(cst.PREFIX_MSG_MOD + 'Getting sample app');

    sexec(cmd1, function(err) {
      if (err) Common.printError(cst.PREFIX_MSG_MOD_ERR + err.message);
      sexec(cmd2, function(err) {
        console.log('');
        sexec(cmd3, function(err) {
          console.log('');
          Common.printOut(cst.PREFIX_MSG_MOD + 'Module sample created in folder: ', path.join(process.cwd(), module_name));
          console.log('');
          Common.printOut('Start module in development mode:');
          Common.printOut('$ cd ' + module_name + '/');
          Common.printOut('$ pm2 install . ');
          console.log('');

          Common.printOut('Module Log:...
var maxMemoryRestart = function(proc_key, cb) {
    var proc = _getProcessById(proc_key.pm2_env.pm_id);

    if (!(proc &&
          proc.pm2_env &&
          proc_key.monit))
      return cb();

    if (proc_key.monit.memory !== undefined &&
        proc.pm2_env.max_memory_restart !== undefined &&
        proc.pm2_env.max_memory_restart < proc_key.monit.memory &&
        proc.pm2_env.axm_options &&
        proc.pm2_env.axm_options.pid === undefined) {
      console.log('[PM2][WORKER] Process %s restarted because it exceeds --max-memory-restart value (current_memory=%s max_memory_limit=%s [octets])', proc.pm2_env.pm_id, proc_key.monit.memory, proc.pm2_env.max_memory_restart);
      God.reloadProcessId({
        id : proc.pm2_env.pm_id
      }, function(err, data) {
        if (err)
          console.error(err.stack || err);
        return cb();
      });
    }
    else {
      return cb();
    }
  }
Monit.refresh = function(processes) {
  debug('Monit refresh');

  if(!processes) {
    processes = [];
  }

  var num = processes.length;
  this.num_bars = Object.size(this.bars);

  if(num !== this.num_bars) {
    debug('Monit addProcesses - actual: %s, new: %s', this.num_bars, num);
    return this.addProcesses(processes);
  } else {

    if(num === 0) {
      return;
    }

    debug('Monit refresh');
    var proc;

    for(var i = 0; i < num; i++) {
      proc = processes[i];

      //this is to avoid a print issue when the process is restarted for example
      //we might also check for the pid but restarted|restarting will be rendered bad
      if(this.bars[proc.pm_id] && proc.pm2_env.status !== this.bars[proc.pm_id].status) {
        debug('bars for %s does not exist', proc.pm_id);
        this.addProcesses(processes);
        break;
      }

      this.updateBars(proc);

    }
  }

  return this;
}
require('vizion').isUpToDate({folder: proc.pm2_env.versioning.repo_path}, function(err, meta) {
          if (err !== null)
            return cb ? cb({msg:err}) : that.exitCli(cst.ERROR_EXIT);
          require('vizion').revertTo(
            {revision: commit_id,
             folder: proc.pm2_env.versioning.repo_path},
            function(err2, meta2) {
              if (!err2 && meta2.success) {
                getPostUpdateCmds(proc.pm2_env.versioning.repo_path, process_name, function (command_list) {
                  execCommands(proc.pm2_env.versioning.repo_path, command_list, function(err, res) {
                    if (err !== null)
                    {
                      printError(err);
                      return cb ? cb({msg:err}) : that.exitCli(cst.ERROR_EXIT);
                    }
                    else {
                      printOut(cst.PREFIX_MSG + 'Process successfully updated %s', process_name);
                      printOut(cst.PREFIX_MSG + 'Current c...
