const hasLockFile = fs.existsSync(path.resolve(rootDir, options.yarn ? 'yarn.lock' : 'package-lock.json')) || fs.existsSync(path.resolve(rootDir, 'npm-shrinkwrap.json'))
tasks.add([
			{
				title: 'Cleanup',
				enabled: () => !hasLockFile,
				task: () => deleteAsync('node_modules'),
			},
			{
				title: 'Installing dependencies using Yarn',
				enabled: () => options.yarn === true,
				task: () => (
					exec('yarn', ['install', '--frozen-lockfile', '--production=false']).pipe(
						catchError(async error => {
							if ((!error.stderr.startsWith('error Your lockfile needs to be updated'))) {
								return;
							}

							if (await git.checkIfFileGitIgnored('yarn.lock')) {
								return;
							}

							throw new Error('yarn.lock file is outdated. Run yarn, commit the updated lockfile and try again.');
						}),
					)
				),
			},
			{
				title: 'Installing dependencies using npm',
				enabled: () => options.yarn === false,
				task() {
					const args = hasLockFile ? ['ci'] : ['install', '--no-package-lock', '--no-production'];
					return exec('npm', [...args, '--engine-strict']);
				},
			},
		])
_tmp_10.push({
				title: 'Cleanup',
				enabled: () => !hasLockFile,
				task: () => deleteAsync('node_modules'),
			})
const getPreReleasePrefix = pMemoize(async options => {
	ow(options, ow.object.hasKeys('yarn'));

	try {
		if (options.yarn) {
			const {stdout} = await execa('yarn', ['config', 'get', 'preId']);
			if (stdout !== 'undefined') {
				return stdout;
			}

			return '';
		}

		const {stdout} = await execa('npm', ['config', 'get', 'preId']);
		if (stdout !== 'undefined') {
			return stdout;
		}

		return '';
	} catch {
		return '';
	}
})
_tmp_10.push({
				title: 'Installing dependencies using Yarn',
				enabled: () => options.yarn === true,
				task: () => (
					exec('yarn', ['install', '--frozen-lockfile', '--production=false']).pipe(
						catchError(async error => {
							if ((!error.stderr.startsWith('error Your lockfile needs to be updated'))) {
								return;
							}

							if (await git.checkIfFileGitIgnored('yarn.lock')) {
								return;
							}

							throw new Error('yarn.lock file is outdated. Run yarn, commit the updated lockfile and try again.');
						}),
					)
				),
			})
const checkIgnoreStrategy = ({files}, rootDir) => {
	const npmignoreExistsInPackageRootDir = pathExists(path.resolve(rootDir, '.npmignore'));

	if (!files && !npmignoreExistsInPackageRootDir) {
		console.log(`
		\n${chalk.bold.yellow('Warning:')} No ${chalk.bold.cyan('files')} field specified in ${chalk.bold.magenta('package.json')} nor is a ${chalk.bold.magenta('.npmignore')} file present. Having one of those will prevent you from accidentally publishing development-specific files along with your package's source code to npm.
		`);
	}
}
tasks.add([
			{
				title: 'Running tests using npm',
				enabled: () => options.yarn === false,
				task: () => exec('npm', testCommand),
			},
			{
				title: 'Running tests using Yarn',
				enabled: () => options.yarn === true,
				task: () => exec('yarn', testCommand).pipe(
					catchError(error => {
						if (error.message.includes(`Command "${testScript}" not found`)) {
							return [];
						}

						return throwError(() => error);
					}),
				),
			},
		])
tasks.add([
		{
			title: 'Bumping version using Yarn',
			enabled: () => options.yarn === true,
			skip() {
				if (options.preview) {
					let previewText = `[Preview] Command not executed: yarn version --new-version ${input}`;

					if (options.message) {
						previewText += ` --message '${options.message.replace(/%s/g, input)}'`;
					}

					return `${previewText}.`;
				}
			},
			task() {
				const args = ['version', '--new-version', input];

				if (options.message) {
					args.push('--message', options.message);
				}

				return exec('yarn', args);
			},
		},
		{
			title: 'Bumping version using npm',
			enabled: () => options.yarn === false,
			skip() {
				if (options.preview) {
					let previewText = `[Preview] Command not executed: npm version ${input}`;

					if (options.message) {
						previewText += ` --message '${options.message.replace(/%s/g, input)}'`;
					}

					return `${previewText}.`;
				}
			},
			task() {
				const args = ['version', input];

				if (o...
const answers = await inquirer.prompt({
		version: {
			type: 'list',
			message: 'Select semver increment or specify new version',
			pageSize: Version.SEMVER_INCREMENTS.length + 2,
			choices: [...Version.SEMVER_INCREMENTS
				.map(inc => ({
					name: `${inc} 	${prettyVersionDiff(oldVersion, inc)}`,
					value: inc,
				})),
			new inquirer.Separator(),
			{
				name: 'Other (specify)',
				value: null,
			}],
			filter: input => Version.isValidInput(input) ? new Version(oldVersion).getNewVersionFrom(input) : input,
		},
		customVersion: {
			type: 'input',
			message: 'Version',
			when: answers => !answers.version,
			filter: input => Version.isValidInput(input) ? new Version(pkg.version).getNewVersionFrom(input) : input,
			validate(input) {
				if (!Version.isValidInput(input)) {
					return 'Please specify a valid semver, for example, `1.2.3`. See https://semver.org';
				}

				if (new Version(oldVersion).isLowerThanOrEqualTo(input)) {
					return `Version must be greater than ${...
tasks.add([
				{
					title: 'Enabling two-factor authentication',
					skip() {
						if (options.preview) {
							const args = enable2fa.getEnable2faArgs(pkg.name, options);
							return `[Preview] Command not executed: npm ${args.join(' ')}.`;
						}
					},
					task: (context, task) => enable2fa(task, pkg.name, {otp: context.otp}),
				},
			])
tasks.add({
		title: 'Pushing tags',
		async skip() {
			if (!(await git.hasUpstream())) {
				return 'Upstream branch not found; not pushing.';
			}

			if (options.preview) {
				return '[Preview] Command not executed: git push --follow-tags.';
			}

			if (publishStatus === 'FAILED' && options.runPublish) {
				return 'Couldn\'t publish package to npm; not pushing.';
			}
		},
		async task() {
			pushedObjects = await git.pushGraceful(isOnGitHub);
		},
	})
_tmp_26.publishScoped = {
			type: 'confirm',
			when: isScoped(pkg.name) && options.availability.isAvailable && !options.availability.isUnknown && options.runPublish && (pkg.publishConfig && pkg.publishConfig.access !== 'restricted') && !npm.isExternalRegistry(pkg),
			message: `This scoped repo ${chalk.bold.magenta(pkg.name)} hasn't been published. Do you want to publish it publicly?`,
			default: false,
		}
_tmp_47.publishScoped = answers.publishScoped
