this.scope = new Scope({
			block: true,
			parent: this.parent.findScope(false),
			declare: id => this.createdDeclarations.push(id)
		})
this.superClassName =
				parentClass.superClass && (parentClass.superClass.name || 'superclass')
!node.program.indentExclusions[indentStart] &&
		code.original.slice(indentStart, start) === indentStr
const children = this.children.filter(child => {
			if (child.type !== 'JSXText') return true;

			// remove whitespace-only literals, unless on a single line
			return /[^ \f\n\r\t\v]/.test(child.raw) || !/\n/.test(child.raw);
		})
Scope.prototype = {
	addDeclaration(node, kind) {
		for (const identifier of extractNames(node)) {
			const name = identifier.name;

			const declaration = { name, node: identifier, kind, instances: [] };
			this.declarations[name] = declaration;

			if (this.isBlockScope) {
				if (!this.functionScope.blockScopedDeclarations[name])
					this.functionScope.blockScopedDeclarations[name] = [];
				this.functionScope.blockScopedDeclarations[name].push(declaration);
			}
		}
	},

	addReference(identifier) {
		if (this.consolidated) {
			this.consolidateReference(identifier);
		} else {
			this.identifiers.push(identifier);
		}
	},

	consolidate() {
		for (let i = 0; i < this.identifiers.length; i += 1) {
			// we might push to the array during consolidation, so don't cache length
			const identifier = this.identifiers[i];
			this.consolidateReference(identifier);
		}

		this.consolidated = true; // TODO understand why this is necessary... seems bad
	},

	consolidateReference(identifier)...
function destructureIdentifier = function destructureIdentifier(
	code,
	createIdentifier,
	resolveName,
	node,
	ref,
	inline,
	statementGenerators
) {
	statementGenerators.push((start, prefix, suffix) => {
		code.overwrite(node.start, node.end, (inline ? prefix : `${prefix}var `) + resolveName(node) + ` = ${ref}${suffix}`);
		code.move(node.start, node.end, start);
	});
}
var result = buble.transform(source, {
		target: options.target,
		transforms: options.transforms,
		source: from,
		file: to,
		jsx: options.jsx,
		objectAssign: options.objectAssign,
		namedFunctionExpressions: options.namedFunctionExpressions
	})
function destructureAssignmentPattern = function destructureAssignmentPattern(
	code,
	createIdentifier,
	resolveName,
	node,
	ref,
	inline,
	statementGenerators
) {
	const isIdentifier = node.left.type === 'Identifier';
	const name = isIdentifier ? node.left.name : ref;

	if (!inline) {
		statementGenerators.push((start, prefix, suffix) => {
			code.prependRight(
				node.left.end,
				`${prefix}if ( ${name} === void 0 ) ${name}`
			);
			code.move(node.left.end, node.right.end, start);
			code.appendLeft(node.right.end, suffix);
		});
	}

	if (!isIdentifier) {
		destructure(code, createIdentifier, resolveName, node.left, ref, inline, statementGenerators);
	}
}
namedFunctions ||
				this.parent.superClass ||
				this.parent.type !== 'ClassDeclaration'
<operator>.formatString("\n", i1, "", superName, ".apply(this, arguments);\n", i0, "}")
removeTrailingComma(code, this.params[this.params.length - 1].end)
