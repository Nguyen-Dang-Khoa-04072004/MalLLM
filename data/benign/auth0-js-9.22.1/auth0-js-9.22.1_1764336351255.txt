this.request
    .post(url)
    .withCredentials()
    .send(authenticateBody)
    .end(function(err, data) {
      if (err) {
        var errorObject = (err.response && err.response.body) || {
          error: 'request_error',
          error_description: JSON.stringify(err)
        };

        return responseHandler(cb, { forceLegacyError: true })(errorObject);
      }

      function doAuth() {
        var popupMode = options.popup === true;

        options = objectHelper.blacklist(options, [
          'password',
          'credentialType',
          'otp',
          'popup',
          'onRedirecting'
        ]);

        var authorizeOptions = objectHelper
          .merge(options)
          .with({ loginTicket: data.body.login_ticket });

        var key = createKey(_this.baseOptions.rootUrl, data.body.co_id);

        _this.storage.setItem(key, data.body.co_verifier, {
          expires: times.MINUTES_15
        });

        if (popupMode) {
          _this.webMessageHandler...
cb(
      null,
      objectHelper.toCamelCase(data.body || data, [], {
        keepOriginal: options.keepOriginalCasing
      })
    )
function injectCaptchaScript = function injectCaptchaScript(element, opts, callback) {
  var providerName;
  switch (opts.provider) {
    case RECAPTCHA_ENTERPRISE_PROVIDER:
      providerName = 'recaptcha';
      break;
    case RECAPTCHA_V2_PROVIDER:
      providerName = 'recaptcha';
      break;
    case HCAPTCHA_PROVIDER:
      providerName = 'hcaptcha';
      break;
    case FRIENDLY_CAPTCHA_PROVIDER:
      providerName = 'friendly_captcha';
      break;
  }
  var callbackName = providerName + 'Callback_' + Math.floor(Math.random() * 1000001);
  window[callbackName] = function() {
    delete window[callbackName];
    callback();
  };
  var script = window.document.createElement('script');
  script.src = scriptForCaptchaProvider(
    opts.provider,
    opts.lang,
    callbackName
  );
  script.async = true;
  script.defer = true;
  if (opts.provider === FRIENDLY_CAPTCHA_PROVIDER) {
    script.onload = window[callbackName];
  }
  window.document.body.appendChild(script);
}
_tmp_11.authParams = {
        optional: true,
        type: 'object',
        message: 'authParams option is required'
      }
Object.keys(object).reduce(function(p, key) {
    var newKey = exceptions.indexOf(key) === -1 ? snakeToCamel(key) : key;

    p[newKey] = toCamelCase(object[newKey] || object[key], [], options);

    if (options.keepOriginal) {
      p[key] = toCamelCase(object[key], [], options);
    }
    return p;
  }, {})
RequestBuilder.prototype.getTelemetryData = function() {
  var telemetryName = this._universalLoginPage ? 'auth0.js-ulp' : 'auth0.js';
  var clientInfo = { name: telemetryName, version: version.raw };
  if (this._telemetryInfo) {
    clientInfo = objectHelper.extend({}, this._telemetryInfo);
    clientInfo.env = objectHelper.extend({}, this._telemetryInfo.env);
    clientInfo.env[telemetryName] = version.raw;
  }
  var jsonClientInfo = JSON.stringify(clientInfo);
  return base64Url.encode(jsonClientInfo);
}
body = objectHelper
    .merge(this.baseOptions, ['clientID'])
    .with(options, ['email', 'connection'])
_tmp_2._telemetryInfo = {
        optional: true,
        type: 'object',
        message: '_telemetryInfo option is not valid'
      }
var authorizeOptions = objectHelper
          .merge(options)
          .with({ loginTicket: data.body.login_ticket })
event.url && !(event.url.indexOf(callbackUrl + '#') === 0)
Authentication.prototype.buildAuthorizeUrl = function (options) {
  var params;
  var qString;

  assert.check(options, {
    type: 'object',
    message: 'options parameter is not valid'
  });

  params = objectHelper
    .merge(this.baseOptions, [
      'clientID',
      'responseType',
      'responseMode',
      'redirectUri',
      'scope',
      'audience'
    ])
    .with(options);

  /* eslint-disable */
  assert.check(
    params,
    { type: 'object', message: 'options parameter is not valid' },
    {
      clientID: { type: 'string', message: 'clientID option is required' },
      redirectUri: {
        optional: true,
        type: 'string',
        message: 'redirectUri option is required'
      },
      responseType: {
        type: 'string',
        message: 'responseType option is required'
      },
      nonce: {
        type: 'string',
        message: 'nonce option is required',
        condition: function (o) {
          return (
            o.responseType.indexO...
new RequestObj(
    this.setCommonConfiguration(request.post(url), options)
  )
this.setCommonConfiguration(request.post(url), options)
