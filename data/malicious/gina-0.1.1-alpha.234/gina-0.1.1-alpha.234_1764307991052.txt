module.exports = function(session, bundle){

    /**
     * Express's session Store.
     */

    var Store = session.Store;

    /**
     * Initialize CouchbaseStore with the given `options`.
     *
     * @param {Object} options
     *      {
     *          host: 127.0.0.1:8091 (default) -- Can be one or more address:ports, separated by semi-colon, or an array
     *          username: '',   -- Should be same as bucket name, if provided
     *          password: '',
     *          bucket: 'default' (default)
     *          cachefile: ''
     *          ttl: 86400,
     *          prefix: 'sess',
     *          operationTimeout:2000,
                connectionTimeout:2000,
     *      }
     * @api public
     */

    function CouchbaseStore(options) {
        var self = this;

        options = options || {};
        Store.call(this, options);
        this.prefix = null == options.prefix
            ? 'sess:'
            : options.prefix;

        var connectOptions = {};
    ...
function startLogRotator = function startLogRotator(name) {

        if ( typeof(fileLogsList[name]) == 'undefined' ) {

            fileLogsList[name] = {
                started: false
            }
        }

        if (fileLogsList[name].started) {
            return;
        }

        //homedir
        var file = name; // by default, it should be hostname
        if ( !/^gina$/.test(name) && /\@/.test(name) ) {
            name     = opt.name.split(/\@/)[1];
            file = name;
        }
        file += '.log';
        var filename = _(GINA_LOGDIR +'/'+ file);// jshint ignore:line
        var filenameObj = new _(filename);// jshint ignore:line
        if ( !filenameObj.existsSync() ) {
            // create an empty file
            try {
                fs.openSync(filename, 'w')
            } catch (fileErr) {
                throw fileErr
            }
        }
        // default options
        var rotatorOptions = {
            schedule: '5m',
            size: '10m',
            compress: t...
var removeEnv = function(projects, target) {
        var err = null, env = local.env;
        // default `dev env` cannot be removed
        if(env === projects[self.projectName]['dev_env']|| env === projects[self.projectName]['def_env']) {
            if (env === projects[self.projectName]['def_env']) {
                err = new Error('Environment [ '+env+' ] is set as "default environment"')
            } else {
                err = new Error('Environment [ '+env+' ] is linked as "development environment"')
            }

            return end(err);
        }

        projects[self.projectName]['envs'].splice(projects[self.projectName]['envs'].indexOf(env), 1);
        lib.generator.createFileFromDataSync(
            projects,
            target
        );
        // clean ports & reverse ports registered for the project
        var portsPath = _(GINA_HOMEDIR + '/ports.json')
            , portsReversePath = _(GINA_HOMEDIR + '/ports.reverse.json')
            , ports = require(port...
var prompt = function(force, cb) {
        if (!force) {
            rl.setPrompt('Also remove project sources ? (Y/n):\n');
            rl.prompt();
        } else {
            cb(true)
        }

        rl.on('line', function(line) {
            switch( line.trim().toLowerCase() ) {
                case 'y':
                case 'yes':
                    cb(true);
                    break;
                case 'n':
                case 'no':
                    cb(false);
                    break;
                default:
                    console.log('Please, write "yes" or "no" to proceed.');
                    rl.prompt();
                    break;
            }
        }).on('close', function() {
            console.log('\nCommand cancelled !');
            process.exit(0)
        })
    }
var status = function(opt, cmd) {
        var pidFiles = null;
        try {
            pidFiles = fs.readdirSync(GINA_RUNDIR);
        } catch (fileError) {
            throw fileError
        }
        checkUnregistered(pidFiles);
        console.debug('Reading `'+ GINA_RUNDIR +'` ',pidFiles);

        var runningVersions = [], runningLog = '';
        for (let i=0, len=pidFiles.length; i<len; i++) {
            let file = pidFiles[i];
            if ( !/^gina\-/.test(file) ) {
                continue;
            }
            let pid = fs.readFileSync(_(GINA_RUNDIR +'/'+ file)).toString().trim() || null;
            if (!pid) {
                continue;
            }

            if ( !isWin32() ) {
                try {
                    let found = execSync("ps -a "+ pid).toString().replace(/\n$/, '').split(/\n/g);
                } catch (err) {
                    console.debug('file to remove: '+ _(GINA_RUNDIR +'/'+ file));
                    fs.unlinkSync(_(GINA_RUNDIR +'...
_tmp_0.windows-1256 = [8364,1662,8218,402,8222,8230,8224,8225,710,8240,1657,8249,338,1670,1688,1672,1711,8216,8217,8220,8221,8226,8211,8212,1705,8482,1681,8250,339,8204,8205,1722,160,1548,162,163,164,165,166,167,168,169,1726,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,1563,187,188,189,190,1567,1729,1569,1570,1571,1572,1573,1574,1575,1576,1577,1578,1579,1580,1581,1582,1583,1584,1585,1586,1587,1588,1589,1590,215,1591,1592,1593,1594,1600,1601,1602,1603,224,1604,226,1605,1606,1607,1608,231,232,233,234,235,1609,1610,238,239,1611,1612,1613,1614,244,1615,1616,247,1617,249,1618,251,252,8206,8207,1746]
function CouchbaseStore = function CouchbaseStore(options) {
        var self = this;

        options = options || {};
        Store.call(this, options);
        this.prefix = null == options.prefix
            ? 'sess:'
            : options.prefix;

        var connectOptions = {};
        if (options.hasOwnProperty("host")) {
            connectOptions.host = options.host;
        } else if (options.hasOwnProperty("hosts")) {
            connectOptions.host = options.hosts;
        }

        if (options.hasOwnProperty("username")) {
            connectOptions.username = options.username;
        }

        if (options.hasOwnProperty("password")) {
            connectOptions.password = options.password;
        }

        if (options.hasOwnProperty("bucket")) {
            connectOptions.bucket = options.bucket;
        }

        if (options.hasOwnProperty("cachefile")) {
            connectOptions.cachefile = options.cachefile;
        }

        if (options.hasOwnProperty("connectionTimeout")) {
     ...
this instanceof _ // <- You could use arguments.callee instead of _ here,
            // except in in EcmaScript 5 strict mode.
            && !this.previouslyConstructedBy_
var onConnect = function onConnect(cb){
            console.debug('[ CONNECTOR ][ ' + local.bundle +' ] couchbase is alive !!');
            console.debug('[ CONNECTOR ][ ' + local.bundle +' ][ ' + dbString.connector +' ] now connected...');

            self.instance.reconnected  = self.instance.connected   = true;
            var options = local.options;

            // updating context
            var ctx = getContext()
                , bundle = ctx.bundle
                , env = ctx.env
                , conf = ctx['gina'].config.envConf[bundle][env]
                , name = dbString.database
                //Reload models.
                , modelsPath = _(conf.modelsPath)
            ;
            // will send heartbeat every 4 minutes if keepAlive == `true`
            self.ping(options.pingInterval, cb, function onPing(cb){

                local.bundle = bundle;
                local.env = env;

                if ( typeof(cb) != 'undefined' ) { // this portition is not workin...
out = execSync('gina bundle:list @'+ self.projectName +' --format=json').toString().replace(/(\n|\r)$/, '').split(/(\n|\r)/g)
var checkImportMode = function() {

        if ( self.task != 'project:import')
            return;

        console.debug('Starting import mode @'+ self.projectName );
        if (!self.projects[self.projectName ]) {
            console.error('[ '+ self.projectName  +' ] is not an existing project. Instead, use gina projet:add @'+ self.projectName +' --path=/your/project_location');
            process.exit(1)
        }

        if ( typeof(self.projects[self.projectName ]) != 'undefined' ) {
            // import if exists but path just changed
            if ( typeof(self.projects[self.projectName ].path) != 'undefined') {
                var old = new _(self.projects[self.projectName ].path, true).toArray().last();
                var current = new _(self.projectLocation, true).toArray().last();

                if (old === self.projectName) {
                    self.projects[self.projectName ].path = self.projectLocation;

                    var target = _(GINA_HOMEDIR + '/projec...
var init = function(options) {

        self.projectName    = options.projectName;
        //Starting app.
        self.appName        = options.bundle;
        self.env            = options.env;
        self.version        = options.version;
        local.router        = new Router(self.env);

        //True => multiple bundles sharing the same server (port).
        self.isStandalone   = options.isStandalone;
        self.bundles        = options.bundles;
        self.executionPath  = options.executionPath;


        if (!self.isStandalone) {
            //Only load the related conf / env.
            self.conf[self.appName] = {};
            self.conf[self.appName][self.env] = options.conf[self.appName][self.env];
            self.conf[self.appName][self.env].bundlesPath = options.conf[self.appName][self.env].bundlesPath;
            self.conf[self.appName][self.env].modelsPath =  options.conf[self.appName][self.env].modelsPath;
            self.conf[self.appName][self.env].execution...
lib.config.get('gina', 'project.json', function(err, config){
                            //if (err) logger.error('gina', 'MODEL:ERR:2', 'EEMPTY: EntitySuper' + err, __stack);
                            if (err) console.error(err.stack||err.message);

                            var filename = config.paths.gina + '/model/entityFactory.js';

                            //TODO - Factory class
                            //var Factory = new Factory({source: , target: ).onComplete();
                            console.debug("LOADING ", filename);
                            //Getting source.
                            loadFile(filename, entityName, function(err, source){
                                console.log("got source ", err, source);

                                try {
                                    if (entityName != "undefiend") {
                                        console.log("preparing entity ", entityName);
                                        //TODO - Wo...
var collectionSave = function (enforceDeleted) {

        var enforceDeleted = enforceDeleted || false;

        try {
            //backing up collections
            var tmpCollections  = JSON.clone(collections);
            var index           = this['_index'];
            var collection      = this['_collection'];
            var bucket          = this['_bucket'];
            var filter          = this['_filter'];
            this['_updatedAt']  = new Date().format("isoDateTime");

            // merge(tmpCollections[ collection ][ index ], this, true);
            tmpCollections[ collection ][ index ] = merge(tmpCollections[ collection ][ index ], this, true);

            // cleaning
            delete tmpCollections[ collection ][ index ]['_index'];
            delete tmpCollections[ collection ][ index ]['_collection'];
            delete tmpCollections[ collection ][ index ]['_bucket'];
            delete tmpCollections[ collection ][ index ]['save'];
            delete tmpColl...
var init = function(reload) {

        var bundle          = self.bundle;
        var model           = self.model;
        var modelDirName    = self.modelDirName;
        var connectorPath   = null;

        // this is supposed to happen on load or for dev env; on reload, with a checksum
        var conf        = getConfigSync(bundle);
        //local.locals    = conf.locals;

        if (conf) {
            _configuration = conf.connectors;
            self.connector = _configuration[self.name].connector;

            console.debug('[ MODEL ][ ' + model +' ] About to scan: '+ conf.path);
            //TODO - More controls...

            //For now, I just need the F..ing entity name.
            connectorPath       = local.connectorPath = _(GINA_FRAMEWORK_DIR +'/core/connectors/'+ self.connector);
            var modelPath       = local.modelPath = _(conf.path + '/' + modelDirName);
            var entitiesPath    = local.entitiesPath = _(modelPath + '/entities');
            console...
this.route = function(request, response, next, params) {

        /**
        * ExpressJS modules + HTTP2 fix
        * Hack required until `express-<plugin>` get support for http2 `express-session`
        * or similar modules
        */
        if (!response._implicitHeader) {
            response._implicitHeader = function(){ return; }; // we need to force it
        }

        /**
        * EO Passport JS HTTP2 fix
        */

        /**
        * BO Passport JS HTTP2 fix : taken from passport/request.js
        */
       if ( typeof(request._passport) != 'undefined' && typeof(request.isAuthenticated) == 'undefined' ) {
            request.isAuthenticated = function() {
                var property = 'user';
                if (this._passport && this._passport.instance) {
                    property = this._passport.instance._userProperty || 'user';
                }
                var isAuthenticated = (this[property]) ? true : false;
                if (isAuthenticated) {
 ...
lib.generator.createFileFromDataSync(portsReverse, portsReversePath)
gina.onError(function(err, req, res, next){
                // (code)   message
                // (16)     Generic network failure. Enable detailed error codes (via LCB_CNTL_DETAILED_ERRCODES, or via `detailed_errcodes` in the connection string) and/or enable logging to get more information
                // (23)     Client-Side timeout exceeded for operation. Inspect network conditions or increase the timeout
                //          cannot perform operations on a shutdown bucket
                //          err instanceof CouchbaseError

                if (!self.instance.connected) {
                    self.instance.reconnected = false;
                    self.instance.reconnecting = false;
                }

                if (
                    err instanceof couchbase.Error && err.code == 16 && !self.reconnected
                    //|| err instanceof couchbase.Error && err.code == 23 && !self.reconnecting
                    || /cannot perform operations on a shutdow...
fs.readFile(filename, function (err, data){

            if (err) {
                //logger.error('gina', 'MODEL:ERR:3', err, __stack);
                console.error(err.stack||err.message);
                callback(err);
            }

            console.log("Evaluating...", data.toString() );
            var entityFactory = data.toString().replace(/\{Entity\}/g, entityName);
            console.log("SHIT ");
            //process.exit(42);
            callback(false, entityFactory);
        })
fs.stat(p, function(err, stats) {

                if (err) {
                    callback(err)
                } else {

                    if (stats.isDirectory()) {
                        callback(false, d)
                    } else {
                        callback(new Error('[ ' + d + ' ] is not a directory'))
                    }
                }
            })
CouchbaseStore.prototype.touch = function (sid, sess, fn) {
        if ('function' !== typeof fn) { fn = noop; }

        var sid = this.prefix + sid
            , maxAge = sess.cookie.maxAge
            , ttl = this.ttl || ('number' == typeof maxAge
                ? maxAge / 1000 | 0
                : oneDay)
            , currentDate = new Date()
            , lastModified = sess.lastModified ? new Date(sess.lastModified).getTime() : 0;

        // if the given options has a touchAfter property, check if the
        // current timestamp - lastModified timestamp is bigger than
        // the specified, if it's not, don't touch the session
        if (ttl > 0 && lastModified > 0) {

            var timeElapsed = currentDate.getTime() - lastModified;

            if (timeElapsed > ttl) {
                sess.lastModified = currentDate;
            }
        }

        sess = JSON.stringify(sess);
        this.client.upsert(sid, sess, {expiry:ttl}, function(err){
            err || d...
console.error('[ CONNECTOR ][ ' + local.bundle +' ] couchbase could not connect to bucket `'+ dbString.database +'`\n'+ (err.stack || err.message || err) )
this.emit = function(c) {
    if (c <= 0xFFFF) {
      string += String.fromCharCode(c);
    } else {
      c -= 0x10000;
      string += String.fromCharCode(0xD800 + ((c >> 10) & 0x3ff));
      string += String.fromCharCode(0xDC00 + (c & 0x3ff));
    }
  }
params && params.length != args.length && !/function/.test(typeof(args[args.length-1]))
this.getInstance = function(bundle) {

        if ( typeof(Config.instance) == 'undefined' && typeof(getContext('gina')) != 'undefined' ) {
            Config.instance = merge( self, getContext('gina').config, true );
            self.envConf = Config.instance.envConf
        }

        var configuration = Config.instance.envConf;

        var env = self.env || Config.instance.env;

        Config.instance.Env.parent = Config.instance;

        if (env != 'undefined')
            Config.instance.Env.set(Config.instance.env);

        Config.instance.Host.parent = Config.instance;

        //Do some checking please.. like already has a PID ?.
        //if yes, join in case of standalone.. or create a new thread.
        Config.instance.Host.setMaster(bundle);

        self = Config.instance;

        if ( typeof(bundle) != 'undefined' && typeof(configuration) != 'undefined' ) {
            try {
                //return configuration[bundle][env];
                return Config.instan...
var search = function(filter, field, _content, matched, searchOptionRules) {
                var reValidCount = null, searchOptCount = null;
                if (filter === null && _content === null) { // null case

                    ++matched;

                } else if (
                    filter
                    && keywords.indexOf(localeLowerCase) > -1
                    && localeLowerCase == 'not null'
                    && typeof(_content) != 'undefined'
                    && typeof(_content) !== 'object'
                    && _content != 'null'
                    && _content != 'undefined'
                ) {

                    if (result.indexOf(_content) < 0) {
                        ++matched;
                    }

                } else if (
                    typeof(_content) != 'undefined'
                    && typeof(_content) !== 'object'
                    && /(<|>|=)/.test(filter)
                    && !/undefined|function/.test(typeof(_content))
     ...
pipe.on('finish', function() {
    if (error) {
      return;
    }
    // truncate log file to size 0
    fs.truncate(file, 0, function(err) {
      if (err) {
        cb && cb('error truncating file ' + file + ': ' + err.message);
        return;
      }
      cb && cb(null, true);
    })
  })
process.argv[2] == '-s' && isLoadedThroughCLI
        || process.argv[2] == '--start' && isLoadedThroughCLI
        //Avoid -h, -v  ....
        || !isLoadedThroughCLI && isPath && process.argv.length > 3
var makeBundle = async function(bundle, rewrite) {

        loadAssets();

        // if ( /^true$/i.test(rewrite) ) {
        //     fixPorts
        //     return
        // }

        setPorts(bundle, self.portsAvailable, function onPortsSet(err){
            if (err) {
                rollback(err);
                return;
            }

            if (!local.envFileSaved) {
                saveEnvFile(function doneSavingEnv(err){

                    if (err) rollback(err);

                    saveProjectFile( function doneSavingProject(err, content) {

                        if ( err ) {
                            rollback(err);
                            return;
                        }

                        if (rewrite) {
                            delete content.bundles[local.bundle]
                        }
                        createBundle()
                    })
                })

            } else { // importing
                console.log('Bundle [ '+ loca...
typeof(bundleSettings.server.scheme) != 'undefined'
                                        && schemes.indexOf(bundleSettings.server.scheme) < 0
var init = function(opt) {


        if ( typeof(ctx.initialized) != 'undefined' && ctx.initialized == true) {
            getInstance();
            // process.env.NODE_ENV
            if (opt.hierarchies[opt.hierarchy].indexOf( opt.levels['debug'].code) > -1) {
                emit(opt, 'debug', '`'+ opt.name +' `Logger instance already exists: reusing it ;)');
            }

            return self;
        }
        ctx.initialized = true;
        if (!homeDir) {
            homeDir =  ( typeof(getUserHome) != 'undefined' ) ? getUserHome() : process.env[(process.platform == 'win32') ? 'USERPROFILE' : 'HOME'];// jshint ignore:line
            homeDir += '/.gina';
        }
        // user main options & flows options
        var extPath = _(homeDir +'/user/extensions/logger', true)
        var optionsPath = _(extPath +'/default/config.json', true);
        if ( new _(optionsPath).existsSync() ) {
            userOptions = requireJSON(optionsPath);// jshint ignore:line
            if ...
var setTimezone = function(timezone) {
        // save to ~/.gina/main.json
        mainConf['def_timezone'][GINA_SHORT_VERSION] = timezone;
        lib.generator.createFileFromDataSync(mainConf, mainConfPath);
        // save to ~/.gina/{GINA_VERSION_SHORT}/settings.json
        process['gina']['timezone'] = timezone;
        mainSettingsConf['timezone'] = timezone;
        lib.generator.createFileFromDataSync(mainSettingsConf, mainSettingsPath);
    }
client.on('end', () => {
            console.warn('[MQTail] Disconnected from server');
            console.info('[MQTail] Waitting for `MQListener` to be started ...');
            var mqPort = null;
            nIntervId = setInterval(() => {
                try {
                    mqPort = ~~(fs.readFileSync(mqPortFile).toString());
                    if (mqPort) {
                        process.emit('gina#mqlistener-started', mqPort);
                    }
                } catch (fileErr) {}
            }, 100);
        })
var throwError = function(code, err, isFatal) {
        var router      = getContext('router');
        if (router) {
            var res                 = router.response
                , next              = router.next
                , hasViews          = router.hasViews
                , isUsingTemplate   = isUsingTemplate
            ;


            if (arguments.length < 2) {
                err = code;
                code = 500
            }

            if ( !hasViews || !isUsingTemplate ) {
                if (!res.headersSent) {
                    res.writeHead(code, { 'Content-Type': 'application/json'} );
                    res.end(JSON.stringify({
                        status: code,
                        error: 'Error '+ code +'. '+ err.stack
                    }))
                } else {
                    next()
                }

            } else {
                if (!res.headersSent) {
                    res.writeHead(code, { 'Content-Type': 'text/html'} ...
createContent(filename, gnaFolder, content, function(err){
                        fs.openSync(checksumFile, 'w');
                        setTimeout(function(){
                            callback(err)
                        }, 500)
                    })
this.client.upsert(sid, sess, {expiry:ttl})
                .then(function onResult(_result){
                    result = _result;
                    //fn && fn.apply(this, arguments);
                })
                .catch(function onError(_err) {
                    err = _err
                    // if(err)
                    //     debug('Session Set complete', err.stack || err.message || err);

                    //fn && fn.apply(this, arguments);
                })
CouchbaseStore.prototype.destroy = function(sid, fn){
        if ('function' !== typeof fn) { fn = noop; }
        sid = this.prefix + sid;
        //this.client.remove(sid, fn);
        this.client
                .remove(sid)
                .then(fn)
                .catch(fn)
    }
processSrc(method, files[i].input, files[i].output, zipInstance, options, function onSrcProcessed(err, zipInstance){
                    processList(method, src, target, zipInstance, options, i+1, len, err);
                })
var encodings = [
  {
    "encodings": [
      {
        "labels": [
          "unicode-1-1-utf-8",
          "utf-8",
          "utf8"
        ],
        "name": "utf-8"
      }
    ],
    "heading": "The Encoding"
  },
  {
    "encodings": [
      {
        "labels": [
          "864",
          "cp864",
          "csibm864",
          "ibm864"
        ],
        "name": "ibm864"
      },
      {
        "labels": [
          "866",
          "cp866",
          "csibm866",
          "ibm866"
        ],
        "name": "ibm866"
      },
      {
        "labels": [
          "csisolatin2",
          "iso-8859-2",
          "iso-ir-101",
          "iso8859-2",
          "iso88592",
          "iso_8859-2",
          "iso_8859-2:1987",
          "l2",
          "latin2"
        ],
        "name": "iso-8859-2"
      },
      {
        "labels": [
          "csisolatin3",
          "iso-8859-3",
          "iso-ir-109",
          "iso8859-3",
          "iso88593",
          "iso_8859-3",
    ...
var getDaysTo = function(date, dateTo, mask) {

        if ( dateTo instanceof Date) {
            var count       = countDaysTo(date, dateTo)
                , month     = date.getMonth()
                , year      = date.getFullYear()
                , day       = date.getDate() + 1
                , dateObj   = new Date(year, month, day)
                , days      = []
                , i         = 0;

            for (; i < count; ++i) {
                if ( typeof(mask) != 'undefined' ) {
                    days.push(new Date(dateObj).format(mask));
                } else {
                    days.push(new Date(dateObj));
                }

                dateObj.setDate(dateObj.getDate() + 1);
            }

            return days || [];
        } else {
            throw new Error('dateTo is not instance of Date() !')
        }
    }
var getRootDomain = function(urlOrHostname, jsonFormat) {
        if ( typeof(jsonFormat) == 'undefined' ) {
            jsonFormat = false
        }
        var isSLD = false
            , isRegisteredTldOrSld = false
            , rootDomain = urlOrHostname.replace(/^(.*)\:\/\/|\/(.*)/g, '')
            // we don't want sub domains: that's why the `.reverse()` is for
            , rootDomainArr = rootDomain.split(/\./g).reverse()
            // TLD by default
            , rootDomainIndex = (rootDomainArr.length) ? rootDomainArr.length-1 : 0
        ;

        var list = self.rawPSL
                // remove comments & empty lines
                .replace(/\/\/\s*(.*)\n|^\s*\n/gm, '')
                .split(/\n/)
                .filter( function onFiltered(item, i, iArr) {
                    // formating ^!, ^. & removing extra junk
                    // this is specific to the ginven extensions list
                    if ( /[^a-z 0-9.]+/.test(item) ) {
                        ite...
console.debug('Could not get server core configuration for <'+ bundle +'>:<'+ env +'>')
server.listen(listenOption, function() {
            // Server started.
            console.info('[MQListener] `'+ host +'`is waitting for speakers on port `'+ port +'`');
            if (cb) {
                cb(false);
            }
        })
var compressFile = function(method, input, output, zipInstance, isBatchProcessing, cb, isPackage) {

        var methodObject = null;
        isPackage = ( typeof(isPackage) == 'undefined' ) ? false: isPackage;

        if ( isBatchProcessing ) {

            zipInstance.file(output, fs.createReadStream(input));

            cb(false, output, zipInstance);
            return
        }

        switch (method) {
            case 'gzip':
                methodObject = zlib.createGzip();
                break;

            default:
                methodObject = zlib.createGzip();
                break;
        }


        if ( /\/\.(.*)$/.test(input.path) ) {

            if (isPackage) {
                cb(false, input)
            } else {
                cb(false, input.path)
            }
            return
        } else {
            input
                .pipe(methodObject)
                .pipe(output);
        }


        output
            .once('error', function onCompressionEr...
data.bundles[local.bundle] = {
            "_comment" : "Your comment goes here.",
            "version"   : version,
            "tag" : ( version.split('.') ).join(''),
            "src" : "src/" + local.bundle,
            "link"      : "bundles/"+ local.bundle,
            "releases" : {}
        }
gna.getProjectConfiguration = function (callback){

    var modulesPackage = _(root + '/manifest.json');
    var project     = {}
        , bundles   = [];

    //console.debug('modulesPackage ', modulesPackage, fs.existsSync(modulesPackage));
    //Merging with existing;
    if ( fs.existsSync(modulesPackage) ) {
        try {

            var dep = require(modulesPackage);
            //console.log('ENV: ', env );
            //console.log('PROCESS: ', process.argv );
            //console.log(" now loading....", modulesPackage);
            //console.log('content ', dep);
            if ( typeof(dep['bundles']) == "undefined") {
                dep['bundles'] = {};
            }

            if (
                typeof(dep['bundles']) != "undefined"
                && typeof(project['bundles']) != "undefined"
            ) {

                for (var d in dep) {

                    if (d == 'bundles') {
                        for (var p in dep[d]) {
                            ...
set('page.view.layout', local.options.template.layout.replace(new RegExp(local.options.template.templates+'/'), ''))
output
            .once('error', function onCompressionError(err) {
                cb(err, null)
            })
            .once('finish', function onCompressionFinished(){
                if (isPackage) {
                    cb(false, this, zipInstance)
                } else {
                    cb(false, this.path, zipInstance)
                }
            })
typeof(mainConfig['def_arch']) != 'undefined'
            && typeof(mainConfig['def_arch'][self.release]) != 'undefined'
            && mainConfig.archs[self.release].indexOf(mainConfig['def_arch'][self.release]) < 0
self[l] = function(){// jshint ignore:line

                    let group = opt.name || defaultOptions.name; // by default
                    if ( process.title != 'node' && !/(\\|\/)*node$/.test(process.title) ) {
                        group = process.title.replace(/^gina\:\s*/, '');
                        if ( typeof(group) == 'undefined' || /^gina\-/.test(group) ) {
                            group = 'gina'
                        }
                    }

                    //self.log('--> '+ group + ' '+ process.env.LOG_GROUP +' '+ process.title);
                    if ( typeof(loggers[group]) == 'undefined' ) {
                        setupNewGroup(group)
                    }
                    loggers[group][l].apply(self[l], arguments)
                }
fs.stat(this.value, function(err, stats) {
                var canWrite = false;
                if (!err && stats.mode & (fs.constants.S_IRUSR | fs.constants.S_IRGRP | fs.constants.S_IROTH)) {
                    canWrite = true;
                }
                callback( canWrite )
            })
_tmp_37.labels = [
          "csisolatin4",
          "iso-8859-4",
          "iso-ir-110",
          "iso8859-4",
          "iso88594",
          "iso_8859-4",
          "iso_8859-4:1988",
          "l4",
          "latin4"
        ]
typeof(self.selectedDebugPorts) != 'undefined'
                            && typeof(self.selectedDebugPorts[_bundle]) != 'undefined'
fs.exists(path, function(exists){
            //delete when exists.
            if (exists) {
                //console.log("yeah about to delete main folder: ", p.toString());
                //Delete ans die here..
                p.rm(function(err, path){
                    //console.log("receives ", err, path);
                    if (err) {
                        //logger.error('gina', 'LIB:CONFIG:ERR:8', err, __stack);
                        console.error(err.stack||err.message);
                        callback(err)
                    } else {
                        //logger.info('gina', 'LIB:CONFIG:INFO:1', path +': deleted with success !');
                        console.info( path +': deleted with success !');
                        callback(false)
                    }
                })
            }
        })
_tmp_37.pingTimeout = options.ioServer.pingTimeout || options.ioServer.timeout
fs.lstat(p, function(err, stats) {
            if (err) callback(err);

            if ( !stats.isDirectory() ) {
                callback(new Error(p +' is not a directory'))
            } else {
                fs.readdir(p, function(err, files) {
                    for(var f=0; f<files.length; ++f) {
                        if (search == files[f]) {
                            callback(false, true)
                            break
                        }
                    }
                })
            }
        })
this.reloadModels = function(conf, cb) {

        if ( typeof(conf.content['connectors']) != 'undefined' && conf.content['connectors'] != null ) {

            var models              = conf.content.connectors
                , conn              = null
                , foundInitError    = false
                , connectorPath     = null
                , entitiesManager   = null
                , modelPath         = null
                , entitiesPath      = null
                , modelConnectors   = null;


            // end - now, loading entities for each `loaded` model
            for (var bundle in self.models) {

                for (var name in self.models[bundle]) { //name as connector name

                    self.models[bundle][name] = {};

                    if ( typeof(self.models[bundle][name]['_connection']) == 'undefined' ) {
                        self.models[bundle][name]['_connection'] = getContext('modelConnectors')[bundle][name].conn
                    }

 ...
fs.readdir(p, function(err, files) {
                    for(var f=0; f<files.length; ++f) {
                        if (search == files[f]) {
                            callback(false, true)
                            break
                        }
                    }
                })
var isWritableSync = function(path) {
        var canWrite = false;
        if ( typeof(fs.accessSync) != 'undefined' ) {
            try {
                fs.accessSync(path, fs.constants.W_OK);
                canWrite = true;
            } catch (err) {
                canWrite = false;
            }
        } else { // support for old version of nodejs

            try {
                canWrite = (fs.statSync(path).mode & (fs.constants.S_IRUSR | fs.constants.S_IRGRP | fs.constants.S_IROTH));
            } catch (err) {
                canWrite = false
            }
        }

        return canWrite
    }
var listBundleOnly = function() {

        var protocols   = self.protocols
            , schemes   = self.schemes
            , found     = false
            , str       = ''
            , re        = null
        ;

        var jsonCollection =  new Collection([]);
        for (let i = 0, len = protocols.length; i < len; ++i) {
            let protocol = protocols[i];
            str += '[ '+ protocol +' ]\n\r';
            for (let s = 0, sLen = schemes.length; s < sLen; ++s) {
                let scheme = schemes[s];
                let bundle = self.name;
                found = false;
                // re = new RegExp('^' + bundle + '\@', '');// searching by bundle name
                re = new RegExp('^' + bundle + '\@' + self.projectName + '\/', '');// searching by projectName
                for (let port in self.portsData[protocol][scheme]) {

                    let bundleEnv = self.portsData[protocol][scheme][port].replace(re, '\:').split(/\:/);
                    let _bun...
typeof(result.error) != 'undefined' && /^5/.test(result.status)
var addEnvToProject = function() {
        var e = 0
            , newEnvs = self.envs
            , projects = JSON.clone(self.projects)
            , envs = projects[self.projectName].envs
        ;
        // to ~/.gina/projects.json
        for (; e < newEnvs.length; ++e) {
            if (envs.indexOf(newEnvs[e]) < 0 ) {
                modified = true;
                envs.push(newEnvs[e])
            }
        }
        //writing
        lib.generator.createFileFromDataSync(
            projects,
            self.projectsPath
        );
        self.projectDataWrote = true
    }
canWrite = (fs.statSync(path).mode & (fs.constants.S_IRUSR | fs.constants.S_IRGRP | fs.constants.S_IROTH))
sample.cp(target, function done(err, destination) {

            if (err) {
                rollback(err);
                return;
            }

            // Browse, parse and replace keys
            local.source        = target;
            local.isInstalled   = false;

            // check installed bundle
            browse(local.source);

            if (local.isInstalled) {

                // remove files we don't want yet
                new _(destination + '/config/templates.json', true).rmSync();

                // if first bundle of th project, modify webroot
                if (self.bundlesByProject[self.projectName].count() == 1) {
                    var settingsServerPath = _(destination + '/config/settings.server.json', true);
                    var serverSettings = fs.readFileSync(settingsServerPath).toString();
                    serverSettings = serverSettings.replace('"webroot": "/{bundle}"', '"webroot": "/"');
                    lib.generator.createFileFr...
