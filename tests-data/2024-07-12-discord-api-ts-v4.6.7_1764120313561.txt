function getThumbnails = function getThumbnails (requests, retryCount = settings.maxRetries) {
  if (!Array.isArray(requests)) {
    throw new Error('thumbnailRequests are not an array')
  }

  requests = [...new Set(requests)]
  if (requests.length > 100) {
    throw new Error(`Too many thumbnailRequests provided (${requests.length}); maximum 100`)
  }

  for (const request of requests) {
    if (!request.size || !request.type) {
      throw new Error('thumbnailRequest must have a size and type')
    } else if (request.format && (request.format.toLowerCase() !== 'png' && request.format.toLowerCase() !== 'jpeg')) {
      throw new Error(`Invalid image type provided: ${request.format} | Use: png, jpeg`)
    }
  }

  return http({
    url: 'https://thumbnails.roblox.com/v1/batch',
    options: {
      method: 'POST',
      json: requests,
      resolveWithFullResponse: true,
      followRedirect: true
    }
  })
    .then(async ({ statusCode, body }) => {
      let { data, errors } = body
      if (statusCode...
function getPlayersInRole = function getPlayersInRole (jar, group, rolesetId, sortOrder, limit, cursor, currentPlayers) {
  return new Promise((resolve, reject) => {
    if (!currentPlayers) currentPlayers = []

    getPlayersInRoleOnPage(jar, group, rolesetId, sortOrder, 100, cursor, currentPlayers)
      .then(function (pageData) {
        const nextPageCursor = pageData.nextPageCursor
        const dataArray = pageData.data

        if (!dataArray) return reject(new Error('Error while retrieving players!'))

        currentPlayers = currentPlayers.concat(dataArray)

        if (limit > 0 && currentPlayers.length >= limit) {
          return resolve(currentPlayers.slice(0, limit))
        } else if (nextPageCursor === null) {
          return resolve(currentPlayers)
        }

        getPlayersInRole(jar, group, rolesetId, sortOrder, limit, nextPageCursor, currentPlayers)
          .then(function (newCurrentPlayers) {
            return resolve(newCurrentPlayers)
          })
      }).catch(error => reject(...
getRequests(jar, group)
      .then(function (requests) {
        const complete = {
          data: [],
          latest: -2,
          repeat: requests.length >= 20
        }
        let handled = 0
        let promise
        if (requests.length > 0) {
          promise = new Promise(function (resolve, reject) {
            evt.on('handle', function (request, accept, callback) {
              const id = request.requester.userId
              handleJoinRequest({ jar: jar, group, userId: id, accept: accept })
                .then(function () {
                  handled++
                  if (callback) {
                    callback()
                  }
                  if (handled === requests.length) {
                    evt.removeAllListeners('handle')
                    resolve(complete)
                  }
                })
                .catch(reject)
            })
          })
        }
        for (let i = 0; i < requests.length; i++) {
          const request = re...
exports.func = function (args) {
  const jar = args.jar
  return queue('Message', getHash({ jar: jar }), function () {
    return getGeneralToken({ jar: jar })
      .then(function (xcsrf) {
        return getSenderId({ jar: jar }).then((senderId) => {
          return message(jar, xcsrf, senderId, args.recipient, args.subject, args.body, args.replyMessageId, args.includePreviousMessage)
        })
      })
  }, function () {
    return true
  })
}
