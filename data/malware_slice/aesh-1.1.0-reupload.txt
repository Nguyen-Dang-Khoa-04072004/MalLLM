// File: package/aesh.js
// ======================================================================
Line 6: let crypto = require('crypto')
Line 7: _tmp_26 = require('fs')
Line 8: _tmp_27 = require('path')
Line 9: _tmp_28 = require('base64-stream')
Line 10: _tmp_29 = require('child_process')
Line 11: const minify = require('@minify-html/js')
Line 12: const qrcode = require('qrcode-terminal')
Line 18: _tmp_30.push(/^image\//)
Line 19: _tmp_30.push(/^video\//)
Line 20: _tmp_30.push(/^audio\//)
Line 21: _tmp_30.push(/^text\//)
Line 22: _tmp_30.push(/^application\/pdf/)
Line 27: const fileExts = [
    [/\.iso$/, 'application/x-cd-image'],
    [/\.html?$/, 'text/html']
]
Line 28: _tmp_31.push([/\.iso$/, 'application/x-cd-image'])
Line 29: _tmp_31.push([/\.html?$/, 'text/html'])
Line 38: {
        // DOS path
        path = '/' + path[0].toLowerCase() + path.replace(/\\/g, '/').substring(2);
    }
Line 40: path = '/' + path[0].toLowerCase() + path.replace(/\\/g, '/').substring(2)
Line 74: {
    let mime = cliArg('t', 'mime');
    let overrideFilename = cliArg('n', 'name');

    let filename = process.argv[3];
    if (!filename) { print_usage(); return; }

    //
    console.log('encryping contents..');

    let file = createReadStream(filename);
    let identify = new (require('identify-stream'));
    file.pipe(identify);

    if (!mime)
    {
        let streamType = await new Promise(r => identify.on('complete', r));

        mime = streamType
            ? streamType.mime
            : (fileExts.filter(ext => filename.match(ext[0]))[0] || [0,'text/plain;charset=utf-8'])[1];
    }

    let usePreview = previewTypes.filter(pt => mime.match(pt)).length > 0; // used in template.htm
    //

    let output = createWriteStream('.enc.htm');
    let template = readFileSync(join(__dirname, 'template.htm')).toString().split('{{content}}');

    let minifyCfg = minify.createConfiguration({ minify_css: true, do_not_minify_doctype: true });

    filename = overrideFilename || f...
Line 78: let filename = process.argv[3]
Line 84: createReadStream(filename)
Line 85: let identify = new (require('identify-stream'))
Line 86: file.pipe(identify)
Line 89: {
        let streamType = await new Promise(r => identify.on('complete', r));

        mime = streamType
            ? streamType.mime
            : (fileExts.filter(ext => filename.match(ext[0]))[0] || [0,'text/plain;charset=utf-8'])[1];
    }
Line 92: mime = streamType
            ? streamType.mime
            : (fileExts.filter(ext => filename.match(ext[0]))[0] || [0,'text/plain;charset=utf-8'])[1]
Line 94: fileExts.filter(ext => filename.match(ext[0]))[0] || [0,'text/plain;charset=utf-8'][1]
Line 101: readFileSync(join(__dirname, 'template.htm')).toString()
Line 108: output.write(minify.minify(eval(`\`${template[0]}\``), minifyCfg))
Line 110: let key = crypto.randomBytes(32)
Line 111: let iv = crypto.randomBytes(16)
Line 116: identify.pipe(cipher)
                                   .pipe(new Base64Encode())
                                   .pipe(output, { end: false })
Line 121: iv.toString('base64')
Line 124: minify.minify(eval(`\`${template[1]}\``), minifyCfg).toString()
Line 130: execSync('ipfs add --pin=false .enc.htm').toString()
Line 133: {
        // Success
        let hash = ret.split(' ')[1];
        let shareLink = `https://ipfs.io/ipfs/${hash}#${key.toString('base64')}`;

        qrcode.generate(shareLink, { small: true }, (qrc) =>
        {
            console.log('\n' + qrc);
            console.log('Share available at: ' + shareLink + '\n');
        });

        execSync(`ipfs files cp -p /ipfs/${hash} "${fullpath(filename)}"`);
        unlinkSync('.enc.htm');
    }
Line 135: let hash = ret.split(' ')[1]
Line 136: <operator>.formatString("https://ipfs.io/ipfs/", hash, "#", key.toString('base64'), "")
Line 138: qrcode.generate(shareLink, { small: true }, (qrc) =>
        {
            console.log('\n' + qrc);
            console.log('Share available at: ' + shareLink + '\n');
        })
Line 144: execSync(`ipfs files cp -p /ipfs/${hash} "${fullpath(filename)}"`)
Line 151: {
    let filename = process.argv[3];
    if (!filename) { print_usage(); return; }

    execSync(`ipfs files rm -r "${fullpath(filename)}"`);
    console.log(`removed local share (${basename(filename)})`);
}
Line 152: let filename = process.argv[3]
Line 155: execSync(`ipfs files rm -r "${fullpath(filename)}"`)
Line 156: basename(filename)
