flushSegment(request, destination, completedRootSegment)
completedRootSegment !== null && request.pendingRootTasks === 0
flushSegment(request, destination, completedRootSegment)
completedRootSegment !== null && request.pendingRootTasks === 0
flushSegment(request, destination, completedRootSegment)
writeCompletedBoundaryInstruction(destination, request.responseState, boundary.id, boundary.rootSegmentID)
var clientRenderedBoundaries = request.clientRenderedBoundaries
function flushPartialBoundary = function flushPartialBoundary(request, destination, boundary) {
  var completedSegments = boundary.completedSegments;
  var i = 0;

  for (; i < completedSegments.length; i++) {
    var segment = completedSegments[i];

    if (!flushPartiallyCompletedSegment(request, destination, boundary, segment)) {
      i++;
      completedSegments.splice(0, i); // Only write as much as the buffer wants. Something higher priority
      // might want to write later.

      return false;
    }
  }

  completedSegments.splice(0, i);
  return true;
}
var completedSegments = boundary.completedSegments
function functionThatReturnsFalse = function functionThatReturnsFalse() {
  return false;
}
var clientRenderedBoundaries = request.clientRenderedBoundaries
var boundary = clientRenderedBoundaries[i]
!flushClientRenderedBoundary(request, destination, boundary)
!flushClientRenderedBoundary(request, destination, boundary)
!flushPartiallyCompletedSegment(request, destination, boundary, segment)
function createSyntheticEvent = function createSyntheticEvent(Interface) {
  /**
   * Synthetic events are dispatched by event plugins, typically in response to a
   * top-level event delegation handler.
   *
   * These systems should generally use pooling to reduce the frequency of garbage
   * collection. The system should check `isPersistent` to determine whether the
   * event should be released into the pool after being dispatched. Users that
   * need a persisted event should invoke `persist`.
   *
   * Synthetic events (and subclasses) implement the DOM Level 3 Events API by
   * normalizing browser quirks. Subclasses do not necessarily have to implement a
   * DOM interface; custom application-specific events can also subclass this.
   */
  function SyntheticBaseEvent(reactName, reactEventType, targetInst, nativeEvent, nativeEventTarget) {
    this._reactName = reactName;
    this._targetInst = targetInst;
    this.type = reactEventType;
    this.nativeEvent = nativeEvent;
    this.target = nativeEventTarg...
!flushClientRenderedBoundary(request, destination, boundary)
var completedBoundaries = request.completedBoundaries
var completedBoundaries = request.completedBoundaries
function createSyntheticEvent = function createSyntheticEvent(Interface) {
    /**
     * Synthetic events are dispatched by event plugins, typically in response to a
     * top-level event delegation handler.
     *
     * These systems should generally use pooling to reduce the frequency of garbage
     * collection. The system should check `isPersistent` to determine whether the
     * event should be released into the pool after being dispatched. Users that
     * need a persisted event should invoke `persist`.
     *
     * Synthetic events (and subclasses) implement the DOM Level 3 Events API by
     * normalizing browser quirks. Subclasses do not necessarily have to implement a
     * DOM interface; custom application-specific events can also subclass this.
     */
    function SyntheticBaseEvent(reactName, reactEventType, targetInst, nativeEvent, nativeEventTarget) {
      this._reactName = reactName;
      this._targetInst = targetInst;
      this.type = reactEventType;
      this.nativeEvent = nativeEven...
function flushPartiallyCompletedSegment = function flushPartiallyCompletedSegment(request, destination, boundary, segment) {
  if (segment.status === FLUSHED) {
    // We've already flushed this inline.
    return true;
  }

  var segmentID = segment.id;

  if (segmentID === -1) {
    // This segment wasn't previously referred to. This happens at the root of
    // a boundary. We make kind of a leap here and assume this is the root.
    var rootSegmentID = segment.id = boundary.rootSegmentID;

    if (rootSegmentID === -1) {
      throw new Error('A root segment ID must have been assigned by now. This is a bug in React.');
    }

    return flushSegmentContainer(request, destination, segment);
  } else {
    flushSegmentContainer(request, destination, segment);
    return writeCompletedSegmentInstruction(destination, request.responseState, segmentID);
  }
}
var completedBoundaries = request.completedBoundaries
function SyntheticBaseEvent = function SyntheticBaseEvent(reactName, reactEventType, targetInst, nativeEvent, nativeEventTarget) {
    this._reactName = reactName;
    this._targetInst = targetInst;
    this.type = reactEventType;
    this.nativeEvent = nativeEvent;
    this.target = nativeEventTarget;
    this.currentTarget = null;

    for (var _propName in Interface) {
      if (!Interface.hasOwnProperty(_propName)) {
        continue;
      }

      var normalize = Interface[_propName];

      if (normalize) {
        this[_propName] = normalize(nativeEvent);
      } else {
        this[_propName] = nativeEvent[_propName];
      }
    }

    var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;

    if (defaultPrevented) {
      this.isDefaultPrevented = functionThatReturnsTrue;
    } else {
      this.isDefaultPrevented = functionThatReturnsFalse;
    }

    this.isPropagationStopped = functionThatReturnsFalse;
    return this;
  }
!flushCompletedBoundary(request, destination, _boundary)
var _boundary = completedBoundaries[i]
!flushCompletedBoundary(request, destination, _boundary)
!flushCompletedBoundary(request, destination, _boundary)
var partialBoundaries = request.partialBoundaries
var partialBoundaries = request.partialBoundaries
flushSegmentContainer(request, destination, segment)
!flushPartialBoundary(request, destination, _boundary2)
var partialBoundaries = request.partialBoundaries
!flushPartialBoundary(request, destination, _boundary2)
function flushCompletedQueues = function flushCompletedQueues(request, destination) {
  beginWriting();

  try {
    // The structure of this is to go through each queue one by one and write
    // until the sink tells us to stop. When we should stop, we still finish writing
    // that item fully and then yield. At that point we remove the already completed
    // items up until the point we completed them.
    // TODO: Emit preloading.
    // TODO: It's kind of unfortunate to keep checking this array after we've already
    // emitted the root.
    var completedRootSegment = request.completedRootSegment;

    if (completedRootSegment !== null && request.pendingRootTasks === 0) {
      flushSegment(request, destination, completedRootSegment);
      request.completedRootSegment = null;
      writeCompletedRoot(destination, request.responseState);
    } // We emit client rendering instructions for already emitted boundaries first.
    // This is so that we can signal to the client to start client rendering them as
...
var _boundary2 = partialBoundaries[i]
!flushPartialBoundary(request, destination, _boundary2)
!flushPartialBoundary(request, destination, _boundary2)
var largeBoundaries = request.completedBoundaries
var completedRootSegment = request.completedRootSegment
assign(SyntheticBaseEvent.prototype, {
    preventDefault: function () {
      this.defaultPrevented = true;
      var event = this.nativeEvent;

      if (!event) {
        return;
      }

      if (event.preventDefault) {
        event.preventDefault(); // $FlowFixMe - flow is not aware of `unknown` in IE
      } else if (typeof event.returnValue !== 'unknown') {
        event.returnValue = false;
      }

      this.isDefaultPrevented = functionThatReturnsTrue;
    },
    stopPropagation: function () {
      var event = this.nativeEvent;

      if (!event) {
        return;
      }

      if (event.stopPropagation) {
        event.stopPropagation(); // $FlowFixMe - flow is not aware of `unknown` in IE
      } else if (typeof event.cancelBubble !== 'unknown') {
        // The ChangeEventPlugin registers a "propertychange" event for
        // IE. This event does not support bubbling or cancelling, and
        // any references to cancelBubble throw "Member not found".  A
        ...
!flushCompletedBoundary(request, destination, _boundary3)
this.isDefaultPrevented = functionThatReturnsFalse
!flushCompletedBoundary(request, destination, _boundary3)
!flushCompletedBoundary(request, destination, _boundary3)
this.isPropagationStopped = functionThatReturnsFalse
!flushCompletedBoundary(request, destination, _boundary3)
!flushCompletedBoundary(request, destination, _boundary3)
assign(SyntheticBaseEvent.prototype, {
      preventDefault: function () {
        this.defaultPrevented = true;
        var event = this.nativeEvent;

        if (!event) {
          return;
        }

        if (event.preventDefault) {
          event.preventDefault(); // $FlowFixMe - flow is not aware of `unknown` in IE
        } else if (typeof event.returnValue !== 'unknown') {
          event.returnValue = false;
        }

        this.isDefaultPrevented = functionThatReturnsTrue;
      },
      stopPropagation: function () {
        var event = this.nativeEvent;

        if (!event) {
          return;
        }

        if (event.stopPropagation) {
          event.stopPropagation(); // $FlowFixMe - flow is not aware of `unknown` in IE
        } else if (typeof event.cancelBubble !== 'unknown') {
          // The ChangeEventPlugin registers a "propertychange" event for
          // IE. This event does not support bubbling or cancelling, and
          // any references to ca...
largeBoundaries.splice(0, i)
request.allPendingTasks === 0 && request.pingedTasks.length === 0 && request.clientRenderedBoundaries.length === 0 && request.completedBoundaries.length === 0
request.allPendingTasks === 0 && request.pingedTasks.length === 0 && request.clientRenderedBoundaries.length === 0 && request.completedBoundaries.length === 0
!flushClientRenderedBoundary(request, destination, boundary)
request.allPendingTasks === 0 && request.pingedTasks.length === 0 && request.clientRenderedBoundaries.length === 0 && request.completedBoundaries.length === 0
error('There was still abortable task at the root when we closed. This is a bug in React.')
error('There was still abortable task at the root when we closed. This is a bug in React.')
error('There was still abortable task at the root when we closed. This is a bug in React.')
error('There was still abortable task at the root when we closed. This is a bug in React.')
this.isDefaultPrevented = functionThatReturnsTrue
_tmp_83.stopPropagation = <lambda>16
var completedBoundaries = request.completedBoundaries
function startWork = function startWork(request) {
    scheduleWork(function () {
      return performWork(request);
    });
  }
scheduleWork(function () {
      return performWork(request);
    })
function startWork = function startWork(request) {
  scheduleWork(function () {
    return performWork(request);
  });
}
var partialBoundaries = request.partialBoundaries
var _boundary2 = partialBoundaries[i]
!flushPartialBoundary(request, destination, _boundary2)
abortableTasks.forEach(function (task) {
      return abortTask(task, request, reason);
    })
flushCompletedQueues(request, request.destination)
var EventInterface = {
    eventPhase: 0,
    bubbles: 0,
    cancelable: 0,
    timeStamp: function (event) {
      return event.timeStamp || Date.now();
    },
    defaultPrevented: 0,
    isTrusted: 0
  }
function renderToStringImpl = function renderToStringImpl(children, options, generateStaticMarkup, abortReason) {
    var didFatal = false;
    var fatalError = null;
    var result = '';
    var destination = {
      push: function (chunk) {
        if (chunk !== null) {
          result += chunk;
        }

        return true;
      },
      destroy: function (error) {
        didFatal = true;
        fatalError = error;
      }
    };
    var readyToStream = false;

    function onShellReady() {
      readyToStream = true;
    }

    var request = createRequest(children, createResponseState$1(generateStaticMarkup, options ? options.identifierPrefix : undefined), createRootFormatContext(), Infinity, onError, undefined, onShellReady, undefined, undefined);
    startWork(request); // If anything suspended and is still pending, we'll abort it before writing.
    // That way we write only client-rendered boundaries from the start.

    abort(request, abortReason);
    startFlowing(request, destination);

    if (...
function onError = function onError() {// Non-fatal errors are ignored.
}
function onShellReady = function onShellReady() {
      var stream = new ReadableStream({
        type: 'bytes',
        pull: function (controller) {
          startFlowing(request, controller);
        },
        cancel: function (reason) {
          abort(request);
        }
      }, // $FlowFixMe size() methods are not allowed on byte streams.
      {
        highWaterMark: 0
      }); // TODO: Move to sub-classing ReadableStream.

      stream.allReady = allReady;
      resolve(stream);
    }
event !== lastMouseEvent
