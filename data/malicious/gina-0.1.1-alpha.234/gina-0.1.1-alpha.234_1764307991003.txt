typeof(result.isXhrRedirect) != 'undefined'
                                && /^true$/i.test(result.isXhrRedirect)
var sourceStream = fs.createReadStream(source)
conf[bundle][env].cacheless     = cacheless
typeof(ports[protocol]) == 'undefined'
referer = request.headers.referer.match(/[^http://|^https://|][a-z0-9-_.:]+\//)[0]
console.info(local.req.method +' ['+local.res.statusCode +'] '+ local.req.url)
(_tmp_128 = gina.popin).getActivePopin
var wroot                   = ( !conf[bundle][env].server.webroot || conf[bundle][env].server.webroot == '' ) ? '/' : conf[bundle][env].server.webroot
arguments.length > 1
            || Array.isArray(arguments[0])
            || typeof(arguments[0]) == 'object' && arguments[0].count() > 1
scheme      = ( new RegExp(authority).test(referer) ) ? referer.match(/^http(.*)\:\/\//)[0].replace(/\:\/\//, '') : conf.server.scheme
portsReverse[bundle + '@' + cmd.projectName][env][protocol][scheme] = {}
_.prototype.mv = function(target, callback) {

        var self = this;
        //Enter dir & start rm.
        var p = self.value;
        exists(p, function(found){
            if ( !found ) {
                var err = new Error(' mv() - source [ '+p+' ] does not exists !');
                console.error(err);
                if ( !callback ) {
                    throw err
                }
                callback(err)
            } else {
                mv(self, target)
                    .onComplete( function(err, path){
                        if (err) {
                            console.error(err);
                            return callback(err)
                        }
                        if (p == path && typeof(callback) != 'undefined') {
                            callback(err)
                        }
                    })
            }
        })
    }
var code_point = code_point_pointer.get()
errors['isInteger'] = replace(this.error || local.errorLabels['isInteger'], this)
_iterator_3 = <operator>.iterator(resHeaders)
errors['isIntegerLength'] = replace(this.error || local.errorLabels['isIntegerMinLength'], this)
var pointer = indexPointerFor(code_point, index)
_.prototype.rmSync = function() {

        if ( !existsSync(this.value) ) {
            return this // always return the instance for sync
        }
        cleanSlashes(this);

        try {
            // console.debug('rmSync() of ['+ this.value +'] : symlink ? '+ fs.lstatSync(this.value).isSymbolicLink());
            if ( fs.lstatSync(this.value).isSymbolicLink() ) {
                fs.unlinkSync(this.value);
                return this;
            }
            browseRemoveSync(this.value);
            return this // always return the instance for sync
        } catch (err) {
            return err // it has to be thrown clean to be "instanceof Error"
        }
    }
triggerEvent(gina, $target, 'success.' + id, result)
_.prototype.rm = function(callback) {
        var self = this;
        //Enter dir & start rm.
        self = cleanSlashes(self);
        var p = self.value;
        exists(p, function(found) {
            //console.debug(" does it exists ? ", p, exists );
            if (!found) {
                //console.debug("done removing ", p);
                callback(new Error('`'+p+'` not found'), p)

            } else {
                rm(p).onComplete( function(err, path) {
                    //console.debug("done removing... ", err);
                    callback(err, path)
                })
            }
        })
    }
code_point === EOF_code_point
exists(p, function(found) {
            //console.debug(" does it exists ? ", p, exists );
            if (!found) {
                //console.debug("done removing ", p);
                callback(new Error('`'+p+'` not found'), p)

            } else {
                rm(p).onComplete( function(err, path) {
                    //console.debug("done removing... ", err);
                    callback(err, path)
                })
            }
        })
self[el]['isRequired'] = function(isApplicable) {

            if ( typeof(isApplicable) == 'boolean' && !isApplicable ) {

                this.valid = true;

                // is in excluded ?
                var excludedIndex = local.excluded.indexOf(this.name);
                if ( excludedIndex > -1 ) {
                    local.excluded.splice(excludedIndex, 1);
                }

                return self[this.name]
            }

            // radio group case
            if (
                isGFFCtx
                && this.target
                && this.target.tagName == 'INPUT'
                && typeof(this.target.type) != 'undefined'
                && this.target.type == 'radio'
            ) {
                var radios = document.getElementsByName(this.name);
                for (var i = 0, len = radios.length; i < len; ++i) {
                    if (radios[i].checked) {
                        if ( /true|false/.test(radios[i].value) ) {
                         ...
var pointer = indexPointerFor(code_point, indexes['gbk'])
throwError({stream: stream}, 500, 'Internal server error\n' + headers[':path'] + '\nNo template found')
var lead = div(pointer, 190) + 0x81
result.message = xhr.responseText
params = {
                    method              : localMethod,
                    requirements        : routing[name].requirements,
                    namespace           : routing[name].namespace || undefined,
                    url                 : decodeURI(pathname), /// avoid %20
                    rule                : routing[name].originalRule || name,
                    param               : routing[name].param,
                    //middleware: routing[name].middleware,
                    middleware          : JSON.clone(routing[name].middleware),
                    bundle              : routing[name].bundle,
                    isXMLRequest        : isXMLRequest
                }
var excludedIndex = local.excluded.indexOf(this.name)
typeof(result) != 'undefined' && typeof(result.error) != 'undefined' &&  result.fields && typeof(result.fields) == 'object'
_tmp_110.url = wroot.substring(0, wroot.length-1)
var rm = function(source) {

        browseRemove(source,  function(err, path) {
            //console.debug('rm done...', err, path, " VS ", source);
            e.emit('rm#complete', err, path)
        });

        return {
            /**
             * Complete event
             * @event rm#onComplete
             * */
            onComplete : function(callback) {
                e.once('rm#complete', function(err, path) {
                    if (err) {
                        console.error(err.stack)
                    }
                    //console.debug('calling back now...', err, path);
                    //This one is listened by several rm().
                    callback(err, path)
                })
            }
        }
    }
_tmp_110.param = {
                    control: "redirect",
                    ignoreWebRoot: true,
                    path: wroot,
                    code: 302
                }
browseRemove(source,  function(err, path) {
            //console.debug('rm done...', err, path, " VS ", source);
            e.emit('rm#complete', err, path)
        })
isGFFCtx
                && this.target
                && this.target.tagName == 'INPUT'
                && typeof(this.target.type) != 'undefined'
                && this.target.type == 'radio'
result.update   = instance.update
output_byte_stream.emit(byte1 + 0x81,
                                   byte2 + 0x30,
                                   byte3 + 0x81,
                                   byte4 + 0x30)
header = {
                    ':status': 301
                }
errorObject[f].isApiError = result.error
_tmp_110.host = conf[bundle][env].host
var code_point = code_point_pointer.get()
var isValidURL = function(url){
        var re = /(http|ftp|https|sftp):\/\/[\w-]+(\.[\w-]+)+([\w.,@?^=%&amp;:\/~+#-]*[\w@?^=%&amp;\/~+#-])?/;
        return (re.test(url)) ? true : false
    }
var getResponseProtocol = function (response) {

        var protocol    = 'http/'+ local.request.httpVersion; // inheriting request protocol version by default
        var bundleConf  = self.conf[self.appName][self.env];
        // switching protocol to h2 when possible
        if ( /http\/2/.test(bundleConf.server.protocol) && response.stream ) {
            protocol    = bundleConf.server.protocol;
        }

        return protocol;
    }
route.toUrl = function (ignoreWebRoot) {
                var wroot       = this.webroot
                    , hostname  = this.hostname
                    , path      = this.url
                ;

                this.url = ( typeof(ignoreWebRoot) != 'undefined' && ignoreWebRoot == true ) ? path.replace(wroot, '/') : path;

                return hostname + this.url
            }
this.setRequestMethod = function(requestMethod, conf) {
        // http/2 case
        if ( /http\/2/i.test(conf.server.protocolShort) ) {
            local.req.headers[':method'] = local.req.method.toUpperCase()
        }

        localRequestMethod = local.req.method = local.req.routing.method = requestMethod.toUpperCase();

        local.res.setHeader('access-control-allow-methods', localRequestMethod);

        return localRequestMethod;
    }
output_byte_stream.emit(code_point)
local.res.setHeader('access-control-allow-methods', localRequestMethod)
!routing[rule].param
console.warn('[FormValidator::isDate] Provided value for field `'+ this.name +'` is not allowed: `'+ val +'`')
typeof(routing[rule].param) != 'undefined' && typeof(routing[rule].param.file) == 'undefined'
!inRange(lead, 0x21, 0x7E) || !inRange(trail, 0x21, 0x7E)
this.setRequestMethodParams = function(params) {
        localRequestMethodParams = local.req[local.req.method.toLowerCase()] = localRequestMethodParams = params
    }
var code_point = code_point_pointer.get()
code_point === EOF_code_point
this.value = this.value.replace(/^\s+|\s+$/, '')
files['settings'] = JSON.clone(conf[bundle][env].tmpSettingFileContent) || {}
var pointer = indexPointerFor(code_point, indexes['big5'])
(_tmp_145 = files['settings']).count
this.redirect = function(req, res, next) {
        var conf    = self.getConfig();
        var bundle  = conf.bundle;
        var env     = conf.env;
        var wroot   = conf.server.webroot;
        var ctx     = getContext('gina');
        var routing = ctx.config.getRouting();//conf.content.routing;
        var route   = '', rte = '';
        var ignoreWebRoot = null, isRelative = false;
        var originalUrl = null;
        var method = null;
        var originalMethod = null;

        if ( typeof(req) === 'string' ) {

            // if ( typeof(res) == 'undefined') {
            //     // nothing to do
            //     ignoreWebRoot = false
            // } else
            if (typeof(res) === 'string' || typeof(res) === 'number' || typeof(res) === 'boolean') {
                if ( /true|1/.test(res) ) {
                    ignoreWebRoot = true
                } else if ( /false|0/.test(res) ) {
                    ignoreWebRoot = false
                } else {
          ...
newObj = parseCtxObject(JSON.parse(str), path)
self[el]['exclude'] = function(isApplicable) {

            if ( typeof(isApplicable) == 'boolean' && !isApplicable ) {

                if ( /^true|false$/i.test(this.value)) {
                    this.value = (/^true$/i.test(this.value)) ? true : false;
                    local.data[this.name] = this.value;
                }

                return self[this.name]
            }
            this.isExcluded = false;
            // list field to be purged
            if ( local.excluded.indexOf(this.name) < 0) {
                local.excluded.push(this.name);
                this.isExcluded = true;
            }


            // remove existing errors
            return self[this.name];
        }
delete require.cache[require.resolve(staticsPath)]
key == 'preview' && typeof(files[f][key]) == 'undefined'
typeof(errors[field]) != 'object'
                    ||
                    typeof(errors[field][r]) == 'undefined'
contentType = getContentTypeByFilename(filename)
contentType = contentType +'; charset='+ bundleConf.encoding
request.url = ( ext != null && typeof(ext[0]) != 'undefined' ) ? request.url : request.url + 'index.html'
typeof(self._options.template.assets[request.url]) == 'undefined'
self._options.template.assets[request.url] = {
                                                    ext: ( ext != null && typeof(ext[0]) != 'undefined' ) ? ext[0] : null,
                                                    //isAvailable: true,
                                                    isAvailable: (!/404\.html/.test(filename)) ? true : false,
                                                    mime: contentType,
                                                    url: request.url,
                                                    filename: filename,
                                                    isBinary: isBinary,
                                                    isHandler: isHandler
                                                }
_tmp_187.ext = ext != null && typeof(ext[0]) != 'undefined' ? ext[0] : null
typeof(files[f][key][previewKey]) != 'undefined' && typeof(fieldsObjectList[key][previewKey]) != 'undefined'
condition = ( typeof(routing[route]) != 'undefined') ? true : false
files['templates'][section] = merge(files['templates'][section], defaultViews[section])
previewKey == 'tmpUri' && uploadProperties.hasPreviewContainer
var isProxyHost = ( typeof(local.req.headers.host) != 'undefined' && local.options.conf.server.scheme +'://'+ local.req.headers.host != local.options.conf.hostname || typeof(local.req.headers[':authority']) != 'undefined' && local.options.conf.server.scheme +'://'+ local.req.headers[':authority'] != local.options.conf.hostname  ) ? true : false
let isSynchrone = $uploadTrigger.getAttribute('data-gina-form-upload-'+ bindingType +'-is-synchrone')
/null/i.test(isSynchrone) || typeof(method) == 'undefined' || method == ''
let xhrOptions = {
                            url: url,
                            method: method,
                            isSynchrone: isSynchrone,
                            headers : {
                                // to upload, use `multipart/form-data` for `enctype`
                                'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8',
                                // cross domain is enabled by default, but you need to setup `Access-Control-Allow-Origin`
                                'X-Requested-With': 'XMLHttpRequest' // in case of cross domain origin
                            }
                        }
typeof(self.conf[self.appName][self.env].server.webroot) != 'undefined'
self.conf[self.appName][self.env].server.webroot == routing['webroot@'+self.appName].webroot
/^(\*|\*\*|all)$/i.test(files['templates'][section][excludedStr])
this.getBundleStatus = function(req, res, next) {
        var conf = self.getConfig();
        self.renderJSON({
            status: 200,
            isAlive: true,
            message: 'I am alive !',
            // bundle: conf.bundle,
            // project: conf.projectName
        });
    }
let eLen = currentCollectionRaw.length
inRange(code_point, 0xFF61, 0xFF9F) &&
        iso2022jp_state !== state.Katakana
var opt     = self.getConfig('app').proxy[bundle]
var route   = lib.routing.getRoute('bundle-status@'+bundle)
var pointer = indexPointerFor(code_point, indexes['jis0208'])
removeListener(gina, $uploadResetTrigger, 'click', function onUploadResetTriggerEventRemoved() {
                            // remove link & image - must be done last
                            $resetLink.remove();
                            childNodes[i].remove();
                        })
var lead = div(pointer, 94) + 0x21
var trail = pointer % 94 + 0x21
output_byte_stream.emit(lead, trail)
/^\./.test(errorFiles[f])
                                ||
                                fs.statSync(errorFilename).isDirectory()
code_point === EOF_code_point
inRange(code_point, 0x0000, 0x0080)
/multipart\/form-data;/.test(request.headers['content-type'])
typeof(files['templates']._common.errorFiles) == 'undefined'
typeof(files['templates']._common.errorFiles[eCode]) == 'undefined'
typeof(opt.autoTmpCleanupTimeout) != 'undefined'
                        &&  opt.autoTmpCleanupTimeout != ''
                        &&  opt.autoTmpCleanupTimeout != 0
                        &&  !/false/i.test(opt.autoTmpCleanupTimeout)
output_byte_stream.emit(code_point - 0xFF61 + 0xA1)
var pointer = indexPointerFor(code_point, indexes['jis0208'])
htmlErrorsPath = null
htmlErrorsFromPath(files['templates']._common.html+ '/errors')
throwError(response, 431, 'Attachment exceeded maximum file size [ '+ opt.maxFieldsSize +' ]')
htmlErrorsFromPath(conf[bundle][env].sharedPath + '/errors')
var offset = trail < 0x3F ? 0x40 : 0x41
output_byte_stream.emit(lead + lead_offset, trail + offset)
var code_point = code_point_pointer.get()
var loadForms = function(formsDir) {
        var forms = { rules: {}}, cacheless = self.isCacheless(), root = '';

        if ( fs.existsSync(formsDir) ) {
            root = ''+formsDir;
            // browsing dir
            var readDir = function (dir, forms, key, previousKey) {
                var files       = fs.readdirSync(dir)
                    , filename  = ''
                    , k         = null;

                for (var i = 0, len = files.length; i < len; ++i) {
                    if ( !/^\./.test(files[i]) ) {
                        filename = _(dir + '/' + files[i], true);

                        if ( fs.statSync(filename).isDirectory() ) {
                            key += dir.replace(root, '') +'/'+ files[i] + '/';
                            k = key.split(/\//g);
                            forms[k[k.length-2]] = {};
                            // special case for user validators/* directories
                            if ( /validators\/(.*)$/i.test(filename)...
typeof(group) != 'undefined'
                            && group != 'untagged'
                            && typeof(opt.groups[group]) != 'undefined'
output_byte_stream.emit(code_point)
var pointer = indexPointerFor(code_point, indexes['euc-kr'])
this.store = async function(target, files, cb) {


        var start = function(target, files, cb) {

            if (arguments.length == 2 && typeof(arguments[1]) == 'function' ) {
                var cb = arguments[1];
            }

            if ( typeof(files) == 'undefined' || typeof(files) == 'function' ) {
                files = local.req.files
            }

            var uploadedFiles = [];

            if ( typeof(files) == 'undefined' || files.count() == 0 ) {
                if (cb) {
                    cb(new Error('No file to upload'))
                } else {
                    self.emit('uploaded', new Error('No file to upload'))
                }
            } else {
                // saving files
                var uploadDir   = new _(target)
                    , list      = []
                    , i         = 0
                    , folder    = uploadDir.mkdirSync();

                if (folder instanceof Error) {
                    if (cb) {
         ...
addListener(gina, $form.target, 'destroy.' + _id, function(event) {

                cancelEvent(event);

                delete instance['$forms'][_id];
                removeListener(gina, event.currentTarget, event.type);
                removeListener(gina, event.currentTarget,'destroy');
            })
arguments.length == 2 && typeof(arguments[1]) == 'function'
trail = pointer % (26 + 26 + 126)
var offset = trail < 26 ? 0x41 : trail < 26 + 26 ? 0x47 : 0x4D
key += dir.replace(root, '') +'/'+ files[i] + '/'
pointer = pointer - (26 + 26 + 126) * (0xC7 - 0x81)
throwError(response, 400, '`'+ fileExt +'` is not an allowed extension. See `'+ group +'` upload group definition.')
(_tmp_200 = /validators\/(.*)$/i).test
readDir( filename, forms, key, k[k.length-2] )
