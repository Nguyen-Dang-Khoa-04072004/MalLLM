const relativePath =
    file !== 'stdin' ? path.relative(path.resolve(), file) : file
file !== 'stdin' ? path.relative(path.resolve(), file) : file
<operator>.formatString("Processing ", pc.bold(relativePath), "...")
(_tmp_13 = rc(ctx, argv.config)
    .then((config) => {
      config = config || cliConfig
      const options = { ...config.options }

      if (file === 'stdin' && output) file = output

      // TODO: Unit test this
      options.from = file === 'stdin' ? path.join(process.cwd(), 'stdin') : file

      if (output || dir || argv.replace) {
        const base = argv.base
          ? file.replace(path.resolve(argv.base), '')
          : path.basename(file)
        options.to = output || (argv.replace ? file : path.join(dir, base))

        if (argv.ext) {
          options.to = options.to.replace(path.extname(options.to), argv.ext)
        }

        options.to = path.resolve(options.to)
      }

      if (!options.to && config.options.map && !config.options.map.inline) {
        error(
          'Output Error: Cannot output external sourcemaps when writing to STDOUT'
        )
      }

      return postcss(config.plugins)
        .process(css, options)
        .then((result) => {
          co...).catch
{
      config = config || cliConfig
      const options = { ...config.options }

      if (file === 'stdin' && output) file = output

      // TODO: Unit test this
      options.from = file === 'stdin' ? path.join(process.cwd(), 'stdin') : file

      if (output || dir || argv.replace) {
        const base = argv.base
          ? file.replace(path.resolve(argv.base), '')
          : path.basename(file)
        options.to = output || (argv.replace ? file : path.join(dir, base))

        if (argv.ext) {
          options.to = options.to.replace(path.extname(options.to), argv.ext)
        }

        options.to = path.resolve(options.to)
      }

      if (!options.to && config.options.map && !config.options.map.inline) {
        error(
          'Output Error: Cannot output external sourcemaps when writing to STDOUT'
        )
      }

      return postcss(config.plugins)
        .process(css, options)
        .then((result) => {
          const tasks = []

          if (options.to) {...
config = config || cliConfig
const options = { ...config.options }
file === 'stdin' && output
options.from = file === 'stdin' ? path.join(process.cwd(), 'stdin') : file
const base = argv.base
          ? file.replace(path.resolve(argv.base), '')
          : path.basename(file)
file.replace(path.resolve(argv.base), '')
path.basename(file)
options.to = output || (argv.replace ? file : path.join(dir, base))
options.to = options.to.replace(path.extname(options.to), argv.ext)
options.to = path.resolve(options.to)
!options.to && config.options.map && !config.options.map.inline
postcss(config.plugins)
        .process(css, options)
        .then((result) => {
          const tasks = []

          if (options.to) {
            tasks.push(outputFile(options.to, result.css))

            if (result.map) {
              const mapfile = getMapfile(options)
              tasks.push(outputFile(mapfile, result.map.toString()))
            }
          } else process.stdout.write(result.css, 'utf8')

          return Promise.all(tasks).then(() => {
            const prettyTime = prettyHrtime(process.hrtime(time))
            printVerbose(
              pc.green(
                `Finished ${pc.bold(relativePath)} in ${pc.bold(prettyTime)}`
              )
            )

            const messages = result.warnings()
            if (messages.length) {
              console.warn(reporter({ ...result, messages }))
            }

            return result
          })
        })
process
(result) => {
          const tasks = []

          if (options.to) {
            tasks.push(outputFile(options.to, result.css))

            if (result.map) {
              const mapfile = getMapfile(options)
              tasks.push(outputFile(mapfile, result.map.toString()))
            }
          } else process.stdout.write(result.css, 'utf8')

          return Promise.all(tasks).then(() => {
            const prettyTime = prettyHrtime(process.hrtime(time))
            printVerbose(
              pc.green(
                `Finished ${pc.bold(relativePath)} in ${pc.bold(prettyTime)}`
              )
            )

            const messages = result.warnings()
            if (messages.length) {
              console.warn(reporter({ ...result, messages }))
            }

            return result
          })
        }
process.stdout.write(result.css, 'utf8')
