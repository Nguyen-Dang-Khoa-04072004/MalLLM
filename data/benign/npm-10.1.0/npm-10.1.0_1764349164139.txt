_tmp_4.push({
    groups: ['permissions'],
    title: 'Perms check on local node_modules',
    cmd: 'checkLocalModulesPermission',
    windows: false,
  })
let output = columnify(
    [pkg],
    {
      include: columns,
      showHeaders: num <= 1,
      columnSplitter: ' | ',
      truncate: truncate,
      config: {
        name: { minWidth: 25, maxWidth: 25, truncate: false, truncateMarker: '' },
        description: { minWidth: 20, maxWidth: 20 },
        author: { minWidth: 15, maxWidth: 15 },
        date: { maxWidth: 11 },
        version: { minWidth: 8, maxWidth: 8 },
        keywords: { maxWidth: Infinity },
      },
    }
  ).split('\n').map(line => line.slice(0, maxWidth)).join('\n')
const getContents = async (manifest, tarball) => {
  const files = []
  const bundled = new Set()
  let totalEntries = 0
  let totalEntrySize = 0

  // reads contents of tarball
  const stream = tar.t({
    onentry (entry) {
      totalEntries++
      totalEntrySize += entry.size
      const p = entry.path
      if (p.startsWith('package/node_modules/')) {
        const name = p.match(/^package\/node_modules\/((?:@[^/]+\/)?[^/]+)/)[1]
        bundled.add(name)
      }
      files.push({
        path: entry.path.replace(/^package\//, ''),
        size: entry.size,
        mode: entry.mode,
      })
    },
  })
  stream.end(tarball)

  const integrity = await ssri.fromData(tarball, {
    algorithms: ['sha1', 'sha512'],
  })

  const comparator = ({ path: a }, { path: b }) => localeCompare(a, b)

  const isUpper = str => {
    const ch = str.charAt(0)
    return ch === ch.toUpperCase()
  }

  const uppers = files.filter(file => isUpper(file.path))
  const others = files.filter(file => !isUpp...
typeof er.path === 'string' &&
        npm.config.loaded &&
        er.path.startsWith(npm.config.get('cache'))
libexec({
      ...flatOptions,
      // we explicitly set packageLockOnly to false because if it's true
      // when we try to install a missing package, we won't actually install it
      packageLockOnly: false,
      // copy args so they dont get mutated
      args: [...args],
      call,
      localBin,
      locationMsg,
      globalBin,
      globalPath,
      output,
      chalk,
      packages,
      path: localPrefix,
      runPath,
      scriptShell,
      yes,
    })
const aliases = {

  // aliases
  author: 'owner',
  home: 'docs',
  issues: 'bugs',
  info: 'view',
  show: 'view',
  find: 'search',
  add: 'install',
  unlink: 'uninstall',
  remove: 'uninstall',
  rm: 'uninstall',
  r: 'uninstall',

  // short names for common things
  un: 'uninstall',
  rb: 'rebuild',
  list: 'ls',
  ln: 'link',
  create: 'init',
  i: 'install',
  it: 'install-test',
  cit: 'install-ci-test',
  up: 'update',
  c: 'config',
  s: 'search',
  se: 'search',
  tst: 'test',
  t: 'test',
  ddp: 'dedupe',
  v: 'view',
  run: 'run-script',
  'clean-install': 'ci',
  'clean-install-test': 'install-ci-test',
  x: 'exec',
  why: 'explain',
  la: 'll',
  verison: 'version',
  ic: 'ci',

  // typos
  innit: 'init',
  // manually abbrev so that install-test doesn't make insta stop working
  in: 'install',
  ins: 'install',
  inst: 'install',
  insta: 'install',
  instal: 'install',
  isnt: 'install',
  isnta: 'install',
  isntal: 'install',
  isntall: 'install',
  'install-clean': ...
const table = new Table({
      head: ['id', 'token', 'created', 'readonly', 'CIDR whitelist'],
      colWidths: [Math.max(idWidth, 2) + 2, 9, 12, 10],
    })
const pruned = lines.reduce((l, r) => {
        if (!(r === null && l[l.length - 1] === null)) {
          l.push(r)
        }

        return l
      }, [])
Promise.all(entries.map(f => fs.rm(`${path}/${f}`, { force: true, recursive: true })))
const content = {
        metadata,
        timers: this.#finished,
        // add any unfinished timers with their relative start/end
        unfinishedTimers: [...this.#unfinished.entries()].reduce((acc, [name, start]) => {
          acc[name] = [start - globalStart, globalEnd - globalStart]
          return acc
        }, {}),
      }
#logHandler = (level, ...args) => {
    try {
      this.#log(level, ...args)
    } catch (ex) {
      try {
        // if it crashed once, it might again!
        this.#npmlog('verbose', `attempt to log ${inspect(args)} crashed`, ex)
      } catch (ex2) {
        // eslint-disable-next-line no-console
        console.error(`attempt to log ${inspect(args)} crashed`, ex, ex2)
      }
    }
  }
const getter = ({ data, key }) => {
  // keys are a list in which each entry represents the name of
  // a property that should be walked through the object in order to
  // return the final found value
  const keys = parseKeys(key)
  let _data = data
  let label = ''

  for (const k of keys) {
    // empty-bracket-shortcut-syntax is not supported on getter
    if (k === _append) {
      throw Object.assign(new Error('Empty brackets are not valid syntax for retrieving values.'), {
        code: 'EINVALIDSYNTAX',
      })
    }

    // extra logic to take into account printing array, along with its
    // special syntax in which using a dot-sep property name after an
    // arry will expand it's results, e.g:
    // arr.name -> arr[0].name=value, arr[1].name=value, ...
    const maybeIndex = Number(k)
    if (Array.isArray(_data) && !Number.isInteger(maybeIndex)) {
      _data = _data.reduce((acc, i, index) => {
        acc[`${label}[${index}].${k}`] = i[k]
        return acc
      }, {})
...
<operator>.formatString("Logged in", opts.scope ? ` to scope ${opts.scope}` : '', " on ", opts.registry, ".")
