overwrites = overwrites.map(overwrite => {
      const role = this.client.resolver.resolveRole(guild, overwrite.id);
      if (role) {
        overwrite.id = role.id;
        overwrite.type = "role";
      } else {
        overwrite.id = this.client.resolver.resolveUserID(overwrite.id);
        overwrite.type = "member";
      }

      return {
        allow: Permissions.resolve(overwrite.allow || overwrite.allowed || 0),
        deny: Permissions.resolve(overwrite.deny || overwrite.denied || 0),
        type: overwrite.type,
        id: overwrite.id
      };
    })
const ffmpegArguments = [
  '-analyzeduration', '0',
  '-loglevel', '0',
  '-f', 's16le',
  '-ar', '48000',
  '-ac', '2',
]
ClientUserGuildSettings = package\src\structures\ClientUserGuildSettings.js::program:ClientUserGuildSettings:<init>
this.build({
      url: url || this.constructor.DFEAULT.url,
      version: version || this.constructor.DEFAULT.version
    })
VoiceConnectionUDPClient = package\src\client\voice\VoiceUDPClient.js::program:VoiceConnectionUDPClient:<init>
VoiceServerUpdate = package\src\client\websocket\packets\handlers\VoiceServerUpdate.js::program:VoiceServerUpdate:<init>
this.message =
      error.message && flattened
        ? `${error.message}\n${flattened}`
        : error.message || flattened
WebSocketPacketManager = package\src\client\websocket\packets\WebSocketPacketManager.js::program:WebSocketPacketManager:<init>
SequentialRequestHandler = package\src\client\rest\RequestHandlers\Sequential.js::program:SequentialRequestHandler:<init>
permissions =
      typeof member === "object" && !(member instanceof Array)
        ? permissions
        : member
const WebSocket = (function findWebSocket() {
  if (browser) return window.WebSocket; // eslint-disable-line no-undef
  try {
    return require('@discordjs/uws');
  } catch (e) {
    return require('ws');
  }
}())
VoiceWebSocket = package\src\client\voice\VoiceWebSocket.js::program:VoiceWebSocket:<init>
Object.defineProperty(this, "_array", {
      value: null,
      writable: true,
      configurable: true
    })
messages[i] = channel._cacheMessage(
            new Message(channel, data[i], client)
          )
const startInd = route.includes("/channels/")
        ? route.indexOf("/channels/")
        : route.indexOf("/guilds/")
exports.fetch = engineOptions => {
  for (const encoder of list) {
    const fetched = fetch(encoder, engineOptions);
    if (fetched) return fetched;
  }

  throw new Error('Couldn\'t find an Opus engine.');
}
lib.ready.then(() => {
        exports.methods = libs[libName](lib);
      }).catch(() => {
        const tweetnacl = require('tweetnacl');
        exports.methods = libs.tweetnacl(tweetnacl);
      }).catch(() => undefined)
this.register(Constants.WSEvents.GUILD_UPDATE, require('./handlers/GuildUpdate'))
const Targets = {
  ALL: 'ALL',
  GUILD: 'GUILD',
  CHANNEL: 'CHANNEL',
  USER: 'USER',
  ROLE: 'ROLE',
  INVITE: 'INVITE',
  WEBHOOK: 'WEBHOOK',
  EMOJI: 'EMOJI',
  MESSAGE: 'MESSAGE',
}
options = Util.mergeDefault(
      {
        totalShards: "auto",
        respawn: true,
        shardArgs: [],
        token: null
      },
      options
    )
new Promise((resolve, reject) => {
      handler.push({
        request: apiRequest,
        resolve,
        reject,
        retries: 0
      });
    })
handler.push({
        request: apiRequest,
        resolve,
        reject,
        retries: 0
      })
item.request.gen().end((err, res) => {
      if (res && res.headers) {
        this.limit = Number(res.headers["x-ratelimit-limit"]);
        this.resetTime = Number(res.headers["x-ratelimit-reset"]) * 1000;
        this.remaining = Number(res.headers["x-ratelimit-remaining"]);
        this.timeDifference = Date.now() - new Date(res.headers.date).getTime();
      }
      if (err) {
        if (err.status === 429) {
          this.queue.unshift(item);
          if (res.headers["x-ratelimit-global"]) this.globalLimit = true;
          if (this.resetTimeout) return;
          this.resetTimeout = this.client.setTimeout(() => {
            this.remaining = this.limit;
            this.globalLimit = false;
            this.handle();
            this.resetTimeout = null;
          }, Number(res.headers["retry-after"]) + this.client.options.restTimeOffset);
        } else if (err.status >= 500 && err.status < 600) {
          if (item.retries === this.client.options.retryLimit) {
          ...
WebSocketConnection = package\src\client\websocket\WebSocketConnection.js::program:WebSocketConnection:<init>
member = guild._addMember({
          user,
          roles: data.roles,
          deaf: false,
          mute: false,
        }, false)
this.bitfield =
      typeof permissions === "number"
        ? permissions
        : this.constructor.resolve(permissions)
exports.DefaultOptions = {
  apiRequestMethod: "sequential",
  shardId: 0,
  shardCount: 0,
  messageCacheMaxSize: 200,
  messageCacheLifetime: 0,
  messageSweepInterval: 0,
  fetchAllMembers: false,
  disableEveryone: false,
  sync: false,
  restWsBridgeTimeout: 5000,
  retryLimit: Infinity,
  disabledEvents: [],
  restTimeOffset: 500,

  /**
   * WebSocket options (these are left as snake_case to match the API)
   * @typedef {Object} WebsocketOptions
   * @property {number} [large_threshold=250] Number of members in a guild to be considered large
   * @property {boolean} [compress=true] Whether to compress data sent on the connection
   * (defaults to `false` for browsers)
   */
  ws: {
    large_threshold: 250,
    compress: require("os").platform() !== "browser",
    properties: {
      $os: process ? process.platform : "discord.js",
      $browser: "discord.js",
      $device: "discord.js",
      $referrer: "",
      $referring_domain: ""
    },
    version: 6
  },

  /**
   * ...
throw new TypeError(
        `"timestamp" argument must be a number (received ${
          isNaN(timestamp) ? "NaN" : typeof timestamp
        })`
      );
<operator>.formatString(""timestamp" argument must be a number (received ", isNaN(timestamp) ? "NaN" : typeof timestamp, ")")
this.client.rest.methods.getGateway().then(res => {
      const protocolVersion = Constants.DefaultOptions.ws.version;
      const gateway = `${res.url}/?v=${protocolVersion}&encoding=${WebSocketConnection.ENCODING}`;
      this.client.emit(Constants.Events.DEBUG, `Using gateway ${gateway}`);
      this.client.ws.connect(gateway);
      this.client.ws.connection.once('error', reject);
      this.client.ws.connection.once('close', event => {
        if (event.code === 4004) reject(new Error(Constants.Errors.BAD_LOGIN));
        if (event.code === 4010) reject(new Error(Constants.Errors.INVALID_SHARD));
        if (event.code === 4011) reject(new Error(Constants.Errors.SHARDING_REQUIRED));
      });
      this.client.once(Constants.Events.READY, () => {
        resolve(token);
        this.client.clearTimeout(timeout);
      });
    }, reject)
this._reEmitter = message => {
      /**
       * Emitted when the collector receives a message.
       * @event MessageCollector#message
       * @param {Message} message The message
       * @deprecated
       */
      this.emit('message', message);
    }
<operator>.formatString("", res.url, "/?v=", protocolVersion, "&encoding=", WebSocketConnection.ENCODING, "")
new Promise((resolve, reject) => {
      if (!channel.joinable) {
        if (channel.full) {
          throw new Error('You do not have permission to join this voice channel; it is full.');
        } else {
          throw new Error('You do not have permission to join this voice channel.');
        }
      }

      let connection = this.connections.get(channel.guild.id);

      if (connection) {
        if (connection.channel.id !== channel.id) {
          this.connections.get(channel.guild.id).updateChannel(channel);
        }
        resolve(connection);
        return;
      } else {
        connection = new VoiceConnection(this, channel);
        this.connections.set(channel.guild.id, connection);
      }

      connection.once('failed', reason => {
        this.connections.delete(channel.guild.id);
        reject(reason);
      });

      connection.once('authenticated', () => {
        connection.once('ready', () => resolve(connection));
        connection.once('error', rejec...
this.client.ws.connection.once('close', event => {
        if (event.code === 4004) reject(new Error(Constants.Errors.BAD_LOGIN));
        if (event.code === 4010) reject(new Error(Constants.Errors.INVALID_SHARD));
        if (event.code === 4011) reject(new Error(Constants.Errors.SHARDING_REQUIRED));
      })
channel.client.setTimeout(() => {
    channel.client.emit(Constants.Events.TYPING_STOP, channel, user, channel._typing.get(user.id));
    channel._typing.delete(user.id);
  }, 6000)
this.rest.makeRequest(
      "get",
      bot ? Endpoints.gateway.bot : Endpoints.gateway,
      true
    )
this.resetTimeout = this.client.setTimeout(() => {
              this.handle();
              this.resetTimeout = null;
            }, 1e3 + this.client.options.restTimeOffset)
item.reject(
            err.status >= 400 && err.status < 500
              ? new DiscordAPIError(
                  res.request.path,
                  res.body,
                  res.request.method
                )
              : err
          )
item.request.gen().end((err, res) => {
        if (res && res.headers) {
          this.requestLimit = Number(res.headers["x-ratelimit-limit"]);
          this.requestResetTime =
            Number(res.headers["x-ratelimit-reset"]) * 1000;
          this.requestRemaining = Number(res.headers["x-ratelimit-remaining"]);
          this.timeDifference =
            Date.now() - new Date(res.headers.date).getTime();
        }
        if (err) {
          if (err.status === 429) {
            this.queue.unshift(item);
            this.client.setTimeout(() => {
              this.globalLimit = false;
              resolve();
            }, Number(res.headers["retry-after"]) + this.client.options.restTimeOffset);
            if (res.headers["x-ratelimit-global"]) this.globalLimit = true;
          } else if (err.status >= 500 && err.status < 600) {
            if (item.retries === this.client.options.retryLimit) {
              item.reject(err);
              resolve();
            } else {...
super.deletable &&
      this.permissionsFor(this.client.user).has(Permissions.FLAGS.CONNECT)
this.client.ws.send({
        op: Constants.OPCodes.HEARTBEAT,
        d: this.client.ws.sequence,
      })
socket.once('message', message => {
      const packet = parseLocalPacket(message);
      if (packet.error) {
        this.emit('error', packet.error);
        return;
      }

      this.localAddress = packet.address;
      this.localPort = packet.port;

      this.voiceConnection.sockets.ws.sendPacket({
        op: Constants.VoiceOPCodes.SELECT_PROTOCOL,
        d: {
          protocol: 'udp',
          data: {
            address: packet.address,
            port: packet.port,
            mode: 'xsalsa20_poly1305',
          },
        },
      });
    })
new Promise((resolve, reject) => {
      this.once("ready", resolve);
      this.once("disconnect", () =>
        reject(
          new Error(
            `Shard ${this.id}'s Client disconnected before becoming ready.`
          )
        )
      );
      this.once("death", () =>
        reject(
          new Error(
            `Shard ${this.id}'s process exited before its Client became ready.`
          )
        )
      );
      setTimeout(
        () =>
          reject(
            new Error(
              `Shard ${this.id}'s Client took too long to become ready.`
            )
          ),
        30000
      );
    }).then(() => this.process)
_tmp_12.d = {
          protocol: 'udp',
          data: {
            address: packet.address,
            port: packet.port,
            mode: 'xsalsa20_poly1305',
          },
        }
this.send({ _sEval: script }).catch(err => {
        process.removeListener("message", listener);
        reject(err);
      })
_tmp_13.data = {
            address: packet.address,
            port: packet.port,
            mode: 'xsalsa20_poly1305',
          }
dispatcher.once('end', () => this.unregisterDispatcher(dispatcher))
dispatcher.on('volumeChange', (o, n) => {
        this.unregisterDispatcher(dispatcher, o);
        if (!this._dispatchers.has(n)) {
          this._dispatchers.set(n, new Set());
          this._encoders.set(n, OpusEncoders.fetch());
        }
        this._dispatchers.get(n).add(dispatcher);
      })
function parseLocalPacket = function parseLocalPacket(message) {
  try {
    const packet = Buffer.from(message);
    let address = '';
    for (let i = 4; i < packet.indexOf(0, i); i++) address += String.fromCharCode(packet[i]);
    const port = parseInt(packet.readUIntLE(packet.length - 2, 2).toString(10), 10);
    return { address, port };
  } catch (error) {
    return { error };
  }
}
this.mentions = new Mentions(
      this,
      'mentions' in data ? data.mentions : this.mentions.users,
      'mentions_roles' in data ? data.mentions_roles : this.mentions.roles,
      'mention_everyone' in data ? data.mention_everyone : this.mentions.everyone
    )
const listener = message => {
        if (!message || message._eval !== script) return;
        this.process.removeListener("message", listener);
        this._evals.delete(script);
        if (!message._error) resolve(message._result);
        else reject(Util.makeError(message._error));
      }
channel._typing.has(this.id) ? channel._typing.get(this.id).elapsedTime : -1
this.opusEncoders.set(user.id, OpusEncoders.fetch())
_tmp_46 = VoiceReceiver._tryDecode(this.opusEncoders.get(user.id), data)
this.fetchMessages({ limit: 1, around: messageID }).then(messages => {
        const msg = messages.get(messageID);
        if (!msg) throw new Error('Message not found.');
        return msg;
      })
(_tmp_14 = [
      Actions.CHANNEL_DELETE,
      Actions.CHANNEL_OVERWRITE_DELETE,
      Actions.MEMBER_KICK,
      Actions.MEMBER_PRUNE,
      Actions.MEMBER_BAN_ADD,
      Actions.ROLE_DELETE,
      Actions.INVITE_DELETE,
      Actions.WEBHOOK_DELETE,
      Actions.EMOJI_DELETE,
      Actions.MESSAGE_DELETE,
    ]).includes
typeof code !== "undefined" &&
      (typeof code !== "boolean" || code === true)
_tmp_55.nicks = recipients.reduce((o, r) => {
        if (r.nick) o[r.user ? r.user.id : r.id] = r.nick;
        return o;
      }, {})
process.emitWarning('fetchApplication: use "@me" as an argument', 'DeprecationWarning')
receiver.stoppedSpeaking(user)
_tmp_92.type = type ? Constants.ChannelTypes[type.toUpperCase()] : "text"
const voiceState = this._rawVoiceStates.get(member.user.id)
member.serverMute = voiceState.mute
this.client.channels.get(voiceState.channel_id).members.set(member.user.id, member)
this.client.emit(Constants.Events.GUILD_MEMBER_ADD, member)
const member = this.members.get(user)
member && member.speaking !== speaking
this.client.emit(Constants.Events.GUILD_MEMBER_SPEAKING, member, speaking)
