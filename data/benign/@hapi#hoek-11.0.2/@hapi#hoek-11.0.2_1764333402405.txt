internals.getSharedType = function (obj, ref, checkPrototype) {

    if (checkPrototype) {
        if (Object.getPrototypeOf(obj) !== Object.getPrototypeOf(ref)) {
            return internals.mismatched;
        }

        return Types.getInternalProto(obj);
    }

    const type = Types.getInternalProto(obj);
    if (type !== Types.getInternalProto(ref)) {
        return internals.mismatched;
    }

    return type;
}
const type = Types.getInternalProto(obj)
type !== Types.getInternalProto(ref)
map.set(value, { allowed: 1, hits: 0 })
internals.array(keys, values, options)
const ref2 = new Set(Set.prototype.values.call(ref))
const symbols = Object.getOwnPropertySymbols(values).filter((sym) => values.propertyIsEnumerable(sym))
const targets = [...Object.keys(values), ...symbols]
_iterator_5 = <operator>.iterator(keys)
isDeepEqual(objEntry, refEntry, options, seen)
ref2.delete(refEntry)
const existing = map.get(value)
const valueOfRef = valueOf(ref)
(obj !== valueOfObj || ref !== valueOfRef) &&
        !isDeepEqual(valueOfObj, valueOfRef, options, seen)
!isDeepEqual(valueOfObj, valueOfRef, options, seen)
const objKeys = keys(obj)
objKeys.length !== keys(ref).length
_iterator_6 = <operator>.iterator(objKeys)
options.skip &&
            options.skip.includes(key)
(_tmp_16 = options.skip).includes
!hasOwnEnumerableProperty(ref, key)
!isDeepEqual(obj[key], ref[key], options, seen)
objKeys.length - skipped !== keys(ref).length
const objSymbols = getOwnPropertySymbols(obj)
_iterator_7 = <operator>.iterator(objSymbols)
!options.skip?.includes(key)
refSymbols.delete(key)
