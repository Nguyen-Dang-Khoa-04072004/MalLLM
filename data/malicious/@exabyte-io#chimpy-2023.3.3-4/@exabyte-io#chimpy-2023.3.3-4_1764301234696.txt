(_tmp_1 = new Fiber(function runJasmineInFiber() {
  const projectDir = process.env.PWD;
  const testsDir = process.env['chimp.path'];
  process.chdir(testsDir);

  const Jasmine = require('jasmine');
  const jasmine = new Jasmine();

  // Capability to add multiple spec filters
  const specFilters = [];
  jasmine.env.specFilter = function shouldRunSpec(spec) {
    return _.every(specFilters, specFilter => specFilter(spec));
  };

  jasmine.jasmine.addSpecFilter = function addSpecFilter(filterFn) {
    specFilters.push(filterFn);
  };

  if (parseBoolean(process.env['chimp.watch'])) {
    // Only run specs with a watch tag in watch mode
    const watchedSpecRegExp = new RegExp(
      parseString(process.env['chimp.watchTags']).split(',').map(escapeRegExp).join('|')
    );
    jasmine.jasmine.addSpecFilter((spec) => watchedSpecRegExp.test(spec.getFullName()));
  }

  // Capability to capture screenshots
  jasmine.jasmine.getEnv().addReporter({
    specDone: function(result) {
      if (screens...).run
function SessionManagerFactory = function SessionManagerFactory(options) {

	  log.debug('[chimp][session-manager-factory] options are', options);

	  if (!options) {
		  throw new Error('options is required');
	}

	  if (!options.port) {
		  throw new Error('options.port is required');
	}

	  if (!options.browser && !options.deviceName) {
		  throw new Error('[chimp][session-manager-factory] options.browser or options.deviceName is required');
	}

	  if (options.host && (options.host.indexOf('browserstack') > -1 || options.host.indexOf('saucelabs') > -1 || options.host.indexOf('testingbot') > -1)) {

		  if (!options.user || !options.key) {
			  throw new Error('[chimp][session-manager-factory] options.user and options.key are required');
		}

		  if (options.host.indexOf('browserstack') > -1) {
			  return new BsManager(options);
		} else if (options.host.indexOf('saucelabs') > -1) {
			  return new SlManager(options);
		} else if (options.host.indexOf('testingbot') > -1) {
			  return new TbManager(options);
		}...
[
    'it', 'xit', 'fit',
    'beforeEach', 'afterEach',
    'beforeAll', 'afterAll',
  ].forEach(function (method) {
    const original = context[method];
    context[method] = _.wrap(original, function (fn) {
      const args = Array.prototype.slice.call(arguments, 1);
      if (_.isFunction(_.last(args))) {
        args.push(fiberize(args.pop()));
      }
      return fn.apply(this, args);
    });
  })
SimianReporter.prototype.report = function report(jsonCucumberResult, callback) {
  SimianReporter.reportCallback = callback;
  const query = {
    accessToken: this.options.simianAccessToken,
  };
  if (this.options.simianRepositoryId) {
    query.repositoryId = this.options.simianRepositoryId;
  }
  const url = require('url').format({
    protocol: 'http',
    host: this.options.simianResultEndPoint,
    query,
  });

  const data = {
    type: 'cucumber',
    branch: this.options.simianResultBranch,
    result: jsonCucumberResult,
  };
  if (this.options.simianBuildNumber) {
    data.buildNumber = parseInt(this.options.simianBuildNumber, 10);
  }

  request.post(
    {
      url,
      json: true,
      body: data,
    },
    (error, response, body) => {
      if (!error && response.statusCode === 200) {
        log.debug('[chimp][simian-reporter]', 'received data', body);
      } else {
        if (body) {
          log.error('[chimp][simian-reporter] Error from Simian:', body.e...
var argv = minimist(process.argv, {
  default: optionsLoader.getOptions(),
  boolean: [
    // - - - - CHIMP - - - -
    'watch',
    'watchWithPolling',
    'server',
    'sync',
    'offline',

    // - - - - CUCUMBER - - - -
    'singleSnippetPerFile',
    'chai',
    'screenshotsOnError',
    'captureAllStepScreenshots',
    'saveScreenshotsToDisk',
    'saveScreenshotsToReport',

    // - - - - SELENIUM  - - - -

    // - - - - WEBDRIVER-IO  - - - -

    // - - - - SESSION-MANAGER  - - - -
    'noSessionReuse',

    // - - - - SIMIAN  - - - -

    // - - - - MOCHA  - - - -
    'mocha',

    // - - - - METEOR  - - - -

    // - - - - DEBUGGING  - - - -
    'debug',
  ],
})
ddpHost.indexOf('http://') === -1 && ddpHost.indexOf('https://') === -1
var chimpHelper = {
  loadAssertionLibrary: function () {
    if (booleanHelper.isTruthy(process.env['chimp.chai'])) {
      log.debug('[chimp][helper] Using the chai-expect assertion library');
      chai.use(chaiAsPromised);
      chai.should();
      // give users access to the chai instance
      global.chai = chai;
      global.expect = chai.expect;
      global.assert = chai.assert;
    } else {
      log.debug('[chimp][helper] Using the jasmine-expect assertion library');
      global.expect = require('xolvio-jasmine-expect').expect;
    }
  },

  setupGlobals: function () {
    global.wrapAsync = wrapAsync;
    global.wrapAsyncObject = wrapAsyncObject;

    // give users access the request module
    global.request = request;
    _.extend(global, wrapAsyncObject(global, ['request'], {
      syncByDefault: booleanHelper.isTruthy(process.env['chimp.sync'])
    }));

    // Give the user access to Promise functions. E.g. Promise.all.
    global.Promise = Promise;

    if (booleanHe...
function getProgram = function getProgram() {
    var program = new Command(path.basename(argv[1]));

    program
      .usage('[options] [<DIR|FILE[:LINE]>...]')
      .version(Cucumber.VERSION, '-v, --version')
      .option('-b, --backtrace', 'show full backtrace for errors')
      .option('--compiler <EXTENSION:MODULE>', 'require files with the given EXTENSION after requiring MODULE (repeatable)', collect, [])
      .option('-d, --dry-run', 'invoke formatters without executing steps')
      .option('--fail-fast', 'abort the run on first failure')
      .option('-f, --format <TYPE[:PATH]>', 'specify the output format, optionally supply PATH to redirect formatter output (repeatable)', collect, ['pretty'])
      .option('--name <REGEXP>', 'only execute the scenarios with name matching the expression (repeatable)', collect, [])
      .option('--no-colors', 'disable colors in formatter output')
      .option('--no-snippets', 'hide step definition snippets for pending steps')
      .option('--no-source', '...
const url = require('url').format({
    protocol: 'http',
    host: this.options.simianResultEndPoint,
    query,
  })
log.debug('[chimp][browserstack-session-manager] created a new SessionManager', options)
this.StepResult((stepResult) => { // eslint-disable-line new-cap
    lastStep = stepResult.getStep();
    if (screenshotHelper.shouldTakeScreenshot(stepResult.getStatus())) {
      log.debug('[chimp][hooks] capturing screenshot');
      if (booleanHelper.isTruthy(process.env['chimp.saveScreenshotsToReport'])) {
        const screenshotId = lastStep.getUri() + ':' + lastStep.getLine();
        // noinspection JSUnresolvedFunction
        screenshots[screenshotId] = {
          keyword: lastStep.getKeyword(),
          name: lastStep.getName(),
          uri: lastStep.getUri(),
          line: lastStep.getLine(),
          png: global.browser.screenshot().value,
        };
      }

      if (booleanHelper.isTruthy(process.env['chimp.saveScreenshotsToDisk'])) {
        const affix = stepResult.getStatus() !== 'passed' ? ' (failed)' : '';
        // noinspection JSUnresolvedFunction
        const fileName = lastStep.getKeyword() + ' ' + lastStep.getName() + affix;
        screenshotHelp...
var fullArgs = argv.slice(0, 2).concat(profileArgs).concat(argv.slice(2))
