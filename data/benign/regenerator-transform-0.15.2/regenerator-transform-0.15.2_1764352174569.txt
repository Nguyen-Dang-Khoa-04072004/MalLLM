self.jumpIfNot(self.explodeExpression(path.get("test")), after)
path.get("body").map(
      self.explodeStatement,
      self
    )
_tmp_28 = __ecma.Array.factory()
self.jumpIf(self.explodeExpression(path.get("test")), first)
throw new Error(
      node.type + " nodes should be handled by their parents");
self.explode(path.get("init"), true)
new Error(
    "all declarations should have been transformed into " +
    "assignments before the Exploder began its work: " +
    JSON.stringify(node))
self.jumpIfNot(self.explodeExpression(path.get("test")), after)
self.mark(update)
self.explode(path.get("update"), true)
t.assertIdentifier(labelId)
self.mark(after)
self.emitAssign(keyIterNextFn, t.callExpression(util.runtimeProperty("keys"), [self.explodeExpression(path.get("right"))]))
self.mark(head)
var keyInfoTmpVar = self.makeTempVar()
self.jumpIf(t.memberExpression(t.assignmentExpression("=", keyInfoTmpVar, t.callExpression(t.cloneDeep(keyIterNextFn), [])), t.identifier("done"), false), after)
self.emitAssign(stmt.left, t.memberExpression(t.cloneDeep(keyInfoTmpVar), t.identifier("value"), false))
self.jump(head)
self.mark(after)
var disc = self.emitAssign(self.makeTempVar(), self.explodeExpression(path.get("discriminant")))
condition = t.conditionalExpression(t.binaryExpression("===", t.cloneDeep(disc), c.test), caseLocs[i] = this.loc(), condition)
self.leapManager.withEntry(
      new leap.LabeledEntry(after, stmt.label),
      function() {
        self.explodeStatement(path.get("body"), stmt.label);
      }
    )
util.replaceWithOrRemove(discriminant, condition)
self.jump(self.explodeExpression(discriminant))
before = this.loc()
self.jumpIfNot(self.explodeExpression(path.get("test")), after)
self.jumpIfNot(self.explodeExpression(path.get("test")), elseLoc || after)
self.explodeStatement(path.get("consequent"))
self.jump(after)
self.mark(elseLoc)
self.explodeStatement(path.get("alternate"))
let test = this.loc()
throw new Error("WithStatement not supported in generator functions.");
self.mark(after)
self.explodeStatement(path.get("block"))
self.explode(path.get("init"), true)
self.mark(head)
self.jump(finallyLoc)
self.jumpIfNot(self.explodeExpression(path.get("test")), after)
self.jump(after)
self.leapManager.withEntry(
      new leap.LoopEntry(after, update, labelId),
      function() { self.explodeStatement(path.get("body")); }
    )
self.explodeStatement(path.get("body"))
self.clearPendingException(tryEntry.firstLoc, safeParam)
_tmp_62.getSafeParam = getSafeParam
self.leapManager.withEntry(catchEntry, function () {
            self.explodeStatement(bodyPath);
          })
self.jump(head)
self.updateContextPrevLoc(self.mark(finallyLoc))
self.leapManager.withEntry(finallyEntry, function () {
            self.explodeStatement(path.get("finalizer"));
          })
self.emit(t.returnStatement(t.callExpression(self.contextProperty("finish"), [finallyEntry.firstLoc])))
self.emit(t.throwStatement(self.explodeExpression(path.get("argument"))))
self.emitAssign(
      keyIterNextFn,
      t.callExpression(
        util.runtimeProperty("keys"),
        [self.explodeExpression(path.get("right"))]
      )
    )
self.emit(self.explodeClass(path))
t.callExpression(
        util.runtimeProperty("keys"),
        [self.explodeExpression(path.get("right"))]
      )
util.runtimeProperty("keys")
throw new Error("unknown Statement of type " + JSON.stringify(stmt.type));
_tmp_67.Identifier = Identifier
util.replaceWithOrRemove(path, state.getSafeParam())
t.memberExpression(
        t.assignmentExpression(
          "=",
          keyInfoTmpVar,
          t.callExpression(t.cloneDeep(keyIterNextFn), [])
        ),
        t.identifier("done"),
        false
      )
t.assignmentExpression(
          "=",
          keyInfoTmpVar,
          t.callExpression(t.cloneDeep(keyIterNextFn), [])
        )
keyInfoTmpVar
t.identifier("done")
self.emitAssign(
      stmt.left,
      t.memberExpression(
        t.cloneDeep(keyInfoTmpVar),
        t.identifier("value"),
        false
      )
    )
_assert["default"].notStrictEqual(record.type, "normal", "normal completions are not abrupt")
t.memberExpression(
        t.cloneDeep(keyInfoTmpVar),
        t.identifier("value"),
        false
      )
var abruptArgs = [t.stringLiteral(record.type)]
record.type === "break" || record.type === "continue"
self.jump(head)
var type = record.type
let disc = self.emitAssign(
      self.makeTempVar(),
      self.explodeExpression(path.get("discriminant"))
    )
self.makeTempVar()
self.explodeExpression(path.get("discriminant"))
condition = t.conditionalExpression(
          t.binaryExpression("===", t.cloneDeep(disc), c.test),
          caseLocs[i] = this.loc(),
          condition
        )
t.binaryExpression("===", t.cloneDeep(disc), c.test)
let discriminant = path.get("discriminant")
util.replaceWithOrRemove(discriminant, condition)
self.jump(self.explodeExpression(discriminant))
var t = util.getTypes()
self.jumpIfNot(
      self.explodeExpression(path.get("test")),
      elseLoc || after
    )
self.explodeExpression(path.get("test"))
self.explodeStatement(path.get("consequent"))
Ep.explodeExpression = function (path, ignoreResult) {
  var t = util.getTypes();
  var expr = path.node;
  if (expr) {
    t.assertExpression(expr);
  } else {
    return expr;
  }
  var self = this;
  var result; // Used optionally by several cases below.
  var after;
  function finish(expr) {
    t.assertExpression(expr);
    if (ignoreResult) {
      self.emit(expr);
    }
    return expr;
  }

  // If the expression does not contain a leap, then we either emit the
  // expression as a standalone statement or return it whole.
  if (!meta.containsLeap(expr)) {
    return finish(expr);
  }

  // If any child contains a leap (such as a yield or labeled continue or
  // break statement), then any sibling subexpressions will almost
  // certainly have to be exploded in order to maintain the order of their
  // side effects relative to the leaping child(ren).
  var hasLeapingChildren = meta.containsLeap.onlyChildren(expr);

  // If ignoreResult is true, then we must take full responsi...
var t = util.getTypes()
self.explodeStatement(path.get("alternate"))
self.mark(after)
self.explodeStatement(path.get("block"))
self.jump(finallyLoc)
self.jump(after)
self.updateContextPrevLoc(self.mark(catchLoc))
newCallee = self.explodeExpression(calleePath)
self.clearPendingException(tryEntry.firstLoc, safeParam)
self.updateContextPrevLoc(self.mark(finallyLoc))
self.leapManager.withEntry(finallyEntry, function() {
          self.explodeStatement(path.get("finalizer"));
        })
self.emit(t.returnStatement(t.callExpression(
          self.contextProperty("finish"),
          [finallyEntry.firstLoc]
        )))
newArgs = newArgs.map(function (arg) {
          return t.cloneDeep(arg);
        })
_tmp_56.push(finallyEntry.firstLoc)
self.emit(t.throwStatement(
      self.explodeExpression(path.get("argument"))
    ))
finish(t.objectExpression(path.get("properties").map(function (propPath) {
        if (propPath.isObjectProperty()) {
          return t.objectProperty(propPath.node.key, self.explodeViaTempVar(null, propPath.get("value"), hasLeapingChildren), propPath.node.computed);
        } else {
          return propPath.node;
        }
      })))
var arg = expr.argument && self.explodeExpression(path.get("argument"))
arg && expr.delegate
var _ret = t.returnStatement(t.callExpression(self.contextProperty("delegateYield"), [arg, t.stringLiteral(_result.property.name), after]))
self.emit(_ret)
var ret = t.returnStatement(t.cloneDeep(arg) || null)
self.emit(ret)
let arg = expr.argument && self.explodeExpression(path.get("argument"))
arg && expr.delegate
let ret = t.returnStatement(t.callExpression(
        self.contextProperty("delegateYield"),
        [
          arg,
          t.stringLiteral(result.property.name),
          after
        ]
      ))
self.contextProperty("delegateYield")
_tmp_70 = __ecma.Array.factory()
_tmp_70.push(arg)
_tmp_70.push(t.stringLiteral(result.property.name))
_tmp_70.push(after)
self.emit(ret)
let ret = t.returnStatement(t.cloneDeep(arg) || null)
self.emit(ret)
