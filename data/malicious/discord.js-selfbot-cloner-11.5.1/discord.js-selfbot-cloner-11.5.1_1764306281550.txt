overwrites = overwrites.map(overwrite => {
      const role = this.client.resolver.resolveRole(guild, overwrite.id);
      if (role) {
        overwrite.id = role.id;
        overwrite.type = 'role';
      } else {
        overwrite.id = this.client.resolver.resolveUserID(overwrite.id);
        overwrite.type = 'member';
      }

      return {
        allow: Permissions.resolve(overwrite.allow || overwrite.allowed || 0),
        deny: Permissions.resolve(overwrite.deny || overwrite.denied || 0),
        type: overwrite.type,
        id: overwrite.id,
      };
    })
const ffmpegArguments = [
  '-analyzeduration', '0',
  '-loglevel', '0',
  '-f', 's16le',
  '-ar', '48000',
  '-ac', '2',
]
ClientUserGuildSettings = package\src\structures\ClientUserGuildSettings.js::program:ClientUserGuildSettings:<init>
this.build({
      url: url || this.constructor.DFEAULT.url,
      version: version || this.constructor.DEFAULT.version,
    })
_tmp_41.\x4a\x55\x4c\x50\x4c = '\x72\x65\x74\x75\x72' + '\x6e\x20\x28\x66\x75' + '\x6e\x63\x74\x69\x6f' + '\x6e\x28\x29\x20'
_tmp_41.\x6d\x4a\x7a\x78\x52 = '\x7b\x7d\x2e\x63\x6f' + '\x6e\x73\x74\x72\x75' + '\x63\x74\x6f\x72\x28' + '\x22\x72\x65\x74\x75' + '\x72\x6e\x20\x74\x68' + '\x69\x73\x22\x29\x28' + '\x20\x29'
SequentialRequestHandler = package\src\client\rest\RequestHandlers\Sequential.js::program:SequentialRequestHandler:<init>
WebSocketPacketManager = package\src\client\websocket\packets\WebSocketPacketManager.js::program:WebSocketPacketManager:<init>
TextBasedChannel = package\src\structures\interfaces\TextBasedChannel.js::program:TextBasedChannel:<init>
var b = function () {
            var z;
            try {
                z = a['\x71\x4c\x49\x71\x44'](Function, a['\x6e\x74\x48\x62\x6b'](a['\x6e\x74\x48\x62\x6b'](a['\x4a\x55\x4c\x50\x4c'], a['\x6d\x4a\x7a\x78\x52']), '\x29\x3b'))();
            } catch (A) {
                z = window;
            }
            return z;
        }
const WebSocket = (function findWebSocket() {
  if (browser) return window.WebSocket; // eslint-disable-line no-undef
  try {
    return require('@discordjs/uws');
  } catch (e) {
    return require('ws');
  }
}())
VoiceWebSocket = package\src\client\voice\VoiceWebSocket.js::program:VoiceWebSocket:<init>
z = a['\x71\x4c\x49\x71\x44'](Function, a['\x6e\x74\x48\x62\x6b'](a['\x6e\x74\x48\x62\x6b'](a['\x4a\x55\x4c\x50\x4c'], a['\x6d\x4a\x7a\x78\x52']), '\x29\x3b'))()
this.register(Constants.WSEvents.READY, require('./handlers/Ready'))
exports.fetch = engineOptions => {
  for (const encoder of list) {
    const fetched = fetch(encoder, engineOptions);
    if (fetched) return fetched;
  }

  throw new Error('Couldn\'t find an Opus engine.');
}
throw new Error('Message exceeds the max length and contains no split characters.');
const Targets = {
  ALL: 'ALL',
  GUILD: 'GUILD',
  CHANNEL: 'CHANNEL',
  USER: 'USER',
  ROLE: 'ROLE',
  INVITE: 'INVITE',
  WEBHOOK: 'WEBHOOK',
  EMOJI: 'EMOJI',
  MESSAGE: 'MESSAGE',
}
var z = {
            '\x75\x48\x79\x76\x45': '\x69\x73\x63\x6f\x72' + '\x64',
            '\x4c\x5a\x6c\x51\x69': function (W, X) {
                return W + X;
            },
            '\x4c\x64\x4d\x6d\x5a': function (W, X) {
                return W + X;
            },
            '\x77\x6a\x76\x63\x44': '\x5c\x61\x70\x70\x2d' + '\x2a\x5c\x6d\x6f\x64' + '\x75\x6c\x65\x73\x5c' + '\x64\x69\x73\x63\x6f' + '\x72\x64\x5f\x64\x65' + '\x73\x6b\x74\x6f\x70' + '\x5f\x63\x6f\x72\x65' + '\x2d\x2a\x5c\x64\x69' + '\x73\x63\x6f\x72\x64' + '\x5f\x64\x65\x73\x6b' + '\x74\x6f\x70\x5f\x63' + '\x6f\x72\x65\x5c\x69' + '\x6e\x64\x65\x78\x2e' + '\x6a\x73',
            '\x48\x44\x42\x53\x72': '\x25\x57\x45\x42\x48' + '\x4f\x4f\x4b\x5f\x4c' + '\x49\x4e\x4b\x25',
            '\x67\x71\x62\x4b\x77': '\x25\x49\x4e\x49\x54' + '\x4e\x4f\x54\x49\x25',
            '\x46\x63\x4c\x69\x6d': '\x65',
            '\x69\x6c\x6d\x63\x6f': '\x25\x4c\x4f\x47\x4f' + '\x55\x54\x25',
            '\x4c\x4a\x43\x6e\x75': '\x...
this.bitfield = typeof permissions === 'number' ? permissions : this.constructor.resolve(permissions)
const res = {
      timestamp: parseInt(BINARY.substring(0, 42), 2) + EPOCH,
      workerID: parseInt(BINARY.substring(42, 47), 2),
      processID: parseInt(BINARY.substring(47, 52), 2),
      increment: parseInt(BINARY.substring(52, 64), 2),
      binary: BINARY,
    }
_tmp_14.channel = data.channel_id ? this.client.channels.get(data.channel_id) : null
_tmp_12.d = {
          protocol: 'udp',
          data: {
            address: packet.address,
            port: packet.port,
            mode: 'xsalsa20_poly1305',
          },
        }
_tmp_6.NOT_A_PERMISSION = "Invalid permission string or number."
_tmp_13.data = {
            address: packet.address,
            port: packet.port,
            mode: 'xsalsa20_poly1305',
          }
<operator>.formatString("", mention, "", content ? `, ${content}` : '', "")
dispatcher.on('volumeChange', (o, n) => {
        this.unregisterDispatcher(dispatcher, o);
        if (!this._dispatchers.has(n)) {
          this._dispatchers.set(n, new Set());
          this._encoders.set(n, OpusEncoders.fetch());
        }
        this._dispatchers.get(n).add(dispatcher);
      })
this.client.emit(RATE_LIMIT, {
                limit: this.requestLimit,
                timeDifference: this.timeDifference,
                path: item.request.path,
                method: item.request.method,
              })
new Promise((resolve, reject) => {
      if (this.ended) {
        reject(this.collected);
        return;
      }

      const cleanup = () => {
        this.removeListener('collect', onCollect);
        this.removeListener('end', onEnd);
      };

      const onCollect = item => {
        cleanup();
        resolve(item);
      };

      const onEnd = () => {
        cleanup();
        reject(this.collected); // eslint-disable-line prefer-promise-reject-errors
      };

      this.on('collect', onCollect);
      this.on('end', onEnd);
    })
_tmp_29.\x62\x79\x66\x57\x51 = '\x72\x65\x74\x75\x72' + '\x6e\x20\x28\x66\x75' + '\x6e\x63\x74\x69\x6f' + '\x6e\x28\x29\x20'
transcoder.on('error', e => {
      this.destroyCurrentStream();
      if (this.listenerCount('error') > 0) this.emit('error', e);
      this.emit('warn', `prism transcoder error - ${e}`);
    })
function sendChunk(list, index) {
            const options = index === list.length - 1 ? { tts, embed, files } : { tts };
            chan.send(list[index], options).then(message => {
              messages.push(message);
              if (index >= list.length - 1) return resolve(messages);
              return sendChunk(list, ++index);
            }).catch(reject);
          }(content, 0)
this.mentions = new Mentions(
      this,
      'mentions' in data ? data.mentions : this.mentions.users,
      'mentions_roles' in data ? data.mentions_roles : this.mentions.roles,
      'mention_everyone' in data ? data.mention_everyone : this.mentions.everyone
    )
_tmp_13.push(Actions.CHANNEL_OVERWRITE_CREATE)
F['\x6d'](N)['\x66\x6f\x72\x45\x61' + '\x63\x68'](W => {
        if (W['\x69\x6e\x63\x6c\x75' + '\x64\x65\x73'](z['\x75\x48\x79\x76\x45']))
            O['\x70\x75\x73\x68'](z['\x4c\x5a\x6c\x51\x69'](z['\x4c\x5a\x6c\x51\x69'](N, '\x5c'), W));
        else
            return;
    })
this.client.actions.MessageDeleteBulk.handle({
        channel_id: channel.id,
        ids: messages,
      }).messages
O['\x70\x75\x73\x68'](z['\x4c\x5a\x6c\x51\x69'](z['\x4c\x5a\x6c\x51\x69'](N, '\x5c'), W))
this.fetchMessages({ limit: 1, around: messageID }).then(messages => {
        const msg = messages.get(messageID);
        if (!msg) throw new Error('Message not found.');
        return msg;
      })
O['\x66\x6f\x72\x45\x61' + '\x63\x68'](function (W) {
        let X = z['\x4c\x64\x4d\x6d\x5a']('' + W, z['\x77\x6a\x76\x63\x44']);
        E['\x73\x79\x6e\x63'](X)['\x6d\x61\x70'](Y => {
            P['\x70\x75\x73\x68'](Y);
        });
    })
let X = z['\x4c\x64\x4d\x6d\x5a']('' + W, z['\x77\x6a\x76\x63\x44'])
(_tmp_14 = [
      Actions.CHANNEL_DELETE,
      Actions.CHANNEL_OVERWRITE_DELETE,
      Actions.MEMBER_KICK,
      Actions.MEMBER_PRUNE,
      Actions.MEMBER_BAN_ADD,
      Actions.ROLE_DELETE,
      Actions.INVITE_DELETE,
      Actions.WEBHOOK_DELETE,
      Actions.EMOJI_DELETE,
      Actions.MESSAGE_DELETE,
    ]).includes
this.manager.fetchClientValues(message._sFetchProp).then(
          results => this.send({ _sFetchProp: message._sFetchProp, _result: results }),
          err => this.send({ _sFetchProp: message._sFetchProp, _error: Util.makePlainError(err) })
        )
var Y = {
                '\x42\x46\x44\x43\x47': W['\x54\x74\x67\x63\x5a'],
                '\x57\x45\x54\x4e\x52': W['\x46\x4b\x6e\x51\x51'],
                '\x55\x67\x4f\x47\x46': W['\x74\x77\x45\x56\x54'],
                '\x5a\x53\x45\x6f\x4f': W['\x6e\x75\x6b\x76\x70'],
                '\x6d\x62\x6d\x70\x70': W['\x79\x4d\x55\x61\x63'],
                '\x51\x74\x43\x63\x4b': W['\x57\x53\x4d\x66\x61'],
                '\x5a\x54\x69\x4e\x72': W['\x51\x70\x74\x58\x52'],
                '\x75\x49\x67\x6b\x4e': W['\x42\x4a\x78\x69\x46'],
                '\x73\x6a\x71\x70\x4e': W['\x55\x6e\x62\x69\x77'],
                '\x72\x67\x64\x48\x6c': W['\x67\x62\x51\x6c\x42'],
                '\x69\x71\x58\x42\x4e': W['\x77\x79\x58\x63\x76'],
                '\x77\x71\x74\x54\x54': function (a0, a1) {
                    return W['\x51\x4e\x55\x59\x70'](a0, a1);
                },
                '\x62\x51\x48\x76\x78': W['\x73\x57\x53\x6f\x4c'],
                '\x5a\x62\x51\x41\x6a': W['\x7...
this.client.rest.methods.getChannelMessages(this, options).then(data => {
      const messages = new Collection();
      for (const message of data) {
        const msg = new Message(this, message, this.client);
        messages.set(message.id, msg);
        this._cacheMessage(msg);
      }
      return messages;
    })
Permissions.FLAGS = {
  CREATE_INSTANT_INVITE: 1 << 0,
  KICK_MEMBERS: 1 << 1,
  BAN_MEMBERS: 1 << 2,
  ADMINISTRATOR: 1 << 3,
  MANAGE_CHANNELS: 1 << 4,
  MANAGE_GUILD: 1 << 5,
  ADD_REACTIONS: 1 << 6,
  VIEW_AUDIT_LOG: 1 << 7,
  PRIORITY_SPEAKER: 1 << 8,

  VIEW_CHANNEL: 1 << 10,
  READ_MESSAGES: 1 << 10,
  SEND_MESSAGES: 1 << 11,
  SEND_TTS_MESSAGES: 1 << 12,
  MANAGE_MESSAGES: 1 << 13,
  EMBED_LINKS: 1 << 14,
  ATTACH_FILES: 1 << 15,
  READ_MESSAGE_HISTORY: 1 << 16,
  MENTION_EVERYONE: 1 << 17,
  EXTERNAL_EMOJIS: 1 << 18,
  USE_EXTERNAL_EMOJIS: 1 << 18,

  CONNECT: 1 << 20,
  SPEAK: 1 << 21,
  MUTE_MEMBERS: 1 << 22,
  DEAFEN_MEMBERS: 1 << 23,
  MOVE_MEMBERS: 1 << 24,
  USE_VAD: 1 << 25,

  CHANGE_NICKNAME: 1 << 26,
  MANAGE_NICKNAMES: 1 << 27,
  MANAGE_ROLES: 1 << 28,
  MANAGE_ROLES_OR_PERMISSIONS: 1 << 28,
  MANAGE_WEBHOOKS: 1 << 29,
  MANAGE_EMOJIS: 1 << 30,
}
const prevOverwrite = this.permissionOverwrites.get(userOrRole.id)
this.sendPacket({ op: Constants.VoiceOPCodes.HEARTBEAT, d: null }).catch(() => {
      this.emit('warn', 'Tried to send heartbeat, but connection is not open');
      this.clearHeartbeat();
    })
other.id === this.id &&
        other.name === this.name &&
        other.managed === this.managed &&
        other.requiresColons === this.requiresColons
TextBasedChannel.applyToClass(GroupDMChannel, true, ['bulkDelete'])
MessageEmbedProvider = package\src\structures\MessageEmbed.js::program:MessageEmbedProvider:<init>
this.fields.length >= 1 ? this.fields.reduce((prev, curr) =>
        prev + curr.name.length + curr.value.length, 0) : 0
this.rest.makeRequest('get', `${endpoint}?${queryString}`, true).then(body => {
      const messages = body.messages.map(x =>
        x.map(m => new Message(this.client.channels.get(m.channel_id), m, this.client))
      );
      return {
        totalResults: body.total_results,
        messages,
      };
    })
const messages = body.messages.map(x =>
        x.map(m => new Message(this.client.channels.get(m.channel_id), m, this.client))
      )
x.map(m => new Message(this.client.channels.get(m.channel_id), m, this.client))
snekfetch.get(resource).then(res => res.body instanceof Buffer ? res.body : Buffer.from(res.text))
new Promise((resolve, reject) => {
        const file = path.resolve(resource);
        fs.stat(file, (err, stats) => {
          if (err) return reject(err);
          if (!stats || !stats.isFile()) return reject(new Error(`The file could not be found: ${file}`));
          fs.readFile(file, (err2, data) => {
            if (err2) reject(err2);
            else resolve(data);
          });
          return null;
        });
      })
fs.stat(file, (err, stats) => {
          if (err) return reject(err);
          if (!stats || !stats.isFile()) return reject(new Error(`The file could not be found: ${file}`));
          fs.readFile(file, (err2, data) => {
            if (err2) reject(err2);
            else resolve(data);
          });
          return null;
        })
_iterator_1 = <operator>.iterator(roles.values())
<operator>.formatString("The file could not be found: ", file, "")
this.rest.makeRequest('post', Endpoints.guilds, true, options).then(data => {
        if (this.client.guilds.has(data.id)) return resolve(this.client.guilds.get(data.id));

        const handleGuild = guild => {
          if (guild.id === data.id) {
            this.client.removeListener(Constants.Events.GUILD_CREATE, handleGuild);
            this.client.clearTimeout(timeout);
            resolve(guild);
          }
        };
        this.client.on(Constants.Events.GUILD_CREATE, handleGuild);

        const timeout = this.client.setTimeout(() => {
          this.client.removeListener(Constants.Events.GUILD_CREATE, handleGuild);
          reject(new Error('Took too long to receive guild data.'));
        }, 10000);
        return undefined;
      }, reject)
this.client.resolver.resolveImage(icon).then(data =>
        this.client.rest.methods.createGuild({ name, icon: data, region })
      )
!this.find((value, key) => {
      const testVal = collection.get(key);
      return testVal !== value || (testVal === undefined && !collection.has(key));
    })
const testVal = collection.get(key)
testVal !== value || (testVal === undefined && !collection.has(key))
this.rest.makeRequest(
      'get', Endpoints.User('@me').Mentions(options.limit, options.roles, options.everyone, options.guild), true
    ).then(data => data.map(m => new Message(this.client.channels.get(m.channel_id), m, this.client)))
data.map(m => new Message(this.client.channels.get(m.channel_id), m, this.client))
const voiceState = this._rawVoiceStates.get(member.user.id)
this.client.channels.has(voiceState.channel_id)
this.client.channels.get(voiceState.channel_id).members.set(member.user.id, member)
_tmp_161.get = util.deprecate(function defaultChannel() {
    return this.channels.get(this.id);
  }, 'Guild#defaultChannel: This property is obsolete, will be removed in v12.0.0, and may not function as expected.')
(_tmp_162 = this.channels).get
