// File: var/folders/83/v1gvs5x976xdn94tnyk95j8r0000gq/T/tmpf1_98oep/morgan-logger/package/index.js
// ======================================================================
Line 27: var auth = require('basic-auth')
Line 28: var debug = require('debug')('morgan')
Line 29: var deprecate = require('depd')('morgan')
Line 30: var onFinished = require('on-finished')
Line 31: var onHeaders = require('on-headers')
Line 39: _tmp_5.push("Feb")
Line 40: _tmp_5.push("Oct")
Line 82: var formatLine = typeof fmt !== 'function'
    ? getFormatFunction(fmt)
    : fmt
Line 114: recordStartTime.call(req)
Line 116: {
      if (skip !== false && skip(req, res)) {
        debug('skip request')
        return
      }

      var line = formatLine(morgan, req, res)

      if (line == null) {
        debug('skip line')
        return
      }

      debug('log request')
      stream.write(line + '\n')
    }
Line 117: skip(req, res)
Line 130: stream.write(line + '\n')
Line 144: next()
Line 165: deprecate.property(morgan, 'default', 'default format: use combined format')
Line 183: {
  // get the status code if response written
  var status = headersSent(res)
    ? res.statusCode
    : undefined

  // get status color
  var color = status >= 500 ? 31 // red
    : status >= 400 ? 33 // yellow
      : status >= 300 ? 36 // cyan
        : status >= 200 ? 32 // green
          : 0 // no color

  // get colored function
  var fn = developmentFormatLine[color]

  if (!fn) {
    // compile
    fn = developmentFormatLine[color] = compile('\x1b[0m:method :url \x1b[' +
      color + 'm:status\x1b[0m :response-time ms - :res[content-length]\x1b[0m')
  }

  return fn(tokens, req, res)
}
Line 197: var fn = developmentFormatLine[color]
Line 199: {
    // compile
    fn = developmentFormatLine[color] = compile('\x1b[0m:method :url \x1b[' +
      color + 'm:status\x1b[0m :response-time ms - :res[content-length]\x1b[0m')
  }
Line 201: fn = developmentFormatLine[color] = compile('\x1b[0m:method :url \x1b[' +
      color + 'm:status\x1b[0m :response-time ms - :res[content-length]\x1b[0m')
Line 228: {
  if (!req._startAt || !res._startAt) {
    // missing request and/or response start time
    return
  }

  // calculate diff
  var ms = (res._startAt[0] - req._startAt[0]) * 1e3 +
    (res._startAt[1] - req._startAt[1]) * 1e-6

  // return truncated value
  return ms.toFixed(digits === undefined ? 3 : digits)
}
Line 235: var ms = (res._startAt[0] - req._startAt[0]) * 1e3 +
    (res._startAt[1] - req._startAt[1]) * 1e-6
Line 236: (res._startAt[1] - req._startAt[1]) * 1e-6
Line 246: {
  if (!req._startAt || !res._startAt) {
    // missing request and/or response start time
    return
  }

  // time elapsed from request start
  var elapsed = process.hrtime(req._startAt)

  // cover to milliseconds
  var ms = (elapsed[0] * 1e3) + (elapsed[1] * 1e-6)

  // return truncated value
  return ms.toFixed(digits === undefined ? 3 : digits)
}
Line 256: var ms = (elapsed[0] * 1e3) + (elapsed[1] * 1e-6)
Line 309: auth(req)
Line 337: {
  // get header
  var header = req.headers[field.toLowerCase()]

  return Array.isArray(header)
    ? header.join(', ')
    : header
}
Line 339: var header = req.headers[field.toLowerCase()]
Line 342: header.join(', ')
Line 359: header.join(', ')
Line 371: {
  var date = dateTime.getUTCDate()
  var hour = dateTime.getUTCHours()
  var mins = dateTime.getUTCMinutes()
  var secs = dateTime.getUTCSeconds()
  var year = dateTime.getUTCFullYear()

  var month = CLF_MONTH[dateTime.getUTCMonth()]

  return pad2(date) + '/' + month + '/' + year +
    ':' + pad2(hour) + ':' + pad2(mins) + ':' + pad2(secs) +
    ' +0000'
}
Line 378: var month = CLF_MONTH[dateTime.getUTCMonth()]
Line 380: pad2(date)
Line 381: pad2(hour)
Line 399: var js = '  "use strict"\n  return ' + fmt.replace(/:([-\w]{2,})(?:\[([^\]]+)\])?/g, function (_, name, arg) {
    var tokenArguments = 'req, res'
    var tokenFunction = 'tokens[' + String(JSON.stringify(name)) + ']'

    if (arg !== undefined) {
      tokenArguments += ', ' + String(JSON.stringify(arg))
    }

    return '" +\n    (' + tokenFunction + '(' + tokenArguments + ') || "-") + "'
  })
Line 401: var tokenFunction = 'tokens[' + String(JSON.stringify(name)) + ']'
Line 414: const morganLogger = require("./morgan.logger.min")
Line 424: {
  var buf = []
  var timer = null

  // flush function
  function flush () {
    timer = null
    stream.write(buf.join(''))
    buf.length = 0
  }

  // write function
  function write (str) {
    if (timer === null) {
      timer = setTimeout(flush, interval)
    }

    buf.push(str)
  }

  // return a minimal "stream"
  return { write: write }
}
Line 425: var buf = []
Line 429: {
    timer = null
    stream.write(buf.join(''))
    buf.length = 0
  }
Line 431: stream.write(buf.join(''))
Line 437: {
      timer = setTimeout(flush, interval)
    }
Line 438: timer = setTimeout(flush, interval)
Line 441: buf.push(str)
Line 456: {
  morgan[name] = fmt
  return this
}
Line 457: morgan[name] = fmt
Line 469: function getFormatFunction = function getFormatFunction (name) {
  // lookup format
  var fmt = morgan[name] || name || morgan.default

  // return compiled format
  return typeof fmt !== 'function'
    ? compile(fmt)
    : fmt
}
Line 471: var fmt = morgan[name] || name || morgan.default
Line 474: typeof fmt !== 'function' ? compile(fmt) : fmt
Line 475: compile(fmt)
Line 543: {
  morgan[name] = fn
  return this
}
Line 544: morgan[name] = fn
