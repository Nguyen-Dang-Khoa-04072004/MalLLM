type = this.get('Content-Type')
debug('no routes defined on app')
this.set('Content-Type', setCharset(type, 'utf-8'))
var generateETag = !this.get('ETag') && typeof etagFn === 'function'
req.range = function range(size, options) {
  var range = this.get('Range');
  if (!range) return;
  return parseRange(size, range, options);
}
var range = this.get('Range')
this.lazyrouter()
parseRange(size, range, options)
var escape = app.get('json escape')
var replacer = app.get('json replacer')
var spaces = app.get('json spaces')
var body = stringify(val, replacer, spaces, escape)
!this.get('Content-Type')
var escape = app.get('json escape')
var replacer = app.get('json replacer')
var spaces = app.get('json spaces')
var body = stringify(val, replacer, spaces, escape)
defineGetter(req, 'protocol', function protocol(){
  var proto = this.connection.encrypted
    ? 'https'
    : 'http';
  var trust = this.app.get('trust proxy fn');

  if (!trust(this.connection.remoteAddress, 0)) {
    return proto;
  }

  // Note: X-Forwarded-Proto is normally only ever a
  //       single value, but this is to be safe.
  var header = this.get('X-Forwarded-Proto') || proto
  var index = header.indexOf(',')

  return index !== -1
    ? header.substring(0, index).trim()
    : header.trim()
})
var proto = this.connection.encrypted
    ? 'https'
    : 'http'
var trust = this.app.get('trust proxy fn')
!trust(this.connection.remoteAddress, 0)
typeof callback === 'string' && callback.length !== 0
this.set('X-Content-Type-Options', 'nosniff')
app.param = function param(name, fn) {
  this.lazyrouter();

  if (Array.isArray(name)) {
    for (var i = 0; i < name.length; i++) {
      this.param(name[i], fn);
    }

    return this;
  }

  this._router.param(name, fn);

  return this;
}
(_tmp_12 = header.substring(0, index)).trim
defineGetter(req, 'secure', function secure(){
  return this.protocol === 'https';
})
this.protocol === 'https'
defineGetter(req, 'ip', function ip(){
  var trust = this.app.get('trust proxy fn');
  return proxyaddr(this, trust);
})
var trust = this.app.get('trust proxy fn')
proxyaddr(this, trust)
defineGetter(req, 'ips', function ips() {
  var trust = this.app.get('trust proxy fn');
  var addrs = proxyaddr.all(this, trust);

  // reverse the order (to farthest -> closest)
  // and remove socket address
  addrs.reverse().pop()

  return addrs
})
var trust = this.app.get('trust proxy fn')
var addrs = proxyaddr.all(this, trust)
this.set('trust proxy fn', compileTrust(val))
return addrs
defineGetter(req, 'subdomains', function subdomains() {
  var hostname = this.hostname;

  if (!hostname) return [];

  var offset = this.app.get('subdomain offset');
  var subdomains = !isIP(hostname)
    ? hostname.split('.').reverse()
    : [hostname];

  return subdomains.slice(offset);
})
var hostname = this.hostname
__ecma.Array.factory()
var offset = this.app.get('subdomain offset')
var subdomains = !isIP(hostname)
    ? hostname.split('.').reverse()
    : [hostname]
(_tmp_17 = hostname.split('.')).reverse
this.parent.path() + this.mountpath
defineGetter(req, 'path', function path() {
  return parse(this).pathname;
})
defineGetter(req, 'hostname', function hostname(){
  var trust = this.app.get('trust proxy fn');
  var host = this.get('X-Forwarded-Host');

  if (!host || !trust(this.connection.remoteAddress, 0)) {
    host = this.get('Host');
  } else if (host.indexOf(',') !== -1) {
    // Note: X-Forwarded-Host is normally only ever a
    //       single value, but this is to be safe.
    host = host.substring(0, host.indexOf(',')).trimRight()
  }

  if (!host) return;

  // IPv6 literal support
  var offset = host[0] === '['
    ? host.indexOf(']') + 1
    : 0;
  var index = host.indexOf(':', offset);

  return index !== -1
    ? host.substring(0, index)
    : host;
})
var trust = this.app.get('trust proxy fn')
var host = this.get('X-Forwarded-Host')
!host || !trust(this.connection.remoteAddress, 0)
host = this.get('Host')
sendfile(res, file, opts, function (err) {
    if (done) return done(err);
    if (err && err.code === 'EISDIR') return next();

    // next() all but write errors
    if (err && err.code !== 'ECONNABORTED' && err.syscall !== 'write') {
      next(err);
    }
  })
(_tmp_20 = host.substring(0, host.indexOf(','))).trimRight
next(err)
var offset = host[0] === '['
    ? host.indexOf(']') + 1
    : 0
host.indexOf(']') + 1
var index = host.indexOf(':', offset)
index !== -1 ? host.substring(0, index) : host
host.substring(0, index)
defineGetter(req, 'host', deprecate.function(function host(){
  return this.hostname;
}, 'req.host: Use req.hostname instead'))
defineGetter(req, 'fresh', function(){
  var method = this.method;
  var res = this.res
  var status = res.statusCode

  // GET or HEAD for weak freshness validation only
  if ('GET' !== method && 'HEAD' !== method) return false;

  // 2xx or 304 as per rfc2616 14.26
  if ((status >= 200 && status < 300) || 304 === status) {
    return fresh(this.headers, {
      'etag': res.get('ETag'),
      'last-modified': res.get('Last-Modified')
    })
  }

  return false;
})
var res = this.res
fresh(this.headers, {
      'etag': res.get('ETag'),
      'last-modified': res.get('Last-Modified')
    })
_tmp_21.etag = res.get('ETag')
_tmp_21.last-modified = res.get('Last-Modified')
defineGetter(req, 'stale', function stale(){
  return !this.fresh;
})
defineGetter(req, 'xhr', function xhr(){
  var val = this.get('X-Requested-With') || '';
  return val.toLowerCase() === 'xmlhttprequest';
})
err && err.code !== 'ECONNABORTED' && err.syscall !== 'write'
val.toLowerCase() === 'xmlhttprequest'
