perf.inPhase(PerfPhase.Reconciliation, () => {
      const physicallyChangedTsFiles = /* @__PURE__ */ new Set();
      const changedResourceFiles = new Set(modifiedResourceFiles != null ? modifiedResourceFiles : []);
      let priorAnalysis;
      switch (oldState.kind) {
        case IncrementalStateKind.Fresh:
          return IncrementalCompilation.fresh(program, newVersions);
        case IncrementalStateKind.Analyzed:
          priorAnalysis = oldState;
          break;
        case IncrementalStateKind.Delta:
          priorAnalysis = oldState.lastAnalyzedState;
          for (const sfPath of oldState.physicallyChangedTsFiles) {
            physicallyChangedTsFiles.add(sfPath);
          }
          for (const resourcePath of oldState.changedResourceFiles) {
            changedResourceFiles.add(resourcePath);
          }
          break;
      }
      const oldVersions = priorAnalysis.versions;
      const oldFilesArray = oldProgram.getSourceFiles().map(toOriginalSourceFile);
...
const sf = toOriginalSourceFile(possiblyRedirectedNewFile)
const sfPath = absoluteFromSourceFile(sf)
deletedTsFiles.delete(sfPath)
oldVersions === null || newVersions === null
oldVersions.has(sfPath) && newVersions.has(sfPath) && oldVersions.get(sfPath) === newVersions.get(sfPath)
IncrementalCompilation.fresh(program, newVersions)
physicallyChangedTsFiles.add(sfPath)
physicallyChangedTsFiles.delete(resolve(deletedFileName))
const logicallyChangedTsFiles = depGraph.updateWithPhysicalChanges(priorAnalysis.depGraph, physicallyChangedTsFiles, deletedTsFiles, changedResourceFiles)
_iterator_28 = <operator>.iterator(physicallyChangedTsFiles)
_tmp_106.expression = new WrappedNodeExpr(ref.node)
new IncrementalCompilation(state, depGraph, newVersions, {
        priorState: priorAnalysis,
        logicallyChangedTsFiles
      })
_tmp_363.logicallyChangedTsFiles = logicallyChangedTsFiles
result = Promise.resolve(result).then(async (str) => {
        const transformResult = await this.adapter.transformResource(str, resourceContext);
        return transformResult === null ? str : transformResult.content;
      })
const transformResult = await this.adapter.transformResource(str, resourceContext)
const isStandalone = def.type.typeArguments.length > 7 && ((_a = readBooleanType(def.type.typeArguments[7])) != null ? _a : false)
const hostDirectives = def.type.typeArguments.length > 8 ? readHostDirectivesType(this.checker, def.type.typeArguments[8], ref.bestGuessOwningModule) : null
const fetchCompletion = result.then((str) => {
        this.fetching.delete(resolvedUrl);
        this.cache.set(resolvedUrl, str);
      })
this.fetching.delete(resolvedUrl)
_tmp_464.selector = readStringType(def.type.typeArguments[1])
const resourceUrl = this.resourceLoader.resolve(styleUrl.url, containingFile)
const resourceStr = this.resourceLoader.load(resourceUrl)
this.depTracker.addResourceDependency(node.getSourceFile(), absoluteFrom(resourceUrl))
const selectorError = checkCustomElementSelectorForErrors(metadata.selector)
<operator>.formatString(" For example, '", expectedKey, "="", expectedValue, ""'.")
diagnostics.push(makeDiagnostic(ErrorCode.COMPONENT_INVALID_SHADOW_DOM_SELECTOR, component.get("selector"), selectorError))
_tmp_1367.name = ExtendedTemplateDiagnosticName.TEXT_ATTRIBUTE_NOT_BINDING
(_tmp_1020 = this.preanalyzeStylesCache).delete
