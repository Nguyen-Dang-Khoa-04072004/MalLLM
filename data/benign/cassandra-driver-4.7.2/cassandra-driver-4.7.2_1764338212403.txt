const message = {
      metadata: {
        name: 'driver.startup',
        insightMappingId: 'v1',
        insightType: 'EVENT',
        timestamp: Date.now(),
        tags: { language: 'nodejs' }
      },
      data: {
        driverName: packageInfo.description,
        driverVersion: packageInfo.version,
        clientId: options.id,
        sessionId: this._sessionId,
        applicationName: appInfo.applicationName,
        applicationVersion: appInfo.applicationVersion,
        applicationNameWasGenerated: appInfo.applicationNameWasGenerated,
        contactPoints: mapToObject(cc.getResolvedContactPoints()),
        dataCenters: this._getDataCenters(),
        initialControlConnection: cc.host ? cc.host.address : undefined,
        protocolVersion: cc.protocolVersion,
        localAddress: cc.getLocalAddress(),
        hostName: os.hostname(),
        executionProfiles: getExecutionProfiles(this._client),
        poolSizeByHostDistance: {
          local: options.pooling.coreConnec...
function validatePoliciesOptions = function validatePoliciesOptions(policiesOptions) {
  if (!policiesOptions) {
    throw new TypeError('policies not defined in options');
  }
  if (!(policiesOptions.loadBalancing instanceof policies.loadBalancing.LoadBalancingPolicy)) {
    throw new TypeError('Load balancing policy must be an instance of LoadBalancingPolicy');
  }
  if (!(policiesOptions.reconnection instanceof policies.reconnection.ReconnectionPolicy)) {
    throw new TypeError('Reconnection policy must be an instance of ReconnectionPolicy');
  }
  if (!(policiesOptions.retry instanceof policies.retry.RetryPolicy)) {
    throw new TypeError('Retry policy must be an instance of RetryPolicy');
  }
  if (!(policiesOptions.addressResolution instanceof policies.addressResolution.AddressTranslator)) {
    throw new TypeError('Address resolution policy must be an instance of AddressTranslator');
  }
  if (policiesOptions.timestampGeneration !== null &&
    !(policiesOptions.timestampGeneration instanceof policies.timest...
_tmp_31.platformInfo = {
          os: {
            name: os.platform(),
            version: os.release(),
            arch: os.arch()
          },
          cpus: {
            length: os.cpus().length,
            model: os.cpus()[0].model
          },
          runtime: {
            node: process.versions['node'],
            v8: process.versions['v8'],
            uv: process.versions['uv'],
            openssl: process.versions['openssl'],
            kerberos: kerberosModule ? kerberosModule.version : undefined
          }
        }
function validateSocketOptions = function validateSocketOptions(socketOptions) {
  if (!socketOptions) {
    throw new TypeError('socketOptions not defined in options');
  }
  if (typeof socketOptions.readTimeout !== 'number') {
    throw new TypeError('socketOptions.readTimeout must be a Number');
  }
  if (typeof socketOptions.coalescingThreshold !== 'number' || socketOptions.coalescingThreshold <= 0) {
    throw new TypeError('socketOptions.coalescingThreshold must be a positive Number');
  }
}
<operator>.formatString("Connection to ", connection.endpointFriendlyName, " used by the ControlConnection was closed")
throw new errors.DriverInternalError('Following chunks can not have an offset greater than zero');
invalidProtocol = (err instanceof errors.ResponseError &&
            err.code === types.responseErrorCodes.serverError &&
            err.message.indexOf('ProtocolException: Invalid or unsupported protocol version') > 0)
this._defaultProfile.loadBalancing = this._defaultProfile.loadBalancing || options.policies.loadBalancing
type.info = {
          keyspace: this.readString(),
          name: this.readString(),
          fields: new Array(this.readShort())
        }
