_regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return connection.getMinimumBalanceForRentExemption(data.length);
            case 2:
              balanceNeeded = _context.sent;
              _context.next = 5;
              return connection.getAccountInfo(program.publicKey, 'confirmed');
            case 5:
              programInfo = _context.sent;
              transaction = null;
              if (!(programInfo !== null)) {
                _context.next = 16;
                break;
              }
              if (!programInfo.executable) {
                _context.next = 11;
                break;
              }
              console.error('Program load failed, account is already executable');
              return _context.abrupt("return", false);
            case 11:
              if (programInfo.data.length !== data.length) {
             ...
var _load = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(connection, payer, program, programId, data) {
        var balanceNeeded, programInfo, transaction, dataLayout, chunkSize, offset, array, transactions, bytes, _data, _transaction, REQUESTS_PER_SECOND, _dataLayout, _data2, _transaction2, deployCommitment, finalizeSignature, _yield$connection$con, context, value, currentSlot;
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return connection.getMinimumBalanceForRentExemption(data.length);
            case 2:
              balanceNeeded = _context.sent;
              _context.next = 5;
              return connection.getAccountInfo(program.publicKey, 'confirmed');
            case 5:
              programInfo = _context.sent;
              transaction = null;
              if (!(programInfo !== null)) {
     ...
_regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return connection.getMinimumBalanceForRentExemption(data.length);
            case 2:
              balanceNeeded = _context.sent;
              _context.next = 5;
              return connection.getAccountInfo(program.publicKey, 'confirmed');
            case 5:
              programInfo = _context.sent;
              transaction = null;
              if (!(programInfo !== null)) {
                _context.next = 16;
                break;
              }
              if (!programInfo.executable) {
                _context.next = 11;
                break;
              }
              console.error('Program load failed, account is already executable');
              return _context.abrupt("return", false);
            case 11:
              if (programInfo.data.length !== data.length) {
             ...
_regeneratorRuntime__default.default.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return connection.getMinimumBalanceForRentExemption(data.length);
            case 2:
              balanceNeeded = _context.sent;
              _context.next = 5;
              return connection.getAccountInfo(program.publicKey, 'confirmed');
            case 5:
              programInfo = _context.sent;
              transaction = null;
              if (!(programInfo !== null)) {
                _context.next = 16;
                break;
              }
              if (!programInfo.executable) {
                _context.next = 11;
                break;
              }
              console.error('Program load failed, account is already executable');
              return _context.abrupt("return", false);
            case 11:
              if (programInfo.data.length !== data.length...
connection.confirmTransaction({
                signature: finalizeSignature,
                lastValidBlockHeight: _transaction2.lastValidBlockHeight,
                blockhash: _transaction2.recentBlockhash
              }, deployCommitment)
function invert = function invert(number, modulo) {
      if (number === _0n$7 || modulo <= _0n$7) {
          throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);
      }
      // Eucledian GCD https://brilliant.org/wiki/extended-euclidean-algorithm/
      // Fermat's little theorem "CT-like" version inv(n) = n^(m-2) mod m is 30x slower.
      let a = mod(number, modulo);
      let b = modulo;
      // prettier-ignore
      let x = _0n$7, u = _1n$7;
      while (a !== _0n$7) {
          // JIT applies optimization if those two lines follow each other
          const q = b / a;
          const r = b % a;
          const m = x - u * q;
          // prettier-ignore
          b = a, a = r, x = u, u = m;
      }
      const gcd = b;
      if (gcd !== _1n$7)
          throw new Error('invert: does not exist');
      return mod(x, modulo);
  }
_tmp_877.blockhash = _transaction2.recentBlockhash
throw new Error("Transaction ".concat(finalizeSignature, " failed (").concat(JSON.stringify(value), ")"));
resolve({
              __type: TransactionStatus.PROCESSED,
              response: {
                context,
                value,
              },
            })
new Promise(function (resolve) {
                return setTimeout(resolve, Math.round(MS_PER_SLOT / 2));
              })
connection.sendTransaction(_transaction2, [payer, program], {
                preflightCommitment: deployCommitment
              })
new Promise(function (resolve) {
                return setTimeout(resolve, Math.round(MS_PER_SLOT / 2));
              })
connection.confirmTransaction({
                signature: finalizeSignature,
                lastValidBlockHeight: _transaction2.lastValidBlockHeight,
                blockhash: _transaction2.recentBlockhash
              }, deployCommitment)
_yield$connection$con = _context.sent
value = _yield$connection$con.value
const p1div4 = (P + _1n$7) / _4n$1
const expiryPromise = new Promise<{
      __type: TransactionStatus.BLOCKHEIGHT_EXCEEDED;
    }>(resolve => {
      const checkBlockHeight = async () => {
        try {
          const blockHeight = await this.getBlockHeight(commitment);
          return blockHeight;
        } catch (_e) {
          return -1;
        }
      };
      (async () => {
        let currentBlockHeight = await checkBlockHeight();
        if (done) return;
        while (currentBlockHeight <= lastValidBlockHeight) {
          await sleep(1000);
          if (done) return;
          currentBlockHeight = await checkBlockHeight();
          if (done) return;
        }
        resolve({__type: TransactionStatus.BLOCKHEIGHT_EXCEEDED});
      })();
    })
function load = function load(_x, _x2, _x3, _x4, _x5) {
        return _load.apply(this, arguments);
      }
new Promise(function (resolve) {
                return setTimeout(resolve, Math.round(MS_PER_SLOT / 2));
              })
const cancellationPromise = this.getCancellationPromise(abortSignal)
_regeneratorRuntime().wrap(function _callee$(_context) {
            while (1) switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return connection.getMinimumBalanceForRentExemption(data.length);
              case 2:
                balanceNeeded = _context.sent;
                _context.next = 5;
                return connection.getAccountInfo(program.publicKey, 'confirmed');
              case 5:
                programInfo = _context.sent;
                transaction = null;
                if (!(programInfo !== null)) {
                  _context.next = 16;
                  break;
                }
                if (!programInfo.executable) {
                  _context.next = 11;
                  break;
                }
                console.error('Program load failed, account is already executable');
                return _context.abrupt("return", false);
              case 11:
                if (programI...
_yield$connection$con = _context.sent
value = _yield$connection$con.value
!value.err
throw new Error("Transaction ".concat(finalizeSignature, " failed (").concat(JSON.stringify(value), ")"));
new Promise(function (resolve) {
                  return setTimeout(resolve, Math.round(MS_PER_SLOT / 2));
                })
setTimeout(resolve, Math.round(MS_PER_SLOT / 2))
_tmp_2081 = __ecma.Array.factory()
