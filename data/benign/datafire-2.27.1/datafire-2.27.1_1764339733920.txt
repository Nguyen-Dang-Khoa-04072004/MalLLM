let Flow = module.exports = function(context) {
  context = context || new Context();
  let nextResultIdx = -1;
  let results = {};

  function wrapPromise(promise, resultName) {
    let then = promise.then.bind(promise);
    promise.then = function(fn, reject) {
      let params = fn ? getParameterNames(fn) : [];
      let fnWrapper = function(result) {
        if (nextResultIdx >= 0) {
          results[nextResultIdx++] = result;
          if (params[0]) results[params[0]] = result;
        } else {
          ++nextResultIdx;
        }
        context.results = results;
        if (fn) {
          return fn(result);
        }
      }
      let newPromise = then(fnWrapper, reject);
      return wrapPromise(newPromise);
    }
    return promise;
  }

  return wrapPromise(Promise.resolve());
}
var Flow = module.exports = function (context) {
  context = context || new Context();
  var nextResultIdx = -1;
  var results = {};

  function wrapPromise(promise, resultName) {
    var then = promise.then.bind(promise);
    promise.then = function (fn, reject) {
      var params = fn ? getParameterNames(fn) : [];
      var fnWrapper = function fnWrapper(result) {
        if (nextResultIdx >= 0) {
          results[nextResultIdx++] = result;
          if (params[0]) results[params[0]] = result;
        } else {
          ++nextResultIdx;
        }
        context.results = results;
        if (fn) {
          return fn(result);
        }
      };
      var newPromise = then(fnWrapper, reject);
      return wrapPromise(newPromise);
    };
    return promise;
  }

  return wrapPromise(Promise.resolve());
}
new Promise((resolve, reject) => {
    if (args.all) {
      getAllIntegrations((err, list) => {
        if (err) return reject(err);
        let keys = Object.keys(list);
        keys.forEach(k => {
          let api = list[k];
          if (args.query && !integrationMatchesQuery(k, api, args.query)) return;
          logger.logIntegration(k, {info: api});
          logger.log();
        });
        resolve();
      });
    } else {
      INTEGRATION_LOCATIONS.forEach(dir => {
        fs.readdir(dir, (err, dirs) => {
          if (err) {
            if (err.code === 'ENOENT') return;
            return reject(err);
          }
          dirs.forEach(name => {
            logger.log(chalk.magenta(name));
          })
          resolve();
        })
      });
    }
  })
var Task = function () {
  function Task(opts) {
    _classCallCheck(this, Task);

    this.id = opts.id;
    this.action = opts.action;
    this.timezone = opts.timezone;
    this.monitor = opts.monitor;
    this.schedule = opts.schedule;
    this.project = opts.project;
    this.input = opts.input;
    this.accounts = opts.accounts;
    this.errorHandler = opts.errorHandler;
    if (!this.schedule) {
      throw new Error("Task " + this.id + " has no schedule");
    }
    if (!this.action) {
      throw new Error("Task " + this.id + " has no action");
    }
  }

  _createClass(Task, [{
    key: 'initializeMonitor',
    value: function initializeMonitor() {
      if (!this.monitor) return Promise.resolve();
      this.seenItems = [];
      return this.runMonitor();
    }
  }, {
    key: 'runMonitor',
    value: function runMonitor() {
      var _this = this;

      if (!this.monitor) return Promise.resolve();
      var accounts = Object.assign({}, this.accounts || {}, this.monitor.acco...
