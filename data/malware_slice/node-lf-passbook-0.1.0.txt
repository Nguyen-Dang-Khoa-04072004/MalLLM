// File: package/lib/images.js
// ======================================================================
Line 4: var File = require("fs")
Line 5: var Path = require("path")
Line 9: _tmp_1.push("background")
Line 28: {
    prototype[key] = function(value) {
      if (arguments.length === 0) {
        return this.images[key];
      } else {
        this.images[key] = value;
        return this;
      }
    };

    var retina = key + "2x";
    prototype[retina] = function(value) {
      if (arguments.length === 0) {
        return this.images[retina];
      } else {
        this.images[retina] = value;
        return this;
      }
    };
  }
Line 29: prototype[key] = function(value) {
      if (arguments.length === 0) {
        return this.images[key];
      } else {
        this.images[key] = value;
        return this;
      }
    }
Line 32: {
        this.images[key] = value;
        return this;
      }
Line 33: this.images[key] = value
Line 39: prototype[retina] = function(value) {
      if (arguments.length === 0) {
        return this.images[retina];
      } else {
        this.images[retina] = value;
        return this;
      }
    }
Line 42: {
        this.images[retina] = value;
        return this;
      }
Line 43: this.images[retina] = value
Line 58: Path.basename(filename, ".png")
Line 59: {
        // High resolution
        self.images[basename.replace(/@2x$/, "2x")] = Path.resolve(path, filename);
      }
Line 61: self.images[basename.replace(/@2x$/, "2x")] = Path.resolve(path, filename)
Line 62: {
        // Normal resolution
        self.images[basename] = Path.resolve(path, filename);
      }
Line 64: self.images[basename] = Path.resolve(path, filename)

// File: package/lib/index.js
// ======================================================================
Line 4: var Template = require("./template")

// File: package/lib/pass.js
// ======================================================================
Line 3: var applyImageMethods = require("./images")
Line 4: var Crypto            = require("crypto")
Line 5: var EventEmitter      = require("events").EventEmitter
Line 6: var child_process     = require('child_process')
Line 7: var Stream            = require("stream")
Line 8: var inherits          = require("util").inherits
Line 9: var File              = require("fs")
Line 10: var HTTP              = require("http")
Line 11: var HTTPS             = require("https")
Line 12: var Path              = require("path")
Line 13: var Zip               = require("./zip")
Line 17: _tmp_9.push("authenticationToken")
Line 18: _tmp_9.push("foregroundColor")
Line 19: _tmp_9.push("organizationName")
Line 20: _tmp_9.push("associatedStoreIdentifiers")
Line 22: _tmp_10.push("passTypeIdentifier")
Line 23: _tmp_10.push("teamIdentifier")
Line 25: _tmp_11.push("auxiliaryFields")
Line 26: _tmp_11.push("secondaryFields")
Line 28: _tmp_12.push("logo")
Line 37: {
    this.template = template;
    this.fields = cloneObject(fields);
    // Structure is basically reference to all the fields under a given style
    // key, e.g. if style is coupon then structure.primaryFields maps to
    // fields.coupon.primaryFields.
    var style = template.style;
    this.structure = this.fields[style];
    if (!this.structure)
        this.structure = this.fields[style] = {};
    this.images = cloneObject(images);
}
Line 44: this.structure = this.fields[style]
Line 50: inherits(Pass, EventEmitter)
Line 62: {
    Pass.prototype[key] = function(value) {
        if (arguments.length === 0) {
            return this.fields[key];
        } else {
            this.fields[key] = value;
            return this;
        }
    };
}
Line 63: Pass.prototype[key] = function(value) {
        if (arguments.length === 0) {
            return this.fields[key];
        } else {
            this.fields[key] = value;
            return this;
        }
    }
Line 66: {
            this.fields[key] = value;
            return this;
        }
Line 67: this.fields[key] = value
Line 115: for (k in options)
                field[k] = options[k];
Line 116: field[k] = options[k]
Line 118: this.all().push(field)
Line 119: {
        var array = arguments[0];
        for (var i in array)
            this.add.call(this, array[i]);
    }
Line 120: var array = arguments[0]
Line 121: for (var i in array)
            this.add.call(this, array[i]);
Line 122: this.add.call(this, array[i])
Line 123: {
        var properties = arguments[0];
        key = properties.key;
        this.remove(key);
        field = {};
        for (k in properties)
            field[k] = properties[k];
        this.all().push(field);
    }
Line 124: var properties = arguments[0]
Line 128: for (k in properties)
            field[k] = properties[k];
Line 129: field[k] = properties[k]
Line 130: this.all().push(field)
Line 142: {
    var fields = this.pass.structure[this.key];
    if (fields) {
        for (var i in fields) {
            var field = fields[i];
            if (field.key == key)
                return field;
        }
    }
    return null;
}
Line 143: var fields = this.pass.structure[this.key]
Line 145: for (var i in fields) {
            var field = fields[i];
            if (field.key == key)
                return field;
        }
Line 146: var field = fields[i]
Line 155: {
    var fields = this.pass.structure[this.key];
    if (!fields)
        this.pass.structure[this.key] = fields = [];
    return fields;
}
Line 156: var fields = this.pass.structure[this.key]
Line 163: {
    var fields = this.pass.structure[this.key];
    if (fields) {
        for (var i in fields) {
            if (fields[i].key == key) {
                fields.splice(i, 1);
                break;
            }
        }
    }
    return this;
}
Line 164: var fields = this.pass.structure[this.key]
Line 166: _iterator_5.next()
Line 177: {
    this.pass.structure[this.key] = [];
    return this;
}
Line 178: this.pass.structure[this.key] = []
Line 185: for (var i in REQUIRED_TOP_LEVEL) {
        var k1 = REQUIRED_TOP_LEVEL[i];
        if (!this.fields[k1])
            throw new Error("Missing field " + k1);
    }
Line 186: var k1 = REQUIRED_TOP_LEVEL[i]
Line 190: for (var j in REQUIRED_IMAGES) {
        var k2 = REQUIRED_IMAGES[j];
        if (!this.images[k2])
            throw new Error("Missing image " + k2 + ".png");
    }
Line 191: var k2 = REQUIRED_IMAGES[j]
Line 208: {
    var self = this;
    var zip = new Zip(output);
    var lastError;

    zip.on("error", function(error) {
        lastError = "zip:"+ JSON.stringify(error);
    });

    // Validate before attempting to create
    try {
        this.validate();
    } catch (error) {
        process.nextTick(function() {
            self.emit("error", "validate:"+ JSON.stringify(error));
        });
        return;
    }

    // Construct manifest here
    var manifest = {};
    // Add file to zip and it's SHA to manifest
    function addFile(filename) {
        var file = zip.addFile(filename);
        var sha = new SHAWriteStream(manifest, filename, file);
        return sha;
    }

    // Create pass.json
    var passJson = new Buffer(JSON.stringify(this.getPassJSON()), "utf-8");
    addFile("pass.json").end(passJson, "utf8");

    var expecting = 0;
    for (var key in this.images) {
        var filename = key.replace(/2x$/, "@2x") + ".png";
        addImage(addFile(filename), this.images[k...
Line 219: this.validate()
Line 221: process.nextTick(function() {
            self.emit("error", "validate:"+ JSON.stringify(error));
        })
Line 222: self.emit("error", "validate:"+ JSON.stringify(error))
Line 238: addFile("pass.json").end(passJson, "utf8")
Line 241: for (var key in this.images) {
        var filename = key.replace(/2x$/, "@2x") + ".png";
        addImage(addFile(filename), this.images[key], function(error) {
            --expecting;
            if (error)
                lastError = "addImage:"+JSON.stringify(error);
            if (expecting === 0)
                doneWithImages();
        });
        ++expecting;
    }
Line 243: addImage(addFile(filename), this.images[key], function(error) {
            --expecting;
            if (error)
                lastError = "addImage:"+JSON.stringify(error);
            if (expecting === 0)
                doneWithImages();
        })
Line 256: self.emit("error", "zipClose:"+lastError)
Line 258: self.emit("info", "processStart")
Line 259: process.nextTick(function() {
                self.emit("info", "signZipStart");
                self.signZip(zip, manifest, function(error) {
                    if (error) {
                        return self.emit("error", "signZip:"+JSON.stringify(error));
                    }
                    zip.close();
                    zip.on("end", function() {
                        self.emit("end");
                    });
                    zip.on("error", function(error) {
                        self.emit("error", "zipError:"+JSON.stringify(error));
                    });
                });
            })
Line 260: self.emit("info", "signZipStart")
Line 263: self.emit("error", "signZip:"+JSON.stringify(error))
Line 267: self.emit("end")
Line 270: self.emit("error", "zipError:"+JSON.stringify(error))
Line 292: this.pipe(response)
Line 298: /^https?:/i.test(source)
Line 300: /^https:/i.test(source)
Line 304: response.pipe(file)
Line 307: callback(new Error("Server returned " + response.statusCode + " for " + source))
Line 311: File.createReadStream(source)
Line 312: stream.pipe(file)
Line 315: {
        file.on("close", callback);
        file.write(source);
        file.end();
    }
Line 317: file.write(source)
Line 318: file.end()
Line 322: callback()
Line 324: callback(error)
Line 328: callback(new Error("Cannot load image " + file.filename + ", must be String (filename), Buffer or function"))
Line 334: {
    var self = this;
    var json = JSON.stringify(manifest);
    // Add manifest.json
    zip.addFile("manifest.json").end(json, "utf-8");
    // Create signature
    self.emit("info", "manifestStart");
    self.signManifest(this.template, json, function(error, signature) {
        if (!error) {
            // Write signature file
            zip.addFile("signature").end(signature);
        }
        callback(error);
    });
}
Line 338: zip.addFile("manifest.json").end(json, "utf-8")
Line 340: self.emit("info", "manifestStart")
Line 341: self.signManifest(this.template, json, function(error, signature) {
        if (!error) {
            // Write signature file
            zip.addFile("signature").end(signature);
        }
        callback(error);
    })
Line 342: {
            // Write signature file
            zip.addFile("signature").end(signature);
        }
Line 344: zip.addFile("signature").end(signature)
Line 346: callback(error)
Line 352: {
    var self = this;
    var identifier = template.passTypeIdentifier().replace(/^pass./, "");
    var passNoKey = Path.resolve(template.keysPath, template.keyName["passNoKey"]+".pem");
    var passKey = Path.resolve(template.keysPath, template.keyName["passKey"]+".pem");
    var wdr = Path.resolve(template.keysPath, template.keyName["wdr"]+".pem");
    var args = [
        "smime",
        "-sign", "-binary",
        "-signer",   passNoKey,
        "-inkey",    passKey,
        "-certfile",  wdr,
        "-passin",    "pass:" + template.password
    ];
    self.emit("info", "opensslStart");
    // var sign = child_process.execFile("openssl", args, { "cwd":__dirname+"/../../../../", "stdio": "pipe" }, function(error, stdout, stderr) {
    //     self.emit("info", "opensslEnd");
    //     if (error) {
    //         callback(new Error(stderr));
    //     } else {
    //         var signature = stdout.split(/\n\n/)[3];
    //         callback(null, new Buffer(signature, "base64"))...
Line 355: var passNoKey = Path.resolve(template.keysPath, template.keyName["passNoKey"]+".pem")
Line 356: var passKey = Path.resolve(template.keysPath, template.keyName["passKey"]+".pem")
Line 357: var wdr = Path.resolve(template.keysPath, template.keyName["wdr"]+".pem")
Line 359: _tmp_30.push("smime")
Line 360: _tmp_30.push("-binary")
Line 361: _tmp_30.push(passNoKey)
Line 362: _tmp_30.push("-inkey")
Line 363: _tmp_30.push("-certfile")
Line 364: _tmp_30.push("pass:" + template.password)
Line 366: self.emit("info", "opensslStart")
Line 377: {
        var sign = child_process.exec(command, function(error, stdout, stderr) {
            self.emit("info", "opensslEnd");
            if (error) {
                callback(new Error(stderr));
            } else {
                var signature = stdout.split(/\n\n/)[3];
                callback(null, new Buffer(signature, "base64"));
            }
        });
    }
Line 378: var sign = child_process.exec(command, function(error, stdout, stderr) {
            self.emit("info", "opensslEnd");
            if (error) {
                callback(new Error(stderr));
            } else {
                var signature = stdout.split(/\n\n/)[3];
                callback(null, new Buffer(signature, "base64"));
            }
        })
Line 379: self.emit("info", "opensslEnd")
Line 381: callback(new Error(stderr))
Line 382: {
                var signature = stdout.split(/\n\n/)[3];
                callback(null, new Buffer(signature, "base64"));
            }
Line 383: var signature = stdout.split(/\n\n/)[3]
Line 384: callback(null, new Buffer(signature, "base64"))
Line 388: self.emit("info", err)
Line 391: self.emit("info", "opensslAend")
Line 392: sign.stdin.write(manifest)
Line 393: sign.stdin.end()
Line 401: for (var key in object)
            clone[key] = object[key];
Line 402: clone[key] = object[key]
Line 422: this.emit.bind(this, "close")
Line 423: this.emit.bind(this, "error")
Line 426: inherits(SHAWriteStream, Stream)
Line 428: {
    this.output.write(buffer, encoding);
    this.sha.update(buffer, encoding);
    return true;
}
Line 429: this.output.write(buffer, encoding)
Line 434: {
    if (buffer)
        this.write(buffer, encoding);
    this.output.end();
    this.manifest[this.filename] = this.sha.digest("hex");
}
Line 437: this.output.end()
Line 438: this.manifest[this.filename] = this.sha.digest("hex")

// File: package/lib/template.js
// ======================================================================
Line 4: var applyImageMethods = require("./images")
Line 5: var Pass              = require("./pass")
Line 9: _tmp_3.push("boardingPass")
Line 11: _tmp_4.push("passTypeIdentifier")
Line 12: _tmp_4.push("foregroundColor")
Line 13: _tmp_4.push("suppressStripShine")
Line 20: {
  if (!~STYLES.indexOf(style))
    throw new Error("Unsupported pass style " + style);
  this.style = style;
  this.fields = {};
  for (var key in fields)
    this.fields[key] = fields[key];
  this.keysPath = "keys";
  this.images = {};
  this.keyName = [];
}
Line 25: for (var key in fields)
    this.fields[key] = fields[key];
Line 26: this.fields[key] = fields[key]
Line 29: this.keyName = []
Line 47: for (var key in names)
            this.keyName[key] = names[key];
Line 48: this.keyName[key] = names[key]
Line 56: for (var k1 in this.fields)
    combined[k1] = this.fields[k1];
Line 57: combined[k1] = this.fields[k1]
Line 58: for (var k2 in fields)
    combined[k2] = fields[k2];
Line 59: combined[k2] = fields[k2]
Line 71: {
  Template.prototype[key] = function(value) {
    if (arguments.length === 0) {
      return this.fields[key];
    } else {
      this.fields[key] = value;
      return this;
    }
  };
}
Line 72: Template.prototype[key] = function(value) {
    if (arguments.length === 0) {
      return this.fields[key];
    } else {
      this.fields[key] = value;
      return this;
    }
  }
Line 75: {
      this.fields[key] = value;
      return this;
    }
Line 76: this.fields[key] = value

// File: package/lib/zip.js
// ======================================================================
Line 12: var EventEmitter  = require("events").EventEmitter
Line 13: var inherits      = require("util").inherits
Line 14: var Stream        = require("stream").Stream
Line 15: var Zlib          = require("zlib")
Line 29: {
  this.output = output;
  // Set to true when zip is closed
  this._closed = false;
  // Keep track of all files added so we can write central directory
  this._files = [];
  // The currently active file
  this._active = null;
  // Current offset in the output stream
  this._offset = 0;

  var zip = this;
  output.on("error", function(error) {
    debug("Zip file encountered an error", error);
    // Closed output, propagate.
    // Output error, destroy all files and propagate.
    zip._closed = true;
    for (var i in zip._files) {
      var file = zip._files[i];
      if (!file._done)
        file.destroy();
    }
    zip.emit("error", error);
  });
  output.on("close", function() {
    debug("Zip completed");
    zip.emit("end");
  });
}
Line 34: this._files = []
Line 46: for (var i in zip._files) {
      var file = zip._files[i];
      if (!file._done)
        file.destroy();
    }
Line 47: var file = zip._files[i]
Line 51: zip.emit("error", error)
Line 55: zip.emit("end")
Line 59: inherits(Zip, EventEmitter)
Line 75: this._files.push(file)
Line 88: _iterator_1.next()
Line 103: {
  var centralDirectoryOffset = this._offset;
  var centralDirectorySize = 0;
  for (var i in this._files)
    this._writeCentralDirectoryHeader(this._files[i]);
  centralDirectorySize = this._offset - centralDirectoryOffset;
  this._writeEndOfCentralDirectory(centralDirectoryOffset, centralDirectorySize);
  // Once this buffer is out, we're done with the output stream
  this.output.end();
}
Line 106: for (var i in this._files)
    this._writeCentralDirectoryHeader(this._files[i]);
Line 107: this._writeCentralDirectoryHeader(this._files[i])
Line 111: this.output.end()
Line 121: buffer.writeInt32LE(0x02014b50, 0)
Line 135: buffer.writeInt32LE(file._crc ^ -1, 16)
Line 137: buffer.writeInt32LE(file._compressedLength, 20)
Line 139: buffer.writeInt32LE(file._uncompressedLength, 24)
Line 151: buffer.writeInt32LE(0, 38)
Line 153: buffer.writeInt32LE(file._offset, 42)
Line 155: filename.copy(buffer, 46)
Line 166: buffer.writeInt32LE(0x06054b50, 0)
Line 176: buffer.writeInt32LE(sizeOfCentralDirectory, 12)
Line 178: buffer.writeInt32LE(offsetOfCentralDirectory, 16)
Line 204: for (var i in this._files) {
    var file = this._files[i];
    if (!file._done) {
      done = false;

      if (!file.writable) {
        // Completed, not flushed: this is now the active file
        this._active = file;
        file._flush();
        return;
      }
    }
  }
Line 205: var file = this._files[i]
Line 219: this.emit("drain")
Line 224: {
  this._offset += buffer.length;
  this.output.write(buffer);
}
Line 226: this.output.write(buffer)
Line 238: {
  this.zip = zip;
  this.filename = filename;
  this.modified = modified || new Date();
  // True while file is writeable (end/destroy change this)
  this.writable = true;
  // We use this to hold any buffer if this is not the active file
  this._buffers = [];
  // Make sure we only write header once.
  this._wroteHeader = false;
  // True if file fully written out; distinct from fully read (writable = false)
  this._done = false;
  // Offset of file within the stream
  this._offset = 0;
  this._crc = 0 ^ -1;
  this._compressedLength = this._uncompressedLength = 0;

  // Write to _deflate, count data size before passing to output.
  var file = this;
  this._deflate = Zlib.createDeflateRaw();
  this._deflate.on("data", function(buffer) {
    file._compressedLength += buffer.length;
    zip._writeBuffer(buffer);
  });
  this._deflate.on("end", function(buffer) {
    file._doneWritingFile();
  });
}
Line 245: this._buffers = []
Line 257: Zlib.createDeflateRaw()
Line 267: inherits(File, Stream)
Line 279: {
    var offset = (this._crc ^ buffer[i]) & 0xFF;
    this._crc = (this._crc >>> 8) ^ CRC32[offset];
  }
Line 280: var offset = (this._crc ^ buffer[i]) & 0xFF
Line 281: this._crc = (this._crc >>> 8) ^ CRC32[offset]
Line 284: this._buffers.push(buffer)
Line 286: this.zip.isActive(this)
Line 300: this.zip.isActive(this)
Line 318: buffer.writeInt32LE(0x04034b50, 0)
Line 330: buffer.writeInt32LE(0, 14)
Line 332: buffer.writeInt32LE(0, 18)
Line 334: buffer.writeInt32LE(0, 22)
Line 340: filename.copy(buffer, 30)
Line 362: {
    for (var i in this._buffers)
      this._deflate.write(this._buffers[i]);
    this._buffers = [];
  }
Line 363: for (var i in this._buffers)
      this._deflate.write(this._buffers[i]);
Line 364: this._deflate.write(this._buffers[i])
Line 365: this._buffers = []
Line 381: this.emit("close")
Line 391: buffer.writeInt32LE(0x08074b50, 0)
Line 392: buffer.writeInt32LE(this._crc ^ -1, 4)
Line 394: buffer.writeInt32LE(this._compressedLength, 8)
Line 396: buffer.writeInt32LE(this._uncompressedLength, 12)
Line 407: date.getMonth()
Line 413: date.getHours()
Line 419: _tmp_26.push(0x990951BA)
Line 420: _tmp_26.push(0x9E6495A3)
Line 421: _tmp_26.push(0x90BF1D91)
Line 422: _tmp_26.push(0x84BE41DE)
Line 423: _tmp_26.push(0x8A65C9EC)
Line 424: _tmp_26.push(0x8D080DF5)
Line 425: _tmp_26.push(0xA50AB56B)
Line 426: _tmp_26.push(0xACBCF940)
Line 427: _tmp_26.push(0xBFD06116)
Line 428: _tmp_26.push(0xB8BDA50F)
Line 429: _tmp_26.push(0xB6662D3D)
Line 430: _tmp_26.push(0xEFD5102A)
Line 431: _tmp_26.push(0xE10E9818)
Line 432: _tmp_26.push(0xE6635C01)
Line 433: _tmp_26.push(0xF50FC457)
Line 434: _tmp_26.push(0xFCB9887C)
Line 435: _tmp_26.push(0xD4BB30E2)
Line 436: _tmp_26.push(0xD3D6F4FB)
Line 437: _tmp_26.push(0xDD0D7CC9)
Line 438: _tmp_26.push(0xC90C2086)
Line 439: _tmp_26.push(0xC7D7A8B4)
Line 440: _tmp_26.push(0xC0BA6CAD)
Line 441: _tmp_26.push(0x73DC1683)
Line 442: _tmp_26.push(0x7A6A5AA8)
Line 443: _tmp_26.push(0x6906C2FE)
Line 444: _tmp_26.push(0x6E6B06E7)
Line 445: _tmp_26.push(0x60B08ED5)
Line 446: _tmp_26.push(0x4FDFF252)
Line 447: _tmp_26.push(0x41047A60)
Line 448: _tmp_26.push(0x4669BE79)
Line 449: _tmp_26.push(0x5505262F)
Line 450: _tmp_26.push(0x5CB36A04)
Line 451: _tmp_26.push(0x026D930A)
Line 452: _tmp_26.push(0x05005713)
Line 453: _tmp_26.push(0x0BDBDF21)
Line 454: _tmp_26.push(0x1FDA836E)
Line 455: _tmp_26.push(0x11010B5C)
Line 456: _tmp_26.push(0x166CCF45)
Line 457: _tmp_26.push(0x3E6E77DB)
Line 458: _tmp_26.push(0x37D83BF0)
Line 459: _tmp_26.push(0x24B4A3A6)
Line 460: _tmp_26.push(0x23D967BF)
Line 461: _tmp_26.push(0x2D02EF8D)
