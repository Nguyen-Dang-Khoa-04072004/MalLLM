function MqContainer = function MqContainer(opt, loggers) {
    var self = {
        // flow or container name/id
        name: 'mq'
    };

    // TODO - get options like the `port` from: ~/.gina/user/extensions/logger/{container}/config.json

    var MQSpeaker       = require('./speaker.js');
    opt = merge(opt, { mqPort: 8125, hostV4: '127.0.0.1' });
    var mqSpeaker       = new MQSpeaker(opt, loggers);

    function init() {

        onPayload()

        // ------------------------------------------------------------------------
        var level = 'debug';
        // Init debugging - Logs not in hierarchy will just be ignored
        if (opt.hierarchies[opt.hierarchy].indexOf( opt.levels[level].code) > -1) {
            process.emit('logger#'+self.name, JSON.stringify({
                group       : opt.name,
                level       : level,
                // Raw content !
                content     : '`'+ self.name +'` logger container loaded !'
            }));
        }
        // --------...
function Remove = function Remove(opt, cmd) {

    var self    = {}
        , local = {
            b : 0,
            bundle : null,
            force : false
        }
    ;

    var init = function(opt) {

        // import CMD helpers
        new CmdHelper(self, opt.client, { port: opt.debugPort, brkEnabled: opt.debugBrkEnabled });

        // check CMD configuration
        if ( !isCmdConfigured() ) return false;


        if ( typeof(self.projects[self.projectName].path) == 'undefined' ) {
            console.error('project path not defined in ~/.gina/projects.json for [ '+ self.projectName + ' ]');
            process.exit(1)
        }

        if (isDefined('project', self.projectName)) {
            removeBundle(0)
        } else {
            //console.error('[ '+ self.projectName+' ] is not an existing project');
            if ( self.bundles.length == 0) {
                console.error('Missing argument <bundle_name>');
            } else if  (!isDefined('project', self.projectName) ) {
 ...
function FormValidatorUtil = function FormValidatorUtil(data, $fields, xhrOptions, fieldsSet) {

    var isGFFCtx        = ( ( typeof(module) !== 'undefined' ) && module.exports ) ? false : true;

    // if (isGFFCtx && !$fields )
    //     throw new Error('No `Validator` instance found.\nTry:\nvar FormValidator = require("gina/validator"):\nvar formValidator = new FormValidator(...);')

    var merge           = (isGFFCtx) ? require('lib/merge') : require('../../../../../lib/merge');
    var helpers         = (isGFFCtx) ? {} : require('../../../../../helpers');
    var dateFormat      = (isGFFCtx) ? require('helpers/dateFormat') : helpers.dateFormat;
    var routing         = (isGFFCtx) ? require('lib/routing') : require('../../../../../lib/routing');

    var hasUserValidators = function() {

        var _hasUserValidators = false, formsContext = null;
        // backend validation check
        if (!isGFFCtx) {
            // TODO - retrieve bakcend forms context
            formsContext = getContext('gina'...
function Link = function Link(opt, cmd) {

    var self    = {
        // destination prefix - usaually the project location
        prefix: null
    };

    var init = function(opt, cmd) {
        var err = false;
        if ( !/^true$/i.test(GINA_GLOBAL_MODE) ) {
            err = new Error('Gina is not installed globally: cannot proceed with linking.');
            return end(err, 'error', true);
        }

        // import CMD helpers
        new CmdHelper(self, opt.client, { port: opt.debugPort, brkEnabled: opt.debugBrkEnabled });

        // check CMD configuration
        if (!isCmdConfigured()) return false;

        self.prefix = self.projectLocation;
        var a = [], k = null, v = null;
        for (let i=3; i<process.argv.length; ++i) {
            a = process.argv[i].split(/=/);
            k = a[0];
            v = a[1];
            // console.log('Preprocessing `framework:link '+ process.argv[i] +'` ['+k+'] -> ['+ v +']');
            if ( /^\-\-prefix$/.test(k) ) {
              ...
function ConfigUtil = function ConfigUtil() {

    var self = this; //, mainConfig

    /**
     * Init
     * @contructor
     * */
    var init = function() {

        if ( !ConfigUtil.instance ) {
            try {
                self.paths = getContext('paths');
            } catch (err) {
                self.paths = {};
            }

            var path = new _(__dirname).toUnixStyle();
            self.__dirname =  _( path.substring(0, (path.length - 4)) );

            ConfigUtil.instance = self;
            return self;
        } else {
            self = ConfigUtil.instance;
            return ConfigUtil.instance;
        }
    }


    /**
     * Set config file if !exists
     *
     * @param {string} app - App name
     * @param {string} file - File to save
     * @param {object} content - JSON content to save
     * */
    this.set = function(app, file, content, callback){
        switch (app) {
            case 'gina':
            case 'gina.lib':
                setFile(app, file, conte...
function Tail = function Tail(opt, cmd) {

    process.title = 'gina-tail';
    var self        = {};
    var nIntervId   = null;
    var mqPortFile  = _(getTmpDir() +'/mq-listener-v'+ GINA_VERSION +'.port', true);


    var init = function(opt, cmd) {

        console.debug('Getting framework logs');
        // import CMD helpers
        new CmdHelper(self, opt.client, { port: opt.debugPort, brkEnabled: opt.debugBrkEnabled });

        // check CMD configuration
        //if (!isCmdConfigured()) return false;

        // handle server not started yet or server exited
        process.on('gina#mqlistener-started', function onGinaStarted(mqPort) {
            clearInterval(nIntervId);
            nIntervId = null;
            opt.mqPort = mqPort;

            tail(opt, cmd);
        });

        // process.on('gina#container-writting', function onGinaStarted(hostV4, mqPort, type) {
        //     console.info('[MQTail] Container resumed writting on  `'+ hostV4 +'` on port `'+ mqPort +'` :)');
       ...
function ApiError = function ApiError(errorMessage, fieldName, errorStatus) {
    var e = null;

    if ( typeof(merge) != 'function' ) {
        merge = require('./../../../lib/merge');
    }
    // if ( typeof(statusCodes) == 'undefined' ) {
        var statusCodes = requireJSON(__dirname + '/../../../core/status.codes');
    // }

    if ( typeof(errorMessage) == 'object' && errorMessage instanceof Error ) {
        e = JSON.clone(errorMessage);
        errorMessage = e.message || e.stack;
    } else {
        e = new Error(errorMessage);
    }

    var isClientError = (arguments.length == 3) ? true : false;
    if ( arguments.length == 2 ) {
        // server error
        if ( typeof(arguments[1]) == 'number' ) {
            errorStatus = arguments[1];
            if (!e.status) {
                e.status = errorStatus;
            }
            fieldName = null;
        }
        // client error
        else if ( Array.isArray(arguments[1]) || typeof(arguments[1]) == 'string' ) {
            isCl...
function DateFormatHelper = function DateFormatHelper() {

    var isGFFCtx        = ( ( typeof(module) !== 'undefined' ) && module.exports ) ? false : true;
    var merge           = (isGFFCtx) ? require('lib/merge') : require('./../lib/merge');


    // if ( typeof(define) === 'function' && define.amd ) {
    //     var Date = this.Date;
    // }

    var self = {};
    // language-country
    self.culture = 'en-US'; // by default
    self.lang = 'en'; // by default

    self.masks = {
        // i18n
        "default":      "ddd mmm dd yyyy HH:MM:ss",
        shortDate:      "m/d/yy",
        shortDate2:      "mm/dd/yyyy",
        mediumDate:     "mmm d, yyyy",
        longDate:       "mmmm d, yyyy",
        fullDate:       "dddd, mmmm d, yyyy",
        // common
        cookieDate:     "GMT:ddd, dd mmm yyyy HH:MM:ss",
        logger:       "yyyy mmm dd HH:MM:ss",
        shortTime:      "h:MM TT",
        shortTime2:      "h:MM",
        mediumTime:     "h:MM:ss TT",
        mediumTime2:     "h:MM:ss",
   ...
var init = function(conn, infos) {
        // load on startup
        var cacheless           = (process.env.NODE_ENV_IS_DEV == 'false') ? false : true;
        var path                = getPath('bundle') + '/models/'+ infos.database +'/entities'
            , n1qlDefault       = __dirname + '/lib'
            , files             = fs.readdirSync(path)
            , entities          = {}
            , entityName        = ''
            , Entity            = null
            , className         = null
            , filename          = null
        ;


        // superEntity
        filename = getPath('gina').core + '/model/entity.js';
        if (cacheless)
            delete require.cache[require.resolve(_(filename, true))]; //EntitySuperClass

        EntitySuperClass = require(_(filename, true));


        // first one for the N1QL queries without entity ( check `/lib/n1ql.js` )
        files.unshift('n1ql.js');
        for (var f = 0, len = files.length; f < len; ++f) {

           ...
function Connector = function Connector(dbString) {
    var self    = this
        , local = {
            bundle: null,
            env: null,
            options: {
                keepAlive: true,
                pingInterval : "2m"
            }
        }
        , sdk = {
            version: 2
        }
    ;

    /**
     * connect
     *
     * @param {object} dbString
     * @callback cb
     * */
    this.connect = async function(dbString, cb) {
        // Attention: the connection is lost 5 minutes once the bucket is opened.
        var conn        = null;

        var onError = function (err, next) {
            delete self.instance.reconnecting;
            self.instance.reconnected = self.instance.connected = false;
            console.error('[ CONNECTOR ][ ' + local.bundle +' ] couchbase could not be reached !!\n'+ ( err.stack || err.message || err ) );

            // reconnecting
            console.debug('[ CONNECTOR ][ ' + local.bundle +' ][ ' + dbString.database +' ] trying to reconn...
