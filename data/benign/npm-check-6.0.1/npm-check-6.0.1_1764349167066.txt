function updateAll = function updateAll(currentState) {
    var packages = currentState.get('packages');

    if (currentState.get('debug')) {
        console.log('packages', packages);
    }

    var packagesToUpdate = packages.filter(function (packageEntry) {
        return packageEntry.mismatch || packageEntry.notInstalled || packageEntry.bump;
    });

    if (!packagesToUpdate.length) {
        console.log(emoji(':heart:  ') + 'Your modules look ' + chalk.bold('amazing') + '. Keep up the great work.' + emoji(' :heart:'));
        return;
    }

    var isYarn = currentState.get('installer') === 'yarn';
    var saveExact = currentState.get('saveExact');

    var saveDependencies = packagesToUpdate.filter(function (pkg) {
        return !pkg.devDependency;
    }).map(function (pkg) {
        return buildPackageToUpdate(pkg.moduleName, pkg.latest, isYarn, saveExact);
    });

    var saveDevDependencies = packagesToUpdate.filter(function (pkg) {
        return pkg.devDependency;
    }).map(function (p...
module.exports = function (currentState) {
    return co( /*#__PURE__*/_regenerator2.default.mark(function _callee() {
        var spinner, cwdPackageJson, dependencies, allDependencies, allDependenciesIncludingMissing, arrayOfPackageInfo;
        return _regenerator2.default.wrap(function _callee$(_context) {
            while (1) {
                switch (_context.prev = _context.next) {
                    case 0:
                        dependencies = function dependencies(pkg) {
                            if (currentState.get('global')) {
                                return currentState.get('globalPackages');
                            }

                            if (currentState.get('ignoreDev')) {
                                return pkg.dependencies;
                            }

                            if (currentState.get('devOnly')) {
                                return pkg.devDependencies;
                            }

                            retur...
_tmp_34.title = <operator>.formatString("", chalk.magenta.underline.bold('Non-Semver'), " ", chalk.magenta('Versions less than 1.0.0, caution.'), "")
execa(installer, npmArgs, { cwd: currentState.get('cwd') }).then(function (output) {
        spinner.stop();
        console.log(output.stdout);
        console.log(output.stderr);

        return currentState;
    }).catch(function (err) {
        spinner.stop();
        throw err;
    })
(_tmp_2 = _([pkg.notInstalled ? chalk.bgRed.white.bold(emoji(' :worried: ') + ' MISSING! ') + ' Not installed.' : '', pkg.notInPackageJson ? chalk.bgRed.white.bold(emoji(' :worried: ') + ' PKG ERR! ') + ' Not in the package.json. ' + pkg.notInPackageJson : '', pkg.pkgError && !pkg.notInstalled ? chalk.bgGreen.white.bold(emoji(' :worried: ') + ' PKG ERR! ') + ' ' + chalk.red(pkg.pkgError.message) : '', pkg.bump && pkg.easyUpgrade ? [chalk.bgGreen.white.bold(emoji(' :heart_eyes: ') + ' UPDATE!  ') + ' Your local install is out of date. ' + chalk.blue.underline(pkg.homepage || ''), indent + upgradeMessage] : '', pkg.bump && !pkg.easyUpgrade ? [chalk.white.bold.bgGreen(pkg.bump === 'nonSemver' ? emoji(' :sunglasses: ') + ' new ver! '.toUpperCase() : emoji(' :sunglasses: ') + ' ' + pkg.bump.toUpperCase() + ' UP ') + ' ' + uppercaseFirstLetter(pkg.bump) + ' update available. ' + chalk.blue.underline(pkg.homepage || ''), indent + upgradeMessage] : '', pkg.unused ? [chalk.black.bold.bgWhite(emoji(' :...).valueOf
function checkUnused = function checkUnused(currentState) {
    const spinner = ora(`Checking for unused packages. --skip-unused if you don't want this.`);
    spinner.enabled = spinner.enabled && currentState.get('spinner');
    spinner.start();

    return new Promise(resolve => {
        if (skipUnused(currentState)) {
            resolve(currentState);
            return;
        }

        const depcheckDefaults = {
            ignoreDirs: [
                'sandbox',
                'dist',
                'generated',
                '.generated',
                'build',
                'fixtures',
                'jspm_packages'
            ],
            ignoreMatches: [
                'gulp-*',
                'grunt-*',
                'karma-*',
                'angular-*',
                'babel-*',
                'metalsmith-*',
                'eslint-plugin-*',
                '@types/*',
                'grunt',
                'mocha',
                'ava'
            ],
            ...
function state = function state(userOptions) {
    var currentStateObject = extend(defaultOptions);

    function get(key) {
        if (!currentStateObject.hasOwnProperty(key)) {
            throw new Error('Can\'t get unknown option "' + key + '".');
        }
        return currentStateObject[key];
    }

    function set(key, value) {
        if (get('debug')) {
            debug('set key', key, 'to value', value);
        }

        if (currentStateObject.hasOwnProperty(key)) {
            currentStateObject[key] = value;
        } else {
            throw new Error('unknown option "' + key + '" setting to "' + (0, _stringify2.default)(value, false, 4) + '".');
        }
    }

    function inspectIfDebugMode() {
        if (get('debug')) {
            inspect();
        }
    }

    function inspect() {
        debug('current state', all());
    }

    function all() {
        return currentStateObject;
    }

    var currentState = {
        get: get,
        set: set,
        all: all,
     ...
function set = function set(key, value) {
        if (get('debug')) {
            debug('set key', key, 'to value', value);
        }

        if (currentStateObject.hasOwnProperty(key)) {
            currentStateObject[key] = value;
        } else {
            throw new Error(`unknown option "${key}" setting to "${JSON.stringify(value, false, 4)}".`);
        }
    }
(_tmp_4 = new Promise(resolve => {
        if (skipUnused(currentState)) {
            resolve(currentState);
            return;
        }

        const depcheckDefaults = {
            ignoreDirs: [
                'sandbox',
                'dist',
                'generated',
                '.generated',
                'build',
                'fixtures',
                'jspm_packages'
            ],
            ignoreMatches: [
                'gulp-*',
                'grunt-*',
                'karma-*',
                'angular-*',
                'babel-*',
                'metalsmith-*',
                'eslint-plugin-*',
                '@types/*',
                'grunt',
                'mocha',
                'ava'
            ],
            specials: getSpecialParsers(currentState)
        };

        const npmCheckRc = loadRcFile('npmcheck');

        const depcheckOptions = {
            ...depcheckDefaults,
            ...npmCheckRc.depcheck
        };

        depcheck...).then
buildPackageToUpdate(pkg.moduleName, pkg.latest, isYarn, saveExact)
_tmp_5.push(pkg.bump && !pkg.easyUpgrade ? [
            chalk.white.bold.bgGreen((pkg.bump === 'nonSemver' ? emoji(' :sunglasses: ') + ' new ver! '.toUpperCase() : emoji(' :sunglasses: ') + ' ' + pkg.bump.toUpperCase() + ' UP ')) + ' ' + uppercaseFirstLetter(pkg.bump) + ' update available. ' + chalk.blue.underline(pkg.homepage || ''),
            indent + upgradeMessage
        ] : "")
_tmp_12.push(chalk.white.bold.bgGreen((pkg.bump === 'nonSemver' ? emoji(' :sunglasses: ') + ' new ver! '.toUpperCase() : emoji(' :sunglasses: ') + ' ' + pkg.bump.toUpperCase() + ' UP ')) + ' ' + uppercaseFirstLetter(pkg.bump) + ' update available. ' + chalk.blue.underline(pkg.homepage || ''))
_tmp_2.flags = {
            update: {
                type: 'boolean',
                alias: 'u'
            },
            updateAll: {
                type: 'boolean',
                alias: 'y'
            },
            global: {
                type: 'boolean',
                alias: 'g'
            },
            skipUnused: {
                type: 'boolean',
                alias: 's'
            },
            production: {
                type: 'boolean',
                alias: 'p'
            },
            devOnly: {
                type: 'boolean',
                alias: 'd'
            },
            saveExact: {
                type: 'boolean',
                alias: 'E'
            },
            ignore: {
                type: 'string',
                alias: 'i'
            },
            specials: {
                type: 'string'
            },
            color: {
                type: 'boolean'
            },
            emoji: {
                type: 'boolean',
             ...
(_tmp_3 = specialsInput.split(',').map(function (special) {
        return depcheck.special[special];
    })).filter
<operator>.formatString("Depcheck did not find code similar to ", chalk.green(`require('${packageName}')`), " or ", chalk.green(`import from '${packageName}'`), ".")
function checkUnused = function checkUnused(currentState) {
    var spinner = ora('Checking for unused packages. --skip-unused if you don\'t want this.');
    spinner.enabled = spinner.enabled && currentState.get('spinner');
    spinner.start();

    return new _promise2.default(function (resolve) {
        if (skipUnused(currentState)) {
            resolve(currentState);
            return;
        }

        var depcheckDefaults = {
            ignoreDirs: ['sandbox', 'dist', 'generated', '.generated', 'build', 'fixtures', 'jspm_packages'],
            ignoreMatches: ['gulp-*', 'grunt-*', 'karma-*', 'angular-*', 'babel-*', 'metalsmith-*', 'eslint-plugin-*', '@types/*', 'grunt', 'mocha', 'ava'],
            specials: getSpecialParsers(currentState)
        };

        var npmCheckRc = loadRcFile('npmcheck');

        var depcheckOptions = (0, _extends3.default)({}, depcheckDefaults, npmCheckRc.depcheck);

        depcheck(currentState.get('cwd'), depcheckOptions, resolve);
    }).then(function (depCheck...
function outputConsole = function outputConsole(currentState) {
    var packages = currentState.get('packages');

    var rows = packages.reduce(function (acc, pkg) {
        return acc.concat(render(pkg, currentState));
    }, []).filter(Boolean);

    if (rows.length) {
        var renderedTable = table(rows, {
            stringLength: function stringLength(s) {
                return stripAnsi(s).length;
            }
        });

        console.log('');
        console.log(renderedTable);
        console.log('Use ' + chalk.green('npm-check -' + (currentState.get('global') ? 'g' : '') + 'u') + ' for interactive update.');
        process.exitCode = 1;
    } else {
        console.log(emoji(':heart:  ') + 'Your modules look ' + chalk.bold('amazing') + '. Keep up the great work.' + emoji(' :heart:'));
        process.exitCode = 0;
    }
}
getLatestFromRegistry(moduleName).then(function (fromRegistry) {
        var installedVersion = modulePackageJson.version;

        var latest = installedVersion && fromRegistry.latest && fromRegistry.next && semver.gt(installedVersion, fromRegistry.latest) ? fromRegistry.next : fromRegistry.latest;
        var versions = fromRegistry.versions || [];

        var versionWanted = semver.maxSatisfying(versions, packageJsonVersion);

        var versionToUse = installedVersion || versionWanted;
        var usingNonSemver = semver.valid(latest) && semver.lt(latest, '1.0.0-pre');

        var bump = semver.valid(latest) && semver.valid(versionToUse) && (usingNonSemver && semverDiff(versionToUse, latest) ? 'nonSemver' : semverDiff(versionToUse, latest));

        var unused = _.includes(unusedDependencies, moduleName);

        return {
            // info
            moduleName: moduleName,
            homepage: fromRegistry.homepage,
            regError: fromRegistry.error,
           ...
