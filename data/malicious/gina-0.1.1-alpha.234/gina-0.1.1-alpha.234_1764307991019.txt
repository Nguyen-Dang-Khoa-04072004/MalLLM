$children[c].className = $children[c].className.replace(/(\s+hidden|hidden)/, '')
getLib = function(bundle, lib) {
        var ctx     = self.contexts;
        var libPath = null
        if (arguments.length == 1 || !bundle) {
            //console.debug(
            //    '\n[ 0 ] = '+ __stack[0].getFileName(),
            //    '\n[ 1 ] = '+ __stack[1].getFileName(),
            //    '\n[ 2 ] = '+ __stack[2].getFileName(),
            //    '\n[ 3 ] = '+ __stack[3].getFileName(),
            //    '\n[ 4 ] = '+ __stack[4].getFileName(),
            //    '\n[ 5 ] = '+ __stack[5].getFileName(),
            //    '\n[ 6 ] = '+ __stack[6].getFileName()
            //);
             lib    = (arguments.length == 1) ? bundle : lib;
             bundle = null;
             var file          = null
                , stackFileName = null
                //, file        = ( !/node_modules/.test(__stack[1].getFileName()) ) ?  __stack[1].getFileName() : __stack[2].getFileName()
            ;
            for (let i = 1, len = 10; i<len; ++i) {
                stackFileNam...
setEnvVar = function(key, val, isProtected) {
        key = key.toUpperCase();
        var err                     = null
            // related task `framework:set` & framework/v.xxx/lib/cmd/framework/init.js
            , specialCases          = ['GINA_PORT', 'GINA_DEBUG_PORT', 'GINA_CULTURE', 'GINA_TIMEZONE']
            , isOverrrideAllowed    = (specialCases.indexOf(key) > -1) ? true : false
        ;

        if (
            key.substr(0, 5) !== 'GINA_' &&
            key.substr(0, 7) !== 'VENDOR_' &&
            key.substr(0, 5) !== 'USER_'
            ) {
            key = 'USER_' + key
        }
        if (
            typeof(process['gina']) != 'undefined' &&
            typeof(process['gina'][key]) != 'undefined' &&
            process['gina'][key] !== '' &&
            // exceptions
            !isOverrrideAllowed
        ) {
            err = new Error('Env variable [ '+ key + ' ] is already set');
            console.warn(err.message);
            return
        } el...
var browse = function(source, list) {

        var newSource   = null
            , files     = fs.readdirSync(source)
            , f         = 0
        ;

        if (source == local.source && typeof(list) == 'undefined') {//root
            list = [];// root list
            for (let l=0; l<files.length; ++l) {
                list[l] = _(local.source +'/'+ files[l])
            }
        }

        if (!files && list.indexOf(source) > -1) {
            list.splice( list.indexOf(source), 1 )
        }

        for (; f < files.length; ++f) {
            newSource = _(source +'/'+ files[f]);
            if ( fs.statSync(newSource).isDirectory() ) {
                browse(newSource, list)
            } else {
                list = parse(newSource, list)
            }

            if ( f == files.length-1) { //end of current dir
                var p = newSource.split('/');
                p.splice(p.length -1);
                newSource = p.join('/');
                if (list != unde...
xhr.onerror = function(event, err) {

                var error = 'Transaction error: might be due to the server CORS settings.\nPlease, check the console for more details.';
                var result = {
                    'status':  xhr.status, //500,
                    'error' : error
                };

                console.debug('query error [2] detected !! ', err, error);
                isOnException = true;
                result = this.responseText;
                    var contentType     = this.getResponseHeader("Content-Type");
                    if ( /\/json/.test( contentType ) ) {
                        result = JSON.parse(this.responseText);

                        if ( typeof(result.status) == 'undefined' )
                            result.status = this.status;

                        //triggerEvent(gina, $target, 'success.' + id, result);
                        return onResult(result)
                    } else {
                        result = { 'stat...
self.register = function(bundle, pid) {

        var processCollection = new Collection(process.list);
        var existingProcess = processCollection.findOne({ name: bundle, pid: pid });
        // cleanup if found;
        if (existingProcess) {
            process.list = processCollection.delete({ name: bundle, pid: pid }, 'pid').toRaw();
            dismiss(existingProcess.pid);
            console.debug('[ PROC ] Don\'t pannic ...');
            existingProcess = null;
            return;
        }



        if ( /^gina\-/.test(bundle) || !/^gina\-/.test(bundle) && self.bundles.indexOf(bundle) < 0 ) {
            console.debug('[ PROC ] Now registering `'+bundle+'` with PID `'+ pid +'`');


            var list = {};

            var processRegistration = function () {


                if (!/^gina\-/.test(bundle) && !existingProcess) {
                    self.bundles.push(bundle);
                }
                // save to ~/.gina/procs.json
                else if (/^gina...
logger[l] = new Function('return '+ write +'('+ JSON.stringify(loggerOptions) +', '+ parse +', "'+ l +'", arguments, '+  emit +');')
