const status = await this.channel.request('transport.produce', internal, reqData)
const data = {
            kind,
            rtpParameters,
            type: status.type,
            consumableRtpParameters
        }
_tmp_93.uri = "urn:ietf:params:rtp-hdrext:sdes:rtp-stream-id"
const producer = new Producer_1.Producer({
            internal,
            data,
            channel: this.channel,
            payloadChannel: this.payloadChannel,
            appData,
            paused
        })
_tmp_85.push({
			kind             : 'video',
			uri              : 'urn:ietf:params:rtp-hdrext:sdes:repaired-rtp-stream-id',
			preferredId      : 5,
			preferredEncrypt : false,
			direction        : 'recvonly'
		})
throw new TypeError('invalid encoding.scalabilityMode');
producer.on('@close', () => {
            this.#producers.delete(producer.id);
            this.emit('@producerclose', producer);
        })
_tmp_85.push({
			kind             : 'video',
			uri              : 'http://tools.ietf.org/html/draft-ietf-avtext-framemarking-07',
			preferredId      : 7,
			preferredEncrypt : false,
			direction        : 'sendrecv'
		})
throw new TypeError('wrong listenIp');
const internal = { ...this.#internal, transportId: (0, uuid_1.v4)() }
_tmp_114.push(router.createPipeTransport({ listenIp, enableSctp, numSctpStreams, enableRtx, enableSrtp }))
const dataProducer = new DataProducer_1.DataProducer({
            internal,
            data,
            channel: this.channel,
            payloadChannel: this.payloadChannel,
            appData
        })
function generateRouterRtpCapabilities = function generateRouterRtpCapabilities(mediaCodecs = []) {
    // Normalize supported RTP capabilities.
    validateRtpCapabilities(supportedRtpCapabilities_1.supportedRtpCapabilities);
    if (!Array.isArray(mediaCodecs))
        throw new TypeError('mediaCodecs must be an Array');
    const clonedSupportedRtpCapabilities = utils.clone(supportedRtpCapabilities_1.supportedRtpCapabilities);
    const dynamicPayloadTypes = utils.clone(DynamicPayloadTypes);
    const caps = {
        codecs: [],
        headerExtensions: clonedSupportedRtpCapabilities.headerExtensions
    };
    for (const mediaCodec of mediaCodecs) {
        // This may throw.
        validateRtpCodecCapability(mediaCodec);
        const matchedSupportedCodec = clonedSupportedRtpCapabilities
            .codecs
            .find((supportedCodec) => (matchCodecs(mediaCodec, supportedCodec, { strict: false })));
        if (!matchedSupportedCodec) {
            throw new errors_1.UnsupportedError(`medi...
_tmp_117.push(localPipeTransport.connect({
                            ip: remotePipeTransport.tuple.localIp,
                            port: remotePipeTransport.tuple.localPort,
                            srtpParameters: remotePipeTransport.srtpParameters
                        }))
dataProducer.on('@close', () => {
            this.dataProducers.delete(dataProducer.id);
            this.emit('@dataproducerclose', dataProducer);
        })
const caps = {
        codecs: [],
        headerExtensions: clonedSupportedRtpCapabilities.headerExtensions
    }
_tmp_118.srtpParameters = remotePipeTransport.srtpParameters
_tmp_117.push(remotePipeTransport.connect({
                            ip: localPipeTransport.tuple.localIp,
                            port: localPipeTransport.tuple.localPort,
                            srtpParameters: localPipeTransport.srtpParameters
                        }))
