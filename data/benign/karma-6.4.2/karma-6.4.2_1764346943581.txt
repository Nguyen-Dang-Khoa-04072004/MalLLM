'Passing raw CLI options to `new Server(config, done)` is ' +
        'deprecated. Use ' +
        '`parseConfig(configFilePath, cliOptions, {promiseConfig: true, throwErrors: true})` ' +
        'to prepare a processed `Config` instance and pass that as the ' +
        '`config` argument instead.'
CoffeeFormatter = package/lib/init/formatters.js::program:CoffeeFormatter:<init>
this.browsers.forEach((browser) => {
      browser.lastResult = new BrowserResult()
    })
this.restart = function () {
    if (this.state === BEING_FORCE_KILLED) {
      return
    }

    if (!killingPromise) {
      killingPromise = this.emitAsync('kill')
    }

    killingPromise.then(() => {
      if (this.state === BEING_FORCE_KILLED) {
        this.state = FINISHED
      } else {
        killingPromise = null
        log.debug(`Restarting ${this.name}`)
        this.start(previousUrl)
      }
    })

    this.state = RESTARTING
  }
function normalizeConfig = function normalizeConfig (config, configFilePath) {
  function basePathResolve (relativePath) {
    if (helper.isUrlAbsolute(relativePath)) {
      return relativePath
    } else if (helper.isDefined(config.basePath) && helper.isDefined(relativePath)) {
      return path.resolve(config.basePath, relativePath)
    } else {
      return ''
    }
  }

  function createPatternMapper (resolve) {
    return (objectPattern) => Object.assign(objectPattern, { pattern: resolve(objectPattern.pattern) })
  }

  if (helper.isString(configFilePath)) {
    config.basePath = path.resolve(path.dirname(configFilePath), config.basePath) // resolve basePath
    config.exclude.push(configFilePath) // always ignore the config file itself
  } else {
    config.basePath = path.resolve(config.basePath || '.')
  }

  config.files = config.files.map(createPatternObject).map(createPatternMapper(basePathResolve))
  config.exclude = config.exclude.map(basePathResolve)
  config.customContextFile = config.customCo...
this._clearTempDirAndReportDone = function (error) {
    tempDir.remove(self._tempDir, function () {
      self._done(error)
      if (onExitCallback) {
        onExitCallback()
        onExitCallback = null
      }
    })
  }
this._boundServer.on('connection', (socket) => {
        // Attach an error handler to avoid UncaughtException errors.
        socket.on('error', (err) => {
          // Errors on this socket are retried, ignore them
          this.log.debug('Ignoring error on webserver connection: ' + err)
        })
      })
this._onKillTimeout = function () {
    if (self.state !== self.STATE_BEING_KILLED && self.state !== self.STATE_BEING_FORCE_KILLED) {
      return
    }

    log.warn(`${self.name} was not killed in ${killTimeout} ms, sending SIGKILL.`)
    self._process.kill('SIGKILL')

    // NOTE: https://github.com/karma-runner/karma/pull/1184
    // NOTE: SIGKILL is just a signal.  Processes should never ignore it, but they can.
    // If a process gets into a state where it doesn't respond in a reasonable amount of time
    // Karma should warn, and continue as though the kill succeeded.
    // This a certainly suboptimal, but it is better than having the test harness hang waiting
    // for a zombie child process to exit.
    self._killTimer = timer.setTimeout(function () {
      log.warn(`${self.name} was not killed by SIGKILL in ${killTimeout} ms, continuing.`)
      self._onProcessExit(-1, null, '')
    }, killTimeout)
  }
this.log = function (type, args) {
    var values = []

    for (var i = 0; i < args.length; i++) {
      values.push(this.stringify(args[i], 3))
    }

    this.info({ log: values.join(', '), type: type })
  }
fileServer(requestedFileUrl, requestedRangeHeader, response, function (data) {
          common.setNoCacheHeaders(response)

          const scriptTags = []
          for (const file of files.included) {
            let filePath = file.path
            const fileType = file.type || file.detectType()

            if (!FILE_TYPES.includes(fileType)) {
              if (file.type == null) {
                log.warn(
                  'Unable to determine file type from the file extension, defaulting to js.\n' +
                  `  To silence the warning specify a valid type for ${file.originalPath} in the configuration file.\n` +
                  '  See https://karma-runner.github.io/latest/config/files.html'
                )
              } else {
                log.warn(`Invalid file type (${file.type || 'empty string'}), defaulting to js.`)
              }
            }

            if (!file.isUrl) {
              filePath = filePathToUrlPath(filePath, basePath, urlRoot, proxyP...
filePath = filePathToUrlPath(filePath, basePath, urlRoot, proxyPath)
'Karma - Spectacular Test Runner for JavaScript.\n\n' +
      'START - Start the server / do a single run.\n\n' +
      'Usage:\n' +
      '  $0 start [configFile]'
<operator>.formatString("<link type="text/css" href="", filePath, "" rel="stylesheet"", integrityAttribute, "", crossOriginAttribute, ">")
assert(Array.isArray(config.client.args), 'Invalid configuration: client.args must be an array of strings')
<operator>.formatString("<link href="", filePath, "" rel="import"", integrityAttribute, "", crossOriginAttribute, ">")
<operator>.formatString("<script onerror="throw 'Error loading ", filePath, "'" type="", scriptType, "" src="", filePath, """, integrityAttribute, "", crossOriginAttribute, "></script>")
<operator>.formatString("<script type="", scriptType, "" src="", filePath, """, integrityAttribute, "", crossOriginAttribute, "></script>")
_tmp_45.describe = "A path to a file that exports the format function."
scriptUrls.push(
                // Escape characters with special roles (tags) in HTML. Open angle brackets are parsed as tags
                // immediately, even if it is within double quotations in browsers
                script.replace(/</g, '\\x3C').replace(/>/g, '\\x3E'))
socket.on('disconnect', (reason) => this.onSocketDisconnect(reason, socket))
sm.process(questions, function (answers) {
    const cwd = process.cwd()
    const configFile = config.configFile || 'karma.conf.js'
    const isCoffee = path.extname(configFile) === '.coffee'
    const testMainFile = isCoffee ? 'test-main.coffee' : 'test-main.js'
    const formatter = formatters.createForPath(configFile)
    const processedAnswers = processAnswers(answers, getBasePath(configFile, cwd), testMainFile)
    const configFilePath = path.resolve(cwd, configFile)
    const testMainFilePath = path.resolve(cwd, testMainFile)

    if (isCoffee) {
      installPackage('coffeescript')
    }

    if (processedAnswers.generateTestMain) {
      formatter.writeRequirejsConfigFile(testMainFilePath)
      console.log(colorScheme.success(`RequireJS bootstrap file generated at "${testMainFilePath}".`))
    }

    formatter.writeConfigFile(configFilePath, processedAnswers)
    console.log(colorScheme.success(`Config file generated at "${configFilePath}".`))
  })
data
            .replace('%SCRIPTS%', () => scriptTags.join('\n'))
            .replace('%CLIENT_CONFIG%', 'window.__karma__.config = ' + JSON.stringify(client) + ';\n')
            .replace('%SCRIPT_URL_ARRAY%', () => 'window.__karma__.scriptUrls = ' + JSON.stringify(scriptUrls) + ';\n')
            .replace('%MAPPINGS%', () => 'window.__karma__.files = {\n' + mappings.join(',\n') + '\n};\n')
            .replace('%X_UA_COMPATIBLE%', getXUACompatibleMetaElement(request.url))
const afterPreprocess = () => {
      if (config.autoWatch) {
        const watcher = this.get('watcher')
        this._injector.invoke(watcher)
      }

      webServer.listen(this._boundServer, () => {
        this.log.info(`Karma v${constant.VERSION} server started at ${config.protocol}//${config.hostname}:${config.port}${config.urlRoot}`)

        this.emit('listening', config.port)
        if (config.browsers && config.browsers.length) {
          this._injector.invoke(launcher.launch, launcher).forEach((browserLauncher) => {
            singleRunDoneBrowsers[browserLauncher.id] = false
          })
        }
        if (this.loadErrors.length > 0) {
          this.log.error(new Error(`Found ${this.loadErrors.length} load error${this.loadErrors.length === 1 ? '' : 's'}`))
          this._close(1)
        }
      })
    }
'window.__karma__.scriptUrls = ' + JSON.stringify(scriptUrls) + ';\n'
