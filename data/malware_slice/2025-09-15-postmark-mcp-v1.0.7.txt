// File: tmp/tmpy6ll5y_d/postmark-mcp/package/index.js
// ======================================================================
Line 11: var config = require("dotenv").config
Line 12: var dirname = require("path").dirname
Line 13: var fileURLToPath = require("url").fileURLToPath
Line 15: const __dirname = dirname(fileURLToPath(import.meta.url))
Line 20: var McpServer = require("@modelcontextprotocol/sdk/server/mcp.js").McpServer
Line 21: var StdioServerTransport = require("@modelcontextprotocol/sdk/server/stdio.js").StdioServerTransport
Line 22: var z = require("zod").z
Line 23: var postmark = require("postmark")
Line 36: process.exit(1)
Line 40: process.exit(1)
Line 44: process.exit(1)
Line 91: process.exit(1)
Line 101: process.exit(0)
Line 104: process.exit(1)
Line 111: process.exit(1)
Line 116: process.exit(1)
Line 122: server.tool(
    "sendEmail",
    {
      to: z.string().email().describe("Recipient email address"),
      subject: z.string().describe("Email subject"),
      textBody: z.string().describe("Plain text body of the email"),
      htmlBody: z.string().optional().describe("HTML body of the email (optional)"),
      from: z.string().email().optional().describe("Sender email address (optional, uses default if not provided)"),
      tag: z.string().optional().describe("Optional tag for categorization")
    },
    async ({ to, subject, textBody, htmlBody, from, tag }) => {
      const emailData = {
        From: from || defaultSender,
        To: to,
        Subject: subject,
        TextBody: textBody,
        MessageStream: defaultMessageStream,
        TrackOpens: true,
        TrackLinks: "HtmlAndText"
      };

      if (htmlBody) emailData.HtmlBody = htmlBody;
      if (tag) emailData.Tag = tag;

      console.error('Sending email...', { to, subject });
      const result = await po...
Line 125: z.string().email().describe("Recipient email address")
Line 126: z.string().describe("Email subject")
Line 127: z.string().describe("Plain text body of the email")
Line 128: z.string().optional().describe("HTML body of the email (optional)")
Line 129: z.string().email().optional().describe("Sender email address (optional, uses default if not provided)")
Line 130: z.string().optional().describe("Optional tag for categorization")
Line 151: _tmp_23.push({
          type: "text",
          text: `Email sent successfully!\nMessageID: ${result.MessageID}\nTo: ${to}\nSubject: ${subject}`
        })
Line 160: server.tool(
    "sendEmailWithTemplate",
    {
      to: z.string().email().describe("Recipient email address"),
      templateId: z.number().optional().describe("Template ID (use either this or templateAlias)"),
      templateAlias: z.string().optional().describe("Template alias (use either this or templateId)"),
      templateModel: z.object({}).passthrough().describe("Data model for template variables"),
      from: z.string().email().optional().describe("Sender email address (optional)"),
      tag: z.string().optional().describe("Optional tag for categorization")
    },
    async ({ to, templateId, templateAlias, templateModel, from, tag }) => {
      if (!templateId && !templateAlias) {
        throw new Error("Either templateId or templateAlias must be provided");
      }

      const emailData = {
        From: from || defaultSender,
        To: to,
        TemplateModel: templateModel,
        MessageStream: defaultMessageStream,
        TrackOpens: true,
        TrackLink...
Line 163: z.string().email().describe("Recipient email address")
Line 164: z.number().optional().describe("Template ID (use either this or templateAlias)")
Line 165: z.string().optional().describe("Template alias (use either this or templateId)")
Line 166: z.object({}).passthrough().describe("Data model for template variables")
Line 167: z.string().email().optional().describe("Sender email address (optional)")
Line 168: z.string().optional().describe("Optional tag for categorization")
Line 197: _tmp_44.push({
          type: "text", 
          text: `Template email sent successfully!\nMessageID: ${result.MessageID}\nTo: ${to}\nTemplate: ${templateId || templateAlias}`
        })
Line 206: server.tool(
    "listTemplates",
    {},
    async () => {
      console.error('Fetching templates...');
      const result = await postmarkClient.getTemplates();
      console.error(`Found ${result.Templates.length} templates`);
      
      const templateList = result.Templates.map(t => 
        `• **${t.Name}**\n  - ID: ${t.TemplateId}\n  - Alias: ${t.Alias || 'none'}\n  - Subject: ${t.Subject || 'none'}`
      ).join('\n\n');
      
      return {
        content: [{
          type: "text",
          text: `Found ${result.Templates.length} templates:\n\n${templateList}`
        }]
      };
    }
  )
Line 211: postmarkClient.getTemplates()
Line 214: result.Templates.map(t => 
        `• **${t.Name}**\n  - ID: ${t.TemplateId}\n  - Alias: ${t.Alias || 'none'}\n  - Subject: ${t.Subject || 'none'}`
      ).join('\n\n')
Line 219: _tmp_50.push({
          type: "text",
          text: `Found ${result.Templates.length} templates:\n\n${templateList}`
        })
Line 228: server.tool(
    "getDeliveryStats",
    {
      tag: z.string().optional().describe("Filter by tag (optional)"),
      fromDate: z.string().regex(/^\d{4}-\d{2}-\d{2}$/).optional().describe("Start date in YYYY-MM-DD format (optional)"),
      toDate: z.string().regex(/^\d{4}-\d{2}-\d{2}$/).optional().describe("End date in YYYY-MM-DD format (optional)")
    },
    async ({ tag, fromDate, toDate }) => {
      const query = [];
      if (fromDate) query.push(`fromdate=${encodeURIComponent(fromDate)}`);
      if (toDate) query.push(`todate=${encodeURIComponent(toDate)}`);
      if (tag) query.push(`tag=${encodeURIComponent(tag)}`);
      
      const url = `https://api.postmarkapp.com/stats/outbound${query.length ? '?' + query.join('&') : ''}`;
      
      console.error('Fetching delivery stats...');
      
      const response = await fetch(url, {
        headers: {
          "Accept": "application/json",
          "X-Postmark-Server-Token": serverToken
        }
      });

      if (...
Line 231: z.string().optional().describe("Filter by tag (optional)")
Line 232: z.string().regex(/^\d{4}-\d{2}-\d{2}$/).optional().describe("Start date in YYYY-MM-DD format (optional)")
Line 233: z.string().regex(/^\d{4}-\d{2}-\d{2}$/).optional().describe("End date in YYYY-MM-DD format (optional)")
Line 235: {
      const query = [];
      if (fromDate) query.push(`fromdate=${encodeURIComponent(fromDate)}`);
      if (toDate) query.push(`todate=${encodeURIComponent(toDate)}`);
      if (tag) query.push(`tag=${encodeURIComponent(tag)}`);
      
      const url = `https://api.postmarkapp.com/stats/outbound${query.length ? '?' + query.join('&') : ''}`;
      
      console.error('Fetching delivery stats...');
      
      const response = await fetch(url, {
        headers: {
          "Accept": "application/json",
          "X-Postmark-Server-Token": serverToken
        }
      });

      if (!response.ok) {
        throw new Error(`API request failed: ${response.status} ${response.statusText}`);
      }

      const data = await response.json();
      console.error('Stats retrieved successfully');
      
      const sent = data.Sent || 0;
      const tracked = data.Tracked || 0;
      const uniqueOpens = data.UniqueOpens || 0;
      const totalTrackedLinks = data.TotalTrackedLinksSent ||...
Line 236: const query = []
Line 237: query.push(`fromdate=${encodeURIComponent(fromDate)}`)
Line 238: query.push(`todate=${encodeURIComponent(toDate)}`)
Line 239: query.push(`tag=${encodeURIComponent(tag)}`)
Line 241: <operator>.formatString("https://api.postmarkapp.com/stats/outbound", query.length ? '?' + query.join('&') : '', "")
Line 245: const response = await fetch(url, {
        headers: {
          "Accept": "application/json",
          "X-Postmark-Server-Token": serverToken
        }
      })
Line 256: response.json()
Line 269: _tmp_67.push({
          type: "text",
          text: `Email Statistics Summary\n\n` +
                `Sent: ${sent} emails\n` +
                `Open Rate: ${openRate}% (${uniqueOpens}/${tracked} tracked emails)\n` +
                `Click Rate: ${clickRate}% (${uniqueLinksClicked}/${totalTrackedLinks} tracked links)\n\n` +
                `${fromDate || toDate ? `Period: ${fromDate || 'start'} to ${toDate || 'now'}\n` : ''}` +
                `${tag ? `Tag: ${tag}\n` : ''}`
        })
Line 284: main()
Line 286: process.exit(1)
