Setup.requireController     = controller.requireController
typeof(EntitySuper[callerName].instance._relations[entityName]) == 'undefined'
e.once('server#started', function(conf){


                // open default browser for dev env only
                // if ( isDev) {
                //     var payload = JSON.stringify({
                //         code    : 200,
                //         command  : "open"
                //     });

                //     if (self.ioClient) { // if client has already made connexion
                //         payload.command = "reload"
                //     } else {
                //         // get default home
                //         // helper/task::run() should be triggered from ioClient
                //         //run('open', [conf.hostname + conf.server.webroot])
                //     }
                // }

                // will start watchers from here
                callback()
            })
lib.generator.createFileFromDataSync(ports, self.portsPath)
console.warn('Dependency bundle config not found for `'+ app +'/'+ env +'`: trying to load on the fly from src')
_tmp_28.push({
        "labels": [
          "cp1257",
          "windows-1257",
          "x-cp1257"
        ],
        "name": "windows-1257"
      })
fs.stat(p, function(err, stats) {
                if (err) {
                    callback(err)
                } else {

                    if (stats.isDirectory()) {
                        callback(false, d)
                    } else {
                        callback(new Error('[ ' + d + ' ] is not a directory'))
                    }
                }
            })
JSON.parse(
                    replaceable
                        .replace(/\"\{(\w+)\}\"/g, function(s, key) {
                            if ( /^(true|false|null)$/i.test(dictionary[key]) ) {
                                return (/^(true|false|null)$/i.test(dictionary[key])) ? dictionary[key] : s
                            }
                            // When "{single}" and not "{sigle}/something"
                            if ( /^\"\{(\w+)\}\"$/i.test(s) && !dictionary[key]) {
                                //return ('"'+ dictionary[key] +'"' || s);
                                return '"'+ (dictionary[key] || s.replace(/\"/g, '')) +'"';
                            }
                            return '"'+ (dictionary[key] || s) +'"';
                        })
                        .replace(/\{(\w+)\}/g, function(s, key) {
                            return dictionary[key] || s;
                        })
                        // OS Environment Variables
          ...
_tmp_28.push({
        "labels": [
          "x-mac-cyrillic",
          "x-mac-ukrainian"
        ],
        "name": "x-mac-cyrillic"
      })
var rollback = function(err) {
        console.error('[ CLI ] could not complete protocol creation: ', (err.stack||err.message));
        console.info('[ CLI ] rolling back...');

        var writeFiles = function() {

            //restore env.json
            if ( typeof(local.envDataWrote) == 'undefined' ) {
                lib.generator.createFileFromDataSync(self.envData, self.envPath);
            }
            //restore project.json
            if ( typeof(local.projectDataWrote) == 'undefined' ) {
                if ( typeof(self.projectData.bundles[local.bundle]) != 'undefined') {
                    delete self.projectData.bundles[local.bundle];
                }
                lib.generator.createFileFromDataSync(self.projectData, self.projectConfigPath);
            }

            //restore ports.json
            if ( typeof(local.portsDataWrote) == 'undefined' ) {
                lib.generator.createFileFromDataSync(self.portsData, self.portsPath);
            }

         ...
instance['or'] = function () {
        arguments[arguments.length] = true;
        ++arguments.length;

        return instance.find.apply(this, arguments);
    }
_tmp_22.push({
    "encodings": [
      {
        "labels": [
          "chinese",
          "csgb2312",
          "csiso58gb231280",
          "gb2312",
          "gb_2312",
          "gb_2312-80",
          "gbk",
          "iso-ir-58",
          "x-gbk"
        ],
        "name": "gbk"
      },
      {
        "labels": [
          "gb18030"
        ],
        "name": "gb18030"
      },
      {
        "labels": [
          "hz-gb-2312"
        ],
        "name": "hz-gb-2312"
      }
    ],
    "heading": "Legacy multi-byte Chinese (simplified) encodings"
  })
e.on('error', function(err, request, response, next) {

                callback(err, request, response, next)
            })
_.prototype.renameSync = function(destination) {
        var self = this;
        var source = self.value;

        if ( !existsSync(source) ) {
            throw new Error('Cannot complete rename from `'+ source +'`: the path does not exist.');
        }

        try {
            fs.renameSync(source, destination);
        } catch (err) {
            throw err
        }
    }
let section = fNameWithNoExt.replace(/(^settings\.|^settings$)/, '').replace(new RegExp('\.'+ env +'$'), '').replace(new RegExp('\.json$'), '')
self.setLevel = function(level, group) {
        if ( typeof(group) == 'undefined' || /^gina\-/.test(group) ) {
            group = 'gina'
        }

        var opt = loggers[group]._options;
        level = level.toLowerCase();
        if ( typeof(opt.hierarchies[level]) == 'undefined' ) {
            console.warn('`'+ level +'` is not a valid level: swithcing to `info`');
            level = 'info';
        }

        opt.name = group;
        process.env.LOG_GROUP = group;
        opt.hierarchy = level;
        process.env.LOG_LEVEL = level;

        setColors(group);
        setDefaultLevels(group);


        self.debug('Log level set for `'+ group +'`: '+ level);

        return
    }
gna.getMountedBundles = process.getMountedBundles = function(callback) {
            fs.readdir(bundlesPath, function onRead(err, files) {
                callback(err, files)
            })
        }
register(trigger, queryOptions, onQueryCallback, _mainCallback)
self.resumeReporting = function(group) {

        //  [ duplicate output fix ]
        // if (group && loggers[group]._options) {
        //     self.warn('[logger]['+ group +'] now resuming ('+ group +')\n');
        //     loggers[group]._options.isFlushing = false;
        // }

        loggers[ctx._options.name]._options.isReporting = true;



    }
cmd.defaultScheme = (cmd.projectName != null && typeof(cmd.projects[cmd.projectName]) != 'undefined' && typeof(cmd.projects[cmd.projectName]['def_scheme']) != 'undefined' ) ? cmd.projects[cmd.projectName]['def_scheme'] :Â cmd.mainConfig['def_scheme'][ GINA_SHORT_VERSION ]
var staticProps = {
            firstLevel  : '/'+ url.split(/\//g)[1] + '/',
            isFile      :  /^\/[A-Za-z0-9_-]+\.(.*)$/.test(url)
        }
controllerOptions.conf.content.routing[controllerOptions.rule].param = params.param
cmd.projectName != null && typeof(cmd.projects[cmd.projectName]) != 'undefined'
self.log = function() {
        var opt = self.getOptions();
        var args = arguments, content = '';

        //To handle logs with coma separated arguments.
        for (let i=0; i<args.length; ++i) {

            if (args[i] instanceof Object) {
                //console.log("\n...", args[i], args[i].toString());
                content += JSON.stringify(args[i], null, '\t');
            } else {
                content += args[i];

                // In case of formated entries - eg.: spawned server that is already returning formated logs
                // if ( /(\[|\[\s+)debug/.test(args[i]) ) {
                //     // args[i] = args[i].replace(/\n$/, '');
                //     // self.debug(args[i].replace(/^.*\[debug.*\]\s+/, '').replace(/\n$/, ''));

                // emit(opt, 'log', content.replace(/\n$/, ''), true);
                // return;

                    // emit(opt, 'debug', content.replace(/\n$/, ''), true);

                    // for (let p=0, pLen=op...
_tmp_109.labels = [
          "cseuckr",
          "csksc56011987",
          "euc-kr",
          "iso-ir-149",
          "korean",
          "ks_c_5601-1987",
          "ks_c_5601-1989",
          "ksc5601",
          "ksc_5601",
          "windows-949"
        ]
section = section.replace(/-([a-z])/g, function(g) { return g[1].toUpperCase(); })
throw new Error('[ Collection ][ notIn ] `filters` argument must be defined: Array or Filter Object(s) expected');
bundleConf = self.conf[altConf.split(/\@/)[1]][bundleConf.env]
filename = (bundleConf.staticResources.indexOf(path) > -1) ? bundleConf.content.statics[path] + url.replace(backedupPath, '/') : bundleConf.content.statics[staticProps.firstLevel] + url.replace(staticProps.firstLevel, '/')
filename = (bundleConf.staticResources.indexOf(path) > -1) ? bundleConf.content.statics[path] + url.replace(path, '/') : bundleConf.content.statics[staticProps.firstLevel] + url.replace(staticProps.firstLevel, '/')
_tmp_22.push({
    "encodings": [
      {
        "labels": [
          "csiso2022kr",
          "iso-2022-cn",
            "iso-2022-cn-ext",
            "iso-2022-kr"
        ],
        "name": "replacement"
      },
      {
        "labels": [
          "utf-16be"
        ],
        "name": "utf-16be"
      },
      {
        "labels": [
          "utf-16",
          "utf-16le"
        ],
        "name": "utf-16le"
      },
      {
        "labels": [
          "x-user-defined"
        ],
        "name": "x-user-defined"
      }
    ],
    "heading": "Legacy miscellaneous encodings"
  })
var onRemoved = function(err, target) {
                        // err: 99% means that it doesn't exist. Well, we don't care do we ?.
                        if (!err) {

                            var isExcluded = false;
                            if ( typeof(source) != 'undefined' && excluded != undefined) {
                                var f, p = source.split('/');
                                f = p[p.length-1];
                                for (var r= 0; r<excluded.length; ++r) {
                                    if ( typeof(excluded[r]) == 'object' ) {
                                        if (excluded[r].test(f)) {
                                            isExcluded = true
                                        }
                                    } else if (f === excluded[r]) {
                                        isExcluded = true
                                    }
                                }
                            }
                         ...
cmd.bundlesByProject[project][bundle].protocols = cmd.projects[project].protocols
cmd.bundlesByProject[project][bundle].def_protocol = cmd.defaultProtocol
isValid = eval(compiledCondition)
