this.connect = function(dbString, cb) {
        // Attention: the connection is lost 5 minutes once the bucket is opened.
        var conn        = null;

        var onError = function (err, next) {
            delete self.instance.reconnecting;
            self.instance.reconnected = self.instance.connected = false;
            console.error('[ CONNECTOR ][ ' + local.bundle +' ] couchbase could not be reached !!\n'+ ( err.stack || err.message || err ) );

            // reconnecting
            console.debug('[ CONNECTOR ][ ' + local.bundle +' ][ ' + dbString.database +' ] trying to reconnect in a few secs...');
            self.instance.reconnecting = true;

            setTimeout( function onRetry(){
                if ( typeof(next) != 'undefined' ) {
                    self.connect(dbString, next)
                } else {
                    self.connect(dbString)
                }
            }, 5000)

        };

        // once
        var onConnect = function onConnect(cb...
var addBundles = function(b) {

        if (b > self.bundles.length-1) { // exits when done
            process.exit(0)
        }

        var options     = {}
            , bundle    = self.bundles[b]
        ;


        if ( /^[a-z0-9_.]/.test(bundle) ) {

            if ( !fs.existsSync(self.envPath) ) {
                lib.generator.createFileFromDataSync({}, self.envPath);
            }

            local.b             = b;
            local.bundle        = bundle;

            local.envFileSaved  = false;

            // find available port
            options = {
                ignore      : getPortsList(),
                limit       : getBundleScanLimit(bundle),
                startFrom   : self.startFrom
            };
            console.log('['+bundle+'] starting ports scan' );

            // scanning for available ports ...
            scan(options, function(err, ports){
                if (err) {
                    rollback(err);
                    return;
           ...
var end = function (opt, cmd, isBulkStop, i, error) {
        if ( typeof(opt.msg) != 'undefined' ) {
            opt.client.write('\n\r'+ opt.msg);
        }
        if (isBulkStop) {
            ++i;
            if ( typeof(self.bundles[i]) != 'undefined' ) {
                stop(opt, cmd, i)
            } else {
                opt.client.write('\n\r[ Offline ] '+ opt.offlineCount +'/'+ self.bundles.length +'\r');
                var notStoppedMsg = '';
                if (opt.notStopped.length > 1) {
                    notStoppedMsg = '\nThe following bundles could not be stopped or were not running: \n - '+ opt.notStopped.join('\n - ') + '\n\r';
                    opt.client.write(notStoppedMsg);
                }


                if ( typeof(error) != 'undefined') {
                    process.exit(1);
                }
                if (!opt.client.destroyed)
                    opt.client.emit('end');

                process.exit(0);
            }
        } else {
        ...
(_tmp_12 = part.on('header', function(header) {
      var contype,
          fieldname,
          parsed,
          charset,
          encoding,
          filename,
          group,
          nsize = 0;

      if (header['content-type']) {
        parsed = parseParams(header['content-type'][0]);
        if (parsed[0]) {
          contype = parsed[0].toLowerCase();
          for (i = 0, len = parsed.length; i < len; ++i) {
            if (RE_CHARSET.test(parsed[i][0])) {
              charset = parsed[i][1].toLowerCase();
              break;
            }
          }
        }
      }

      if (contype === undefined)
        contype = 'text/plain';
      if (charset === undefined)
        charset = defCharset;

      if (header['content-disposition']) {
        parsed = parseParams(header['content-disposition'][0]);
        if (!RE_FIELD.test(parsed[0]))
          return skipPart(part);
        for (i = 0, len = parsed.length; i < len; ++i) {
          if (RE_NAME.test(parsed[i][0])) {
      ...).on
gina.onError(function(err, req, res, next){
                // (code)   message
                // (16)     Generic network failure. Enable detailed error codes (via LCB_CNTL_DETAILED_ERRCODES, or via `detailed_errcodes` in the connection string) and/or enable logging to get more information
                // (23)     Client-Side timeout exceeded for operation. Inspect network conditions or increase the timeout
                //          cannot perform operations on a shutdown bucket
                //          err instanceof CouchbaseError

                if (!self.instance.connected) {
                    self.instance.reconnected = false;
                    self.instance.reconnecting = false;
                }

                if (
                    err instanceof couchbase.Error && err.code == 16 && !self.reconnected
                    //|| err instanceof couchbase.Error && err.code == 23 && !self.reconnecting
                    || /cannot perform operations on a shutdow...
var end = function(err) {
        console.debug('GINA_ENV_IS_DEV ', GINA_ENV_IS_DEV);
        if (err) {
            if (GINA_ENV_IS_DEV) {
                console.error(err.stack);
            } else {
                console.error(err.message);
            }

            return process.exit(1);
        }
        var env = local.env;
        console.log('Environment [ '+env+' ] removed with success');

        return process.exit(0)
    }
function ByteOutputStream = function ByteOutputStream(bytes) {
  /** @type {number} */
  var pos = 0;

  /**
   * @param {...number} var_args The byte or bytes to emit into the stream.
   * @returns {number} The last byte emitted.
   */
  this.emit = function(var_args) {
    /** @type {number} */
    var last = EOF_byte;
    var i;
    for (i = 0; i < arguments.length; ++i) {
      last = Number(arguments[i]);
      bytes[pos++] = last;
    }
    return last;
  };
}
Object.defineProperty( Array.prototype, 'inArray', {
            writable:   false,
            enumerable: false,
            //If loaded several times, it can lead to an exception. That's why I put this.
            configurable: true,
            value: function(o){ return this.indexOf(o)!=-1 }
        })
CouchbaseStore.prototype.get = function(sid, fn){
        if ('function' !== typeof fn) { fn = noop; }
        sid = this.prefix + sid;
        debug('GET "%s"', sid);
        this.client.get(sid, function(err, data){
            //Handle Key Not Found error
            if (err && err.code == 13) {
                return fn();
            }
            if (err) return fn(err);
            if (!data || !data.value) return fn();
            var result;
            data = data.value.toString();
            debug('GOT %s', data);
            try {
                result = JSON.parse(data);
            } catch (err) {
                return fn(err);
            }
            return fn(null, result);
        });
    }
var readSource = function (entities, entityName, source) {
        var arr             = source.split(/\//g)
            , name          = arr[arr.length-1].replace(/\.sql/, '') || null
            , comments      = ''
            , queryString   = null
            , includes      = null
            , queryStatement= null // this is the usable queryString
            , params        = []
            , inlineParams  = [] // order of use inside the query
            , returnType    = null // Array or Object : Array by default
            , returnVariable= null // return variable
        ;


        if (! /^\./.test(source) && name && typeof(conn[name]) == 'undefined' ) {
            // N.B: because of the cache, if replacement of placeholders is done, it will affect the statement
            queryString = fs.readFileSync( source ).toString();
            // handle includes
            includes = queryString.match(/\@include(.*)\;/g) || null;
            if ( includes && includes.length > ...
(_tmp_21 = rl
            .on('line', function(line) {

                if (!choice || typeof(choices[choice]) == 'undefined') { // protocol definition
                    choice = line.trim().toLowerCase();

                    if ( typeof(choices[choice]) != 'undefined') {
                        rl.clearLine();

                        // to the next question
                        list = '';
                        choicesOpt = JSON.clone(self.schemesAvailable);
                        choicesOpt.push('cancel');

                        for (var p = 0, len = choicesOpt.length; p < len; ++p) {

                            if (p < len-1) {
                                choices2[p+1] = choicesOpt[p];
                                choices2[choicesOpt[p]] = choicesOpt[p];
                            }

                            if (p == len-1) {
                                list += '\n';
                            }

                            if ( self.defaultScheme == choicesOpt[p...).on
var createPackageFile = function(target, isCreatedFromExistingPackage) {

        loadAssets();

        var conf = _(getPath('gina').core +'/template/conf/package.json', true);
        var contentFile = requireJSON(conf);
        var dic = {
            'project' : self.projectName,
            'node_version' : GINA_NODE_VERSION.match(/\d+/g).join('.'),
            'gina_version' : GINA_VERSION
        };

        contentFile = whisper(dic, contentFile);//data

        // Updating package.json if needed
        if (
            typeof(isCreatedFromExistingPackage) != 'undefined'
            && /^true$/i.test(isCreatedFromExistingPackage)
        ) {
            var existingPack = require(target);
            contentFile = merge(contentFile, existingPack);
            new _(target, true).rmSync()
        }

        lib.generator.createFileFromDataSync(
            contentFile,
            target
        );

        end(true)
    }
compressFile(method, input, output, zipInstance, isBatchProcessing, function(err, target, zipInstance) {
                    if ( isBatchProcessing ) {
                        cb(err, zipInstance);
                    } else {
                        self.emit('archiver-'+ method +'#complete', err, target)
                    }

                })
loadBundlesConfiguration( function(err, file, routing) {

                    if (err) {
                        console.error(err.stack||err.message);

                        setTimeout(() => {
                            process.exit(1);
                        }, 0);
                        return;
                    }

                    if ( typeof(Config.initialized) == 'undefined' ) {
                        Config.initialized  = true;
                        self.isStandalone   = self.Host.isStandalone();
                        self.bundle         = self.startingApp;
                        Config.instance     = self
                    }


                    //logger.debug('gina', 'CONFIG:DEBUG:42', 'CONF LOADED 43', __stack);
                    self.bundlesConfiguration = {
                        env             : self.Env.get(),
                        version         : self.version,
                        conf            : self.getInstance(),
                    ...
isCmdConfigured = function() {

        cmd.configured = ( typeof(cmd.configured) != 'undefined' ) ? cmd.configured : false;

        if (cmd.configured) return; // can only be called once !!

        var errMsg = null;

        try {

            // framework package
            //cmd.package     = require( _(GINA_HOMEDIR + '/template/conf/package.json', true) );


            // main config
            cmd.mainConfigPath = _(GINA_HOMEDIR + '/main.json', true);
            if ( typeof(require.cache[cmd.mainConfigPath]) != 'undefined') {
                delete require.cache[require.resolve(cmd.mainConfigPath)]
            }
            cmd.mainConfig  = requireJSON( cmd.mainConfigPath );

            // projectsprojects
            cmd.projectConfigPath = _(GINA_HOMEDIR + '/projects.json', true);
            if ( typeof(require.cache[cmd.projectConfigPath]) != 'undefined') {
                delete require.cache[require.resolve(cmd.projectConfigPath)]
            }

            cmd.p...
proc.on('uncaughtException', function(err) {

                if ( /ERR\_HTTP\_HEADERS\_SENT/.test(err.stack) ) {
                    console.error('[ SERVER ][ HTTP UNCAUGHT EXCEPTION ]', err.stack);
                    return false;
                }

                if ( /ERR\_HTTP2/.test(err.stack) ) {
                    console.warn('[ SERVER ][ HTTP2 UNCAUGHT EXCEPTION ]', err.stack);
                    return false;
                }

                //console.debug("[ PROC ] @=>", self.args);
                var bundle = self.bundle;
                var pid = self.getPidByBundleName(bundle);
                // Do not dissmis the framework
                if ( /^gina\-v/.test(bundle) ) {
                    if ( err.code == 'EPIPE' ) {
                        proc.stdout.write(err.stack);
                        return;
                    }
                    console.warn('[ FRAMEWORK ][ uncaughtException ] ', err.stack);
                    return;
                }

   ...
function basename = function basename(path) {
  var f = splitPathPosix(path)[2];
  if (f === path)
    f = splitPathWindows(path)[2];
  return f;
}
resetContext = function() {
        setPath('gina.root', getEnvVar('GINA_DIR'));
        var frameworkPath = getEnvVar('GINA_FRAMEWORK_DIR');
        setPath('framework', frameworkPath);
        setPath('gina.core', getEnvVar('GINA_CORE'));
        setPath('gina.lib', _(frameworkPath +'/lib'));
        setPath('gina.helpers', _(frameworkPath +'/helpers'));
        setPath( 'node', _(process.argv[0]), true);
        var projects    = require( _(getEnvVar('GINA_HOMEDIR') + '/projects.json', true) );
        var projectName = getContext('projectName');
        var root        = projects[projectName].path;
        setPath('project', root);
        var env         = getContext('env');
        var isDev       = (env === projects[projectName]['dev_env']) ? true: false;
        var bundlesPath = projects[projectName]['path'] + '/bundles'; // by default
        var isProductionScope = ('production' === projects[projectName]['def_scope']) ? true: false;
        if (isDev) {
            bundle...
entity.once(events[i].shortName, function () { // cannot be `entity.on` for prod/stage
                                            // check if not already fired
                                            if (entity._callbacks[events[i].shortName]) {

                                                entity.removeAllListeners([events[i].shortName]);
                                                console.log('\nFIRING #1 - promise ' + events[i].shortName +'('+ events[i].index  +')');
                                                cb.apply(this, arguments);
                                            }
                                        })
rl.setPrompt('Bundle [ '+ local.bundle +' ] already exists !\n(r) Replace - All existing files will be lost !\n(c) Cancel\n(i) Import\n> ')
self.bundlesConfiguration = {
                        env             : self.Env.get(),
                        version         : self.version,
                        conf            : self.getInstance(),
                        bundles         : self.getBundles(),
                        allBundles      : self.getAllBundles(),
                        isStandalone    : self.Host.isStandalone()
                    }
var createFolder = function(){
            if ( fs.existsSync(gnaFolder) ) {
                if ( !fs.existsSync(gnaFolder +'/'+ file) ) {
                    createContent(gnaFolder +'/'+ file, gnaFolder, content, function(err){
                        setTimeout(function(){
                            callback(err)
                        }, 500)
                    })
                } else { // already existing ... won't overwrite
                    callback(false)
                }

            } else {
                fs.mkdir(gnaFolder, 0777, function(err){
                    if (err) {
                        console.error(err.stack);
                        callback(err)
                    } else {
                        //Creating content.
                        createContent(gnaFolder+ '/' +file, gnaFolder, content, function(err){
                            setTimeout(function(){
                                callback(err)
                            }, 500)
         ...
conn = await couchbase.connect(dbString.protocol + dbString.host, dbString, function onBucketOpened(bErr, conn) {
                    if (bErr) {
                        // console.emerg('[ CONNECTOR ][ ' + local.bundle +' ] Could not connect to couchbase @`'+ dbString.protocol + dbString.host +'`\n'+ (bErr.stack || bErr.message || bErr) + '\nCheck:\n - if couchbabse is running\n - if bucket `'+dbString.bucketName+'` exists\n - if you have permission to access couchabase' );
                        var cErr = new Error('Could not connect to couchbase @`'+ dbString.protocol + dbString.host +'`\n'+ (bErr.stack || bErr.message || bErr) + '\nCheck:\n - if couchbabse is running\n - if bucket `'+dbString.bucketName+'` exists\n - if you have permission to access couchabase');

                        if ( typeof(cb) != 'undefined' ) {
                            return cb(cErr)
                        }
                        // return self.emit('ready', bErr, null);
                     ...
this.verifyCertificate = async function(endpoint, port) {
        let sslDetails = null;
        console.debug('Checking certificate validity...');
        try {
            sslDetails = await sslChecker(endpoint, {
                method: 'GET',
                // rejectUnauthorized: true,
                port: port || 443,
                ca: fs.readFileSync(self.conf[self.appName][self.env].content.settings.server.credentials.ca),
                agent: new https.Agent({
                    maxCachedSessions: 0
                })
            });
        } catch (err) {
            if (!sslDetails) {
                throw new Error('DNS issue ? Did you check your `/etc/hosts` or your DNS configuration ?\n'+ err.stack);
            }
            throw new Error(sslDetails +'\n'+ err.stack);
        }


        const failed  = !sslDetails.valid;
        const humanView = JSON.stringify(sslDetails, null, '  ');

        // Wildcard exception - See https://github.com/dyaa/ssl-checker/...
var end = function (output, type, messageOnly) {
        var err = false;
        if ( typeof(output) != 'undefined') {
            if ( output instanceof Error ) {
                err = output = ( typeof(messageOnly) != 'undefined' && /^true$/i.test(messageOnly) ) ? output.message : (output.stack||output.message);
            }
            if ( typeof(type) != 'undefined' ) {
                console[type](output)
            } else {
                console.log(output);
            }
        }

        process.exit( err ? 1:0 )
    }
eval('async function on'+functName+'(){ await promisify('+ funct + ')().catch(function(e){ console.error(e.toString()); process.exit(1);}).then(function(){ begin('+(i+1)+')});}; on'+functName+'();')
fs.stat(p, function(err, stats) {

                if (err) {
                    callback(err)
                } else {

                    if (stats.isDirectory()) {
                        callback(false, d)
                    } else {
                        callback(new Error('[ ' + d + ' ] is not a directory'))
                    }
                }
            })
entities[entityName].prototype[name] = function() {
                    var self = this;
                    var key     = null
                        , index = null
                        , i     = null
                        , len   = null
                        , args  = Array.prototype.slice.call(arguments)
                        , _mainCallback = null;

                    if ( params && params.length != args.length && !/function/.test(typeof(args[args.length-1])) ) {
                        throw new Error('[N1QL][ ' + entityName+'#'+name+'() ] arguments must match parameters length. Please refer to [ '+ source +' ]\nFound in param list: ('+ params.join(', ') +') !')
                    } else if ( /function/.test( typeof(args[args.length-1]) ) ) {
                        // to hande Nodejs Util.promisify
                        _mainCallback = args[args.length-1]
                    }

                    var sdkVersion = conn.sdk.version || 2;
                    var qu...
var getFormById = function(formId) {
        var $form = null, _id = formId;

        if ( !instance['$forms'] )
            throw new Error('`$forms` collection not found');

        if ( typeof(_id) == 'undefined') {
            throw new Error('[ FormValidator::getFormById(formId) ] `formId` is missing')
        }

        _id = _id.replace(/\#/, '');

        // in case form is created on the fly and is not yet registered
        if (document.getElementById(_id) != null && typeof (instance['$forms'][_id]) == 'undefined') {
            initForm( document.getElementById(_id) );
        }

        if ( typeof(instance.$forms[_id]) != 'undefined' ) {
            instance['$forms'][_id].withUserBindings = true;

            if ( typeof(this.$forms) != 'undefined' && typeof(this.$forms[_id]) == 'undefined' ) {
                $form = this.$forms[_id] = instance['$forms'][_id];
            } else {
                $form = instance.$forms[_id];
            }
        }

        if (!$form) {...
isBundleMounted(projects, bundlesPath, getContext('bundle'), function onBundleMounted(err) {
    if (err) {
        return abort(err);
    }
    // get configuration
    gna.getProjectConfiguration( async function onGettingProjectConfig(err, project) {

        if (err) console.error(err.stack);

        /**
         * On middleware initialization
         *
         * @callback callback
         *
         * */
        gna.onInitialize = process.onInitialize = function(callback) {

            gna.initialized = true;
            e.once('init', function(instance, middleware, conf) {

                var configuration = config.getInstance();

                modelUtil.loadAllModels(
                    conf.bundles,
                    configuration,
                    env,
                    function() {

                        joinContext(conf.contexts);
                        gna.getConfig = function(name){
                            var tmp = '';
                            ...
Setup.requireController     = controller.requireController
typeof(contentType) == 'undefined' || contentType == null
path = _(process.argv[1])
var portsReverse = require(_(GINA_HOMEDIR + '/ports.reverse.json'))
ext         = url.substr(url.lastIndexOf('.')).match(/(\.[A-Za-z0-9]+)/)[0]
!localOptions.template.javascriptsExcluded || localOptions.template.javascriptsExcluded != '**'
setPorts = function(bundle, portsAvailable, cb) {
        var portsPath           = _(GINA_HOMEDIR + '/ports.json', true)
            , portsReversePath  = _(GINA_HOMEDIR + '/ports.reverse.json', true)
            , envDataPath       = _(cmd.projects[cmd.projectName].path + '/env.json', true)
        ;

        if ( typeof(require.cache[portsPath]) != 'undefined') {
            delete require.cache[require.resolve(portsPath)]
        }
        if ( typeof(require.cache[portsReversePath]) != 'undefined') {
            delete require.cache[require.resolve(portsReversePath)]
        }
        if ( typeof(require.cache[envDataPath]) != 'undefined') {
            delete require.cache[require.resolve(envDataPath)]
        }

        var envData             = requireJSON(envDataPath)
            , portsData         = requireJSON(portsPath)
            , portsReverseData  = requireJSON(portsReversePath)
        ;


        var content                 = JSON.clone(envData)
            , port...
typeof(require.cache[portsReversePath]) != 'undefined'
result = {
                                    contentType : contentType,
                                    content     : xhr.responseText
                                }
var portsReverse          = JSON.clone(portsReverseData)
var allProjectEnvs        = cmd.projects[cmd.projectName].envs
var originHostReplacement = function(name) {
        var matched = name.match(/\{\s*(.*)\s*\}/g);
        if (!matched || !Array.isArray(matched) || Array.isArray(matched) && matched.length == 0 ) {
            return name
        }
        var env = self.envConf.env;

        for (let i=0, len=matched.length; i<len; ++i) {
            let oldHost = matched[i];
            let newHost = matched[i].replace(/\{|\}|\s+/g, '');
            newHost = newHost.split(/\@/);
            let bundle      = newHost[0]
                , project   = newHost[1]
                , arr       = null
                , hostname  = null
                , scheme    = null
            ;
            if ( /\//.test(newHost[1]) ) {
                arr     = newHost[1].split(/\//);
                project = arr[0];
                env     = (arr[1]) ? arr[1] : env;
            }
            scheme  = self.envConf[bundle][env].server.scheme;
            hostname  = ( !self.envConf[bundle][env].hostname ) ? self.env...
local.res.statusCode = ( typeof(localOptions.conf.server.coreConfiguration.statusCodes[data.page.data.status])  != 'undefined' ) ? data.page.data.status : 200
errors['isBoolean'] = replace(this.error || local.errorLabels['isBoolean'], this)
route.request = function(ignoreWebRoot, options) {

            var cb = null, _this = null;
            if ( typeof(arguments[arguments.length-1]) == 'function' ) {
                cb = arguments[arguments.length-1];
            }
            if ( typeof(arguments[2]) == 'object' ) {
                _this = arguments[2];
            }

            var wroot       = this.webroot || _this.webroot
                , hostname  = this.hostname || _this.hostname
                , url       = ( typeof(ignoreWebRoot) != 'undefined' && ignoreWebRoot == true ) ? path.replace(wroot, '/') : this.url || _this.url
            ;

            var scheme = ( /^https/.test(hostname) ) ? 'https' : 'http';

            if (isGFFCtx) {
                var target = ( typeof(options) != 'undefined' && typeof(options.target) != 'undefined' ) ? options.target : "_self";
                window.open(url, target)
            } else {
                if ( typeof(options.agent) == 'undefined' ) {
               ...
