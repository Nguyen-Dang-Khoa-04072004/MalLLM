// File: tmp/tmp49m2psr0/@ahmedhfarag-ngx-virtual-scroller/package/fesm2022/ahmedfharag-ngx-virtual-scroller.mjs
// ======================================================================
Line 1: var i0 = require("@angular/core")
Line 2: var EventEmitter = require("@angular/core").EventEmitter
Line 3: var isPlatformServer = require("@angular/common").isPlatformServer
Line 4: var tween = require("@tweenjs/tween.js")
Line 94: this.debounce(() => {
                this.refresh_internal(false);
            }, this.scrollDebounceTime)
Line 99: this.throttleTrailing(() => {
                this.refresh_internal(false);
            }, this.scrollThrottlingTime)
Line 121: _items = [];
Line 125: {
        if (value === this._items) {
            return;
        }
        this._items = value || [];
        this.refresh_internal(true);
    }
Line 129: this._items = value || []
Line 142: this.getScrollElement()
Line 143: {
            scrollElement.style['overflow-y'] = this.oldParentScrollOverflow.y;
            scrollElement.style['overflow-x'] = this.oldParentScrollOverflow.x;
        }
Line 144: scrollElement.style['overflow-y'] = this.oldParentScrollOverflow.y
Line 145: scrollElement.style['overflow-x'] = this.oldParentScrollOverflow.x
Line 161: this.getScrollElement()
Line 162: {
            this.oldParentScrollOverflow = { x: scrollElement.style['overflow-x'], y: scrollElement.style['overflow-y'] };
            scrollElement.style['overflow-y'] = this.horizontal ? 'visible' : 'auto';
            scrollElement.style['overflow-x'] = this.horizontal ? 'auto' : 'visible';
        }
Line 163: this.oldParentScrollOverflow = { x: scrollElement.style['overflow-x'], y: scrollElement.style['overflow-y'] }
Line 164: scrollElement.style['overflow-y'] = this.horizontal ? 'visible' : 'auto'
Line 165: scrollElement.style['overflow-x'] = this.horizontal ? 'auto' : 'visible'
Line 198: this.compareItems(this.items[this.previousViewPort.startIndexWithBuffer + i], this.viewPortItems[i])
Line 236: {
            let cachedMeasurement = this.wrapGroupDimensions.maxChildSizePerWrapGroup[index];
            if (cachedMeasurement) {
                this.wrapGroupDimensions.maxChildSizePerWrapGroup[index] = undefined;
                --this.wrapGroupDimensions.numberOfKnownWrapGroupChildSizes;
                this.wrapGroupDimensions.sumOfKnownWrapGroupChildWidths -= cachedMeasurement.childWidth || 0;
                this.wrapGroupDimensions.sumOfKnownWrapGroupChildHeights -= cachedMeasurement.childHeight || 0;
            }
        }
Line 237: let cachedMeasurement = this.wrapGroupDimensions.maxChildSizePerWrapGroup[index]
Line 238: {
                this.wrapGroupDimensions.maxChildSizePerWrapGroup[index] = undefined;
                --this.wrapGroupDimensions.numberOfKnownWrapGroupChildSizes;
                this.wrapGroupDimensions.sumOfKnownWrapGroupChildWidths -= cachedMeasurement.childWidth || 0;
                this.wrapGroupDimensions.sumOfKnownWrapGroupChildHeights -= cachedMeasurement.childHeight || 0;
            }
Line 239: this.wrapGroupDimensions.maxChildSizePerWrapGroup[index] = undefined
Line 283: this.calculatePadding(index, dimensions)
Line 284: {
            scroll -= dimensions.wrapGroupsPerPage * dimensions[this._childScrollDim];
        }
Line 285: scroll -= dimensions.wrapGroupsPerPage * dimensions[this._childScrollDim]
Line 287: this.scrollToPosition(scroll, animationMilliseconds, animationCompletedCallback)
Line 289: {
        scrollPosition += this.getElementsOffset();
        animationMilliseconds = animationMilliseconds === undefined ? this.scrollAnimationTime : animationMilliseconds;
        let scrollElement = this.getScrollElement();
        let animationRequest;
        if (this.currentTween) {
            this.currentTween.stop();
            this.currentTween = undefined;
        }
        if (!animationMilliseconds) {
            this.renderer.setProperty(scrollElement, this._scrollType, scrollPosition);
            this.refresh_internal(false, animationCompletedCallback);
            return;
        }
        const tweenConfigObj = { scrollPosition: scrollElement[this._scrollType] };
        let newTween = new tween.Tween(tweenConfigObj)
            .to({ scrollPosition }, animationMilliseconds)
            .easing(tween.Easing.Quadratic.Out)
            .onUpdate((data) => {
            if (isNaN(data.scrollPosition)) {
                return;
            }
            this.renderer....
Line 292: this.getScrollElement()
Line 295: this.currentTween.stop()
Line 303: const tweenConfigObj = { scrollPosition: scrollElement[this._scrollType] }
Line 304: new tween.Tween(tweenConfigObj)
            .to({ scrollPosition }, animationMilliseconds)
            .easing(tween.Easing.Quadratic.Out)
            .onUpdate((data) => {
            if (isNaN(data.scrollPosition)) {
                return;
            }
            this.renderer.setProperty(scrollElement, this._scrollType, data.scrollPosition);
            this.refresh_internal(false);
        })
Line 315: cancelAnimationFrame(animationRequest)
Line 335: {
        this.element = element;
        this.renderer = renderer;
        this.zone = zone;
        this.changeDetectorRef = changeDetectorRef;
        this.isAngularUniversalSSR = isPlatformServer(platformId);
        this.checkResizeInterval = options.checkResizeInterval;
        this.modifyOverflowStyleOfParentScroll = options.modifyOverflowStyleOfParentScroll;
        this.resizeBypassRefreshThreshold = options.resizeBypassRefreshThreshold;
        this.scrollAnimationTime = options.scrollAnimationTime;
        this.scrollDebounceTime = options.scrollDebounceTime;
        this.scrollThrottlingTime = options.scrollThrottlingTime;
        this.scrollbarHeight = options.scrollbarHeight;
        this.scrollbarWidth = options.scrollbarWidth;
        this.stripedTable = options.stripedTable;
        this.horizontal = false;
        this.resetWrapGroupDimensions();
    }
Line 340: isPlatformServer(platformId)
Line 351: this.resetWrapGroupDimensions()
Line 353: {
        const result = element.getBoundingClientRect();
        const styles = getComputedStyle(element);
        const marginTop = parseInt(styles['margin-top'], 10) || 0;
        const marginBottom = parseInt(styles['margin-bottom'], 10) || 0;
        const marginLeft = parseInt(styles['margin-left'], 10) || 0;
        const marginRight = parseInt(styles['margin-right'], 10) || 0;
        return {
            x: result.left,
            y: result.top,
            top: result.top + marginTop,
            bottom: result.bottom + marginBottom,
            left: result.left + marginLeft,
            right: result.right + marginRight,
            width: result.width + marginLeft + marginRight,
            height: result.height + marginTop + marginBottom,
            toJSON: () => null
        };
    }
Line 355: getComputedStyle(element)
Line 356: const marginTop = parseInt(styles['margin-top'], 10) || 0
Line 357: const marginBottom = parseInt(styles['margin-bottom'], 10) || 0
Line 358: const marginLeft = parseInt(styles['margin-left'], 10) || 0
Line 359: const marginRight = parseInt(styles['margin-right'], 10) || 0
Line 374: this.getScrollElement()
Line 418: {
        const throttled = this.throttleTrailing(func, wait);
        const result = function () {
            throttled['cancel']();
            throttled.apply(this, arguments);
        };
        result['cancel'] = function () {
            throttled['cancel']();
        };
        return result;
    }
Line 419: this.throttleTrailing(func, wait)
Line 420: {
            throttled['cancel']();
            throttled.apply(this, arguments);
        }
Line 421: throttled['cancel']()
Line 424: result['cancel'] = function () {
            throttled['cancel']();
        }
Line 425: throttled['cancel']()
Line 429: {
        let timeout = undefined;
        let _arguments = arguments;
        const result = function () {
            const _this = this;
            _arguments = arguments;
            if (timeout) {
                return;
            }
            if (wait <= 0) {
                func.apply(_this, _arguments);
            }
            else {
                timeout = setTimeout(function () {
                    timeout = undefined;
                    func.apply(_this, _arguments);
                }, wait);
            }
        };
        result['cancel'] = function () {
            if (timeout) {
                clearTimeout(timeout);
                timeout = undefined;
            }
        };
        return result;
    }
Line 441: {
                timeout = setTimeout(function () {
                    timeout = undefined;
                    func.apply(_this, _arguments);
                }, wait);
            }
Line 442: timeout = setTimeout(function () {
                    timeout = undefined;
                    func.apply(_this, _arguments);
                }, wait)
Line 448: result['cancel'] = function () {
            if (timeout) {
                clearTimeout(timeout);
                timeout = undefined;
            }
        }
Line 450: clearTimeout(timeout)
Line 476: {
                    let oldStartItem = oldViewPortItems[0];
                    let oldStartItemIndex = this.items.findIndex(x => this.compareItems(oldStartItem, x));
                    if (oldStartItemIndex > this.previousViewPort.startIndexWithBuffer) {
                        let itemOrderChanged = false;
                        for (let i = 1; i < this.viewPortItems.length; ++i) {
                            if (!this.compareItems(this.items[oldStartItemIndex + i], oldViewPortItems[i])) {
                                itemOrderChanged = true;
                                break;
                            }
                        }
                        if (!itemOrderChanged) {
                            this.scrollToPosition(this.previousViewPort.scrollStartPosition + scrollLengthDelta, 0, oldRefreshCompletedCallback);
                            return;
                        }
                    }
                }
Line 477: let oldStartItem = oldViewPortItems[0]
Line 478: this.compareItems(oldStartItem, x)
Line 482: this.compareItems(this.items[oldStartItemIndex + i], oldViewPortItems[i])
Line 488: this.scrollToPosition(this.previousViewPort.scrollStartPosition + scrollLengthDelta, 0, oldRefreshCompletedCallback)
Line 501: this.resetWrapGroupDimensions()
Line 511: this.renderer.setStyle(this.invisiblePaddingElementRef.nativeElement, 'transform', `${this._invisiblePaddingProperty}(${viewport.scrollLength})`)
Line 512: this.renderer.setStyle(this.invisiblePaddingElementRef.nativeElement, 'webkitTransform', `${this._invisiblePaddingProperty}(${viewport.scrollLength})`)
Line 516: this.renderer.setStyle(this.contentElementRef.nativeElement, this._marginDir, `${viewport.padding}px`)
Line 519: this.renderer.setStyle(this.contentElementRef.nativeElement, 'transform', `${this._translateDir}(${viewport.padding}px)`)
Line 520: this.renderer.setStyle(this.contentElementRef.nativeElement, 'webkitTransform', `${this._translateDir}(${viewport.padding}px)`)
Line 523: {
                    let scrollPosition = this.getScrollElement()[this._scrollType];
                    let containerOffset = this.getElementsOffset();
                    let offset = Math.max(scrollPosition - viewport.padding - containerOffset + this.headerElementRef.nativeElement.clientHeight, 0);
                    this.renderer.setStyle(this.headerElementRef.nativeElement, 'transform', `${this._translateDir}(${offset}px)`);
                    this.renderer.setStyle(this.headerElementRef.nativeElement, 'webkitTransform', `${this._translateDir}(${offset}px)`);
                }
Line 524: let scrollPosition = this.getScrollElement()[this._scrollType]
Line 527: this.renderer.setStyle(this.headerElementRef.nativeElement, 'transform', `${this._translateDir}(${offset}px)`)
Line 528: this.renderer.setStyle(this.headerElementRef.nativeElement, 'webkitTransform', `${this._translateDir}(${offset}px)`)
Line 540: {
                        // update the scroll list to trigger re-render of components in viewport
                        this.viewPortItems = viewport.startIndexWithBuffer >= 0 && viewport.endIndexWithBuffer >= 0 ? this.items.slice(viewport.startIndexWithBuffer, viewport.endIndexWithBuffer + 1) : [];
                        this.vsUpdate.emit(this.viewPortItems);
                        if (startChanged) {
                            this.vsStart.emit(changeEventArg);
                        }
                        if (endChanged) {
                            this.vsEnd.emit(changeEventArg);
                        }
                        if (startChanged || endChanged) {
                            this.changeDetectorRef.markForCheck();
                            this.vsChange.emit(changeEventArg);
                        }
                        if (maxRunTimes > 0) {
                            this.refresh_internal(false, refreshCompletedCallback, maxRunTimes - 1);
    ...
Line 542: this.viewPortItems = viewport.startIndexWithBuffer >= 0 && viewport.endIndexWithBuffer >= 0 ? this.items.slice(viewport.startIndexWithBuffer, viewport.endIndexWithBuffer + 1) : []
Line 543: this.vsUpdate.emit(this.viewPortItems)
Line 545: this.vsStart.emit(changeEventArg)
Line 548: this.vsEnd.emit(changeEventArg)
Line 551: this.changeDetectorRef.markForCheck()
Line 552: this.vsChange.emit(changeEventArg)
Line 559: refreshCompletedCallback()
Line 562: this.executeRefreshOutsideAngularZone
Line 565: {
                        this.zone.run(handleChanged);
                    }
Line 566: this.zone.run(handleChanged)
Line 575: refreshCompletedCallback()
Line 588: this.getScrollElement()
Line 597: {
                    this.checkScrollElementResizedTimer = setInterval(() => { this.checkScrollElementResized(); }, this._checkResizeInterval);
                }
Line 598: this.checkScrollElementResizedTimer = setInterval(() => { this.checkScrollElementResized(); }, this._checkResizeInterval)
Line 608: this.disposeScrollHandler()
Line 612: this.disposeResizeHandler()
Line 621: {
            offset += this.containerElementRef.nativeElement[this._offsetType];
        }
Line 622: offset += this.containerElementRef.nativeElement[this._offsetType]
Line 625: this.getScrollElement()
Line 634: {
                offset += scrollElement[this._scrollType];
            }
Line 635: offset += scrollElement[this._scrollType]
Line 640: {
        if (this.isAngularUniversalSSR) {
            return Math.round(this.horizontal ? this.ssrViewportHeight / this.ssrChildHeight : this.ssrViewportWidth / this.ssrChildWidth);
        }
        let propertyName = this.horizontal ? 'offsetLeft' : 'offsetTop';
        let children = ((this.containerElementRef && this.containerElementRef.nativeElement) || this.contentElementRef.nativeElement).children;
        let childrenLength = children ? children.length : 0;
        if (childrenLength === 0) {
            return 1;
        }
        let firstOffset = children[0][propertyName];
        let result = 1;
        while (result < childrenLength && firstOffset === children[result][propertyName]) {
            ++result;
        }
        return result;
    }
Line 650: let firstOffset = children[0][propertyName]
Line 653: ++result
Line 659: {
            windowScrollValue = window[this._pageOffsetType];
        }
Line 660: windowScrollValue = window[this._pageOffsetType]
Line 662: this.getScrollElement()
Line 674: {
            const oldWrapGroupDimension = oldWrapGroupDimensions.maxChildSizePerWrapGroup[wrapGroupIndex];
            if (!oldWrapGroupDimension || !oldWrapGroupDimension.items || !oldWrapGroupDimension.items.length) {
                continue;
            }
            if (oldWrapGroupDimension.items.length !== itemsPerWrapGroup) {
                return;
            }
            let itemsChanged = false;
            let arrayStartIndex = itemsPerWrapGroup * wrapGroupIndex;
            for (let i = 0; i < itemsPerWrapGroup; ++i) {
                if (!this.compareItems(oldWrapGroupDimension.items[i], this.items[arrayStartIndex + i])) {
                    itemsChanged = true;
                    break;
                }
            }
            if (!itemsChanged) {
                ++this.wrapGroupDimensions.numberOfKnownWrapGroupChildSizes;
                this.wrapGroupDimensions.sumOfKnownWrapGroupChildWidths += oldWrapGroupDimension.childWidth || 0;
                this.wra...
Line 675: const oldWrapGroupDimension = oldWrapGroupDimensions.maxChildSizePerWrapGroup[wrapGroupIndex]
Line 685: this.compareItems(oldWrapGroupDimension.items[i], this.items[arrayStartIndex + i])
Line 690: {
                ++this.wrapGroupDimensions.numberOfKnownWrapGroupChildSizes;
                this.wrapGroupDimensions.sumOfKnownWrapGroupChildWidths += oldWrapGroupDimension.childWidth || 0;
                this.wrapGroupDimensions.sumOfKnownWrapGroupChildHeights += oldWrapGroupDimension.childHeight || 0;
                this.wrapGroupDimensions.maxChildSizePerWrapGroup[wrapGroupIndex] = oldWrapGroupDimension;
            }
Line 694: this.wrapGroupDimensions.maxChildSizePerWrapGroup[wrapGroupIndex] = oldWrapGroupDimension
Line 699: this.getScrollElement()
Line 715: Math.ceil(viewportWidth / defaultChildWidth)
Line 716: Math.ceil(viewportHeight / defaultChildHeight)
Line 720: {
                if (!this.childWidth || !this.childHeight) {
                    if (!this.minMeasuredChildWidth && viewportWidth > 0) {
                        this.minMeasuredChildWidth = viewportWidth;
                    }
                    if (!this.minMeasuredChildHeight && viewportHeight > 0) {
                        this.minMeasuredChildHeight = viewportHeight;
                    }
                }
                let child = content.children[0];
                let clientRect = this.getElementSize(child);
                this.minMeasuredChildWidth = Math.min(this.minMeasuredChildWidth, clientRect.width);
                this.minMeasuredChildHeight = Math.min(this.minMeasuredChildHeight, clientRect.height);
            }
Line 729: let child = content.children[0]
Line 736: Math.ceil(viewportWidth / defaultChildWidth)
Line 737: Math.ceil(viewportHeight / defaultChildHeight)
Line 740: {
            let scrollOffset = scrollElement[this._scrollType] - (this.previousViewPort ? this.previousViewPort.padding : 0);
            let arrayStartIndex = this.previousViewPort.startIndexWithBuffer || 0;
            let wrapGroupIndex = Math.ceil(arrayStartIndex / itemsPerWrapGroup);
            let maxWidthForWrapGroup = 0;
            let maxHeightForWrapGroup = 0;
            let sumOfVisibleMaxWidths = 0;
            let sumOfVisibleMaxHeights = 0;
            wrapGroupsPerPage = 0;
            for (let i = 0; i < content.children.length; ++i) {
                ++arrayStartIndex;
                let child = content.children[i];
                let clientRect = this.getElementSize(child);
                maxWidthForWrapGroup = Math.max(maxWidthForWrapGroup, clientRect.width);
                maxHeightForWrapGroup = Math.max(maxHeightForWrapGroup, clientRect.height);
                if (arrayStartIndex % itemsPerWrapGroup === 0) {
                    let oldValue = this.wra...
Line 741: let scrollOffset = scrollElement[this._scrollType] - (this.previousViewPort ? this.previousViewPort.padding : 0)
Line 743: Math.ceil(arrayStartIndex / itemsPerWrapGroup)
Line 749: {
                ++arrayStartIndex;
                let child = content.children[i];
                let clientRect = this.getElementSize(child);
                maxWidthForWrapGroup = Math.max(maxWidthForWrapGroup, clientRect.width);
                maxHeightForWrapGroup = Math.max(maxHeightForWrapGroup, clientRect.height);
                if (arrayStartIndex % itemsPerWrapGroup === 0) {
                    let oldValue = this.wrapGroupDimensions.maxChildSizePerWrapGroup[wrapGroupIndex];
                    if (oldValue) {
                        --this.wrapGroupDimensions.numberOfKnownWrapGroupChildSizes;
                        this.wrapGroupDimensions.sumOfKnownWrapGroupChildWidths -= oldValue.childWidth || 0;
                        this.wrapGroupDimensions.sumOfKnownWrapGroupChildHeights -= oldValue.childHeight || 0;
                    }
                    ++this.wrapGroupDimensions.numberOfKnownWrapGroupChildSizes;
                    const items = this.items.slice(arraySt...
Line 751: let child = content.children[i]
Line 755: {
                    let oldValue = this.wrapGroupDimensions.maxChildSizePerWrapGroup[wrapGroupIndex];
                    if (oldValue) {
                        --this.wrapGroupDimensions.numberOfKnownWrapGroupChildSizes;
                        this.wrapGroupDimensions.sumOfKnownWrapGroupChildWidths -= oldValue.childWidth || 0;
                        this.wrapGroupDimensions.sumOfKnownWrapGroupChildHeights -= oldValue.childHeight || 0;
                    }
                    ++this.wrapGroupDimensions.numberOfKnownWrapGroupChildSizes;
                    const items = this.items.slice(arrayStartIndex - itemsPerWrapGroup, arrayStartIndex);
                    this.wrapGroupDimensions.maxChildSizePerWrapGroup[wrapGroupIndex] = {
                        childWidth: maxWidthForWrapGroup,
                        childHeight: maxHeightForWrapGroup,
                        items: items
                    };
                    this.wrapGroupDimensions.sumOfKnownWrapGroupChildWidths...
Line 756: let oldValue = this.wrapGroupDimensions.maxChildSizePerWrapGroup[wrapGroupIndex]
Line 764: this.wrapGroupDimensions.maxChildSizePerWrapGroup[wrapGroupIndex] = {
                        childWidth: maxWidthForWrapGroup,
                        childHeight: maxHeightForWrapGroup,
                        items: items
                    }
Line 795: ++wrapGroupIndex
Line 806: Math.ceil((viewportWidth - sumOfVisibleMaxWidths) / defaultChildWidth)
Line 811: Math.ceil((viewportHeight - sumOfVisibleMaxHeights) / defaultChildHeight)
Line 818: Math.ceil(itemCount / itemsPerWrapGroup)
Line 823: {
                let childSize = this.wrapGroupDimensions.maxChildSizePerWrapGroup[i] && this.wrapGroupDimensions.maxChildSizePerWrapGroup[i][this._childScrollDim];
                if (childSize) {
                    scrollLength += childSize;
                }
                else {
                    ++numUnknownChildSizes;
                }
            }
Line 824: let childSize = this.wrapGroupDimensions.maxChildSizePerWrapGroup[i] && this.wrapGroupDimensions.maxChildSizePerWrapGroup[i][this._childScrollDim]
Line 857: {
        if (dimensions.itemCount === 0) {
            return 0;
        }
        let defaultScrollLengthPerWrapGroup = dimensions[this._childScrollDim];
        let startingWrapGroupIndex = Math.floor(arrayStartIndexWithBuffer / dimensions.itemsPerWrapGroup) || 0;
        if (!this.enableUnequalChildrenSizes) {
            return defaultScrollLengthPerWrapGroup * startingWrapGroupIndex;
        }
        let numUnknownChildSizes = 0;
        let result = 0;
        for (let i = 0; i < startingWrapGroupIndex; ++i) {
            let childSize = this.wrapGroupDimensions.maxChildSizePerWrapGroup[i] && this.wrapGroupDimensions.maxChildSizePerWrapGroup[i][this._childScrollDim];
            if (childSize) {
                result += childSize;
            }
            else {
                ++numUnknownChildSizes;
            }
        }
        result += Math.round(numUnknownChildSizes * defaultScrollLengthPerWrapGroup);
        return result;
    }
Line 861: let defaultScrollLengthPerWrapGroup = dimensions[this._childScrollDim]
Line 868: {
            let childSize = this.wrapGroupDimensions.maxChildSizePerWrapGroup[i] && this.wrapGroupDimensions.maxChildSizePerWrapGroup[i][this._childScrollDim];
            if (childSize) {
                result += childSize;
            }
            else {
                ++numUnknownChildSizes;
            }
        }
Line 869: let childSize = this.wrapGroupDimensions.maxChildSizePerWrapGroup[i] && this.wrapGroupDimensions.maxChildSizePerWrapGroup[i][this._childScrollDim]
Line 882: {
            const numberOfWrapGroups = Math.ceil(dimensions.itemCount / dimensions.itemsPerWrapGroup);
            let totalScrolledLength = 0;
            let defaultScrollLengthPerWrapGroup = dimensions[this._childScrollDim];
            for (let i = 0; i < numberOfWrapGroups; ++i) {
                let childSize = this.wrapGroupDimensions.maxChildSizePerWrapGroup[i] && this.wrapGroupDimensions.maxChildSizePerWrapGroup[i][this._childScrollDim];
                if (childSize) {
                    totalScrolledLength += childSize;
                }
                else {
                    totalScrolledLength += defaultScrollLengthPerWrapGroup;
                }
                if (scrollPosition < totalScrolledLength) {
                    scrollPercentage = i / numberOfWrapGroups;
                    break;
                }
            }
        }
Line 883: Math.ceil(dimensions.itemCount / dimensions.itemsPerWrapGroup)
Line 885: let defaultScrollLengthPerWrapGroup = dimensions[this._childScrollDim]
Line 886: {
                let childSize = this.wrapGroupDimensions.maxChildSizePerWrapGroup[i] && this.wrapGroupDimensions.maxChildSizePerWrapGroup[i][this._childScrollDim];
                if (childSize) {
                    totalScrolledLength += childSize;
                }
                else {
                    totalScrolledLength += defaultScrollLengthPerWrapGroup;
                }
                if (scrollPosition < totalScrolledLength) {
                    scrollPercentage = i / numberOfWrapGroups;
                    break;
                }
            }
Line 887: let childSize = this.wrapGroupDimensions.maxChildSizePerWrapGroup[i] && this.wrapGroupDimensions.maxChildSizePerWrapGroup[i][this._childScrollDim]
Line 913: Math.ceil(startingArrayIndex_fractional)
Line 951: this.calculatePadding(pageInfo.startIndexWithBuffer, dimensions)
Line 965: _tmp_52.push({ token: 'virtual-scroller-default-options', optional: true })
Line 966: { minVersion: "14.0.0", version: "19.1.4", type: VirtualScrollerComponent, isStandalone: true, selector: "virtual-scroller,[virtualScroller]", inputs: { executeRefreshOutsideAngularZone: "executeRefreshOutsideAngularZone", enableUnequalChildrenSizes: "enableUnequalChildrenSizes", RTL: "RTL", useMarginInsteadOfTranslate: "useMarginInsteadOfTranslate", modifyOverflowStyleOfParentScroll: "modifyOverflowStyleOfParentScroll", stripedTable: "stripedTable", scrollbarWidth: "scrollbarWidth", scrollbarHeight: "scrollbarHeight", childWidth: "childWidth", childHeight: "childHeight", ssrChildWidth: "ssrChildWidth", ssrChildHeight: "ssrChildHeight", ssrViewportWidth: "ssrViewportWidth", ssrViewportHeight: "ssrViewportHeight", bufferAmount: "bufferAmount", scrollAnimationTime: "scrollAnimationTime", resizeBypassRefreshThreshold: "resizeBypassRefreshThreshold", scrollThrottlingTime: "scrollThrottlingTime", scrollDebounceTime: "scrollDebounceTime", checkResizeInterval: "checkResizeInterval", items:...
Line 971: _tmp_59.styles = [":host{position:relative;display:block;-webkit-overflow-scrolling:touch}:host.horizontal.selfScroll{overflow-y:visible;overflow-x:auto}:host.horizontal.selfScroll.rtl{transform:scaleX(-1)}:host.vertical.selfScroll{overflow-y:auto;overflow-x:visible}.scrollable-content{top:0;left:0;width:100%;height:100%;max-width:100vw;max-height:100vh;position:absolute}.scrollable-content ::ng-deep>*{box-sizing:border-box}:host.horizontal{white-space:nowrap}:host.horizontal .scrollable-content{display:flex}:host.horizontal .scrollable-content ::ng-deep>*{flex-shrink:0;flex-grow:0;white-space:initial}:host.horizontal.rtl .scrollable-content ::ng-deep>*{transform:scaleX(-1)}.total-padding{position:absolute;top:0;left:0;height:1px;width:1px;transform-origin:0 0;opacity:0}:host.horizontal .total-padding{height:100%}\n"]
Line 973: _tmp_78.decorators = [{
            type: Component,
            args: [{ selector: 'virtual-scroller,[virtualScroller]', standalone: true, imports: [CommonModule], exportAs: 'virtualScroller', template: `
	  <div class="total-padding" #invisiblePadding></div>
	  <div class="scrollable-content" #content>
		<ng-content></ng-content>
	  </div>
	`, host: {
                        '[class.horizontal]': 'horizontal',
                        '[class.vertical]': '!horizontal',
                        '[class.selfScroll]': '!parentScroll',
                        '[class.rtl]': 'RTL'
                    }, styles: [":host{position:relative;display:block;-webkit-overflow-scrolling:touch}:host.horizontal.selfScroll{overflow-y:visible;overflow-x:auto}:host.horizontal.selfScroll.rtl{transform:scaleX(-1)}:host.vertical.selfScroll{overflow-y:auto;overflow-x:visible}.scrollable-content{top:0;left:0;width:100%;height:100%;max-width:100vw;max-height:100vh;position:absolute}.scrollable-content ::ng-deep>*{box-sizing:bord...
Line 975: _tmp_80.args = [{ selector: 'virtual-scroller,[virtualScroller]', standalone: true, imports: [CommonModule], exportAs: 'virtualScroller', template: `
	  <div class="total-padding" #invisiblePadding></div>
	  <div class="scrollable-content" #content>
		<ng-content></ng-content>
	  </div>
	`, host: {
                        '[class.horizontal]': 'horizontal',
                        '[class.vertical]': '!horizontal',
                        '[class.selfScroll]': '!parentScroll',
                        '[class.rtl]': 'RTL'
                    }, styles: [":host{position:relative;display:block;-webkit-overflow-scrolling:touch}:host.horizontal.selfScroll{overflow-y:visible;overflow-x:auto}:host.horizontal.selfScroll.rtl{transform:scaleX(-1)}:host.vertical.selfScroll{overflow-y:auto;overflow-x:visible}.scrollable-content{top:0;left:0;width:100%;height:100%;max-width:100vw;max-height:100vh;position:absolute}.scrollable-content ::ng-deep>*{box-sizing:border-box}:host.horizontal{white-space:nowrap}:host.h...
Line 980: _tmp_82.host = {
                        '[class.horizontal]': 'horizontal',
                        '[class.vertical]': '!horizontal',
                        '[class.selfScroll]': '!parentScroll',
                        '[class.rtl]': 'RTL'
                    }
Line 981: _tmp_84.[class.horizontal] = "horizontal"
Line 982: _tmp_84.[class.vertical] = "!horizontal"
Line 983: _tmp_84.[class.selfScroll] = "!parentScroll"
Line 984: _tmp_84.[class.rtl] = "RTL"
Line 985: _tmp_82.styles = [":host{position:relative;display:block;-webkit-overflow-scrolling:touch}:host.horizontal.selfScroll{overflow-y:visible;overflow-x:auto}:host.horizontal.selfScroll.rtl{transform:scaleX(-1)}:host.vertical.selfScroll{overflow-y:auto;overflow-x:visible}.scrollable-content{top:0;left:0;width:100%;height:100%;max-width:100vw;max-height:100vh;position:absolute}.scrollable-content ::ng-deep>*{box-sizing:border-box}:host.horizontal{white-space:nowrap}:host.horizontal .scrollable-content{display:flex}:host.horizontal .scrollable-content ::ng-deep>*{flex-shrink:0;flex-grow:0;white-space:initial}:host.horizontal.rtl .scrollable-content ::ng-deep>*{transform:scaleX(-1)}.total-padding{position:absolute;top:0;left:0;height:1px;width:1px;transform-origin:0 0;opacity:0}:host.horizontal .total-padding{height:100%}\n"]
Line 986: [{ type: i0.ElementRef }, { type: i0.Renderer2 }, { type: i0.NgZone }, { type: i0.ChangeDetectorRef }, { type: Object, decorators: [{
                    type: Inject,
                    args: [PLATFORM_ID]
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['virtual-scroller-default-options']
                }] }]
Line 988: _tmp_93.args = [PLATFORM_ID]
Line 989: _tmp_86.push({ type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: ['virtual-scroller-default-options']
                }] })
Line 991: _tmp_96.push({
                    type: Inject,
                    args: ['virtual-scroller-default-options']
                })
Line 993: _tmp_98.args = ['virtual-scroller-default-options']
Line 994: _tmp_101.push({
                type: Input
            })
Line 996: _tmp_103.push({
                type: Input
            })
Line 998: _tmp_105.push({
                type: Input
            })
Line 1000: _tmp_107.push({
                type: Input
            })
Line 1002: _tmp_109.push({
                type: Input
            })
Line 1004: _tmp_111.push({
                type: Input
            })
Line 1006: _tmp_113.push({
                type: Input
            })
Line 1008: _tmp_115.push({
                type: Input
            })
Line 1010: _tmp_117.push({
                type: Input
            })
Line 1012: _tmp_119.push({
                type: Input
            })
Line 1014: _tmp_121.push({
                type: Input
            })
Line 1016: _tmp_123.push({
                type: Input
            })
Line 1018: _tmp_125.push({
                type: Input
            })
Line 1020: _tmp_127.push({
                type: Input
            })
Line 1022: _tmp_129.push({
                type: Input
            })
Line 1024: _tmp_131.push({
                type: Input
            })
Line 1026: _tmp_133.push({
                type: Input
            })
Line 1028: _tmp_135.push({
                type: Input
            })
Line 1030: _tmp_137.push({
                type: Input
            })
Line 1032: _tmp_139.push({
                type: Input
            })
Line 1034: _tmp_141.push({
                type: Input
            })
Line 1036: _tmp_143.push({
                type: Input
            })
Line 1038: _tmp_145.push({
                type: Input
            })
Line 1040: _tmp_147.push({
                type: Input
            })
Line 1042: _tmp_149.push({
                type: Output
            })
Line 1044: _tmp_151.push({
                type: Output
            })
Line 1046: _tmp_153.push({
                type: Output
            })
Line 1048: _tmp_155.push({
                type: Output
            })
Line 1050: _tmp_157.push({
                type: ViewChild,
                args: ['content', { read: ElementRef, static: true }]
            })
Line 1052: _tmp_158.args = ['content', { read: ElementRef, static: true }]
Line 1053: _tmp_161.push({
                type: ViewChild,
                args: ['invisiblePadding', { read: ElementRef, static: true }]
            })
Line 1055: _tmp_162.args = ['invisiblePadding', { read: ElementRef, static: true }]
Line 1056: _tmp_165.push({
                type: ContentChild,
                args: ['header', { read: ElementRef, static: false }]
            })
Line 1058: _tmp_166.args = ['header', { read: ElementRef, static: false }]
Line 1059: _tmp_169.push({
                type: ContentChild,
                args: ['container', { read: ElementRef, static: false }]
            })
Line 1061: _tmp_170.args = ['container', { read: ElementRef, static: false }]
