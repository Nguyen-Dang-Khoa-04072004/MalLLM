function json2decomposed = function json2decomposed(key, value) {
    var endpoint;
    var split;
    var error;

    key = trim(key);
    value = trim(value);

    if (!key) {
        error = new Error('The key must be specified');
        error.code = 'EINVEND';
        throw error;
    }

    endpoint = key + '=';
    split = value.split('#').map(trim);

    // If # was found, the source was specified
    if (split.length > 1) {
        endpoint += (split[0] || key) + '#' + split[1];
        // Check if value looks like a source
    } else if (isSource(value)) {
        endpoint += value + '#*';
        // Otherwise use the key as the source
    } else {
        endpoint += key + '#' + split[0];
    }

    return decompose(endpoint);
}
(_tmp_6 = this._getResolver(decEndpoint, logger)
            // Decide if we retrieve from the cache or not
            // Also decide if we validate the cached entry or not
            .then(function(resolver) {
                info.resolver = resolver;
                isTargetable = resolver.constructor.isTargetable;

                if (!resolver.isCacheable()) {
                    return that._resolve(resolver, logger);
                }

                // If force flag is used, bypass cache, but write to cache anyway
                if (that._config.force) {
                    logger.action(
                        'resolve',
                        resolver.getSource() + '#' + resolver.getTarget()
                    );
                    return that._resolve(resolver, logger);
                }

                // Note that we use the resolver methods to query the
                // cache because transformations/normalisations can occur
                return (
                    ...).fail
FsResolver.prototype._copy = function() {
    var that = this;

    return Q.nfcall(fs.stat, this._source).then(function(stat) {
        var dst;
        var copyOpts;
        var promise;

        that._sourceStat = stat;
        copyOpts = { mode: stat.mode };

        // If it's a folder
        if (stat.isDirectory()) {
            dst = that._tempDir;

            // Read the bower.json inside the folder, so that we
            // copy only the necessary files if it has ignore specified
            promise = that
                ._readJson(that._source)
                .then(function(json) {
                    copyOpts.ignore = json.ignore;
                    return copy.copyDir(that._source, dst, copyOpts);
                })
                .then(function() {
                    // Resolve to null because it's a dir
                    return;
                });
            // Else it's a file
        } else {
            dst = path.join(that._tempDir, path.basename(that._...
'Registering a package will make it installable via the registry (' +
                    chalk.cyan.underline(config.registry.register) +
                    '), continue?'
callback(null, {
                name: name,
                url: url
            })
function env = function env(prefix) {
    var obj = {};
    var prefixLength = prefix.length;

    prefix = prefix.toLowerCase();

    object.forOwn(process.env, function(value, key) {
        key = key.toLowerCase();

        if (string.startsWith(key, prefix)) {
            var parsedKey = key
                .substr(prefixLength)
                .replace(/__/g, '.') // __ is used for nesting
                .replace(/_/g, '-'); // _ is used as a - separator

            //use a convention patern to accept array from process.env
            //e.g. export bower_registry__search='["http://abc.com","http://def.com"]'
            var match = /\[([^\]]*)\]/g.exec(value);
            var targetValue;
            if (!match || match.length === 0) {
                targetValue = value;
            } else {
                targetValue = match[1].split(',').map(function(m) {
                    return m.trim();
                });
            }
            object.set(obj, parsedKey, targetValue);
        ...
logger.action(
                                'validate',
                                (pkgMeta._release
                                    ? pkgMeta._release + ' against '
                                    : '') +
                                    resolver.getSource() +
                                    (resolver.getTarget()
                                        ? '#' + resolver.getTarget()
                                        : '')
                            )
