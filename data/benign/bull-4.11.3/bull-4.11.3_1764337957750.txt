process.on('message', msg => {
  switch (msg.cmd) {
    case 'init':
      try {
        processor = require(msg.value);
      } catch (err) {
        status = 'Errored';
        err.message = `Error loading process file ${msg.value}. ${err.message}`;
        return process.send({
          cmd: 'error',
          error: err
        });
      }

      if (processor.default) {
        // support es2015 module.
        processor = processor.default;
      }
      if (processor.length > 1) {
        processor = promisify(processor);
      } else {
        const origProcessor = processor;
        processor = function() {
          try {
            return Promise.resolve(origProcessor.apply(null, arguments));
          } catch (err) {
            return Promise.reject(err);
          }
        };
      }
      status = 'IDLE';
      process.send({
        cmd: 'init-complete'
      });
      break;

    case 'start':
      if (status !== 'IDLE') {
        return process.send({
         ...
processor = require(msg.value)
<operator>.formatString("Error loading process file ", msg.value, ". ", err.message, "")
keyValues.forEach(keyValue => {
        const index = keyValue.indexOf('=');
        const key = keyValue.substring(0, index);
        const value = keyValue.substring(index + 1);
        client[key] = value;
      })
done.finally(() => {
        child.removeListener('message', msgHandler);
        child.removeListener('exit', exitHandler);

        if (child.exitCode !== null || /SIG.*/.test(child.signalCode)) {
          childPool.remove(child);
        } else {
          childPool.release(child);
        }
      })
client
        .zscore(this.keys.repeat, repeatKey)
        .then(repeatableExists => {
          // The job could have been deleted since this check
          if (repeatableExists) {
            return createNextJob();
          }
          return Promise.resolve();
        })
process.on('uncaughtException', err => {
  if (!err.message) {
    err = new Error(err);
  }
  process.send({
    cmd: 'failed',
    value: err
  });

  // An uncaughException leaves this process in a potentially undetermined state so
  // we must exit
  process.exit(-1);
})
Queue.prototype.removeRepeatableByKey = function(repeatJobKey) {
    const repeatMeta = this._keyToData(repeatJobKey);
    const queueKey = this.keys[''];

    const jobId = repeatMeta.id ? repeatMeta.id + ':' : ':';
    const repeatJobId = getRepeatJobId(
      repeatMeta.name || Job.DEFAULT_JOB_NAME,
      jobId,
      '',
      md5(repeatJobKey)
    );

    return this.isReady().then(() => {
      return this.client.removeRepeatable(
        this.keys.repeat,
        this.keys.delayed,
        repeatJobId,
        repeatJobKey,
        queueKey
      );
    });
  }
const repeatMeta = this._keyToData(repeatJobKey)
opts.redis = {
    enableReadyCheck: false,
    ...opts.redis
  }
const repeatJobId = getRepeatJobId(
      repeatMeta.name || Job.DEFAULT_JOB_NAME,
      jobId,
      '',
      md5(repeatJobKey)
    )
await new Promise(resolve =>
    child.send({ cmd: 'init', value: processFile }, resolve)
  )
_.defaults(opts.redis, {
    port: 6379,
    host: '127.0.0.1',
    db: opts.redis.db || opts.redis.DB,
    retryStrategy: function(times) {
      return Math.min(Math.exp(times), 20000);
    }
  })
