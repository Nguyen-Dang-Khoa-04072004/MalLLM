_tmp_1.PACKAGE_MANAGER_PRODUCTION_INSTALLATION_IN_PROGRESS = <operator>.formatString("Package installation in progress... ", emojis_1.EMOJIS.COFFEE, "")
const generateFiles = async (inputs) => {
    const configuration = await (0, load_configuration_1.loadConfiguration)();
    const collectionOption = inputs.find((option) => option.name === 'collection').value;
    const schematic = inputs.find((option) => option.name === 'schematic')
        .value;
    const appName = inputs.find((option) => option.name === 'project')
        .value;
    const spec = inputs.find((option) => option.name === 'spec');
    const flat = inputs.find((option) => option.name === 'flat');
    const specFileSuffix = inputs.find((option) => option.name === 'specFileSuffix');
    const collection = schematics_1.CollectionFactory.create(collectionOption || configuration.collection || schematics_1.Collection.NESTJS);
    const schematicOptions = mapSchematicOptions(inputs);
    schematicOptions.push(new schematics_1.SchematicOption('language', configuration.language));
    const configurationProjects = configuration.projects;
    let sourceRoot = appName
        ? (0...
function getAllPid = function getAllPid() {
    const rows = (0, child_process_1.execSync)('ps -A -o pid,ppid')
        .toString()
        .trim()
        .split('\n')
        .slice(1);
    return rows
        .map(function (row) {
        const parts = row.match(/\s*(\d+)\s*(\d+)/);
        if (parts === null) {
            return null;
        }
        return {
            pid: Number(parts[1]),
            ppid: Number(parts[2]),
        };
    })
        .filter((input) => {
        return input != null;
    });
}
const resultFile = tsBinary.createSourceFile('file.ts', '', tsBinary.ScriptTarget.Latest, 
        /*setParentNodes*/ false, tsBinary.ScriptKind.TS)
_tmp_1.module = {
            rules: [
                {
                    test: /.tsx?$/,
                    use: [
                        {
                            loader: 'ts-loader',
                            options: {
                                transpileOnly: !isPluginRegistered,
                                configFile: tsConfigFile,
                                getCustomTransformers: (program) => ({
                                    before: plugins.beforeHooks.map((hook) => hook(program)),
                                    after: plugins.afterHooks.map((hook) => hook(program)),
                                    afterDeclarations: plugins.afterDeclarationsHooks.map((hook) => hook(program)),
                                }),
                            },
                        },
                    ],
                    exclude: /node_modules/,
                },
            ],
        }
_tmp_6.rules = [
                {
                    test: /.tsx?$/,
                    use: [
                        {
                            loader: 'ts-loader',
                            options: {
                                transpileOnly: !isPluginRegistered,
                                configFile: tsConfigFile,
                                getCustomTransformers: (program) => ({
                                    before: plugins.beforeHooks.map((hook) => hook(program)),
                                    after: plugins.afterHooks.map((hook) => hook(program)),
                                    afterDeclarations: plugins.afterDeclarationsHooks.map((hook) => hook(program)),
                                }),
                            },
                        },
                    ],
                    exclude: /node_modules/,
                },
            ]
_tmp_7.push({
                    test: /.tsx?$/,
                    use: [
                        {
                            loader: 'ts-loader',
                            options: {
                                transpileOnly: !isPluginRegistered,
                                configFile: tsConfigFile,
                                getCustomTransformers: (program) => ({
                                    before: plugins.beforeHooks.map((hook) => hook(program)),
                                    after: plugins.afterHooks.map((hook) => hook(program)),
                                    afterDeclarations: plugins.afterDeclarationsHooks.map((hook) => hook(program)),
                                }),
                            },
                        },
                    ],
                    exclude: /node_modules/,
                })
NestCollection.schematics = [
    {
        name: 'application',
        alias: 'application',
        description: 'Generate a new application workspace',
    },
    {
        name: 'angular-app',
        alias: 'ng-app',
        description: '',
    },
    {
        name: 'class',
        alias: 'cl',
        description: 'Generate a new class',
    },
    {
        name: 'configuration',
        alias: 'config',
        description: 'Generate a CLI configuration file',
    },
    {
        name: 'controller',
        alias: 'co',
        description: 'Generate a controller declaration',
    },
    {
        name: 'decorator',
        alias: 'd',
        description: 'Generate a custom decorator',
    },
    {
        name: 'filter',
        alias: 'f',
        description: 'Generate a filter declaration',
    },
    {
        name: 'gateway',
        alias: 'ga',
        description: 'Generate a gateway declaration',
    },
    {
        name: 'guard',
        alias: 'gu',
      ...
_tmp_9.push({
                            loader: 'ts-loader',
                            options: {
                                transpileOnly: !isPluginRegistered,
                                configFile: tsConfigFile,
                                getCustomTransformers: (program) => ({
                                    before: plugins.beforeHooks.map((hook) => hook(program)),
                                    after: plugins.afterHooks.map((hook) => hook(program)),
                                    afterDeclarations: plugins.afterDeclarationsHooks.map((hook) => hook(program)),
                                }),
                            },
                        })
options.push({
                name: 'packageManager',
                value: command.packageManager,
            })
const webpackConfigurations = extras.webpackConfigFactoryOrConfig.map((configOrFactory) => {
                const unwrappedConfig = typeof configOrFactory !== 'function'
                    ? configOrFactory
                    : configOrFactory(defaultOptions, webpack);
                return {
                    ...defaultOptions,
                    mode: extras.watchMode ? 'development' : defaultOptions.mode,
                    ...unwrappedConfig,
                };
            })
const unwrappedConfig = typeof configOrFactory !== 'function'
                    ? configOrFactory
                    : configOrFactory(defaultOptions, webpack)
this.typeCheckerHost.run(tsConfigPath, {
                watch: extras.watch,
                onTypeCheck: onTypeCheckOrProgramInit,
                onProgramInit: onTypeCheckOrProgramInit,
            })
options.push({
                name: 'spec',
                value: typeof command.spec === 'boolean'
                    ? command.spec
                    : command.spec.value,
                options: {
                    passedAsInput: typeof command.spec === 'boolean'
                        ? false
                        : command.spec.passedAsInput,
                },
            })
const instance = new plugin.ReadonlyVisitor({
                    ...options,
                    ...extras,
                    readonly: true,
                })
const reportWatchStatusCallback = (diagnostic) => {
            if (diagnostic.messageText !== constants_1.TSC_NO_ERRORS_MESSAGE) {
                if (diagnostic.messageText?.includes('Found')) {
                    console.log(constants_1.TSC_LOG_ERROR_PREFIX, chalk.red(diagnostic.messageText));
                }
                return;
            }
            if (!builderProgram) {
                return;
            }
            const tsProgram = builderProgram.getProgram().getProgram();
            options.onTypeCheck?.(tsProgram);
        }
tsBinary.factory.createVariableStatement(undefined, tsBinary.factory.createVariableDeclarationList([
            tsBinary.factory.createVariableDeclaration(tsBinary.factory.createIdentifier(TYPE_IMPORT_VARIABLE_NAME), undefined, undefined, tsBinary.factory.createObjectLiteralExpression(Object.keys(typeImports).map((ti) => this.createPropertyAssignment(ti, typeImports[ti], tsBinary)), true)),
        ], tsBinary.NodeFlags.Const |
            tsBinary.NodeFlags.AwaitContext |
            tsBinary.NodeFlags.ContextFlags |
            tsBinary.NodeFlags.TypeExcludesFlags))
_tmp_25.push(tsBinary.factory.createVariableDeclaration(tsBinary.factory.createIdentifier(TYPE_IMPORT_VARIABLE_NAME), undefined, undefined, tsBinary.factory.createObjectLiteralExpression(Object.keys(typeImports).map((ti) => this.createPropertyAssignment(ti, typeImports[ti], tsBinary)), true)))
host.createProgram = (rootNames, options, 
        // tslint:disable-next-line:no-shadowed-variable
        host, oldProgram) => {
            if (manualRestart) {
                (0, manual_restart_1.displayManualRestartTip)();
            }
            const tsconfigPathsPlugin = options
                ? (0, tsconfig_paths_hook_1.tsconfigPathsBeforeHookFactory)(options)
                : null;
            const program = origCreateProgram(rootNames, options, host, oldProgram, undefined, projectReferences);
            const origProgramEmit = program.emit;
            program.emit = (targetSourceFile, writeFile, cancellationToken, emitOnlyDtsFiles, customTransformers) => {
                let transforms = customTransformers;
                transforms = typeof transforms !== 'object' ? {} : transforms;
                const before = plugins.beforeHooks.map((hook) => hook(program.getProgram()));
                const after = plugins.afterHooks.map((hook) => hook(program.getProgram(...
const askForMissingInformation = async (inputs, options) => {
    console.info(ui_1.MESSAGES.PROJECT_INFORMATION_START);
    console.info();
    const prompt = inquirer.createPromptModule();
    const nameInput = getApplicationNameInput(inputs);
    if (!nameInput.value) {
        const message = 'What name would you like to use for the new project?';
        const questions = [(0, questions_1.generateInput)('name', message)('nest-app')];
        const answers = await prompt(questions);
        replaceInputMissingInformation(inputs, answers);
    }
    const packageManagerInput = getPackageManagerInput(options);
    if (!packageManagerInput.value) {
        const answers = await askForPackageManager();
        replaceInputMissingInformation(options, answers);
    }
}
options.push({
                name: 'preserveWatchOutput',
                value: !!command.preserveWatchOutput &&
                    !!command.watch &&
                    !isWebpackEnabled,
            })
function askForProjectName = async function askForProjectName(promptQuestion, projects) {
    const questions = [
        (0, questions_1.generateSelect)('appName')(promptQuestion)(projects),
    ];
    const prompt = inquirer.createPromptModule();
    return prompt(questions);
}
await runner.run('init', true, (0, path_1.join)(process.cwd(), dir)).catch(() => {
        console.error(chalk.red(ui_1.MESSAGES.GIT_INITIALIZATION_ERROR));
    })
