// File: tmp/tmpdv12lf8j/color-convert/package/conversions.js
// ======================================================================
Line 3: var cssKeywords = require("color-name")
Line 10: for (const key of Object.keys(cssKeywords)) {
	reverseKeywords[cssKeywords[key]] = key;
}
Line 11: reverseKeywords[cssKeywords[key]] = key
Line 14: const convert = {
	rgb: {channels: 3, labels: 'rgb'},
	hsl: {channels: 3, labels: 'hsl'},
	hsv: {channels: 3, labels: 'hsv'},
	hwb: {channels: 3, labels: 'hwb'},
	cmyk: {channels: 4, labels: 'cmyk'},
	xyz: {channels: 3, labels: 'xyz'},
	lab: {channels: 3, labels: 'lab'},
	oklab: {channels: 3, labels: ['okl', 'oka', 'okb']},
	lch: {channels: 3, labels: 'lch'},
	oklch: {channels: 3, labels: ['okl', 'okc', 'okh']},
	hex: {channels: 1, labels: ['hex']},
	keyword: {channels: 1, labels: ['keyword']},
	ansi16: {channels: 1, labels: ['ansi16']},
	ansi256: {channels: 1, labels: ['ansi256']},
	hcg: {channels: 3, labels: ['h', 'c', 'g']},
	apple: {channels: 3, labels: ['r16', 'g16', 'b16']},
	gray: {channels: 1, labels: ['gray']},
}
Line 22: _tmp_1.oklab = {channels: 3, labels: ['okl', 'oka', 'okb']}
Line 24: _tmp_1.oklch = {channels: 3, labels: ['okl', 'okc', 'okh']}
Line 25: _tmp_1.hex = {channels: 1, labels: ['hex']}
Line 26: _tmp_1.keyword = {channels: 1, labels: ['keyword']}
Line 27: _tmp_1.ansi16 = {channels: 1, labels: ['ansi16']}
Line 28: _tmp_1.ansi256 = {channels: 1, labels: ['ansi256']}
Line 29: _tmp_1.hcg = {channels: 3, labels: ['h', 'c', 'g']}
Line 30: _tmp_1.apple = {channels: 3, labels: ['r16', 'g16', 'b16']}
Line 31: _tmp_1.gray = {channels: 1, labels: ['gray']}
Line 52: for (const model of Object.keys(convert)) {
	if (!('channels' in convert[model])) {
		throw new Error('missing channels property: ' + model);
	}

	if (!('labels' in convert[model])) {
		throw new Error('missing channel labels property: ' + model);
	}

	if (convert[model].labels.length !== convert[model].channels) {
		throw new Error('channel and label counts mismatch: ' + model);
	}

	const {channels, labels} = convert[model];
	delete convert[model].channels;
	delete convert[model].labels;
	Object.defineProperty(convert[model], 'channels', {value: channels});
	Object.defineProperty(convert[model], 'labels', {value: labels});
}
Line 65: const {channels, labels} = convert[model]
Line 66: delete convert[model].channels
Line 67: delete convert[model].labels
Line 68: Object.defineProperty(convert[model], 'channels', {value: channels})
Line 69: Object.defineProperty(convert[model], 'labels', {value: labels})
Line 72: {
	const r = rgb[0] / 255;
	const g = rgb[1] / 255;
	const b = rgb[2] / 255;
	const min = Math.min(r, g, b);
	const max = Math.max(r, g, b);
	const delta = max - min;
	let h;
	let s;

	switch (max) {
		case min: {
			h = 0;

			break;
		}

		case r: {
			h = (g - b) / delta;

			break;
		}

		case g: {
			h = 2 + (b - r) / delta;

			break;
		}

		case b: {
			h = 4 + (r - g) / delta;

			break;
		}
	// No default
	}

	h = Math.min(h * 60, 360);

	if (h < 0) {
		h += 360;
	}

	const l = (min + max) / 2;

	if (max === min) {
		s = 0;
	} else if (l <= 0.5) {
		s = delta / (max + min);
	} else {
		s = delta / (2 - max - min);
	}

	return [h, s * 100, l * 100];
}
Line 73: const r = rgb[0] / 255
Line 74: const g = rgb[1] / 255
Line 75: const b = rgb[2] / 255
Line 125: _tmp_34.push(l * 100)
Line 128: {
	let rdif;
	let gdif;
	let bdif;
	let h;
	let s;

	const r = rgb[0] / 255;
	const g = rgb[1] / 255;
	const b = rgb[2] / 255;
	const v = Math.max(r, g, b);
	const diff = v - Math.min(r, g, b);
	const diffc = function (c) {
		return (v - c) / 6 / diff + 1 / 2;
	};

	if (diff === 0) {
		h = 0;
		s = 0;
	} else {
		s = diff / v;
		rdif = diffc(r);
		gdif = diffc(g);
		bdif = diffc(b);

		switch (v) {
			case r: {
				h = bdif - gdif;

				break;
			}

			case g: {
				h = (1 / 3) + rdif - bdif;

				break;
			}

			case b: {
				h = (2 / 3) + gdif - rdif;

				break;
			}
		// No default
		}

		if (h < 0) {
			h += 1;
		} else if (h > 1) {
			h -= 1;
		}
	}

	return [
		h * 360,
		s * 100,
		v * 100,
	];
}
Line 135: const r = rgb[0] / 255
Line 136: const g = rgb[1] / 255
Line 137: const b = rgb[2] / 255
Line 182: _tmp_35.push(h * 360)
Line 183: _tmp_35.push(s * 100)
Line 184: _tmp_35.push(v * 100)
Line 188: {
	const r = rgb[0];
	const g = rgb[1];
	let b = rgb[2];
	const h = convert.rgb.hsl(rgb)[0];
	const w = 1 / 255 * Math.min(r, Math.min(g, b));

	b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));

	return [h, w * 100, b * 100];
}
Line 189: const r = rgb[0]
Line 190: const g = rgb[1]
Line 191: let b = rgb[2]
Line 192: const h = convert.rgb.hsl(rgb)[0]
Line 197: _tmp_37.push(b * 100)
Line 200: {
	// Assume sRGB
	const r = srgbNonlinearTransformInv(rgb[0] / 255);
	const g = srgbNonlinearTransformInv(rgb[1] / 255);
	const b = srgbNonlinearTransformInv(rgb[2] / 255);

	const lp = Math.cbrt(0.412_221_470_8 * r + 0.536_332_536_3 * g + 0.051_445_992_9 * b);
	const mp = Math.cbrt(0.211_903_498_2 * r + 0.680_699_545_1 * g + 0.107_396_956_6 * b);
	const sp = Math.cbrt(0.088_302_461_9 * r + 0.281_718_837_6 * g + 0.629_978_700_5 * b);

	const l = 0.210_454_255_3 * lp + 0.793_617_785 * mp - 0.004_072_046_8 * sp;
	const aa = 1.977_998_495_1 * lp - 2.428_592_205 * mp + 0.450_593_709_9 * sp;
	const bb = 0.025_904_037_1 * lp + 0.782_771_766_2 * mp - 0.808_675_766 * sp;

	return [l * 100, aa * 100, bb * 100];
}
Line 202: const r = srgbNonlinearTransformInv(rgb[0] / 255)
Line 203: const g = srgbNonlinearTransformInv(rgb[1] / 255)
Line 204: const b = srgbNonlinearTransformInv(rgb[2] / 255)
Line 206: Math.cbrt(0.412_221_470_8 * r + 0.536_332_536_3 * g + 0.051_445_992_9 * b)
Line 207: Math.cbrt(0.211_903_498_2 * r + 0.680_699_545_1 * g + 0.107_396_956_6 * b)
Line 208: Math.cbrt(0.088_302_461_9 * r + 0.281_718_837_6 * g + 0.629_978_700_5 * b)
Line 214: _tmp_38.push(bb * 100)
Line 217: {
	const r = rgb[0] / 255;
	const g = rgb[1] / 255;
	const b = rgb[2] / 255;

	const k = Math.min(1 - r, 1 - g, 1 - b);
	const c = (1 - r - k) / (1 - k) || 0;
	const m = (1 - g - k) / (1 - k) || 0;
	const y = (1 - b - k) / (1 - k) || 0;

	return [c * 100, m * 100, y * 100, k * 100];
}
Line 218: const r = rgb[0] / 255
Line 219: const g = rgb[1] / 255
Line 220: const b = rgb[2] / 255
Line 227: _tmp_39.push(m * 100)
Line 235: ((x[0] - y[0]) ** 2) +
		((x[1] - y[1]) ** 2) +
		((x[2] - y[2]) ** 2)
Line 236: (x[1] - y[1]) ** 2
Line 237: (x[2] - y[2]) ** 2
Line 241: {
	const reversed = reverseKeywords[rgb];
	if (reversed) {
		return reversed;
	}

	let currentClosestDistance = Number.POSITIVE_INFINITY;
	let currentClosestKeyword;

	for (const keyword of Object.keys(cssKeywords)) {
		const value = cssKeywords[keyword];

		// Compute comparative distance
		const distance = comparativeDistance(rgb, value);

		// Check if its less, if so set as closest
		if (distance < currentClosestDistance) {
			currentClosestDistance = distance;
			currentClosestKeyword = keyword;
		}
	}

	return currentClosestKeyword;
}
Line 242: const reversed = reverseKeywords[rgb]
Line 250: for (const keyword of Object.keys(cssKeywords)) {
		const value = cssKeywords[keyword];

		// Compute comparative distance
		const distance = comparativeDistance(rgb, value);

		// Check if its less, if so set as closest
		if (distance < currentClosestDistance) {
			currentClosestDistance = distance;
			currentClosestKeyword = keyword;
		}
	}
Line 251: const value = cssKeywords[keyword]
Line 270: {
	// Assume sRGB
	const r = srgbNonlinearTransformInv(rgb[0] / 255);
	const g = srgbNonlinearTransformInv(rgb[1] / 255);
	const b = srgbNonlinearTransformInv(rgb[2] / 255);

	const x = (r * 0.412_456_4) + (g * 0.357_576_1) + (b * 0.180_437_5);
	const y = (r * 0.212_672_9) + (g * 0.715_152_2) + (b * 0.072_175);
	const z = (r * 0.019_333_9) + (g * 0.119_192) + (b * 0.950_304_1);

	return [x * 100, y * 100, z * 100];
}
Line 272: const r = srgbNonlinearTransformInv(rgb[0] / 255)
Line 273: const g = srgbNonlinearTransformInv(rgb[1] / 255)
Line 274: const b = srgbNonlinearTransformInv(rgb[2] / 255)
Line 280: _tmp_40.push(x * 100)
Line 283: {
	const xyz = convert.rgb.xyz(rgb);
	let x = xyz[0];
	let y = xyz[1];
	let z = xyz[2];

	x /= 95.047;
	y /= 100;
	z /= 108.883;

	x = x > LAB_FT ? (x ** (1 / 3)) : (7.787 * x) + (16 / 116);
	y = y > LAB_FT ? (y ** (1 / 3)) : (7.787 * y) + (16 / 116);
	z = z > LAB_FT ? (z ** (1 / 3)) : (7.787 * z) + (16 / 116);

	const l = (116 * y) - 16;
	const a = 500 * (x - y);
	const b = 200 * (y - z);

	return [l, a, b];
}
Line 285: let x = xyz[0]
Line 286: let y = xyz[1]
Line 287: let z = xyz[2]
Line 301: _tmp_42.push(b)
Line 304: {
	const h = hsl[0] / 360;
	const s = hsl[1] / 100;
	const l = hsl[2] / 100;
	let t3;
	let value;

	if (s === 0) {
		value = l * 255;
		return [value, value, value];
	}

	const t2 = l < 0.5 ? l * (1 + s) : l + s - l * s;

	const t1 = 2 * l - t2;

	const rgb = [0, 0, 0];
	for (let i = 0; i < 3; i++) {
		t3 = h + 1 / 3 * -(i - 1);
		if (t3 < 0) {
			t3++;
		}

		if (t3 > 1) {
			t3--;
		}

		if (6 * t3 < 1) {
			value = t1 + (t2 - t1) * 6 * t3;
		} else if (2 * t3 < 1) {
			value = t2;
		} else if (3 * t3 < 2) {
			value = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
		} else {
			value = t1;
		}

		rgb[i] = value * 255;
	}

	return rgb;
}
Line 305: const h = hsl[0] / 360
Line 306: const s = hsl[1] / 100
Line 307: const l = hsl[2] / 100
Line 313: _tmp_43.push(value)
Line 320: const rgb = [0, 0, 0]
Line 321: {
		t3 = h + 1 / 3 * -(i - 1);
		if (t3 < 0) {
			t3++;
		}

		if (t3 > 1) {
			t3--;
		}

		if (6 * t3 < 1) {
			value = t1 + (t2 - t1) * 6 * t3;
		} else if (2 * t3 < 1) {
			value = t2;
		} else if (3 * t3 < 2) {
			value = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
		} else {
			value = t1;
		}

		rgb[i] = value * 255;
	}
Line 324: t3++
Line 341: rgb[i] = value * 255
Line 347: {
	const h = hsl[0];
	let s = hsl[1] / 100;
	let l = hsl[2] / 100;
	let smin = s;
	const lmin = Math.max(l, 0.01);

	l *= 2;
	s *= (l <= 1) ? l : 2 - l;
	smin *= lmin <= 1 ? lmin : 2 - lmin;
	const v = (l + s) / 2;
	const sv = l === 0 ? (2 * smin) / (lmin + smin) : (2 * s) / (l + s);

	return [h, sv * 100, v * 100];
}
Line 348: const h = hsl[0]
Line 349: let s = hsl[1] / 100
Line 350: let l = hsl[2] / 100
Line 360: _tmp_45.push(sv * 100)
Line 363: {
	const h = hsv[0] / 60;
	const s = hsv[1] / 100;
	let v = hsv[2] / 100;
	const hi = Math.floor(h) % 6;

	const f = h - Math.floor(h);
	const p = 255 * v * (1 - s);
	const q = 255 * v * (1 - (s * f));
	const t = 255 * v * (1 - (s * (1 - f)));
	v *= 255;

	switch (hi) {
		case 0: {
			return [v, t, p];
		}

		case 1: {
			return [q, v, p];
		}

		case 2: {
			return [p, v, t];
		}

		case 3: {
			return [p, q, v];
		}

		case 4: {
			return [t, p, v];
		}

		case 5: {
			return [v, p, q];
		}
	}
}
Line 364: const h = hsv[0] / 60
Line 365: const s = hsv[1] / 100
Line 366: let v = hsv[2] / 100
Line 377: _tmp_46.push(p)
Line 381: _tmp_47.push(p)
Line 385: _tmp_48.push(t)
Line 389: _tmp_49.push(v)
Line 393: _tmp_50.push(v)
Line 397: _tmp_51.push(q)
Line 402: {
	const h = hsv[0];
	const s = hsv[1] / 100;
	const v = hsv[2] / 100;
	const vmin = Math.max(v, 0.01);
	let sl;
	let l;

	l = (2 - s) * v;
	const lmin = (2 - s) * vmin;
	sl = s * vmin;
	sl /= (lmin <= 1) ? lmin : 2 - lmin;
	sl = sl || 0;
	l /= 2;

	return [h, sl * 100, l * 100];
}
Line 403: const h = hsv[0]
Line 404: const s = hsv[1] / 100
Line 405: const v = hsv[2] / 100
Line 417: _tmp_52.push(sl * 100)
Line 421: {
	const h = hwb[0] / 360;
	let wh = hwb[1] / 100;
	let bl = hwb[2] / 100;
	const ratio = wh + bl;
	let f;

	// Wh + bl cant be > 1
	if (ratio > 1) {
		wh /= ratio;
		bl /= ratio;
	}

	const i = Math.floor(6 * h);
	const v = 1 - bl;
	f = 6 * h - i;

	// eslint-disable-next-line no-bitwise
	if ((i & 0x01) !== 0) {
		f = 1 - f;
	}

	const n = wh + f * (v - wh); // Linear interpolation

	let r;
	let g;
	let b;
	/* eslint-disable max-statements-per-line,no-multi-spaces, default-case-last */
	switch (i) {
		default:
		case 6:
		case 0: { r = v;  g = n;  b = wh; break;
		}

		case 1: { r = n;  g = v;  b = wh; break;
		}

		case 2: { r = wh; g = v;  b = n; break;
		}

		case 3: { r = wh; g = n;  b = v; break;
		}

		case 4: { r = n;  g = wh; b = v; break;
		}

		case 5: { r = v;  g = wh; b = n; break;
		}
	}
	/* eslint-enable max-statements-per-line,no-multi-spaces, default-case-last */

	return [r * 255, g * 255, b * 255];
}
Line 422: const h = hwb[0] / 360
Line 423: let wh = hwb[1] / 100
Line 424: let bl = hwb[2] / 100
Line 472: _tmp_53.push(r * 255)
Line 475: {
	const c = cmyk[0] / 100;
	const m = cmyk[1] / 100;
	const y = cmyk[2] / 100;
	const k = cmyk[3] / 100;

	const r = 1 - Math.min(1, c * (1 - k) + k);
	const g = 1 - Math.min(1, m * (1 - k) + k);
	const b = 1 - Math.min(1, y * (1 - k) + k);

	return [r * 255, g * 255, b * 255];
}
Line 476: const c = cmyk[0] / 100
Line 477: const m = cmyk[1] / 100
Line 478: const y = cmyk[2] / 100
Line 479: const k = cmyk[3] / 100
Line 485: _tmp_54.push(b * 255)
Line 488: {
	const x = xyz[0] / 100;
	const y = xyz[1] / 100;
	const z = xyz[2] / 100;
	let r;
	let g;
	let b;

	r = (x * 3.240_454_2) + (y * -1.537_138_5) + (z * -0.498_531_4);
	g = (x * -0.969_266) + (y * 1.876_010_8) + (z * 0.041_556);
	b = (x * 0.055_643_4) + (y * -0.204_025_9) + (z * 1.057_225_2);

	// Assume sRGB
	r = srgbNonlinearTransform(r);
	g = srgbNonlinearTransform(g);
	b = srgbNonlinearTransform(b);

	return [r * 255, g * 255, b * 255];
}
Line 489: const x = xyz[0] / 100
Line 490: const y = xyz[1] / 100
Line 491: const z = xyz[2] / 100
Line 505: _tmp_55.push(b * 255)
Line 508: {
	let x = xyz[0];
	let y = xyz[1];
	let z = xyz[2];

	x /= 95.047;
	y /= 100;
	z /= 108.883;

	x = x > LAB_FT ? (x ** (1 / 3)) : (7.787 * x) + (16 / 116);
	y = y > LAB_FT ? (y ** (1 / 3)) : (7.787 * y) + (16 / 116);
	z = z > LAB_FT ? (z ** (1 / 3)) : (7.787 * z) + (16 / 116);

	const l = (116 * y) - 16;
	const a = 500 * (x - y);
	const b = 200 * (y - z);

	return [l, a, b];
}
Line 509: let x = xyz[0]
Line 510: let y = xyz[1]
Line 511: let z = xyz[2]
Line 525: _tmp_56.push(l)
Line 528: {
	const x = xyz[0] / 100;
	const y = xyz[1] / 100;
	const z = xyz[2] / 100;

	const lp = Math.cbrt(0.818_933_010_1 * x + 0.361_866_742_4 * y - 0.128_859_713_7 * z);
	const mp = Math.cbrt(0.032_984_543_6 * x + 0.929_311_871_5 * y + 0.036_145_638_7 * z);
	const sp = Math.cbrt(0.048_200_301_8 * x + 0.264_366_269_1 * y + 0.633_851_707 * z);

	const l = 0.210_454_255_3 * lp + 0.793_617_785 * mp - 0.004_072_046_8 * sp;
	const a = 1.977_998_495_1 * lp - 2.428_592_205 * mp + 0.450_593_709_9 * sp;
	const b = 0.025_904_037_1 * lp + 0.782_771_766_2 * mp - 0.808_675_766 * sp;

	return [l * 100, a * 100, b * 100];
}
Line 529: const x = xyz[0] / 100
Line 530: const y = xyz[1] / 100
Line 531: const z = xyz[2] / 100
Line 533: Math.cbrt(0.818_933_010_1 * x + 0.361_866_742_4 * y - 0.128_859_713_7 * z)
Line 534: Math.cbrt(0.032_984_543_6 * x + 0.929_311_871_5 * y + 0.036_145_638_7 * z)
Line 535: Math.cbrt(0.048_200_301_8 * x + 0.264_366_269_1 * y + 0.633_851_707 * z)
Line 541: _tmp_57.push(b * 100)
Line 548: {
	const ll = oklab[0] / 100;
	const a = oklab[1] / 100;
	const b = oklab[2] / 100;

	const l = (0.999_999_998 * ll + 0.396_337_792 * a + 0.215_803_758 * b) ** 3;
	const m = (1.000_000_008 * ll - 0.105_561_342 * a - 0.063_854_175 * b) ** 3;
	const s = (1.000_000_055 * ll - 0.089_484_182 * a - 1.291_485_538 * b) ** 3;

	const x = 1.227_013_851 * l - 0.557_799_98 * m + 0.281_256_149 * s;
	const y = -0.040_580_178 * l + 1.112_256_87 * m - 0.071_676_679 * s;
	const z = -0.076_381_285 * l - 0.421_481_978 * m + 1.586_163_22 * s;

	return [x * 100, y * 100, z * 100];
}
Line 549: const ll = oklab[0] / 100
Line 550: const a = oklab[1] / 100
Line 551: const b = oklab[2] / 100
Line 561: _tmp_59.push(y * 100)
Line 564: {
	const ll = oklab[0] / 100;
	const aa = oklab[1] / 100;
	const bb = oklab[2] / 100;

	const l = (ll + 0.396_337_777_4 * aa + 0.215_803_757_3 * bb) ** 3;
	const m = (ll - 0.105_561_345_8 * aa - 0.063_854_172_8 * bb) ** 3;
	const s = (ll - 0.089_484_177_5 * aa - 1.291_485_548 * bb) ** 3;

	// Assume sRGB
	const r = srgbNonlinearTransform(4.076_741_662_1 * l - 3.307_711_591_3 * m + 0.230_969_929_2 * s);
	const g = srgbNonlinearTransform(-1.268_438_004_6 * l + 2.609_757_401_1 * m - 0.341_319_396_5 * s);
	const b = srgbNonlinearTransform(-0.004_196_086_3 * l - 0.703_418_614_7 * m + 1.707_614_701 * s);

	return [r * 255, g * 255, b * 255];
}
Line 565: const ll = oklab[0] / 100
Line 566: const aa = oklab[1] / 100
Line 567: const bb = oklab[2] / 100
Line 578: _tmp_60.push(r * 255)
Line 585: {
	const l = lab[0];
	const a = lab[1];
	const b = lab[2];
	let x;
	let y;
	let z;

	y = (l + 16) / 116;
	x = a / 500 + y;
	z = y - b / 200;

	const y2 = y ** 3;
	const x2 = x ** 3;
	const z2 = z ** 3;
	y = y2 > LAB_FT ? y2 : (y - 16 / 116) / 7.787;
	x = x2 > LAB_FT ? x2 : (x - 16 / 116) / 7.787;
	z = z2 > LAB_FT ? z2 : (z - 16 / 116) / 7.787;

	// Illuminant D65 XYZ Tristrimulus Values
	// https://en.wikipedia.org/wiki/CIE_1931_color_space
	x *= 95.047;
	y *= 100;
	z *= 108.883;

	return [x, y, z];
}
Line 586: const l = lab[0]
Line 587: const a = lab[1]
Line 588: const b = lab[2]
Line 610: _tmp_62.push(z)
Line 613: {
	const l = lab[0];
	const a = lab[1];
	const b = lab[2];
	let h;

	const hr = Math.atan2(b, a);
	h = hr * 360 / 2 / Math.PI;

	if (h < 0) {
		h += 360;
	}

	const c = Math.sqrt(a * a + b * b);

	return [l, c, h];
}
Line 614: const l = lab[0]
Line 615: const a = lab[1]
Line 616: const b = lab[2]
Line 626: Math.sqrt(a * a + b * b)
Line 628: _tmp_63.push(l)
Line 631: {
	const l = lch[0];
	const c = lch[1];
	const h = lch[2];

	const hr = h / 360 * 2 * Math.PI;
	const a = c * Math.cos(hr);
	const b = c * Math.sin(hr);

	return [l, a, b];
}
Line 632: const l = lch[0]
Line 633: const c = lch[1]
Line 634: const h = lch[2]
Line 640: _tmp_64.push(b)
Line 643: {
	const [r, g, b] = args;
	let value = saturation === null ? convert.rgb.hsv(args)[2] : saturation; // Hsv -> ansi16 optimization

	value = Math.round(value / 50);

	if (value === 0) {
		return 30;
	}

	let ansi = 30
		/* eslint-disable no-bitwise */
		+ ((Math.round(b / 255) << 2)
		| (Math.round(g / 255) << 1)
		| Math.round(r / 255));
		/* eslint-enable no-bitwise */

	if (value === 2) {
		ansi += 60;
	}

	return ansi;
}
Line 644: const [r, g, b] = args
Line 645: let value = saturation === null ? convert.rgb.hsv(args)[2] : saturation
Line 673: {
	const r = args[0];
	const g = args[1];
	const b = args[2];

	// We use the extended greyscale palette here, with the exception of
	// black and white. normal palette only has 4 greyscale shades.
	// eslint-disable-next-line no-bitwise
	if (r >> 4 === g >> 4 && g >> 4 === b >> 4) {
		if (r < 8) {
			return 16;
		}

		if (r > 248) {
			return 231;
		}

		return Math.round(((r - 8) / 247) * 24) + 232;
	}

	const ansi = 16
		+ (36 * Math.round(r / 255 * 5))
		+ (6 * Math.round(g / 255 * 5))
		+ Math.round(b / 255 * 5);

	return ansi;
}
Line 674: const r = args[0]
Line 675: const g = args[1]
Line 676: const b = args[2]
Line 701: {
	args = args[0];

	let color = args % 10;

	// Handle greyscale
	if (color === 0 || color === 7) {
		if (args > 50) {
			color += 3.5;
		}

		color = color / 10.5 * 255;

		return [color, color, color];
	}

	const mult = (Math.trunc(args > 50) + 1) * 0.5;
	/* eslint-disable no-bitwise */
	const r = ((color & 1) * mult) * 255;
	const g = (((color >> 1) & 1) * mult) * 255;
	const b = (((color >> 2) & 1) * mult) * 255;
	/* eslint-enable no-bitwise */

	return [r, g, b];
}
Line 702: args = args[0]
Line 714: _tmp_69.push(color)
Line 724: _tmp_70.push(b)
Line 727: {
	args = args[0];

	// Handle greyscale
	if (args >= 232) {
		const c = (args - 232) * 10 + 8;
		return [c, c, c];
	}

	args -= 16;

	let rem;
	const r = Math.floor(args / 36) / 5 * 255;
	const g = Math.floor((rem = args % 36) / 6) / 5 * 255;
	const b = (rem % 6) / 5 * 255;

	return [r, g, b];
}
Line 728: args = args[0]
Line 733: _tmp_71.push(c)
Line 743: _tmp_72.push(g)
Line 746: {
	/* eslint-disable no-bitwise */
	const integer = ((Math.round(args[0]) & 0xFF) << 16)
		+ ((Math.round(args[1]) & 0xFF) << 8)
		+ (Math.round(args[2]) & 0xFF);
	/* eslint-enable no-bitwise */

	const string = integer.toString(16).toUpperCase();
	return '000000'.slice(string.length) + string;
}
Line 748: const integer = ((Math.round(args[0]) & 0xFF) << 16)
		+ ((Math.round(args[1]) & 0xFF) << 8)
		+ (Math.round(args[2]) & 0xFF)
Line 749: (Math.round(args[1]) & 0xFF) << 8
Line 750: Math.round(args[2]) & 0xFF
Line 753: integer.toString(16)
Line 757: {
	const match = args.toString(16).match(/[a-f\d]{6}|[a-f\d]{3}/i);
	if (!match) {
		return [0, 0, 0];
	}

	let colorString = match[0];

	if (match[0].length === 3) {
		colorString = [...colorString].map(char => char + char).join('');
	}

	const integer = Number.parseInt(colorString, 16);
	/* eslint-disable no-bitwise */
	const r = (integer >> 16) & 0xFF;
	const g = (integer >> 8) & 0xFF;
	const b = integer & 0xFF;
	/* eslint-enable no-bitwise */

	return [r, g, b];
}
Line 758: const match = args.toString(16).match(/[a-f\d]{6}|[a-f\d]{3}/i)
Line 760: _tmp_76.push(0)
Line 763: let colorString = match[0]
Line 765: {
		colorString = [...colorString].map(char => char + char).join('');
	}
Line 766: colorString = [...colorString].map(char => char + char).join('')
Line 769: Number.parseInt(colorString, 16)
Line 776: _tmp_80.push(b)
Line 779: {
	const r = rgb[0] / 255;
	const g = rgb[1] / 255;
	const b = rgb[2] / 255;
	const max = Math.max(Math.max(r, g), b);
	const min = Math.min(Math.min(r, g), b);
	const chroma = (max - min);
	let hue;

	const grayscale = chroma < 1 ? min / (1 - chroma) : 0;

	if (chroma <= 0) {
		hue = 0;
	} else if (max === r) {
		hue = ((g - b) / chroma) % 6;
	} else if (max === g) {
		hue = 2 + (b - r) / chroma;
	} else {
		hue = 4 + (r - g) / chroma;
	}

	hue /= 6;
	hue %= 1;

	return [hue * 360, chroma * 100, grayscale * 100];
}
Line 780: const r = rgb[0] / 255
Line 781: const g = rgb[1] / 255
Line 782: const b = rgb[2] / 255
Line 803: _tmp_81.push(grayscale * 100)
Line 806: {
	const s = hsl[1] / 100;
	const l = hsl[2] / 100;

	const c = l < 0.5 ? (2 * s * l) : (2 * s * (1 - l));

	let f = 0;
	if (c < 1) {
		f = (l - 0.5 * c) / (1 - c);
	}

	return [hsl[0], c * 100, f * 100];
}
Line 807: const s = hsl[1] / 100
Line 808: const l = hsl[2] / 100
Line 817: _tmp_82.push(f * 100)
Line 820: {
	const s = hsv[1] / 100;
	const v = hsv[2] / 100;

	const c = s * v;
	let f = 0;

	if (c < 1) {
		f = (v - c) / (1 - c);
	}

	return [hsv[0], c * 100, f * 100];
}
Line 821: const s = hsv[1] / 100
Line 822: const v = hsv[2] / 100
Line 831: _tmp_83.push(f * 100)
Line 834: {
	const h = hcg[0] / 360;
	const c = hcg[1] / 100;
	const g = hcg[2] / 100;

	if (c === 0) {
		return [g * 255, g * 255, g * 255];
	}

	const pure = [0, 0, 0];
	const hi = (h % 1) * 6;
	const v = hi % 1;
	const w = 1 - v;
	let mg = 0;

	/* eslint-disable max-statements-per-line */
	switch (Math.floor(hi)) {
		case 0: {
			pure[0] = 1; pure[1] = v; pure[2] = 0; break;
		}

		case 1: {
			pure[0] = w; pure[1] = 1; pure[2] = 0; break;
		}

		case 2: {
			pure[0] = 0; pure[1] = 1; pure[2] = v; break;
		}

		case 3: {
			pure[0] = 0; pure[1] = w; pure[2] = 1; break;
		}

		case 4: {
			pure[0] = v; pure[1] = 0; pure[2] = 1; break;
		}

		default: {
			pure[0] = 1; pure[1] = 0; pure[2] = w;
		}
	}
	/* eslint-enable max-statements-per-line */

	mg = (1 - c) * g;

	return [
		(c * pure[0] + mg) * 255,
		(c * pure[1] + mg) * 255,
		(c * pure[2] + mg) * 255,
	];
}
Line 835: const h = hcg[0] / 360
Line 836: const c = hcg[1] / 100
Line 837: const g = hcg[2] / 100
Line 840: _tmp_84.push(g * 255)
Line 843: const pure = [0, 0, 0]
Line 850: switch (Math.floor(hi)) {
		case 0: {
			pure[0] = 1; pure[1] = v; pure[2] = 0; break;
		}

		case 1: {
			pure[0] = w; pure[1] = 1; pure[2] = 0; break;
		}

		case 2: {
			pure[0] = 0; pure[1] = 1; pure[2] = v; break;
		}

		case 3: {
			pure[0] = 0; pure[1] = w; pure[2] = 1; break;
		}

		case 4: {
			pure[0] = v; pure[1] = 0; pure[2] = 1; break;
		}

		default: {
			pure[0] = 1; pure[1] = 0; pure[2] = w;
		}
	}
Line 851: {
			pure[0] = 1; pure[1] = v; pure[2] = 0; break;
		}
Line 852: pure[2] = 0
Line 855: {
			pure[0] = w; pure[1] = 1; pure[2] = 0; break;
		}
Line 856: pure[0] = w
Line 859: {
			pure[0] = 0; pure[1] = 1; pure[2] = v; break;
		}
Line 860: pure[1] = 1
Line 863: {
			pure[0] = 0; pure[1] = w; pure[2] = 1; break;
		}
Line 864: pure[2] = 1
Line 867: {
			pure[0] = v; pure[1] = 0; pure[2] = 1; break;
		}
Line 868: pure[2] = 1
Line 871: {
			pure[0] = 1; pure[1] = 0; pure[2] = w;
		}
Line 872: pure[0] = 1
Line 879: [
		(c * pure[0] + mg) * 255,
		(c * pure[1] + mg) * 255,
		(c * pure[2] + mg) * 255,
	]
Line 880: _tmp_86.push((c * pure[0] + mg) * 255)
Line 881: _tmp_86.push((c * pure[1] + mg) * 255)
Line 882: _tmp_86.push((c * pure[2] + mg) * 255)
Line 886: {
	const c = hcg[1] / 100;
	const g = hcg[2] / 100;

	const v = c + g * (1 - c);
	let f = 0;

	if (v > 0) {
		f = c / v;
	}

	return [hcg[0], f * 100, v * 100];
}
Line 887: const c = hcg[1] / 100
Line 888: const g = hcg[2] / 100
Line 897: _tmp_87.push(f * 100)
Line 900: {
	const c = hcg[1] / 100;
	const g = hcg[2] / 100;

	const l = g * (1 - c) + 0.5 * c;
	let s = 0;

	if (l > 0 && l < 0.5) {
		s = c / (2 * l);
	} else if (l >= 0.5 && l < 1) {
		s = c / (2 * (1 - l));
	}

	return [hcg[0], s * 100, l * 100];
}
Line 901: const c = hcg[1] / 100
Line 902: const g = hcg[2] / 100
Line 913: _tmp_88.push(l * 100)
Line 916: {
	const c = hcg[1] / 100;
	const g = hcg[2] / 100;
	const v = c + g * (1 - c);
	return [hcg[0], (v - c) * 100, (1 - v) * 100];
}
Line 917: const c = hcg[1] / 100
Line 918: const g = hcg[2] / 100
Line 920: _tmp_89.push((1 - v) * 100)
Line 923: {
	const w = hwb[1] / 100;
	const b = hwb[2] / 100;
	const v = 1 - b;
	const c = v - w;
	let g = 0;

	if (c < 1) {
		g = (v - c) / (1 - c);
	}

	return [hwb[0], c * 100, g * 100];
}
Line 924: const w = hwb[1] / 100
Line 925: const b = hwb[2] / 100
Line 934: _tmp_90.push(c * 100)
Line 938: _tmp_91.push((apple[0] / 65_535) * 255)
Line 942: _tmp_92.push((rgb[0] / 255) * 65_535)
Line 946: _tmp_93.push(args[0] / 100 * 255)
Line 950: _tmp_94.push(args[0])
Line 956: _tmp_95.push(gray[0])
Line 960: _tmp_96.push(gray[0])
Line 964: _tmp_97.push(gray[0])
Line 967: {
	/* eslint-disable no-bitwise */
	const value = Math.round(gray[0] / 100 * 255) & 0xFF;
	const integer = (value << 16) + (value << 8) + value;
	/* eslint-enable no-bitwise */

	const string = integer.toString(16).toUpperCase();
	return '000000'.slice(string.length) + string;
}
Line 969: const value = Math.round(gray[0] / 100 * 255) & 0xFF
Line 973: integer.toString(16)
Line 977: {
	const value = (rgb[0] + rgb[1] + rgb[2]) / 3;
	return [value / 255 * 100];
}
Line 978: const value = (rgb[0] + rgb[1] + rgb[2]) / 3
Line 979: _tmp_100.push(value / 255 * 100)

// File: tmp/tmpdv12lf8j/color-convert/package/index.js
// ======================================================================
Line 1: var conversions = require("./conversions.js")
Line 2: var route = require("./route.js")
Line 5: _tmp_10.push(_0xba16ef[_0x29ad9a(0x69b)])
Line 8: Object.keys(conversions)
Line 11: {
		const arg0 = args[0];
		if (arg0 === undefined || arg0 === null) {
			return arg0;
		}

		if (arg0.length > 1) {
			args = arg0;
		}

		return fn(args);
	}
Line 12: const arg0 = args[0]
Line 33: {
		const arg0 = args[0];

		if (arg0 === undefined || arg0 === null) {
			return arg0;
		}

		if (arg0.length > 1) {
			args = arg0;
		}

		const result = fn(args);

		// We're assuming the result is an array here.
		// see notice in conversions.js; don't use box types
		// in conversion functions.
		if (typeof result === 'object') {
			for (let {length} = result, i = 0; i < length; i++) {
				result[i] = Math.round(result[i]);
			}
		}

		return result;
	}
Line 34: const arg0 = args[0]
Line 50: {
				result[i] = Math.round(result[i]);
			}
Line 51: result[i] = Math.round(result[i])
Line 66: for (const fromModel of models) {
	convert[fromModel] = {};

	Object.defineProperty(convert[fromModel], 'channels', {value: conversions[fromModel].channels});
	Object.defineProperty(convert[fromModel], 'labels', {value: conversions[fromModel].labels});

	const routes = route(fromModel);
	const routeModels = Object.keys(routes);

	for (const toModel of routeModels) {
		const fn = routes[toModel];

		convert[fromModel][toModel] = wrapRounded(fn);
		convert[fromModel][toModel].raw = wrapRaw(fn);
	}
}
Line 67: convert[fromModel] = {}
Line 69: Object.defineProperty(convert[fromModel], 'channels', {value: conversions[fromModel].channels})
Line 70: Object.defineProperty(convert[fromModel], 'labels', {value: conversions[fromModel].labels})
Line 73: Object.keys(routes)
Line 75: for (const toModel of routeModels) {
		const fn = routes[toModel];

		convert[fromModel][toModel] = wrapRounded(fn);
		convert[fromModel][toModel].raw = wrapRaw(fn);
	}
Line 76: const fn = routes[toModel]
Line 78: convert[fromModel][toModel] = wrapRounded(fn)
Line 79: convert[fromModel][toModel].raw = wrapRaw(fn)

// File: tmp/tmpdv12lf8j/color-convert/package/route.js
// ======================================================================
Line 1: var conversions = require("./conversions.js")
Line 17: Object.keys(conversions)
Line 19: {
		graph[models[i]] = {
			// http://jsperf.com/1-vs-infinity
			// micro-opt, but this is simple.
			distance: -1,
			parent: null,
		};
	}
Line 20: graph[models[i]] = {
			// http://jsperf.com/1-vs-infinity
			// micro-opt, but this is simple.
			distance: -1,
			parent: null,
		}
Line 32: {
	const graph = buildGraph();
	const queue = [fromModel]; // Unshift -> queue -> pop

	graph[fromModel].distance = 0;

	while (queue.length > 0) {
		const current = queue.pop();
		const adjacents = Object.keys(conversions[current]);

		for (let {length} = adjacents, i = 0; i < length; i++) {
			const adjacent = adjacents[i];
			const node = graph[adjacent];

			if (node.distance === -1) {
				node.distance = graph[current].distance + 1;
				node.parent = current;
				queue.unshift(adjacent);
			}
		}
	}

	return graph;
}
Line 34: const queue = [fromModel]
Line 36: graph[fromModel].distance = 0
Line 38: {
		const current = queue.pop();
		const adjacents = Object.keys(conversions[current]);

		for (let {length} = adjacents, i = 0; i < length; i++) {
			const adjacent = adjacents[i];
			const node = graph[adjacent];

			if (node.distance === -1) {
				node.distance = graph[current].distance + 1;
				node.parent = current;
				queue.unshift(adjacent);
			}
		}
	}
Line 40: const adjacents = Object.keys(conversions[current])
Line 42: {
			const adjacent = adjacents[i];
			const node = graph[adjacent];

			if (node.distance === -1) {
				node.distance = graph[current].distance + 1;
				node.parent = current;
				queue.unshift(adjacent);
			}
		}
Line 43: const adjacent = adjacents[i]
Line 44: const node = graph[adjacent]
Line 46: {
				node.distance = graph[current].distance + 1;
				node.parent = current;
				queue.unshift(adjacent);
			}
Line 47: node.distance = graph[current].distance + 1
Line 59: from(args)
Line 63: {
	const path = [graph[toModel].parent, toModel];
	let fn = conversions[graph[toModel].parent][toModel];

	let cur = graph[toModel].parent;
	while (graph[cur].parent) {
		path.unshift(graph[cur].parent);
		fn = link(conversions[graph[cur].parent][cur], fn);
		cur = graph[cur].parent;
	}

	fn.conversion = path;
	return fn;
}
Line 64: const path = [graph[toModel].parent, toModel]
Line 65: let fn = conversions[graph[toModel].parent][toModel]
Line 67: let cur = graph[toModel].parent
Line 68: {
		path.unshift(graph[cur].parent);
		fn = link(conversions[graph[cur].parent][cur], fn);
		cur = graph[cur].parent;
	}
Line 69: path.unshift(graph[cur].parent)
Line 70: fn = link(conversions[graph[cur].parent][cur], fn)
Line 71: cur = graph[cur].parent
Line 82: Object.keys(graph)
Line 83: {
		const toModel = models[i];
		const node = graph[toModel];

		if (node.parent === null) {
			// No possible conversion, or this node is the source model.
			continue;
		}

		conversion[toModel] = wrapConversion(toModel, graph);
	}
Line 84: const toModel = models[i]
Line 85: const node = graph[toModel]
Line 92: conversion[toModel] = wrapConversion(toModel, graph)
