var generate = function(opt) {

        var filename    = null
            , dir       = __dirname
        ;

        filename = (opt.filename) ? opt.filename : _(dir +'/resources/'+ opt.target +'.csv', true);

        var region      = (opt.region) ? opt.region : 'en';
        var mappingFile = _(dir+ '/resources/'+ opt.target +'.mapping.json', true);
        var content     = null;
        try {
            rec.mapping = requireJSON(mappingFile);
        } catch (err) {
            throw err
        }

        try {
            rec.mapping = requireJSON(mappingFile);
        } catch (err) {
            throw err
        }

        if ( opt.region != 'en' ) {
            rec.mapping[ 'official_name_' + opt.region ] = JSON.clone(rec.mapping["official_name_en"]);
            // remove default
            delete rec.mapping["official_name_en"];
            console.debug('region set to ', opt.region);
        }

        cleanMapping();

        try {

            content = fs.readFileSync(...
var removeEnv = function(projects, target) {
        var err = null, env = local.env;
        // default `dev env` cannot be removed
        if(env === projects[self.projectName]['dev_env']|| env === projects[self.projectName]['def_env']) {
            if (env === projects[self.projectName]['def_env']) {
                err = new Error('Environment [ '+env+' ] is set as "default environment"')
            } else {
                err = new Error('Environment [ '+env+' ] is linked as "development environment"')
            }

            return end(err);
        }

        projects[self.projectName]['envs'].splice(projects[self.projectName]['envs'].indexOf(env), 1);
        lib.generator.createFileFromDataSync(
            projects,
            target
        );
        // clean ports & reverse ports registered for the project
        var portsPath = _(GINA_HOMEDIR + '/ports.json')
            , portsReversePath = _(GINA_HOMEDIR + '/ports.reverse.json')
            , ports = require(port...
_tmp_0.iso-8859-8 = [128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,null,162,163,164,165,166,167,168,169,215,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,247,187,188,189,190,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,8215,1488,1489,1490,1491,1492,1493,1494,1495,1496,1497,1498,1499,1500,1501,1502,1503,1504,1505,1506,1507,1508,1509,1510,1511,1512,1513,1514,null,null,8206,8207,null]
formatDataFromString = function(bodyStr){

        if ( typeof(bodyStr) == 'object' ) {
            bodyStr = JSON.stringify(bodyStr)
        }

        try {
            bodyStr = decodeURIComponent(bodyStr);
        } catch (err) {
            // Already decoded - ignoring
        }

        // false & true case
        if ( /(\"false\"|\"true\"|\"on\")/.test(bodyStr) ) {
            bodyStr = bodyStr.replace(/\"false\"/g, false).replace(/\"true\"/g, true).replace(/\"on\"/g, true);
        }
        if ( /(\"null\")/i.test(bodyStr) ) {
            bodyStr = bodyStr.replace(/\"null\"/ig, null);
        }

        return parseBody(bodyStr);
    }
_tmp_0.windows-1256 = [8364,1662,8218,402,8222,8230,8224,8225,710,8240,1657,8249,338,1670,1688,1672,1711,8216,8217,8220,8221,8226,8211,8212,1705,8482,1681,8250,339,8204,8205,1722,160,1548,162,163,164,165,166,167,168,169,1726,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,1563,187,188,189,190,1567,1729,1569,1570,1571,1572,1573,1574,1575,1576,1577,1578,1579,1580,1581,1582,1583,1584,1585,1586,1587,1588,1589,1590,215,1591,1592,1593,1594,1600,1601,1602,1603,224,1604,226,1605,1606,1607,1608,231,232,233,234,235,1609,1610,238,239,1611,1612,1613,1614,244,1615,1616,247,1617,249,1618,251,252,8206,8207,1746]
isRealApp(bundle, function(err, appPath) {
                if (err) {
                    console.error(err.stack || err.message)
                }


                var error = null;
                //console.debug(' OPTIONS => ', opt.debugPort, opt.debugBrkEnabled);
                //console.info('running: gina bundle:restart '+ bundle + '@' + self.projectName);
                msg = 'Restarting, please wait ...';
                cmd = '$gina bundle:stop ' + bundle + ' @' + self.projectName + ' && $gina bundle:start ' + bundle + ' @' + self.projectName;
                if (self.inheritedArgv != '') {
                    cmd += ' '+ self.inheritedArgv;
                }
                if (opt.debugPort) {
                    cmd += ' --inspect';
                    if (opt.debugBrkEnabled) {
                        cmd += '-brk'
                    }
                    cmd += '='+ opt.debugPort;
                    msg = 'You should now start your debug session on port #'+opt.deb...
function CouchbaseStore = function CouchbaseStore(options) {
        var self = this;

        options = options || {};
        Store.call(this, options);
        this.prefix = null == options.prefix
            ? 'sess:'
            : options.prefix;

        var connectOptions = {};
        if (options.hasOwnProperty("host")) {
            connectOptions.host = options.host;
        } else if (options.hasOwnProperty("hosts")) {
            connectOptions.host = options.hosts;
        }

        if (options.hasOwnProperty("username")) {
            connectOptions.username = options.username;
        }

        if (options.hasOwnProperty("password")) {
            connectOptions.password = options.password;
        }

        if (options.hasOwnProperty("bucket")) {
            connectOptions.bucket = options.bucket;
        }

        if (options.hasOwnProperty("cachefile")) {
            connectOptions.cachefile = options.cachefile;
        }

        if (options.hasOwnProperty("connectionTimeout")) {
     ...
console.warn('[ ApiValidator ] statusCode `'+ e.status +'` not matching any definition in `'+_( getPath('gina').core + '/status.codes')+'`\nPlease contact the Gina dev team to add one if required')
var listAll = function() {
        var projects = self.projects
            , list = []
            , p = ''
            , path
            , bundles
            , b
            , str = ''
            , json = []
        ;

        for (p in projects) {
            list.push(p)
        }
        list.sort();

        p = 0;
        for (; p<list.length; ++p) {
            let jsonProject  = { project: list[p], status: 'ok' }
            try {
                path = projects[list[p]].path;
                bundles = require( _(path +'/manifest.json')).bundles;
                bundles = orderBundles(bundles);

                str += '------------------------------------\n\r';
                if ( !fs.existsSync(projects[list[p]].path) ) {
                    str += '?! ';
                    jsonProject.status = '?!'
                }
                str += list[p] + '\n\r';
                str += '------------------------------------\n\r';
                jsonProject.bundles = [];
       ...
var onConnect = function onConnect(cb){
            console.debug('[ CONNECTOR ][ ' + local.bundle +' ] couchbase is alive !!');
            console.debug('[ CONNECTOR ][ ' + local.bundle +' ][ ' + dbString.connector +' ] now connected...');

            self.instance.reconnected  = self.instance.connected   = true;
            var options = local.options;

            // updating context
            var ctx = getContext()
                , bundle = ctx.bundle
                , env = ctx.env
                , conf = ctx['gina'].config.envConf[bundle][env]
                , name = dbString.database
                //Reload models.
                , modelsPath = _(conf.modelsPath)
            ;
            // will send heartbeat every 4 minutes if keepAlive == `true`
            self.ping(options.pingInterval, cb, function onPing(cb){

                local.bundle = bundle;
                local.env = env;

                if ( typeof(cb) != 'undefined' ) { // this portition is not workin...
var onConnect = function onConnect(cb){
            console.debug('[ CONNECTOR ][ ' + local.bundle +' ] couchbase is alive !!');
            console.debug('[ CONNECTOR ][ ' + local.bundle +' ][ ' + dbString.connector +' ] now connected...');

            self.instance.reconnected  = self.instance.connected   = true;
            var options = local.options;

            // updating context
            var ctx = getContext()
                , bundle = ctx.bundle
                , env = ctx.env
                , conf = ctx['gina'].config.envConf[bundle][env]
                , name = dbString.database
                //Reload models.
                , modelsPath = _(conf.modelsPath)
            ;
            // will send heartbeat every 4 minutes if keepAlive == `true`
            self.ping(options.pingInterval, cb, function onPing(cb){

                local.bundle = bundle;
                local.env = env;

                if ( typeof(cb) != 'undefined' ) { // this portition is not workin...
out = execSync('gina bundle:list @'+ self.projectName +' --format=json').toString().replace(/(\n|\r)$/, '').split(/(\n|\r)/g)
function ByteInputStream = function ByteInputStream(bytes) {
  /** @type {number} */
  var pos = 0;

  /**
   * @this {ByteInputStream}
   * @returns {number} Get the next byte from the stream.
   */
  this.get = function() {
    return (pos >= bytes.length) ? EOF_byte : Number(bytes[pos]);
  };

  /** @param {number} n Number (positive or negative) by which to
   *      offset the byte pointer. */
  this.offset = function(n) {
    pos += n;
    if (pos < 0) {
      throw new Error('Seeking past start of the buffer');
    }
    if (pos > bytes.length) {
      throw new Error('Seeking past EOF');
    }
  };

  /**
   * @param {Array.<number>} test Array of bytes to compare against.
   * @returns {boolean} True if the start of the stream matches the test
   *     bytes.
   */
  this.match = function(test) {
    if (test.length > pos + bytes.length) {
      return false;
    }
    var i;
    for (i = 0; i < test.length; i += 1) {
      if (Number(bytes[pos + i]) !== test[i]) {
        return false;
      }
    }...
client.on('data', (data) => {
            //console.log('[MQSpeaker]  (data): ' + data.toString());
            payloads = data.toString();

            // from speakers & tail
            if ( /^(\{\"|\[\{\")/.test(payloads) ) {
                payloads = payloads.split(/\r\n/g);
                //console.log(payloads);
                i = -1;
                while(i < payloads.length) {
                    i++;
                    let payload = payloads[i];
                    if (
                        /^\{/.test(payload) && /\}$/.test(payload)
                        || /^\[\{/.test(payload) && /\}\]$/.test(payload)
                    ) {
                        let pl = null;
                        try {
                            pl = JSON.parse(payload);
                        } catch(plErr) {
                            process.stdout.write(  '[MQSpeaker] (exception) '+ payload +'\n' );
                            continue;
                        }


                 ...
s.on('error', function(err) {
            s.destroy();
            // silently catch all errors - assume the port is closed => available for use
            if ( /ECONNREFUSED/i.test(err.message) ) {
                if ( !opt.ignore.length || opt.ignore.length > 0 && opt.ignore.indexOf( port ) == -1 ) {
                    // ports.push(''+port);
                    ports.push(port);
                    ports.sort();
                    console.debug('available port found '+ port +' ['+ ports.length +'/'+ total +']');
                    opt.limit--;
                }

                if (opt.limit <= 0) {
                    cb(false, ports);
                } else {
                    port++;
                    find(port);
                }
                return;
            } else if (err) {
                // error not handled - not connection to the network ?
                console.warn('exeption not handled: '+ err);
                cb(err);
                return;
       ...
var init = function(options) {

        self.projectName    = options.projectName;
        //Starting app.
        self.appName        = options.bundle;
        self.env            = options.env;
        self.version        = options.version;
        local.router        = new Router(self.env);

        //True => multiple bundles sharing the same server (port).
        self.isStandalone   = options.isStandalone;
        self.bundles        = options.bundles;
        self.executionPath  = options.executionPath;


        if (!self.isStandalone) {
            //Only load the related conf / env.
            self.conf[self.appName] = {};
            self.conf[self.appName][self.env] = options.conf[self.appName][self.env];
            self.conf[self.appName][self.env].bundlesPath = options.conf[self.appName][self.env].bundlesPath;
            self.conf[self.appName][self.env].modelsPath =  options.conf[self.appName][self.env].modelsPath;
            self.conf[self.appName][self.env].execution...
var produce = function(entityName, i){
                        console.debug("producing ", files[i]);

                        lib.config.get('gina', 'project.json', function(err, config){
                            //if (err) logger.error('gina', 'MODEL:ERR:2', 'EEMPTY: EntitySuper' + err, __stack);
                            if (err) console.error(err.stack||err.message);

                            var filename = config.paths.gina + '/model/entityFactory.js';

                            //TODO - Factory class
                            //var Factory = new Factory({source: , target: ).onComplete();
                            console.debug("LOADING ", filename);
                            //Getting source.
                            loadFile(filename, entityName, function(err, source){
                                console.log("got source ", err, source);

                                try {
                                    if (entityName != "undefiend") {
              ...
_tmp_2.fr = {
            dayNames: [
                "dim", "lun", "mar", "mer", "jeu", "ven", "sam",
                "dimanche", "lundi", "mardi", "mercredi", "jeudi", "vendredi", "samedi"
            ],
            monthNames: [
                "Jan", "Fév", "Mar", "Avr", "Mai", "Jui", "Juil", "Aoû", "Sep", "Oct", "Nov", "Déc",
                "Janvier", "Février", "Mars", "Avril", "Mai", "Juin", "Juillet", "Août", "Septembre", "Octobre", "Novembre", "Décembre"
            ],
            masks: {
                "default":      "ddd mmm dd yyyy HH:MM:ss",
                shortDate:      "d/m/yy",
                shortDate2:      "dd/mm/yyyy",
                mediumDate:     "d mmm, yyyy",
                longDate:       "d mmmm, yyyy",
                fullDate:       "dddd, d mmmm, yyyy"
            }
        }
lib.config.get('gina', 'project.json', function(err, config){
                            //if (err) logger.error('gina', 'MODEL:ERR:2', 'EEMPTY: EntitySuper' + err, __stack);
                            if (err) console.error(err.stack||err.message);

                            var filename = config.paths.gina + '/model/entityFactory.js';

                            //TODO - Factory class
                            //var Factory = new Factory({source: , target: ).onComplete();
                            console.debug("LOADING ", filename);
                            //Getting source.
                            loadFile(filename, entityName, function(err, source){
                                console.log("got source ", err, source);

                                try {
                                    if (entityName != "undefiend") {
                                        console.log("preparing entity ", entityName);
                                        //TODO - Wo...
self.ping(options.pingInterval, cb, function onPing(cb){

                local.bundle = bundle;
                local.env = env;

                if ( typeof(cb) != 'undefined' ) { // this portition is not working yet on Mac OS X
                    console.debug('[ CONNECTOR ][ ' + local.bundle +' ][ '+ env +' ] connected to couchbase !!');


                    modelUtil.setConnection(bundle, name, self.instance);

                    if ( fs.existsSync(modelsPath) ) {
                        modelUtil.setConnection(bundle, name, self.instance);
                        modelUtil.reloadModels(
                            conf,
                            function doneReloadingModel(err) {
                                self.reconnecting = false;
                                cb(err)
                            })
                    } else {
                        cb(new Error('[ CONNECTOR ][ ' + local.bundle +' ][ '+ env +' ] '+ modelsPath+ ' not found') )
                   ...
gina.onError(function(err, req, res, next){
                // (code)   message
                // (16)     Generic network failure. Enable detailed error codes (via LCB_CNTL_DETAILED_ERRCODES, or via `detailed_errcodes` in the connection string) and/or enable logging to get more information
                // (23)     Client-Side timeout exceeded for operation. Inspect network conditions or increase the timeout
                //          cannot perform operations on a shutdown bucket
                //          err instanceof CouchbaseError

                if (!self.instance.connected) {
                    self.instance.reconnected = false;
                    self.instance.reconnecting = false;
                }

                if (
                    err instanceof couchbase.Error && err.code == 16 && !self.reconnected
                    //|| err instanceof couchbase.Error && err.code == 23 && !self.reconnecting
                    || /cannot perform operations on a shutdow...
self.getUrl = function (route, params, base) {

        //var ctx = SwigFilters().getConfig();
        //var ctx = self.options;
        if (typeof(params) == 'undefined') {
            params = {}
        }
        var ctx  = SwigFilters.instance._options || self.options;

        var config              = null
            , hostname          = null
            , wroot             = null
            , wrootRe           = null
            , isStandalone      = null
            , isMaster          = null
            , isProxyHost       = ctx.isProxyHost
            , routingRules      = null
            , rule              = null
            , url               = NaN
            , urlStr            = null
            , method            = 'GET'
        ;

        if (ctx.options.method != 'undefined') {
            method = ctx.options.method
        }

        // if no route, returns current route
        if ( !route || typeof(route) == 'undefined') {
            route = ctx.options...
var end = function(err) {
        console.debug('GINA_ENV_IS_DEV ', GINA_ENV_IS_DEV);
        if (err) {
            if (GINA_ENV_IS_DEV) {
                console.error(err.stack);
            } else {
                console.error(err.message);
            }

            return process.exit(1);
        }
        var env = local.env;
        console.log('Environment [ '+env+' ] removed with success');

        return process.exit(0)
    }
var makeObject = function(obj, value, args, len, i) {

        if (i >= len) {
            return false
        }

        var key     = args[i];
        var nextKey = ( i < len-1 && typeof(args[i+1]) != 'undefined' ) ?  args[i+1] : null;

        if ( typeof(obj[key]) == 'undefined' ) {
            if (nextKey && /^\d+$/.test(nextKey)) {
                nextKey = parseInt(nextKey);
                obj[key] = []
            } else {
                obj[key] = {}
            }
        }

        for (var o in obj) {

            if ( typeof(obj[o]) == 'object' ) {

                if ( Array.isArray(obj[o]) ) {

                    if (o === key) {

                        var _args = JSON.clone(args);
                        _args.splice(0, 1);

                        for (var a = i, aLen = _args.length; a < aLen; ++a) {
                            key = parseInt(_args[a])
                            obj[o][key] = {};

                            if (a == aLen-1) {
                    ...
var end = function (output, type, messageOnly) {
        var err = false;
        if ( typeof(output) != 'undefined') {
            if ( output instanceof Error ) {
                err = output = ( typeof(messageOnly) != 'undefined' && /^true$/i.test(messageOnly) ) ? output.message : (output.stack||output.message);
            }
            if ( typeof(type) != 'undefined' ) {
                console[type](output)
            } else {
                console.log(output);
            }
        }

        process.exit( err ? 1:0 )
    }
typeof(rec[id].values) == 'undefined'
throw new Error('rec["'+ id +'"].values not found ! Please inspect your record root: type must be an Array.');
symlinkSync(fs.realpathSync(source), destination)
self.updateUserProfile = async function(done) {

        if ( !self.isGlobalInstall || isWin32() ) {
            return done()
        }
        // if (!self.isCustomPrefix || self.prefix == self.defaultPrefix) {
        //     return done()
        // }
        var cmd = null;
        var profilePath = getUserHome() + '/.profile';
        var profilePathObj = new _(profilePath);
        if ( !profilePathObj.existsSync() ) {
            cmd = 'touch '+ profilePath;
            await promisify(run)(cmd, { cwd: _(self.versionPath), tmp: _(getTmpDir(), true), outToProcessSTD: true, shell: "/bin/bash"})
                .catch(function onError(err){
                    if (err) {
                        console.warn('Try to run: sudo ' + cmd);
                        return done(err);
                    }
                });
        }

        var inFile = null;
        var patt = _(self.prefix.replace( new RegExp( '^' +getUserHome() ), '(.*)[$]HOME') + '/bin', tr...
typeof (require.cache[projectPropertiesPath]) != 'undefined'
projectPath = (typeof(content[app][env]['projectPath']) != 'undefined')
                    ?  content[app][env].projectPath
                    :  template["{bundle}"]["{env}"].projectPath
queryString += '\t\nVALUES ("'+ id +'", '+ JSON.stringify(rec[id].values) +'),'
var layoutAssets        = layoutStr.match(/<link .*?<\/link>|<link .*?(rel\=\"(stylesheet|icon|manifest|(.*)\-icon))(.*)|<script.*?<\/script>|<img .*?(.*)/g) || []
