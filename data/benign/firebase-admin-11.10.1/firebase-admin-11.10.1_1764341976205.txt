this.getUrl()
            .then((url) => {
            const request = {
                method: 'GET',
                url: `${url}/remoteConfig`,
                headers: FIREBASE_REMOTE_CONFIG_HEADERS
            };
            return this.httpClient.send(request);
        })
            .then((resp) => {
            return this.toRemoteConfigTemplate(resp);
        })
            .catch((err) => {
            throw this.toFirebaseError(err);
        })
(0, project_management_api_request_internal_1.assertServerResponse)(validator.isNonNullObject(responseData), responseData, 'getMetadata()\'s responseData must be a non-null object.')
utils.findProjectId(this.app)
            .then((projectId) => {
            if (!validator.isNonEmptyString(projectId)) {
                throw new eventarc_utils_1.FirebaseEventarcError('unknown-error', 'Failed to determine project ID. Initialize the '
                    + 'SDK with service account credentials or set project ID as an app option. '
                    + 'Alternatively, set the GOOGLE_CLOUD_PROJECT environment variable.');
            }
            this.projectId = projectId;
            return projectId;
        })
function applicationDefault = function applicationDefault(httpAgent) {
    if (typeof globalAppDefaultCred === 'undefined') {
        globalAppDefaultCred = (0, credential_internal_1.getApplicationDefault)(httpAgent);
    }
    return globalAppDefaultCred;
}
(0, installations_1.getInstallations)(this.app).deleteInstallation(instanceId)
            .catch((err) => {
            if (err instanceof error_1.FirebaseInstallationsError) {
                let code = err.code.replace('installations/', '');
                if (code === error_1.InstallationsClientErrorCode.INVALID_INSTALLATION_ID.code) {
                    code = error_1.InstanceIdClientErrorCode.INVALID_INSTANCE_ID.code;
                }
                throw new error_1.FirebaseInstanceIdError({ code, message: err.message });
            }
            throw err;
        })
this.getUrl(appId)
            .then((url) => {
            const request = {
                method: 'POST',
                url,
                headers: FIREBASE_APP_CHECK_CONFIG_HEADERS,
                data: { customToken }
            };
            return this.httpClient.send(request);
        })
            .then((resp) => {
            return this.toAppCheckToken(resp);
        })
            .catch((err) => {
            throw this.toFirebaseError(err);
        })
function addReadonlyGetter = function addReadonlyGetter(obj, prop, value) {
    Object.defineProperty(obj, prop, {
        value,
        // Make this property read-only.
        writable: false,
        // Include this property during enumeration of obj's properties.
        enumerable: true,
    });
}
super.verifyIdToken(idToken, checkRevoked)
            .then((decodedClaims) => {
            // Validate tenant ID.
            if (decodedClaims.firebase.tenant !== this.tenantId) {
                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.MISMATCHING_TENANT_ID);
            }
            return decodedClaims;
        })
this.signUrlIfPresent(model)
            .then((modelContent) => this.client.createModel(modelContent))
            .then((operation) => this.client.handleOperation(operation))
            .then((modelResponse) => new Model(modelResponse, this.client))
this.client.validateTemplate(template)
            .then((templateResponse) => {
            return new RemoteConfigTemplateImpl(templateResponse);
        })
this.getUrl()
            .then((url) => {
            const request = {
                method: 'GET',
                url: `${url}/remoteConfig`,
                headers: FIREBASE_REMOTE_CONFIG_HEADERS,
                data
            };
            return this.httpClient.send(request);
        })
            .then((resp) => {
            return this.toRemoteConfigTemplate(resp);
        })
            .catch((err) => {
            throw this.toFirebaseError(err);
        })
function getErrorCode = function getErrorCode(response) {
    if (validator.isNonNullObject(response) && 'error' in response) {
        const error = response.error;
        if (validator.isString(error)) {
            return error;
        }
        if (validator.isArray(error.details)) {
            const fcmErrorType = 'type.googleapis.com/google.firebase.fcm.v1.FcmError';
            for (const element of error.details) {
                if (element['@type'] === fcmErrorType) {
                    return element.errorCode;
                }
            }
        }
        if ('status' in error) {
            return error.status;
        }
        else {
            return error.message;
        }
    }
    return null;
}
function validateStringMap = function validateStringMap(map, label) {
    if (typeof map === 'undefined') {
        return;
    }
    else if (!validator.isNonNullObject(map)) {
        throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, `${label} must be a non-null object`);
    }
    Object.keys(map).forEach((key) => {
        if (!validator.isString(map[key])) {
            throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, `${label} must only contain string values`);
        }
    });
}
this.getPathPrefix()
            .then((path) => {
            const req = {
                url: `https://${this.host}${path}${apiSettings.getEndpoint()}`,
                method: apiSettings.getHttpMethod(),
                timeout: this.timeout,
            };
            return this.httpClient.send(req);
        })
            .then(() => {
            // return nothing on success
        })
            .catch((err) => {
            if (err instanceof api_request_1.HttpError) {
                const response = err.response;
                const errorMessage = (response.isJson() && 'error' in response.data) ?
                    response.data.error : response.text;
                const template = ERROR_CODES[response.status];
                const message = template ?
                    `Installation ID "${apiSettings.getEndpoint()}": ${template}` : errorMessage;
                throw new error_1.FirebaseInstallationsError(error_1.InstallationsClientErrorCode.API_ERROR, messag...
throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CREDENTIAL, 'INTERNAL ASSERT: Must provide a CryptoSigner to use FirebaseTokenGenerator.');
function getNumberField = function getNumberField(obj, key) {
    if (typeof obj[key] !== 'undefined' && obj[key] !== null) {
        return parseInt(obj[key].toString(), 10);
    }
    return NaN;
}
throw new error_1.FirebaseAppError(error_1.AppErrorCodes.UNABLE_TO_PARSE_RESPONSE, 'Unable to parse multipart payload as JSON');
(0, jwt_1.decodeJwt)(jwtToken)
            .catch(() => {
            const errorMessage = 'Decoding App Check token failed. Make sure you passed ' +
                'the entire string JWT which represents the Firebase App Check token.';
            throw new app_check_api_client_internal_1.FirebaseAppCheckError('invalid-argument', errorMessage);
        })
function getFirestoreOptions = function getFirestoreOptions(app, firestoreSettings) {
    if (!validator.isNonNullObject(app) || !('options' in app)) {
        throw new error_1.FirebaseFirestoreError({
            code: 'invalid-argument',
            message: 'First argument passed to admin.firestore() must be a valid Firebase app instance.',
        });
    }
    const projectId = utils.getExplicitProjectId(app);
    const credential = app.options.credential;
    // eslint-disable-next-line @typescript-eslint/no-var-requires
    const { version: firebaseVersion } = require('../../package.json');
    const preferRest = firestoreSettings?.preferRest;
    if (credential instanceof credential_internal_1.ServiceAccountCredential) {
        return {
            credentials: {
                private_key: credential.privateKey,
                client_email: credential.clientEmail,
            },
            // When the SDK is initialized with ServiceAccountCredentials an explicit projectId is
            // guarantee...
this.getVerifyTokenUrl()
            .then((url) => {
            const request = {
                method: 'POST',
                url,
                headers: FIREBASE_APP_CHECK_CONFIG_HEADERS,
                data: { app_check_token: token }
            };
            return this.httpClient.send(request);
        })
            .then((resp) => {
            if (typeof resp.data.alreadyConsumed !== 'undefined'
                && !validator.isBoolean(resp.data?.alreadyConsumed)) {
                throw new FirebaseAppCheckError('invalid-argument', '`alreadyConsumed` must be a boolean value.');
            }
            return resp.data.alreadyConsumed || false;
        })
            .catch((err) => {
            throw this.toFirebaseError(err);
        })
const request = {
            method: 'POST',
            url: `https://${GOOGLE_AUTH_TOKEN_HOST}${GOOGLE_AUTH_TOKEN_PATH}`,
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded',
            },
            data: postData,
            httpAgent: this.httpAgent,
        }
const request = {
                method: 'POST',
                url,
                headers: FIREBASE_APP_CHECK_CONFIG_HEADERS,
                data: { app_check_token: token }
            }
throw new error_1.FirebaseError({
                code: 'storage/invalid-credential',
                message: 'Failed to initialize Google Cloud Storage client with the available credential. ' +
                    'Must initialize the SDK with a certificate credential or application default credentials ' +
                    'to use Cloud Storage API.',
            });
function validateWebpushConfig = function validateWebpushConfig(config) {
    if (typeof config === 'undefined') {
        return;
    }
    else if (!validator.isNonNullObject(config)) {
        throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, 'webpush must be a non-null object');
    }
    validateStringMap(config.headers, 'webpush.headers');
    validateStringMap(config.data, 'webpush.data');
}
this.getAccountId().then((serviceAccount) => {
            const request = {
                method: 'POST',
                url: `https://iamcredentials.googleapis.com/v1/projects/-/serviceAccounts/${serviceAccount}:signBlob`,
                data: { payload: buffer.toString('base64') },
            };
            return this.httpClient.send(request);
        }).then((response) => {
            // Response from IAM is base64 encoded. Decode it into a buffer and return.
            return Buffer.from(response.data.signedBlob, 'base64');
        }).catch((err) => {
            if (err instanceof api_request_1.HttpError) {
                throw new CryptoSignerError({
                    code: CryptoSignerErrorCode.SERVER_ERROR,
                    message: err.message,
                    cause: err
                });
            }
            throw err;
        })
const claims = {
            scope: [
                'https://www.googleapis.com/auth/cloud-platform',
                'https://www.googleapis.com/auth/firebase.database',
                'https://www.googleapis.com/auth/firebase.messaging',
                'https://www.googleapis.com/auth/identitytoolkit',
                'https://www.googleapis.com/auth/userinfo.email',
            ].join(' '),
        }
function createPart = function createPart(request, boundary, idx) {
    const serializedRequest = serializeSubRequest(request);
    let part = `--${boundary}\r\n`;
    part += `Content-Length: ${serializedRequest.length}\r\n`;
    part += 'Content-Type: application/http\r\n';
    part += `content-id: ${idx + 1}\r\n`;
    part += 'content-transfer-encoding: binary\r\n';
    part += '\r\n';
    part += `${serializedRequest}\r\n`;
    return part;
}
function getErrorMessage = function getErrorMessage(response) {
    if (validator.isNonNullObject(response) &&
        'error' in response &&
        validator.isNonEmptyString(response.error.message)) {
        return response.error.message;
    }
    return null;
}
this.getUrl()
            .then((url) => {
            const request = {
                method: 'POST',
                url: `${url}/remoteConfig:rollback`,
                headers: FIREBASE_REMOTE_CONFIG_HEADERS,
                data
            };
            return this.httpClient.send(request);
        })
            .then((resp) => {
            return this.toRemoteConfigTemplate(resp);
        })
            .catch((err) => {
            throw this.toFirebaseError(err);
        })
throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `"${multiFactorProviderConfig}" is not a valid "MultiFactorProviderConfig" type.`);
function initFirestore = function initFirestore(app, databaseId, firestoreSettings) {
    const options = getFirestoreOptions(app, firestoreSettings);
    options.databaseId = databaseId;
    let firestoreDatabase;
    try {
        // Lazy-load the Firestore implementation here, which in turns loads gRPC.
        firestoreDatabase = require('@google-cloud/firestore').Firestore;
    }
    catch (err) {
        throw new error_1.FirebaseFirestoreError({
            code: 'missing-dependencies',
            message: 'Failed to import the Cloud Firestore client library for Node.js. '
                + 'Make sure to install the "@google-cloud/firestore" npm package. '
                + `Original error: ${err}`,
        });
    }
    return new firestoreDatabase(options);
}
this.batchClient.send(requests)
            .then((responses) => {
            return responses.map((part) => {
                return this.buildSendResponse(part);
            });
        }).then((responses) => {
            const successCount = responses.filter((resp) => resp.success).length;
            return {
                responses,
                successCount,
                failureCount: responses.length - successCount,
            };
        }).catch((err) => {
            if (err instanceof api_request_1.HttpError) {
                throw (0, messaging_errors_internal_1.createFirebaseError)(err);
            }
            // Re-throw the error if it already has the proper format.
            throw err;
        })
function appCheckErrorFromCryptoSignerError = function appCheckErrorFromCryptoSignerError(err) {
    if (!(err instanceof crypto_signer_1.CryptoSignerError)) {
        return err;
    }
    if (err.code === crypto_signer_1.CryptoSignerErrorCode.SERVER_ERROR && validator.isNonNullObject(err.cause)) {
        const httpError = err.cause;
        const errorResponse = httpError.response.data;
        if (errorResponse?.error) {
            const status = errorResponse.error.status;
            const description = errorResponse.error.message || JSON.stringify(httpError.response);
            let code = 'unknown-error';
            if (status && status in app_check_api_client_internal_1.APP_CHECK_ERROR_CODE_MAPPING) {
                code = app_check_api_client_internal_1.APP_CHECK_ERROR_CODE_MAPPING[status];
            }
            return new app_check_api_client_internal_1.FirebaseAppCheckError(code, `Error returned from server while signing a custom token: ${description}`);
        }
        return new app_check_api_client_inte...
this.getUrl()
            .then((url) => {
            const request = {
                method: 'GET',
                url: `${url}/remoteConfig:listVersions`,
                headers: FIREBASE_REMOTE_CONFIG_HEADERS,
                data: options
            };
            return this.httpClient.send(request);
        })
            .then((resp) => {
            return resp.data;
        })
            .catch((err) => {
            throw this.toFirebaseError(err);
        })
throw new CryptoSignerError({
                code: CryptoSignerErrorCode.INVALID_CREDENTIAL,
                message: 'Failed to determine service account. Make sure to initialize ' +
                    'the SDK with a service account credential. Alternatively specify a service ' +
                    `account with iam.serviceAccounts.signBlob permission. Original error: ${err}`,
            });
this
            .invokeRequestHandler('POST', `${parentResourceName}/androidApps`, requestData, 'v1beta1')
            .then((responseData) => {
            assertServerResponse(validator.isNonNullObject(responseData), responseData, 'createAndroidApp\'s responseData must be a non-null object.');
            assertServerResponse(validator.isNonEmptyString(responseData.name), responseData, 'createAndroidApp\'s responseData.name must be a non-empty string.');
            return this.pollRemoteOperationWithExponentialBackoff(responseData.name);
        })
function isPassword = function isPassword(password) {
    // A password must be a string of at least 6 characters.
    return typeof password === 'string' && password.length >= 6;
}
this.getUrl()
            .then((url) => {
            return this.getReleaseDescription(name, rulesetName)
                .then((release) => {
                const request = {
                    method: 'POST',
                    url: `${url}/releases`,
                    data: release,
                };
                return this.sendRequest(request);
            });
        })
this.getUrl()
            .then((url) => {
            const request = {
                method: 'PUT',
                url: `${url}/${path}`,
                headers: { ...FIREBASE_REMOTE_CONFIG_HEADERS, 'If-Match': etag },
                data: {
                    conditions: template.conditions,
                    parameters: template.parameters,
                    parameterGroups: template.parameterGroups,
                    version: template.version,
                }
            };
            return this.httpClient.send(request);
        })
Promise.resolve()
            .then(() => {
            if (typeof projectId !== 'undefined' && validator.isNonEmptyString(projectId)) {
                return projectId;
            }
            return this.getProjectId();
        })
            .then((projectId) => {
            const urlParams = {
                projectId,
                locationId,
                resourceId,
            };
            // Formats a string of form 'project/{projectId}/{api}' and replaces
            // with corresponding arguments {projectId: '1234', api: 'resource'}
            // and returns output: 'project/1234/resource'.
            return utils.formatString(urlFormat, urlParams);
        })
AsyncHttpCall.invoke(config)
            .then((resp) => {
            return this.createHttpResponse(resp);
        })
            .catch((err) => {
            const [delayMillis, canRetry] = this.getRetryDelayMillis(retryAttempts, err);
            if (canRetry && this.retry && delayMillis <= this.retry.maxDelayInMillis) {
                return this.waitForRetry(delayMillis).then(() => {
                    return this.sendWithRetry(config, retryAttempts + 1);
                });
            }
            if (err.response) {
                throw new HttpError(this.createHttpResponse(err.response));
            }
            if (err.code === 'ETIMEDOUT') {
                throw new error_1.FirebaseAppError(error_1.AppErrorCodes.NETWORK_TIMEOUT, `Error while making request: ${err.message}.`);
            }
            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.NETWORK_ERROR, `Error while making request: ${err.message}. Error code: ${err.code}`);
        })
this.pollRemoteOperationWithExponentialBackoff(responseData.name)
throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, 'notification.imageUrl must be a valid URL string');
urlBuilder.getUrl(apiSettings.getEndpoint(), additionalResourceParams)
            .then((url) => {
            // Validate request.
            if (requestData) {
                const requestValidator = apiSettings.getRequestValidator();
                requestValidator(requestData);
            }
            // Process request.
            const req = {
                method: apiSettings.getHttpMethod(),
                url,
                headers: FIREBASE_AUTH_HEADER,
                data: requestData,
                timeout: FIREBASE_AUTH_TIMEOUT,
            };
            return this.httpClient.send(req);
        })
            .then((response) => {
            // Validate response.
            const responseValidator = apiSettings.getResponseValidator();
            responseValidator(response.data);
            // Return entire response.
            return response.data;
        })
            .catch((err) => {
            if (err instanceof api_request_1.HttpError) {
  ...
(url) => {
            // Validate request.
            if (requestData) {
                const requestValidator = apiSettings.getRequestValidator();
                requestValidator(requestData);
            }
            // Process request.
            const req = {
                method: apiSettings.getHttpMethod(),
                url,
                headers: FIREBASE_AUTH_HEADER,
                data: requestData,
                timeout: FIREBASE_AUTH_TIMEOUT,
            };
            return this.httpClient.send(req);
        }
requestValidator(requestData)
const req = {
                method: apiSettings.getHttpMethod(),
                url,
                headers: FIREBASE_AUTH_HEADER,
                data: requestData,
                timeout: FIREBASE_AUTH_TIMEOUT,
            }
_tmp_269.url = url
_tmp_269.data = requestData
(_tmp_270 = this.httpClient).send
