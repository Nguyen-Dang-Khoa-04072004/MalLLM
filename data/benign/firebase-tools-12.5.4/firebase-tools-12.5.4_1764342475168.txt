function getUnemulatedAPIs = async function getUnemulatedAPIs(projectId, instances) {
    var _a;
    const unemulatedAPIs = {};
    for (const i of instances) {
        const extensionSpec = await planner.getExtensionSpec(i);
        for (const api of (_a = extensionSpec.apis) !== null && _a !== void 0 ? _a : []) {
            if (!EMULATED_APIS.includes(api.apiName)) {
                if (unemulatedAPIs[api.apiName]) {
                    unemulatedAPIs[api.apiName].instanceIds.push(i.instanceId);
                }
                else {
                    const enabled = !constants_1.Constants.isDemoProject(projectId) &&
                        (await (0, ensureApiEnabled_1.check)(projectId, api.apiName, "extensions", true));
                    unemulatedAPIs[api.apiName] = {
                        apiName: api.apiName,
                        instanceIds: [i.instanceId],
                        enabled,
                    };
                }
            }
        }
    }
    return Object.values(unemul...
function displayWarningsForDeploy = async function displayWarningsForDeploy(instancesToCreate) {
    const uploadedExtensionInstances = instancesToCreate.filter((i) => i.ref);
    for (const i of uploadedExtensionInstances) {
        await (0, planner_1.getExtensionVersion)(i);
    }
    const unpublishedExtensions = uploadedExtensionInstances.filter((i) => { var _a, _b; return ((_b = (_a = i.extensionVersion) === null || _a === void 0 ? void 0 : _a.listing) === null || _b === void 0 ? void 0 : _b.state) !== "APPROVED"; });
    if (unpublishedExtensions.length) {
        const humanReadableList = unpublishedExtensions.map(toListEntry).join("\n");
        utils.logLabeledBullet(extensionsHelper_1.logPrefix, (0, marked_1.marked)(`The following extension versions have not been published to the Firebase Extensions Hub:\n${humanReadableList}\n.` +
            "Unpublished extensions have not been reviewed by " +
            "Firebase. Please make sure you trust the extension publisher before installing this extension.", { ...
function deprecate = async function deprecate(extensionRef, versionPredicate, options) {
    const { publisherId, extensionId, version } = extensionRef;
    if (version) {
        throw new error_1.FirebaseError(`The input extension reference must be of the format ${clc.bold("<publisherId>/<extensionId>")}. Version should be supplied in the version predicate argument.`);
    }
    if (!publisherId || !extensionId) {
        throw new error_1.FirebaseError(`Error parsing publisher ID and extension ID from extension reference '${clc.bold(refs.toExtensionRef(extensionRef))}'. Please use the format '${clc.bold("<publisherId>/<extensionId>")}'.`);
    }
    let filter = "";
    if (versionPredicate) {
        const { comparator, targetSemVer } = (0, versionHelper_1.parseVersionPredicate)(versionPredicate);
        filter = `id${comparator}"${targetSemVer}"`;
    }
    const extensionVersions = await (0, publisherApi_1.listExtensionVersions)(refs.toExtensionRef(extensionRef), filter);
    const filteredExtens...
function logAndTrackDeployStats = async function logAndTrackDeployStats(summary, context) {
    var _a, _b, _c;
    let totalTime = 0;
    let totalErrors = 0;
    let totalSuccesses = 0;
    let totalAborts = 0;
    const reports = [];
    const regions = new Set();
    const codebases = new Set();
    for (const result of summary.results) {
        const fnDeployEvent = {
            platform: result.endpoint.platform,
            trigger_type: backend.endpointTriggerType(result.endpoint),
            region: result.endpoint.region,
            runtime: result.endpoint.runtime,
            status: !result.error
                ? "success"
                : result.error instanceof AbortedDeploymentError
                    ? "aborted"
                    : "failure",
            duration: result.durationMs,
        };
        reports.push((0, track_1.trackGA4)("function_deploy", fnDeployEvent));
        regions.add(result.endpoint.region);
        codebases.add(result.endpoint.codebase || "default");
        totalT...
function hostingChannelDeployAction = async function hostingChannelDeployAction(channelId, options) {
    const projectId = (0, projectUtils_1.needProjectId)(options);
    if (options.open) {
        throw new error_1.FirebaseError("open is not yet implemented");
    }
    let expireTTL = expireUtils_1.DEFAULT_DURATION;
    if (options.expires) {
        expireTTL = (0, expireUtils_1.calculateChannelExpireTTL)(options.expires);
        logger_1.logger.debug(`Expires TTL: ${expireTTL}`);
    }
    if (!channelId) {
        throw new error_1.FirebaseError("channelID is currently required");
    }
    channelId = (0, api_1.normalizeName)(channelId);
    if (channelId.toLowerCase().trim() === "live") {
        throw new error_1.FirebaseError(`Cannot deploy to the ${(0, colorette_1.bold)("live")} channel using this command. Please use ${(0, colorette_1.bold)((0, colorette_1.yellow)("firebase deploy"))} instead.`);
    }
    if (options.only) {
        options.only = options.only
            .split(",")
            .map((o) =...
const extractEntriesFromBuffer = async (data, outputDir) => {
    let position = 0;
    logger_1.logger.debug(`Data is ${data.length}`);
    while (position < data.length) {
        const entryHeader = data.slice(position, position + 30);
        const entry = {};
        if (readUInt32LE(entryHeader, 0) !== 0x04034b50) {
            break;
        }
        entry.generalPurposeBitFlag = entryHeader.readUint16LE(6);
        entry.compressedSize = readUInt32LE(entryHeader, 18);
        entry.uncompressedSize = readUInt32LE(entryHeader, 22);
        entry.fileNameLength = entryHeader.readUInt16LE(26);
        entry.extraLength = entryHeader.readUInt16LE(28);
        entry.fileName = data.toString("utf-8", position + 30, position + 30 + entry.fileNameLength);
        entry.headerSize = 30 + entry.fileNameLength + entry.extraLength;
        let dataDescriptorSize = 0;
        if (entry.generalPurposeBitFlag === 8 &&
            entry.compressedSize === 0 &&
            entry.uncompressedSize ...
function cloneConfigOrVariable = async function cloneConfigOrVariable(key, fromProject, toProject) {
    const parts = key.split(".");
    if (functionsConfig.RESERVED_NAMESPACES.includes(parts[0])) {
        throw new error_1.FirebaseError("Cannot clone reserved namespace " + clc.bold(parts[0]));
    }
    const configName = ["projects", fromProject, "configs", parts[0]].join("/");
    if (parts.length === 1) {
        return cloneConfig(configName, toProject);
    }
    return runtimeconfig.variables.list(configName).then((variables) => {
        const promises = [];
        for (const variable of variables) {
            const varId = functionsConfig.varNameToIds(variable.name).variable;
            const variablePrefixFilter = parts.slice(1);
            if (matchPrefix(variablePrefixFilter, varId.split("/"))) {
                promises.push(cloneVariable(variable.name, toProject));
            }
        }
        return Promise.all(promises);
    });
}
function enable = async function enable(projectId, apiName) {
    try {
        await apiClient.post(`/projects/${projectId}/services/${apiName}:enable`, undefined, {
            headers: { "x-goog-quota-user": `projects/${projectId}` },
            skipLog: { resBody: true },
        });
    }
    catch (err) {
        if ((0, error_1.isBillingError)(err)) {
            throw new error_1.FirebaseError(`Your project ${(0, colorette_1.bold)(projectId)} must be on the Blaze (pay-as-you-go) plan to complete this command. Required API ${(0, colorette_1.bold)(apiName)} can't be enabled until the upgrade is complete. To upgrade, visit the following URL:

https://console.firebase.google.com/project/${projectId}/usage/details`);
        }
        else if (isPermissionError(err)) {
            const apiPermissionDeniedRegex = new RegExp(/Permission denied to enable service \[([.a-zA-Z]+)\]/);
            const permissionsError = apiPermissionDeniedRegex.exec(err.message);
            if (permissionsError && p...
function findEndpointForRewrite = function findEndpointForRewrite(site, targetBackend, id, region) {
    const endpoints = backend.allEndpoints(targetBackend).filter((e) => e.id === id);
    if (endpoints.length === 0) {
        return { matchingEndpoint: undefined, foundMatchingId: false };
    }
    if (endpoints.length === 1) {
        if (region && region !== endpoints[0].region) {
            return { matchingEndpoint: undefined, foundMatchingId: true };
        }
        return { matchingEndpoint: endpoints[0], foundMatchingId: true };
    }
    if (!region) {
        const us = endpoints.find((e) => e.region === "us-central1");
        if (!us) {
            throw new error_1.FirebaseError(`More than one backend found for function name: ${id}. If the function is deployed in multiple regions, you must specify a region.`);
        }
        (0, utils_1.logLabeledBullet)(`hosting[${site}]`, `Function \`${id}\` found in multiple regions, defaulting to \`us-central1\`. ` +
            `To rewrite to a different re...
