_tmp_0.jis0212 = [null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,728,711,184,729,733,175,731,730,65374,900,901,null,null,null,null,null,null,null,null,161,166,191,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,186,170,169,174,8482,164,8470,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,nul...
function SuperController = function SuperController(options) {

    //public
    this.name = 'SuperController';
    this.engine = {};


    var self = this;
    //private
    var local = {
        req     : null,
        res     : null,
        next    : null,
        options : options || null,
        query   : {},
        _data   : {},
        view    : {}
    };

    /**
     * SuperController Constructor
     * @constructor
     * */
    var init = function() {

        if ( typeof(SuperController.initialized) != 'undefined' ) {
            return getInstance()
        } else {

            SuperController.instance = self;


            if (local.options) {
                SuperController.instance._options = local.options;
            }

            SuperController.initialized = true;

        }
    }

    var getInstance = function() {
        local.options = SuperController.instance._options = options;
        // 2022-03-07 Fix for none-developpement environnements (without cache)
        self._options ...
this.connect = function(dbString, cb) {
        // Attention: the connection is lost 5 minutes once the bucket is opened.
        var conn        = null;

        var onError = function (err, next) {
            delete self.instance.reconnecting;
            self.instance.reconnected = self.instance.connected = false;
            console.error('[ CONNECTOR ][ ' + local.bundle +' ] couchbase could not be reached !!\n'+ ( err.stack || err.message || err ) );

            // reconnecting
            console.debug('[ CONNECTOR ][ ' + local.bundle +' ][ ' + dbString.database +' ] trying to reconnect in a few secs...');
            self.instance.reconnecting = true;

            setTimeout( function onRetry(){
                if ( typeof(next) != 'undefined' ) {
                    self.connect(dbString, next)
                } else {
                    self.connect(dbString)
                }
            }, 5000)

        };

        // once
        var onConnect = function onConnect(cb...
setTimeout(() => {
                            end(opt, cmd, isBulkRestart, bundleIndex, true)
                        }, 500)
var objectToString = function(obj) {
        var str = '';
        if (Array.isArray(obj)) {
            obj = JSON.stringify(obj.sort(), null, 0);
        } else {
            var arr = [], i = 0;
            for (let k in obj) {
                if ( /function/i.test(typeof(obj[k])) )
                    continue;
                arr[i] = k +':'+ obj[k];
                ++i;
            }
            str = arr.sort().join(',');
        }

        return str;
    }
this.client = cluster.openBucket(connectOptions.bucket, connectOptions.password, function(err) {
                if (err) {
                    console.log("Could not connect to couchbase with bucket: " + connectOptions.bucket);
                    self.emit('disconnect');
                } else {
                    self.emit('connect');
                }
            })
var end = function (output, type, messageOnly) {
        var err = false;
        if ( typeof(output) != 'undefined') {
            if ( output instanceof Error ) {
                err = output = ( typeof(messageOnly) != 'undefined' && /^true$/i.test(messageOnly) ) ? output.message : (output.stack||output.message);
            }
            if ( typeof(type) != 'undefined' ) {
                console[type](output)
            } else {
                console.log(output);
            }
        }

        process.exit( err ? 1:0 )
    }
client.on('error', (data) => {
            var err = data.toString();
            console.error('[MQTail] ' + err + ' - Gina might not be running');
            console.info('[MQTail] Waitting for `MQListener` to be started ...');

            // var mqPort = null;
            // nIntervId = setInterval(() => {
            //     try {
            //         mqPort = ~~(fs.readFileSync(mqPortFile).toString());
            //         if (mqPort) {
            //             process.emit('gina#mqlistener-started', mqPort, host);
            //         }
            //     } catch (fileErr) {}
            // }, 100);
        })
var loadPSL = async function(opt, cb) {
        var filenameOrUrl   = (isGFFCtx || opt.isCachingRequired) ? opt.url : opt.filename;
        var isUpdating      = ( typeof(opt.isUpdating) != 'undefined' ) ? opt.isUpdating : false;
        var err             = null;

        if (isGFFCtx) {

            if (self.rawPSL && !isUpdating) {
                cb(false);
                return;
            }

            if (!window.fetch) {// just in case
                err = new Error('[DOMAIN] Fetch API not supported');
                cb(err);
                return;
            }

            var response = null
                , result = null
            ;
            try {
                response    = await fetch(filenameOrUrl);
                result      = await response.text();

                self.rawPSL = result;
            } catch (PSLErr) {
                // There was an error
                // console.warn('[DOMAIN] Could not load PSL', err.stack || err.message || err);
    ...
modelUtil.reloadModels(
                            conf,
                            function doneReloadingModel(err) {
                                self.reconnecting = false;
                                cb(err)
                            })
var $validator      = { // isGFFCtx only
        'id'                    : null, // form id

        'plugin'                : this.plugin,
        'on'                    : (isGFFCtx) ? on : null,
        'eventData'             : {},
        'target'                : (isGFFCtx) ? document : null, // by default
        'cachedErrors'          : {},
        'binded'                : false,
        'unbinded'              : false,
        'withUserBindings'      : false,
        'rules'                 : {},
        'setOptions'            : null,
        'send'                  : null,
        'isValidating'          : null,
        'isSubmitting'          : null,
        'submit'                : null,
        'destroy'               : null,
        'resetErrorsDisplay'    : null,
        'resetFields'           : null
    }
(_tmp_12 = part.on('header', function(header) {
      var contype,
          fieldname,
          parsed,
          charset,
          encoding,
          filename,
          group,
          nsize = 0;

      if (header['content-type']) {
        parsed = parseParams(header['content-type'][0]);
        if (parsed[0]) {
          contype = parsed[0].toLowerCase();
          for (i = 0, len = parsed.length; i < len; ++i) {
            if (RE_CHARSET.test(parsed[i][0])) {
              charset = parsed[i][1].toLowerCase();
              break;
            }
          }
        }
      }

      if (contype === undefined)
        contype = 'text/plain';
      if (charset === undefined)
        charset = defCharset;

      if (header['content-disposition']) {
        parsed = parseParams(header['content-disposition'][0]);
        if (!RE_FIELD.test(parsed[0]))
          return skipPart(part);
        for (i = 0, len = parsed.length; i < len; ++i) {
          if (RE_NAME.test(parsed[i][0])) {
      ...).on
var format = function(date, mask, utc) {

        // if ( typeof(merge) == 'undefined' || !merge ) {
        //     merge = (isGFFCtx) ? require('lib/merge') : require('./../lib/merge');

        // }

        var dF          = self
            , i18n      = dF.i18n[dF.lang] || dF.i18n['en']
            //, masksList = merge(i18n.masks, dF.masks)
            , masksList = null
        ;

        try {
            masksList = merge(i18n.masks, dF.masks);
        } catch( mergeErr) {
            // called from logger - redefinition needed for none-dev env: cache issue
            isGFFCtx        = ( ( typeof(module) !== 'undefined' ) && module.exports ) ? false : true;
            merge           = (isGFFCtx) ? require('lib/merge') : require('./../lib/merge');
            masksList = merge(i18n.masks, dF.masks);
        }

        if ( typeof(dF.i18n[dF.culture]) != 'undefined' ) {
            i18n  = dF.i18n[dF.culture];
            if ( typeof(dF.i18n[dF.culture].mask) != 'undefined' ) ...
gina.onError(function(err, req, res, next){
                // (code)   message
                // (16)     Generic network failure. Enable detailed error codes (via LCB_CNTL_DETAILED_ERRCODES, or via `detailed_errcodes` in the connection string) and/or enable logging to get more information
                // (23)     Client-Side timeout exceeded for operation. Inspect network conditions or increase the timeout
                //          cannot perform operations on a shutdown bucket
                //          err instanceof CouchbaseError

                if (!self.instance.connected) {
                    self.instance.reconnected = false;
                    self.instance.reconnecting = false;
                }

                if (
                    err instanceof couchbase.Error && err.code == 16 && !self.reconnected
                    //|| err instanceof couchbase.Error && err.code == 23 && !self.reconnecting
                    || /cannot perform operations on a shutdow...
var end = function(err) {
        console.debug('GINA_ENV_IS_DEV ', GINA_ENV_IS_DEV);
        if (err) {
            if (GINA_ENV_IS_DEV) {
                console.error(err.stack);
            } else {
                console.error(err.message);
            }

            return process.exit(1);
        }
        var env = local.env;
        console.log('Environment [ '+env+' ] removed with success');

        return process.exit(0)
    }
self.checkIfVersionDir = function(done) {

        var version = require(self.opt.pack).version;

        if ( !getEnvVar('GINA_VERSION') ) {
            setEnvVar('GINA_VERSION', version)
        } else {
            version = getEnvVar('GINA_VERSION')
        }

        if ( !getEnvVar('GINA_SHORT_VERSION') ) {
            var shortVersion = version.split('.');
            shortVersion.splice(2);
            shortVersion = shortVersion.join('.');
            setEnvVar('GINA_SHORT_VERSION', shortVersion);
        }


        var release = version.split('.').splice(0,2).join(".");
        setEnvVar('GINA_RELEASE', release, true);
        var releasePath = self.opt.homedir + '/' + release;
        self.release = self.opt.release = release;

        console.debug('Checking version path... [ '+ releasePath +' ]');

        if ( !fs.existsSync(releasePath) ) {
            try {
                fs.mkdirSync(releasePath, 0775)
            } catch (err) {
                // console.error(e...
instance['setSearchOption'] = function() {

        if (!arguments.length)
            throw new Error('searchOption cannot be left blank');

        if (arguments.length > 3 || arguments.length < 3 && arguments.length > 1)
            throw new Error('argument length mismatch');

        var i       = 0
            , len   = arguments.length
        ;

        if (arguments.length == 1) {
            if ( typeof(arguments[0]) != 'object' )
                throw new Error('searchOption must be an object');

            for (var prop in arguments[0]) {
                if ( typeof(searchOptionRules[prop]) == 'undefined' )
                    throw new Error(arguments[1] + ' is not an allowed searchOption !');
            }

            localSearchOptions = arguments[0];
        } else {

            if ( !localSearchOptions )
                localSearchOptions = {};

            for (; i < len; ++i) {
                if ( typeof(searchOptionRules[arguments[1]]) == 'undefined' )
      ...
this.client.get(sid, function(err, data){
            //Handle Key Not Found error
            if (err && err.code == 13) {
                return fn();
            }
            if (err) return fn(err);
            if (!data || !data.value) return fn();
            var result;
            data = data.value.toString();
            debug('GOT %s', data);
            try {
                result = JSON.parse(data);
            } catch (err) {
                return fn(err);
            }
            return fn(null, result);
        })
function onPayload = function onPayload(opt, isResuming) {
        // console.debug('mqFile options: ', JSON.stringify(opt, null, 2));
        var port = opt.mqPort || getEnvVar('GINA_MQ_PORT') || 8125;// jshint ignore:line
        var host = opt.hostV4 || getEnvVar('GINA_HOST_V4') || '127.0.0.1';// jshint ignore:line
        var clientOptions = {
            host    : host,
            port    : port,
            request : 'writeToFile'
        }
        // var loggerOptions   = console.getOptions();
        // var loggers         = console.getLoggers();
        // var loggerHelper    = LoggerHelper(loggerOptions, loggers);
        // var format          = loggerHelper.format;




        var delayedMessages = [];
        var resume = function(payload) {
            // process.stdout.write('['+ mqId +'] Resuming with group: '+ payload.group);
            var i = 0;
            while (i < delayedMessages.length) {
                let pl = delayedMessages[i];
                // debug only
               ...
var addViews = function(b) {
        if (b > self.bundles.length-1) {// done
            process.exit(0)
        }

        var bundle = self.bundles[b];


        if ( /^[a-z0-9_.]/.test(bundle) ) {

            if ( !fs.existsSync(self.envPath) ) {
                lib.generator.createFileFromDataSync({}, self.envPath);
            }

            local.bundle    = bundle;
            local.b         = b;
            local.env       = self.projects[self.projectName]['def_env'];
            local.root      = self.projects[self.projectName].path;
            local.src       = _(self.bundlesLocation +'/'+ bundle, true);

            console.info('Adding view folder for: '+ local.bundle +'@'+ self.projectName);

            // local.namespaces = checkForNamespaces(local.src);


            addConfFile()

        } else {
            console.error('[ '+ bundle+' ] is not a valid bundle name')
            process.exit(1)
        }
    }
(_tmp_21 = rl
            .on('line', function(line) {

                if (!choice || typeof(choices[choice]) == 'undefined') { // protocol definition
                    choice = line.trim().toLowerCase();

                    if ( typeof(choices[choice]) != 'undefined') {
                        rl.clearLine();

                        // to the next question
                        list = '';
                        choicesOpt = JSON.clone(self.schemesAvailable);
                        choicesOpt.push('cancel');

                        for (var p = 0, len = choicesOpt.length; p < len; ++p) {

                            if (p < len-1) {
                                choices2[p+1] = choicesOpt[p];
                                choices2[choicesOpt[p]] = choicesOpt[p];
                            }

                            if (p == len-1) {
                                list += '\n';
                            }

                            if ( self.defaultScheme == choicesOpt[p...).on
app.init = function(credentials) {
                    this.cache = {};
                    this.engines = {};
                    this.settings = {};
                    this.credentials = credentials;
                    
                    this.defaultConfiguration();
                }
var cachedErrors = (
                            typeof(gina.validator) != 'undefined'
                            && typeof(gina.validator.$forms[currentFormId]) != 'undefined'
                            && typeof(gina.validator.$forms[currentFormId].cachedErrors) != 'undefined'
                        )
                        ? gina.validator.$forms[currentFormId].cachedErrors
                        : null
resetContext = function() {
        setPath('gina.root', getEnvVar('GINA_DIR'));
        var frameworkPath = getEnvVar('GINA_FRAMEWORK_DIR');
        setPath('framework', frameworkPath);
        setPath('gina.core', getEnvVar('GINA_CORE'));
        setPath('gina.lib', _(frameworkPath +'/lib'));
        setPath('gina.helpers', _(frameworkPath +'/helpers'));
        setPath( 'node', _(process.argv[0]), true);
        var projects    = require( _(getEnvVar('GINA_HOMEDIR') + '/projects.json', true) );
        var projectName = getContext('projectName');
        var root        = projects[projectName].path;
        setPath('project', root);
        var env         = getContext('env');
        var isDev       = (env === projects[projectName]['dev_env']) ? true: false;
        var bundlesPath = projects[projectName]['path'] + '/bundles'; // by default
        var isProductionScope = ('production' === projects[projectName]['def_scope']) ? true: false;
        if (isDev) {
            bundle...
self.bundlesConfiguration = {
                        env             : self.Env.get(),
                        version         : self.version,
                        conf            : self.getInstance(),
                        bundles         : self.getBundles(),
                        allBundles      : self.getAllBundles(),
                        isStandalone    : self.Host.isStandalone()
                    }
(_tmp_23 = rl
                .on('line', function(line) {

                    switch( line.trim().toLowerCase() ) {

                        case 'r':
                        case 'replace':
                            rl.clearLine();
                            makeBundle(local.bundle, true);
                        break;

                        case 'c':
                        case 'cancel':

                            if (local.b < self.bundles.length) {

                                rl.clearLine();
                                // continue to next bundle
                                ++local.b;
                                addBundles(local.b)

                            } else {

                                console.log('Aborting bundle installation');
                                rl.clearLine();
                                process.exit(0);
                            }

                        break;

                        case 'i':
                        cas...).on
var parseRouting = async function(params, url, request, response, next) {

        // Sample debug break for specific rule
        // if ( params.rule == 'my-specific-rule@bundle' ) {
        //     console.debug('passed '+ params.rule);
        // }

        var uRe             = params.url.split(/\//)
            , uRo           = url.split(/\//)
            , uReCount      = 0
            , uRoCount      = 0
            , maxLen        = uRo.length
            , score         = 0
            , foundRoute    = {}
            , i             = 0
            , method        = request.method.toLowerCase()
        ;

        // TODO - remove comments
        // when requirement is not listed but still validated
        // if (
        //     typeof(params.requirements) != 'undefined'
        //     && method == params.method.toLowerCase()
        //     //&& /validator\:\:/.test(JSON.stringify(params.requirements))
        // ) {

        //     var requiremements = Object.getOwnPropertyN...
var createFolder = function(){
            if ( fs.existsSync(gnaFolder) ) {
                if ( !fs.existsSync(gnaFolder +'/'+ file) ) {
                    createContent(gnaFolder +'/'+ file, gnaFolder, content, function(err){
                        setTimeout(function(){
                            callback(err)
                        }, 500)
                    })
                } else { // already existing ... won't overwrite
                    callback(false)
                }

            } else {
                fs.mkdir(gnaFolder, 0777, function(err){
                    if (err) {
                        console.error(err.stack);
                        callback(err)
                    } else {
                        //Creating content.
                        createContent(gnaFolder+ '/' +file, gnaFolder, content, function(err){
                            setTimeout(function(){
                                callback(err)
                            }, 500)
         ...
