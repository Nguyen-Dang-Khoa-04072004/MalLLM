gina.onError(function(err, req, res, next){
                // (code)   message
                // (16)     Generic network failure. Enable detailed error codes (via LCB_CNTL_DETAILED_ERRCODES, or via `detailed_errcodes` in the connection string) and/or enable logging to get more information
                // (23)     Client-Side timeout exceeded for operation. Inspect network conditions or increase the timeout
                //          cannot perform operations on a shutdown bucket
                //          err instanceof CouchbaseError

                if (!self.instance.connected) {
                    self.instance.reconnected = false;
                    self.instance.reconnecting = false;
                }

                if (
                    err instanceof couchbase.Error && err.code == 16 && !self.reconnected
                    //|| err instanceof couchbase.Error && err.code == 23 && !self.reconnecting
                    || /cannot perform operations on a shutdow...
var processSrc = function(method, src, target, zipInstance, options, cb) {

            if ( !fs.existsSync(src) ) {
                self.emit('archiver-'+ method +'#complete', new Error('file not found `'+ src +'`'));

                return;
            }

            stats = fs.statSync(src);

            var isBatchProcessing = ( typeof(cb) != 'undefined' ) ? true : false;

            if ( stats.isFile() ) { // single file compression


                var input   = null;
                var output  = null;

                if ( isBatchProcessing ) {
                    input   = src;
                    output  = target
                } else {
                    // targeted filename
                    if ( typeof(options.name) != 'undefined' && options.name != 'default') {
                        target += options.name;
                    } else {
                        target += src.substr(src.lastIndexOf('/')+1);
                    }

                    input   = fs.creat...
var setDefaultEvents = function(bundle, PID, proc) {


        if ( typeof(PID) != 'undefined' && typeof(PID) == 'number' ) {

            console.debug('[ PROC ] Setting listeners for ', PID, ':', bundle);

            proc.dismiss = dismiss;
            proc.isMaster = isMaster;


            proc.on('SIGTERM', function(code){
                if ( typeof(code) == 'undefined')
                    code = 0;
                // will handle `dismiss()`
                proc.exit(code);
            });

            proc.on('SIGABRT', function(code){
                if ( typeof(code) == 'undefined')
                    code = 0;
                // will handle `dismiss()`
                proc.exit(code);
            });


            proc.on('SIGINT', function(code){

                if (code == undefined)
                    code = 0;

                console.warn('[ PROC ] Got exit code. Now killing: ', code);
                // will handle `dismiss()`
                proc.exit(code);
      ...
var outputTo = function(data) {

        var targetObj = null;
        if (self.filename) {
            targetObj = new _(self.filename);
            if ( targetObj.existsSync() ) {
                targetObj.rmSync()
            }
        }
        if ( /^conf$/.test(self.format) ) {
            if (typeof(data) != 'string' ) {
                var str = '', i = 0, len = data.length;
                while (i<len) {
                    let d = data[i];
                    str += d.env +'_'+ d.bundle +'_'+ d.protocol +'_'+ d.scheme +'='+ d.port +':'+ d.port +'\n';
                    // Adding debug port
                    if (
                        typeof(self.selectedDebugPorts) != 'undefined'
                        && typeof(self.selectedDebugPorts[d.bundle]) != 'undefined'
                    ) {
                        str += d.env +'_'+ d.bundle +'_debug_port='+ d.debug_port +':'+ d.debug_port +'\n';
                    }
                    i++;
                }

              ...
CouchbaseStore.prototype.get = function(sid, fn){
        if ('function' !== typeof fn) { fn = noop; }
        sid = this.prefix + sid;
        debug('GET "%s"', sid);
        this.client.get(sid, function(err, data){
            //Handle Key Not Found error
            if (err && err.code == 13) {
                return fn();
            }
            if (err) return fn(err);
            if (!data || !data.value) return fn();
            var result;
            data = data.value.toString();
            debug('GOT %s', data);
            try {
                result = JSON.parse(data);
            } catch (err) {
                return fn(err);
            }
            return fn(null, result);
        });
    }
body = body.replace(/\"false\"/g, false).replace(/\"true\"/g, true).replace(/\"on\"/g, true)
self.respond = function(sessionId, payload) {
        //process.stdout.write(  '[MQListener] sending `'+ sessionId +'` '+ JSON.stringify(payload) +'\n' );
        sessions[sessionId].write( JSON.stringify(payload) +'\r\n');
    }
var addBundlePorts = function(b) {
        loadAssets();

        if (b > self.bundles.length-1) { // writing to files on complete

            hasPastProtocolAndSchemeCheck(self.defaultProtocol, self.defaultScheme, true);

            //console.debug('self.protocols ...', self.protocols);
            // get user protocols list
            var protocols = JSON.clone(self.protocols);
            // get user schemes list
            var schemes = JSON.clone(self.schemes);
            var projectConfig   = JSON.clone(self.projects);

            //console.debug('about to update project ports conf\n\rBundles: '+ JSON.stringify(self.projectData, null, 4));
            var ports               = JSON.clone(self.portsData) // cloning
                , portsReverse      = JSON.clone(self.portsReverseData) // cloning
                , portsList         = local.ports
                , isPortUsed        = false
                , envs              = self.envs
                , i                 = 0
...
function startMQListener = function startMQListener(opt, cb) {
        var port = opt.port;
        var host = opt.hostV4;
        var server = net.createServer( function(conn) {//'connection' listener

            conn.sessionId = uuid.v4();
            // conn.request = 'report'; // by default
            sessions[conn.sessionId] = conn;
            conn.write(JSON.stringify({ sessionId: conn.sessionId }) +'\r\n' );

            //feedback.
            var forwardId = null;
            conn.on('end', function() {
                delete sessions[this.sessionId];
                if ( this.request != 'report' ) {
                    forwardId = forwardList[this.request].indexOf(this.sessionId);
                    if ( forwardId > -1 && typeof(forwardList[this.request]) != 'undefined') {
                        forwardList[this.request].splice(forwardId, 1);
                    }
                }
                console.debug('[MQListener] (end) client disconected');
                //process.stdout.write('[M...
var isRealApp = function(bundle, callback) {

        var p               = null
            , d             = null
            , env           = self.projects[self.projectName]['def_env']
            , isDev         = GINA_ENV_IS_DEV
            , root          = self.projects[self.projectName].path
            , bundleDir     = null
            , bundlesPath   = null
            , bundleInit    = null
        ;

        try {
            //This is mostly for dev.
            var pkg = require( _(root + '/manifest.json') ).bundles;

            if ( typeof(pkg[bundle].version) == 'undefined' && typeof(pkg[bundle].tag) != 'undefined') {
                pkg[bundle].version = pkg[bundle].tag
            }
            if (
                pkg[bundle] != 'undefined' && pkg[bundle]['src'] != 'undefined' && isDev
            ) {
                var path = pkg[bundle].src;

                p = _( root +'/'+ path );//path.replace('/' + bundle, '')
                d = _( root +'/'+ path + '/inde...
var end = function (output, type, messageOnly) {
        var err = false;
        if ( typeof(output) != 'undefined') {
            if ( output instanceof Error ) {
                err = output = ( typeof(messageOnly) != 'undefined' && /^true$/i.test(messageOnly) ) ? output.message : (output.stack||output.message);
            }
            if ( typeof(type) != 'undefined' ) {
                console[type](output)
            } else {
                console.log(output);
            }
        }

        process.exit( err ? 1:0 )
    }
function stringToCodePoints = function stringToCodePoints(string) {
    /** @type {Array.<number>} */
    var cps = [];
    // Based on http://www.w3.org/TR/WebIDL/#idl-DOMString
    var i = 0, n = string.length;
    while (i < string.length) {
      var c = string.charCodeAt(i);
      if (!inRange(c, 0xD800, 0xDFFF)) {
        cps.push(c);
      } else if (inRange(c, 0xDC00, 0xDFFF)) {
        cps.push(0xFFFD);
      } else { // (inRange(cu, 0xD800, 0xDBFF))
        if (i === n - 1) {
          cps.push(0xFFFD);
        } else {
          var d = string.charCodeAt(i + 1);
          if (inRange(d, 0xDC00, 0xDFFF)) {
            var a = c & 0x3FF;
            var b = d & 0x3FF;
            i += 1;
            cps.push(0x10000 + (a << 10) + b);
          } else {
            cps.push(0xFFFD);
          }
        }
      }
      i += 1;
    }
    return cps;
  }
_tmp_28.push({
        "labels": [
          "cp1254",
          "csisolatin5",
          "iso-8859-9",
          "iso-ir-148",
          "iso8859-9",
          "iso88599",
          "iso_8859-9",
          "iso_8859-9:1989",
          "l5",
          "latin5",
          "windows-1254",
          "x-cp1254"
        ],
        "name": "windows-1254"
      })
cmd.protocols.indexOf(protocol) < 0 && re.test(ports[protocol][scheme][port])
typeof(EntitySuper[callerName].instance._relations[entityName]) == 'undefined'
e.once('server#started', function(conf){


                // open default browser for dev env only
                // if ( isDev) {
                //     var payload = JSON.stringify({
                //         code    : 200,
                //         command  : "open"
                //     });

                //     if (self.ioClient) { // if client has already made connexion
                //         payload.command = "reload"
                //     } else {
                //         // get default home
                //         // helper/task::run() should be triggered from ioClient
                //         //run('open', [conf.hostname + conf.server.webroot])
                //     }
                // }

                // will start watchers from here
                callback()
            })
lib.generator.createFileFromDataSync(ports, self.portsPath)
_tmp_28.push({
        "labels": [
          "cp1257",
          "windows-1257",
          "x-cp1257"
        ],
        "name": "windows-1257"
      })
fs.stat(p, function(err, stats) {
                if (err) {
                    callback(err)
                } else {

                    if (stats.isDirectory()) {
                        callback(false, d)
                    } else {
                        callback(new Error('[ ' + d + ' ] is not a directory'))
                    }
                }
            })
_tmp_28.push({
        "labels": [
          "x-mac-cyrillic",
          "x-mac-ukrainian"
        ],
        "name": "x-mac-cyrillic"
      })
var rollback = function(err) {
        console.error('[ CLI ] could not complete protocol creation: ', (err.stack||err.message));
        console.info('[ CLI ] rolling back...');

        var writeFiles = function() {

            //restore env.json
            if ( typeof(local.envDataWrote) == 'undefined' ) {
                lib.generator.createFileFromDataSync(self.envData, self.envPath);
            }
            //restore project.json
            if ( typeof(local.projectDataWrote) == 'undefined' ) {
                if ( typeof(self.projectData.bundles[local.bundle]) != 'undefined') {
                    delete self.projectData.bundles[local.bundle];
                }
                lib.generator.createFileFromDataSync(self.projectData, self.projectConfigPath);
            }

            //restore ports.json
            if ( typeof(local.portsDataWrote) == 'undefined' ) {
                lib.generator.createFileFromDataSync(self.portsData, self.portsPath);
            }

         ...
instance['or'] = function () {
        arguments[arguments.length] = true;
        ++arguments.length;

        return instance.find.apply(this, arguments);
    }
_tmp_22.push({
    "encodings": [
      {
        "labels": [
          "chinese",
          "csgb2312",
          "csiso58gb231280",
          "gb2312",
          "gb_2312",
          "gb_2312-80",
          "gbk",
          "iso-ir-58",
          "x-gbk"
        ],
        "name": "gbk"
      },
      {
        "labels": [
          "gb18030"
        ],
        "name": "gb18030"
      },
      {
        "labels": [
          "hz-gb-2312"
        ],
        "name": "hz-gb-2312"
      }
    ],
    "heading": "Legacy multi-byte Chinese (simplified) encodings"
  })
e.on('error', function(err, request, response, next) {

                callback(err, request, response, next)
            })
_.prototype.renameSync = function(destination) {
        var self = this;
        var source = self.value;

        if ( !existsSync(source) ) {
            throw new Error('Cannot complete rename from `'+ source +'`: the path does not exist.');
        }

        try {
            fs.renameSync(source, destination);
        } catch (err) {
            throw err
        }
    }
let section = fNameWithNoExt.replace(/(^settings\.|^settings$)/, '').replace(new RegExp('\.'+ env +'$'), '').replace(new RegExp('\.json$'), '')
self.setLevel = function(level, group) {
        if ( typeof(group) == 'undefined' || /^gina\-/.test(group) ) {
            group = 'gina'
        }

        var opt = loggers[group]._options;
        level = level.toLowerCase();
        if ( typeof(opt.hierarchies[level]) == 'undefined' ) {
            console.warn('`'+ level +'` is not a valid level: swithcing to `info`');
            level = 'info';
        }

        opt.name = group;
        process.env.LOG_GROUP = group;
        opt.hierarchy = level;
        process.env.LOG_LEVEL = level;

        setColors(group);
        setDefaultLevels(group);


        self.debug('Log level set for `'+ group +'`: '+ level);

        return
    }
gna.getMountedBundles = process.getMountedBundles = function(callback) {
            fs.readdir(bundlesPath, function onRead(err, files) {
                callback(err, files)
            })
        }
cmd.devEnv = (cmd.projectName != null &&typeof(cmd.projects[cmd.projectName]) != 'undefined' ) ? cmd.projects[cmd.projectName]['dev_env'] : cmd.mainConfig['dev_env'][ GINA_SHORT_VERSION ]
register(trigger, queryOptions, onQueryCallback, _mainCallback)
self.resumeReporting = function(group) {

        //  [ duplicate output fix ]
        // if (group && loggers[group]._options) {
        //     self.warn('[logger]['+ group +'] now resuming ('+ group +')\n');
        //     loggers[group]._options.isFlushing = false;
        // }

        loggers[ctx._options.name]._options.isReporting = true;



    }
cmd.defaultScheme = (cmd.projectName != null && typeof(cmd.projects[cmd.projectName]) != 'undefined' && typeof(cmd.projects[cmd.projectName]['def_scheme']) != 'undefined' ) ? cmd.projects[cmd.projectName]['def_scheme'] : cmd.mainConfig['def_scheme'][ GINA_SHORT_VERSION ]
controllerOptions.conf.content.routing[controllerOptions.rule].param = params.param
cmd.projectName != null && typeof(cmd.projects[cmd.projectName]) != 'undefined'
self.log = function() {
        var opt = self.getOptions();
        var args = arguments, content = '';

        //To handle logs with coma separated arguments.
        for (let i=0; i<args.length; ++i) {

            if (args[i] instanceof Object) {
                //console.log("\n...", args[i], args[i].toString());
                content += JSON.stringify(args[i], null, '\t');
            } else {
                content += args[i];

                // In case of formated entries - eg.: spawned server that is already returning formated logs
                // if ( /(\[|\[\s+)debug/.test(args[i]) ) {
                //     // args[i] = args[i].replace(/\n$/, '');
                //     // self.debug(args[i].replace(/^.*\[debug.*\]\s+/, '').replace(/\n$/, ''));

                // emit(opt, 'log', content.replace(/\n$/, ''), true);
                // return;

                    // emit(opt, 'debug', content.replace(/\n$/, ''), true);

                    // for (let p=0, pLen=op...
_tmp_109.labels = [
          "cseuckr",
          "csksc56011987",
          "euc-kr",
          "iso-ir-149",
          "korean",
          "ks_c_5601-1987",
          "ks_c_5601-1989",
          "ksc5601",
          "ksc_5601",
          "windows-949"
        ]
section = section.replace(/-([a-z])/g, function(g) { return g[1].toUpperCase(); })
throw new Error('[ Collection ][ notIn ] `filters` argument must be defined: Array or Filter Object(s) expected');
bundleConf = self.conf[altConf.split(/\@/)[1]][bundleConf.env]
filename = (bundleConf.staticResources.indexOf(path) > -1) ? bundleConf.content.statics[path] + url.replace(backedupPath, '/') : bundleConf.content.statics[staticProps.firstLevel] + url.replace(staticProps.firstLevel, '/')
filename = (bundleConf.staticResources.indexOf(path) > -1) ? bundleConf.content.statics[path] + url.replace(path, '/') : bundleConf.content.statics[staticProps.firstLevel] + url.replace(staticProps.firstLevel, '/')
_tmp_22.push({
    "encodings": [
      {
        "labels": [
          "csiso2022kr",
          "iso-2022-cn",
            "iso-2022-cn-ext",
            "iso-2022-kr"
        ],
        "name": "replacement"
      },
      {
        "labels": [
          "utf-16be"
        ],
        "name": "utf-16be"
      },
      {
        "labels": [
          "utf-16",
          "utf-16le"
        ],
        "name": "utf-16le"
      },
      {
        "labels": [
          "x-user-defined"
        ],
        "name": "x-user-defined"
      }
    ],
    "heading": "Legacy miscellaneous encodings"
  })
pkg[app] != 'undefined' && pkg[app]['src'] != 'undefined' && self.isCacheless()
var onRemoved = function(err, target) {
                        // err: 99% means that it doesn't exist. Well, we don't care do we ?.
                        if (!err) {

                            var isExcluded = false;
                            if ( typeof(source) != 'undefined' && excluded != undefined) {
                                var f, p = source.split('/');
                                f = p[p.length-1];
                                for (var r= 0; r<excluded.length; ++r) {
                                    if ( typeof(excluded[r]) == 'object' ) {
                                        if (excluded[r].test(f)) {
                                            isExcluded = true
                                        }
                                    } else if (f === excluded[r]) {
                                        isExcluded = true
                                    }
                                }
                            }
                         ...
cmd.bundlesByProject[project][bundle].protocols = cmd.projects[project].protocols
cmd.bundlesByProject[project][bundle].def_protocol = cmd.defaultProtocol
let reps = {
                    "frameworkDir"  : getEnvVar('GINA_FRAMEWORK_DIR'),
                    "executionPath" : root,
                    "projectPath"   : projectPath,
                    "bundlesPath" : appsPath,
                    "modelsPath" : modelsPath,
                    "tmpPath" : newContent[app][env].tmpPath,
                    "scope"     : newContent[app][env].server.scope,
                    "rootDomain"     : rootDomain,
                    "projectVersion"   : manifest,
                    "projectVersionMajor"   : manifest.version.split(/\./g)[0],
                    "host"     : newContent[app][env].host,
                    "scheme"    : newContent[app][env].server.scheme,
                    "env" : env,
                    "bundle" : app,
                    "version" : version
                }
throw new TypeError('Unknown encoding: ' + opt_encoding);
hasViews() && self.isCacheless() && !isWithoutLayout
                && localOptions.debugMode
                ||
                hasViews() && self.isCacheless() && !isWithoutLayout
                && typeof(localOptions.debugMode) == 'undefined'
                ||
                hasViews() && localOptions.debugMode
isValid = eval(compiledCondition)
