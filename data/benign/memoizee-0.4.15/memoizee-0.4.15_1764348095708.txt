memoized = defineLength(function (arg) {
			var id, result, args = arguments;
			if (resolve) args = resolve(args);
			id = get(args);
			if (id !== null) {
				if (hasOwnProperty.call(cache, id)) {
					if (getListeners) conf.emit("get", id, args, this);
					return cache[id];
				}
			}
			if (args.length === 1) result = call.call(original, this, args[0]);
			else result = apply.call(original, this, args);
			if (id === null) {
				id = get(args);
				if (id !== null) throw customError("Circular invocation", "CIRCULAR_INVOCATION");
				id = set(args);
			} else if (hasOwnProperty.call(cache, id)) {
				throw customError("Circular invocation", "CIRCULAR_INVOCATION");
			}
			cache[id] = result;
			if (setListeners) conf.emit("set", id, null, result);
			return result;
		}, memLength)
(_tmp_8 = (cachedCount / (initialCount + cachedCount)) * 100).toFixed
currentCallback = currentContext = currentArgs = null
nextTick(function () {
			var data;
			if (hasOwnProperty.call(cache, id)) {
				data = cache[id];
				conf.emit("getasync", id, args, context);
				apply.call(cb, data.context, data.args);
			} else {
				// Purged in a meantime, we shouldn't rely on cached value, recall
				currentCallback = cb;
				currentContext = context;
				currentArgs = args;
				base.apply(context, args);
			}
		})
log = "------------------------------------------------------------\n"
_tmp_1.__memoized__ = d(true)
result = call.call(original, this, args[0])
result = apply.call(original, this, args)
_tmp_9 = __ecma.Array.factory()
throw customError("Circular invocation", "CIRCULAR_INVOCATION");
memoized = defineProperties(
			defineLength(function (obj) {
				var memoizer, args = arguments;
				if (resolve) {
					args = resolve(args);
					obj = args[0];
				}
				memoizer = map.get(obj);
				if (!memoizer) {
					if (normalizer) {
						options = copy(options);
						options.normalizer = copy(normalizer);
						options.normalizer.get = partial.call(options.normalizer.get, obj);
						options.normalizer.set = partial.call(options.normalizer.set, obj);
						if (options.normalizer.delete) {
							options.normalizer.delete = partial.call(
								options.normalizer.delete, obj
							);
						}
					}
					map.set(obj, memoizer = memoize(partial.call(fn, obj), options));
				}
				return memoizer.apply(this, slice.call(args, 1));
			}, length),
			{
				__memoized__: d(true),
				delete: d(
					defineLength(function (obj) {
						var memoizer, args = arguments;
						if (resolve) {
							args = resolve(args);
							obj = args[0];
						}
						memoizer = map.get(obj);
	...
this[nameA].initial + this[nameA].cached
conf.original = function () {
		var args, cb, origCb, result;
		if (!currentCallback) return apply.call(original, this, arguments);
		args = aFrom(arguments);
		cb = function self(err) {
			var cb, args, id = self.id;
			if (id == null) {
				// Shouldn't happen, means async callback was called sync way
				nextTick(apply.bind(self, this, arguments));
				return undefined;
			}
			delete self.id;
			cb = waiting[id];
			delete waiting[id];
			if (!cb) {
				// Already processed,
				// outcome of race condition: asyncFn(1, cb), asyncFn.clear(), asyncFn(1, cb)
				return undefined;
			}
			args = aFrom(arguments);
			if (conf.has(id)) {
				if (err) {
					conf.delete(id);
				} else {
					cache[id] = { context: this, args: args };
					conf.emit("setasync", id, typeof cb === "function" ? 1 : cb.length);
				}
			}
			if (typeof cb === "function") {
				result = apply.call(cb, this, args);
			} else {
				cb.forEach(function (cb) { result = apply.call(cb, this, args); }, this);
			}...
extDel = defineLength(function (arg) {
			var id, args = arguments;
			if (resolve) args = resolve(args);
			id = get(args);
			if (id === null) return;
			conf.delete(id);
		}, memLength)
promises = create(null)
conf.emit("clearasync", objectMap(oldCache, function (data) { return [data]; }))
id === null
conf.on("clear", function () {
		var oldCache = cache;
		cache = create(null);
		conf.emit(
			"clearasync", objectMap(oldCache, function (data) { return slice.call(data.args, 1); })
		);
	})
