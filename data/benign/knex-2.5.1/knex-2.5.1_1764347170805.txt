module.exports = class Oracle_Transaction extends Transaction {
  // disable autocommit to allow correct behavior (default is true)
  begin(conn) {
    if (this.isolationLevel) {
      if (isIsolationLevelEnabled) {
        if (!supportedIsolationLevels.includes(this.isolationLevel)) {
          this.client.logger.warn(
            'Oracle only supports read committed and serializable transactions, ignoring the isolation level param'
          );
        } else {
          // I tried this, but it didn't work
          // Doc here: https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SET-TRANSACTION.html
          return this.query(conn, `SET TRANSACTION ${this.isolationLevel}`);
        }
      } else {
        this.client.logger.warn(
          'Transaction isolation is not currently supported for Oracle'
        );
      }
    }
    return Promise.resolve();
  }

  async commit(conn, value) {
    this._completed = true;
    try {
      await conn.commitAsync();
    ...
function stdMysqlQuery = async function stdMysqlQuery(con, sql) {
  return new Promise((resolve, reject) => {
    try {
      con.query(
        {
          sql,
          timeout: 500,
        },
        function (error, results, fields) {
          if (error) {
            reject(error);
          } else {
            resolve(results);
          }
        }
      );
    } catch (err) {
      reject(err); // double sure...
    }
  });
}
conn.saveTransaction(
        (err) => {
          if (err) {
            debug(
              'transaction::savepoint id=%s message=%s',
              this.txid,
              err.message
            );
            return reject(err);
          }

          this.trxClient.emit('query', {
            __knexUid: this.trxClient.__knexUid,
            __knexTxId: this.trxClient.__knexTxId,
            autogenerated: true,
            sql: this.outerTx
              ? `SAVE TRANSACTION [${this.txid}]`
              : `SAVE TRANSACTION`,
          });
          resolve();
        },
        this.outerTx ? this.txid : undefined
      )
function columnConstraintList = function columnConstraintList(ast, wrap) {
  return `${primaryColumnConstraint(ast, wrap)}${notnullColumnConstraint(
    ast,
    wrap
  )}${nullColumnConstraint(ast, wrap)}${uniqueColumnConstraint(
    ast,
    wrap
  )}${checkColumnConstraint(ast, wrap)}${defaultColumnConstraint(
    ast,
    wrap
  )}${collateColumnConstraint(ast, wrap)}${referencesColumnConstraint(
    ast,
    wrap
  )}${asColumnConstraint(ast, wrap)}`;
}
trxOrKnex
    .select('*')
    .from(lockTableWithSchema)
    .then((data) => {
      return !data.length
        ? trxOrKnex.from(lockTableWithSchema).insert({ is_locked: 0 })
        : null;
    })
function getFilepathsInFolder = async function getFilepathsInFolder(dir, recursive = false) {
  const pathsList = await readdir(dir);
  return flatten(
    await Promise.all(
      pathsList.sort().map(async (currentPath) => {
        const currentFile = path.resolve(dir, currentPath);
        const statFile = await stat(currentFile);
        if (statFile && statFile.isDirectory()) {
          if (recursive) {
            return await getFilepathsInFolder(currentFile, true);
          }
          return [];
        }
        return [currentFile];
      })
    )
  );
}
new Promise((resolver, rejecter) => {
      const connection = this.driver.createConnection(this.connectionSettings);
      connection.on('error', (err) => {
        connection.__knex__disposed = err;
      });
      connection.connect((err) => {
        if (err) {
          // if connection is rejected, remove listener that was registered above...
          connection.removeAllListeners();
          return rejecter(err);
        }
        resolver(connection);
      });
    })
function arrayToList = function arrayToList(array, finalEscape, ctx) {
  let sql = '';
  for (let i = 0; i < array.length; i++) {
    const val = array[i];
    if (Array.isArray(val)) {
      sql +=
        (i === 0 ? '' : ', ') + '(' + arrayToList(val, finalEscape, ctx) + ')';
    } else {
      sql += (i === 0 ? '' : ', ') + finalEscape(val, ctx);
    }
  }
  return sql;
}
const installArgs = _(buildDependencies)
          .pickBy(function (semver, dep) {
            // Check if the dependency is already installed
            try {
              require(dep);
              return false;
            } catch (err) {
              return true;
            }
          })
          .map(function (semver, dep) {
            // Format installable dependencies
            return dep + '@' + semver;
          })
          .value()
          .join(' ')
function escapeString = function escapeString(val, finalEscape, ctx) {
  let chunkIndex = (charsRegex.lastIndex = 0);
  let escapedVal = '';
  let match;

  while ((match = charsRegex.exec(val))) {
    escapedVal += val.slice(chunkIndex, match.index) + charsMap[match[0]];
    chunkIndex = charsRegex.lastIndex;
  }

  if (chunkIndex === 0) {
    // Nothing was escaped
    return "'" + val + "'";
  }

  if (chunkIndex < val.length) {
    return "'" + escapedVal + val.slice(chunkIndex) + "'";
  }

  return "'" + escapedVal + "'";
}
function recreateProxy = async function recreateProxy(serviceName, listenPort, proxyToPort) {
  try {
    await rp.delete({
      url: `${toxicli.host}/proxies/${serviceName}`,
    });
  } catch (err) {
    /* empty */
  }

  const proxy = await toxicli.createProxy({
    name: serviceName,
    listen: `0.0.0.0:${listenPort}`,
    upstream: `${serviceName}:${proxyToPort}`,
  });

  // add some latency
  await proxy.addToxic(
    new toxiproxy.Toxic(proxy, {
      type: 'latency',
      attributes: { latency: 1, jitter: 1 },
    })
  );

  // cause connections to be closed every some transferred bytes
  await proxy.addToxic(
    new toxiproxy.Toxic(proxy, {
      type: 'limit_data',
      attributes: { bytes: 1000 },
    })
  );
}
new Promise((_resolve, reject) => {
      if (!conn.inTransaction) {
        return reject(
          error || new Error('Transaction rejected with non-error: undefined')
        );
      }

      if (conn.state.name !== 'LoggedIn') {
        return reject(
          new Error(
            "Can't rollback transaction. There is a request in progress"
          )
        );
      }

      conn.rollbackTransaction(
        (err) => {
          if (err) {
            debug(
              'transaction::rollback error id=%s message=%s',
              this.txid,
              err.message
            );
          }

          reject(
            err ||
              error ||
              new Error('Transaction rejected with non-error: undefined')
          );
        },
        this.outerTx ? this.txid : undefined
      );
    }).catch((err) => {
      if (!error && this.doNotRejectOnRollback) {
        this._resolver();
        return;
      }
      if (error) {
        try {
          er...
let returnObj = {
      references(tableColumn) {
        let pieces;
        if (isString(tableColumn)) {
          pieces = tableColumn.split('.');
        }
        if (!pieces || pieces.length === 1) {
          foreignData.references = pieces ? pieces[0] : tableColumn;
          return {
            on(tableName) {
              if (typeof tableName !== 'string') {
                throw new TypeError(
                  `Expected tableName to be a string, got: ${typeof tableName}`
                );
              }
              foreignData.inTable = tableName;
              return returnObj;
            },
            inTable() {
              return this.on.apply(this, arguments);
            },
          };
        }
        foreignData.inTable = pieces[0];
        foreignData.references = pieces[1];
        return returnObj;
      },
      withKeyName(keyName) {
        foreignData.keyName = keyName;
        return returnObj;
      },
      onUpdate(statement) {
        foreignD...
(_tmp_6 = insertData.values
        .map(function (value, index) {
          const parameterizedValues = !insertDefaultsOnly
            ? self.client.parameterize(
                value,
                self.client.valueForUndefined,
                self.builder,
                self.bindingsHolder
              )
            : '';
          let subSql = 'insert into ' + self.tableName;

          if (insertDefaultsOnly) {
            // No columns given so only the default value
            subSql +=
              ' (' +
              self.formatter.wrap(self.single.returning) +
              ') values (default)';
          } else {
            subSql +=
              ' (' +
              self.formatter.columnize(insertData.columns) +
              ') values (' +
              parameterizedValues +
              ')';
          }

          let returningClause = '';
          let intoClause = '';
          // ToDo review if this code is still needed or could be dropped
          // eslint-di...).join
(_tmp_11 = dependenciesInstalledQ
          .then(function () {
            console.log('✓');
            // Don't need the flag anymore as `postinstall` was already run.
            // Change it back so the environment is minimally changed for the
            // remaining commands.
            process.env.POSTINSTALL_BUILD_CWD = POSTINSTALL_BUILD_CWD;
            console.log('Building compiled files (' + BUILD_COMMAND + ')');
            return exec(BUILD_COMMAND, opts);
          })
          .catch(function (err) {
            console.error(err);
            process.exit(1);
          })
          .then(function () {
            if (process.env.NODE_ENV === 'production') {
              console.log('✓');
              console.log('Pruning dev dependencies for production build');
              return exec('npm prune --production', opts);
            } else {
              console.log('Skipping npm prune');
            }
          })
          .then(function () {
            console.log('✓');...).catch
const connectionAcquirePromise = this.ensureConnection(
      ensureConnectionStreamCallback,
      {
        options,
        hasHandler,
        stream,
      }
    )
      // Emit errors on the stream if the error occurred before a connection
      // could be acquired.
      // If the connection was acquired, assume the error occurred in the client
      // code and has already been emitted on the stream. Don't emit it twice.
      .catch((err) => {
        if (!this.connection) {
          stream.emit('error', err);
        }
      })
SchemaBuilder.extend = (methodName, fn) => {
  if (
    Object.prototype.hasOwnProperty.call(SchemaBuilder.prototype, methodName)
  ) {
    throw new Error(
      `Can't extend SchemaBuilder with existing method ('${methodName}').`
    );
  }

  assign(SchemaBuilder.prototype, { [methodName]: fn });
}
joinWheres.push(
            this.whereBasic({
              column: clause.column,
              operator: '=',
              value: clause.value,
              asColumn: true,
            })
          )
Object.assign(knexContext, {
    queryBuilder() {
      return this.client.queryBuilder();
    },

    raw() {
      return this.client.raw.apply(this.client, arguments);
    },

    batchInsert(table, batch, chunkSize = 1000) {
      return batchInsert(this, table, batch, chunkSize);
    },

    // Creates a new transaction.
    // If container is provided, returns a promise for when the transaction is resolved.
    // If container is not provided, returns a promise with a transaction that is resolved
    // when transaction is ready to be used.
    transaction(container, _config) {
      // Overload support of `transaction(config)`
      if (!_config && isObject(container)) {
        _config = container;
        container = null;
      }

      const config = Object.assign({}, _config);
      config.userParams = this.userParams || {};
      if (config.doNotRejectOnRollback === undefined) {
        config.doNotRejectOnRollback = true;
      }

      return this._transaction(contain...
