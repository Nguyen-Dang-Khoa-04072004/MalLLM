this.rest.makeRequest('post', Endpoints.guilds, true, options).then(data => {
        if (this.client.guilds.has(data.id)) return resolve(this.client.guilds.get(data.id));

        const handleGuild = guild => {
          if (guild.id === data.id) {
            this.client.removeListener(Constants.Events.GUILD_CREATE, handleGuild);
            this.client.clearTimeout(timeout);
            resolve(guild);
          }
        };
        this.client.on(Constants.Events.GUILD_CREATE, handleGuild);

        const timeout = this.client.setTimeout(() => {
          this.client.removeListener(Constants.Events.GUILD_CREATE, handleGuild);
          reject(new Error('Took too long to receive guild data.'));
        }, 10000);
        return undefined;
      }, reject)
MessageEmbed.Thumbnail = MessageEmbedThumbnail
const timeout = this.client.setTimeout(() => {
          this.client.removeListener(Constants.Events.GUILD_CREATE, handleGuild);
          reject(new Error('Took too long to receive guild data.'));
        }, 10000)
this.rest.makeRequest(
      'delete', `${Endpoints.Channel(overwrite.channel).permissions}/${overwrite.id}`,
      true, undefined, undefined, reason
    ).then(() => overwrite)
<operator>.formatString("", Endpoints.Channel(overwrite.channel).permissions, "/", overwrite.id, "")
this.onSpeaking({ user_id: user.id, ssrc, speaking: true })
speakingTimeout = this.client.setTimeout(() => {
      try {
        this.onSpeaking({ user_id: user.id, ssrc, speaking: false });
        this.client.clearTimeout(speakingTimeout);
        this.speakingTimeouts.delete(ssrc);
      } catch (ex) {
        // Connection already closed, ignore
      }
    }, DISCORD_SPEAKING_DELAY)
util.deprecate(Collection.prototype.findAll, 'Collection#findAll: use Collection#filter instead')
