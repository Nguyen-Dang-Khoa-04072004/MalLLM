// File: package/index.js
// ======================================================================
Line 2: const escapeStringRegexp = require('escape-string-regexp')
Line 3: const ansiStyles = require('ansi-styles')
Line 4: const stdoutColor = require('supports-color').stdout
Line 6: const template = require('./templates.js')
Line 11: _tmp_16.push("ansi16m")
Line 14: _tmp_18.push("gray")
Line 32: applyOptions(chalk, options)
Line 34: {
			const args = [].slice.call(arguments);
			return chalkTag.apply(null, [chalk.template].concat(args));
		}
Line 35: const args = [].slice.call(arguments)
Line 36: _tmp_4.push(chalk.template)
Line 47: applyOptions(this, options)
Line 55: for (const key of Object.keys(ansiStyles)) {
	ansiStyles[key].closeRe = new RegExp(escapeStringRegexp(ansiStyles[key].close), 'g');

	styles[key] = {
		get() {
			const codes = ansiStyles[key];
			return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, key);
		}
	};
}
Line 56: ansiStyles[key].closeRe = new RegExp(escapeStringRegexp(ansiStyles[key].close), 'g')
Line 58: styles[key] = {
		get() {
			const codes = ansiStyles[key];
			return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, key);
		}
	}
Line 59: {
			const codes = ansiStyles[key];
			return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, key);
		}
Line 60: const codes = ansiStyles[key]
Line 61: build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, key)
Line 68: build.call(this, this._styles || [], true, 'visible')
Line 73: for (const model of Object.keys(ansiStyles.color.ansi)) {
	if (skipModels.has(model)) {
		continue;
	}

	styles[model] = {
		get() {
			const level = this.level;
			return function () {
				const open = ansiStyles.color[levelMapping[level]][model].apply(null, arguments);
				const codes = {
					open,
					close: ansiStyles.color.close,
					closeRe: ansiStyles.color.closeRe
				};
				return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, model);
			};
		}
	};
}
Line 78: styles[model] = {
		get() {
			const level = this.level;
			return function () {
				const open = ansiStyles.color[levelMapping[level]][model].apply(null, arguments);
				const codes = {
					open,
					close: ansiStyles.color.close,
					closeRe: ansiStyles.color.closeRe
				};
				return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, model);
			};
		}
	}
Line 81: {
				const open = ansiStyles.color[levelMapping[level]][model].apply(null, arguments);
				const codes = {
					open,
					close: ansiStyles.color.close,
					closeRe: ansiStyles.color.closeRe
				};
				return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, model);
			}
Line 82: const open = ansiStyles.color[levelMapping[level]][model].apply(null, arguments)
Line 88: build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, model)
Line 95: for (const model of Object.keys(ansiStyles.bgColor.ansi)) {
	if (skipModels.has(model)) {
		continue;
	}

	const bgModel = 'bg' + model[0].toUpperCase() + model.slice(1);
	styles[bgModel] = {
		get() {
			const level = this.level;
			return function () {
				const open = ansiStyles.bgColor[levelMapping[level]][model].apply(null, arguments);
				const codes = {
					open,
					close: ansiStyles.bgColor.close,
					closeRe: ansiStyles.bgColor.closeRe
				};
				return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, model);
			};
		}
	};
}
Line 100: const bgModel = 'bg' + model[0].toUpperCase() + model.slice(1)
Line 101: styles[bgModel] = {
		get() {
			const level = this.level;
			return function () {
				const open = ansiStyles.bgColor[levelMapping[level]][model].apply(null, arguments);
				const codes = {
					open,
					close: ansiStyles.bgColor.close,
					closeRe: ansiStyles.bgColor.closeRe
				};
				return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, model);
			};
		}
	}
Line 104: {
				const open = ansiStyles.bgColor[levelMapping[level]][model].apply(null, arguments);
				const codes = {
					open,
					close: ansiStyles.bgColor.close,
					closeRe: ansiStyles.bgColor.closeRe
				};
				return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, model);
			}
Line 105: const open = ansiStyles.bgColor[levelMapping[level]][model].apply(null, arguments)
Line 111: build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, model)
Line 117: Object.defineProperties(() => {}, styles)
Line 159: {
	// Support varags, but simply cast to string in case there's only one arg
	const args = arguments;
	const argsLen = args.length;
	let str = String(arguments[0]);

	if (argsLen === 0) {
		return '';
	}

	if (argsLen > 1) {
		// Don't slice `arguments`, it prevents V8 optimizations
		for (let a = 1; a < argsLen; a++) {
			str += ' ' + args[a];
		}
	}

	if (!this.enabled || this.level <= 0 || !str) {
		return this._empty ? '' : str;
	}

	// Turns out that on Windows dimmed gray text becomes invisible in cmd.exe,
	// see https://github.com/chalk/chalk/issues/58
	// If we're on Windows and we're dealing with a gray color, temporarily make 'dim' a noop.
	const originalDim = ansiStyles.dim.open;
	if (isSimpleWindowsTerm && this.hasGrey) {
		ansiStyles.dim.open = '';
	}

	for (const code of this._styles.slice().reverse()) {
		// Replace any instances already present with a re-opening code
		// otherwise only the part of the string until said closing code
		// will be colored, and the res...
Line 163: let str = String(arguments[0])
Line 171: {
			str += ' ' + args[a];
		}
Line 172: str += ' ' + args[a]
Line 188: _iterator_0.next()
Line 206: {
	if (!Array.isArray(strings)) {
		// If chalk() was called by itself or with a string,
		// return the string itself as a string.
		return [].slice.call(arguments, 1).join(' ');
	}

	const args = [].slice.call(arguments, 2);
	const parts = [strings.raw[0]];

	for (let i = 1; i < strings.length; i++) {
		parts.push(String(args[i - 1]).replace(/[{}\\]/g, '\\$&'));
		parts.push(String(strings.raw[i]));
	}

	return template(chalk, parts.join(''));
}
Line 210: [].slice.call(arguments, 1).join(' ')
Line 213: const args = [].slice.call(arguments, 2)
Line 214: const parts = [strings.raw[0]]
Line 216: {
		parts.push(String(args[i - 1]).replace(/[{}\\]/g, '\\$&'));
		parts.push(String(strings.raw[i]));
	}
Line 217: parts.push(String(args[i - 1]).replace(/[{}\\]/g, '\\$&'))
Line 218: parts.push(String(strings.raw[i]))
Line 221: template(chalk, parts.join(''))
Line 224: Object.defineProperties(Chalk.prototype, styles)

// File: package/templates.js
// ======================================================================
Line 7: new Map([
	['n', '\n'],
	['r', '\r'],
	['t', '\t'],
	['b', '\b'],
	['f', '\f'],
	['v', '\v'],
	['0', '\0'],
	['\\', '\\'],
	['e', '\u001B'],
	['a', '\u0007']
])
Line 8: _tmp_10.push(['n', '\n'])
Line 9: _tmp_10.push(['r', '\r'])
Line 10: _tmp_10.push(['t', '\t'])
Line 11: _tmp_10.push(['b', '\b'])
Line 12: _tmp_10.push(['f', '\f'])
Line 13: _tmp_10.push(['v', '\v'])
Line 14: _tmp_10.push(['0', '\0'])
Line 15: _tmp_10.push(['\\', '\\'])
Line 16: _tmp_10.push(['e', '\u001B'])
Line 17: _tmp_10.push(['a', '\u0007'])
Line 20: function unescape = function unescape(c) {
	if ((c[0] === 'u' && c.length === 5) || (c[0] === 'x' && c.length === 3)) {
		return String.fromCharCode(parseInt(c.slice(1), 16));
	}

	return ESCAPES.get(c) || c;
}
Line 22: String.fromCharCode(parseInt(c.slice(1), 16))
Line 28: {
	const results = [];
	const chunks = args.trim().split(/\s*,\s*/g);
	let matches;

	for (const chunk of chunks) {
		if (!isNaN(chunk)) {
			results.push(Number(chunk));
		} else if ((matches = chunk.match(STRING_REGEX))) {
			results.push(matches[2].replace(ESCAPE_REGEX, (m, escape, chr) => escape ? unescape(escape) : chr));
		} else {
			throw new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name}')`);
		}
	}

	return results;
}
Line 29: const results = []
Line 30: args.trim()
Line 33: _iterator_0.next()
Line 35: results.push(Number(chunk))
Line 36: {
			results.push(matches[2].replace(ESCAPE_REGEX, (m, escape, chr) => escape ? unescape(escape) : chr));
		}
Line 37: results.push(matches[2].replace(ESCAPE_REGEX, (m, escape, chr) => escape ? unescape(escape) : chr))
Line 46: {
	STYLE_REGEX.lastIndex = 0;

	const results = [];
	let matches;

	while ((matches = STYLE_REGEX.exec(style)) !== null) {
		const name = matches[1];

		if (matches[2]) {
			const args = parseArguments(name, matches[2]);
			results.push([name].concat(args));
		} else {
			results.push([name]);
		}
	}

	return results;
}
Line 49: const results = []
Line 52: {
		const name = matches[1];

		if (matches[2]) {
			const args = parseArguments(name, matches[2]);
			results.push([name].concat(args));
		} else {
			results.push([name]);
		}
	}
Line 53: const name = matches[1]
Line 55: {
			const args = parseArguments(name, matches[2]);
			results.push([name].concat(args));
		}
Line 56: const args = parseArguments(name, matches[2])
Line 57: results.push([name].concat(args))
Line 58: {
			results.push([name]);
		}
Line 59: results.push([name])
Line 69: _iterator_1.next()
Line 70: for (const style of layer.styles) {
			enabled[style[0]] = layer.inverse ? null : style.slice(1);
		}
Line 71: enabled[style[0]] = layer.inverse ? null : style.slice(1)
Line 76: Object.keys(enabled)
Line 82: {
				current = current[styleName].apply(current, enabled[styleName]);
			}
Line 83: current = current[styleName].apply(current, enabled[styleName])
Line 84: {
				current = current[styleName];
			}
Line 85: current = current[styleName]
Line 93: {
	const styles = [];
	const chunks = [];
	let chunk = [];

	// eslint-disable-next-line max-params
	tmp.replace(TEMPLATE_REGEX, (m, escapeChar, inverse, style, close, chr) => {
		if (escapeChar) {
			chunk.push(unescape(escapeChar));
		} else if (style) {
			const str = chunk.join('');
			chunk = [];
			chunks.push(styles.length === 0 ? str : buildStyle(chalk, styles)(str));
			styles.push({inverse, styles: parseStyle(style)});
		} else if (close) {
			if (styles.length === 0) {
				throw new Error('Found extraneous } in Chalk template literal');
			}

			chunks.push(buildStyle(chalk, styles)(chunk.join('')));
			chunk = [];
			styles.pop();
		} else {
			chunk.push(chr);
		}
	});

	chunks.push(chunk.join(''));

	if (styles.length > 0) {
		const errMsg = `Chalk template literal is missing ${styles.length} closing bracket${styles.length === 1 ? '' : 's'} (\`}\`)`;
		throw new Error(errMsg);
	}

	return chunks.join('');
}
Line 94: const styles = []
Line 95: const chunks = []
Line 96: let chunk = []
Line 101: chunk.push(unescape(escapeChar))
Line 102: {
			const str = chunk.join('');
			chunk = [];
			chunks.push(styles.length === 0 ? str : buildStyle(chalk, styles)(str));
			styles.push({inverse, styles: parseStyle(style)});
		}
Line 103: chunk.join('')
Line 104: chunk = []
Line 105: chunks.push(styles.length === 0 ? str : buildStyle(chalk, styles)(str))
Line 106: styles.push({inverse, styles: parseStyle(style)})
Line 107: {
			if (styles.length === 0) {
				throw new Error('Found extraneous } in Chalk template literal');
			}

			chunks.push(buildStyle(chalk, styles)(chunk.join('')));
			chunk = [];
			styles.pop();
		}
Line 112: chunks.push(buildStyle(chalk, styles)(chunk.join('')))
Line 113: chunk = []
Line 116: chunk.push(chr)
Line 120: chunks.push(chunk.join(''))
Line 127: chunks.join('')
