var removeEnv = function(projects, target) {
        var err = null, env = local.env;
        // default `dev env` cannot be removed
        if(env === projects[self.projectName]['dev_env']|| env === projects[self.projectName]['def_env']) {
            if (env === projects[self.projectName]['def_env']) {
                err = new Error('Environment [ '+env+' ] is set as "default environment"')
            } else {
                err = new Error('Environment [ '+env+' ] is linked as "development environment"')
            }

            return end(err);
        }

        projects[self.projectName]['envs'].splice(projects[self.projectName]['envs'].indexOf(env), 1);
        lib.generator.createFileFromDataSync(
            projects,
            target
        );
        // clean ports & reverse ports registered for the project
        var portsPath = _(GINA_HOMEDIR + '/ports.json')
            , portsReversePath = _(GINA_HOMEDIR + '/ports.reverse.json')
            , ports = require(port...
_tmp_0.iso-8859-8 = [128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,null,162,163,164,165,166,167,168,169,215,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,247,187,188,189,190,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,8215,1488,1489,1490,1491,1492,1493,1494,1495,1496,1497,1498,1499,1500,1501,1502,1503,1504,1505,1506,1507,1508,1509,1510,1511,1512,1513,1514,null,null,8206,8207,null]
_tmp_0.windows-1256 = [8364,1662,8218,402,8222,8230,8224,8225,710,8240,1657,8249,338,1670,1688,1672,1711,8216,8217,8220,8221,8226,8211,8212,1705,8482,1681,8250,339,8204,8205,1722,160,1548,162,163,164,165,166,167,168,169,1726,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,1563,187,188,189,190,1567,1729,1569,1570,1571,1572,1573,1574,1575,1576,1577,1578,1579,1580,1581,1582,1583,1584,1585,1586,1587,1588,1589,1590,215,1591,1592,1593,1594,1600,1601,1602,1603,224,1604,226,1605,1606,1607,1608,231,232,233,234,235,1609,1610,238,239,1611,1612,1613,1614,244,1615,1616,247,1617,249,1618,251,252,8206,8207,1746]
var onError = function (err, next) {
            delete self.instance.reconnecting;
            self.instance.reconnected = self.instance.connected = false;
            console.error('[ CONNECTOR ][ ' + local.bundle +' ] couchbase could not be reached !!\n'+ ( err.stack || err.message || err ) );

            // reconnecting
            console.debug('[ CONNECTOR ][ ' + local.bundle +' ][ ' + dbString.database +' ] trying to reconnect in a few secs...');
            self.instance.reconnecting = true;

            setTimeout( function onRetry(){
                if ( typeof(next) != 'undefined' ) {
                    self.connect(dbString, next)
                } else {
                    self.connect(dbString)
                }
            }, 5000)

        }
out = execSync('gina bundle:list @'+ self.projectName +' --format=json').toString().replace(/(\n|\r)$/, '').split(/(\n|\r)/g)
function ByteInputStream = function ByteInputStream(bytes) {
  /** @type {number} */
  var pos = 0;

  /**
   * @this {ByteInputStream}
   * @returns {number} Get the next byte from the stream.
   */
  this.get = function() {
    return (pos >= bytes.length) ? EOF_byte : Number(bytes[pos]);
  };

  /** @param {number} n Number (positive or negative) by which to
   *      offset the byte pointer. */
  this.offset = function(n) {
    pos += n;
    if (pos < 0) {
      throw new Error('Seeking past start of the buffer');
    }
    if (pos > bytes.length) {
      throw new Error('Seeking past EOF');
    }
  };

  /**
   * @param {Array.<number>} test Array of bytes to compare against.
   * @returns {boolean} True if the start of the stream matches the test
   *     bytes.
   */
  this.match = function(test) {
    if (test.length > pos + bytes.length) {
      return false;
    }
    var i;
    for (i = 0; i < test.length; i += 1) {
      if (Number(bytes[pos + i]) !== test[i]) {
        return false;
      }
    }...
var init = function(options) {

        self.projectName    = options.projectName;
        //Starting app.
        self.appName        = options.bundle;
        self.env            = options.env;
        self.version        = options.version;
        local.router        = new Router(self.env);

        //True => multiple bundles sharing the same server (port).
        self.isStandalone   = options.isStandalone;
        self.bundles        = options.bundles;
        self.executionPath  = options.executionPath;


        if (!self.isStandalone) {
            //Only load the related conf / env.
            self.conf[self.appName] = {};
            self.conf[self.appName][self.env] = options.conf[self.appName][self.env];
            self.conf[self.appName][self.env].bundlesPath = options.conf[self.appName][self.env].bundlesPath;
            self.conf[self.appName][self.env].modelsPath =  options.conf[self.appName][self.env].modelsPath;
            self.conf[self.appName][self.env].execution...
function setup = function setup(group, filenames, props) {
        //var group = process.title; // gina, frontend@myproject ...
        console.log('['+ mqId +'] setting up '+ group);

        // we only want the bundle's logs
        if (
            !/\@/.test(group)
            // ||
            // props.bundles
            // && props.bundles.length == 0
            // ||
            // props.bundles
            // && props.bundles.indexOf(group) < 0
        ) {
            return
        }

        if ( !filenames[group] ) {
            filenames[group] = {}
        }
        process.stdout.write( format(opt.name, 'info', '['+ mqId +'] setting up '+ group +'\nFilenames: '+ JSON.stringify(filenames, null, 2)) );
        /// aready defiened
        if ( filenames[group].filename) {
            return
        }

        // retriving hostname
        var bfnArr = group.split(/\@/);
        var bundleName = bfnArr[0];
        var projectName = bfnArr[1];
        var homeDir = getUserHome() || proces...
browse(method, src, target, zipInstance, options, [], [], 0, null, isBatchProcessing, function(err, target, zipInstance) {
                    if ( isBatchProcessing ) {
                        cb(err, zipInstance);
                    } else {
                        self.emit('archiver-'+ method +'#complete', err, target);
                    }
                })
this.onReady = function(callback) {
        self.once('model#ready', function(err, bundle, model, conn) {
            // entities == null when the database server has not started.
            if ( err ) {
                console.error(err.stack||err.message)
                //console.log('No entities found for [ '+ self.name +':'+ entityName +'].\n 1) Check if the database is started.\n2) Check if exists: /models/entities/'+ entityName);
            }
            callback(err, bundle, model, conn)
        });
        setup(namespace);
        return init()
    }
this.client.upsert(sid, sess, {expiry:ttl})
                .then(function onResult(_result){
                    result = _result;
                    //fn && fn.apply(this, arguments);
                })
                .catch(function onError(_err) {
                    err = _err
                    // if(err)
                    //     debug('Session Set complete', err.stack || err.message || err);

                    //fn && fn.apply(this, arguments);
                })
var existsSync = function(value) {
        if ( typeof(fs.accessSync) != 'undefined' ) {
            try {
                fs.accessSync(value, fs.constants.F_OK);
                return true;
            } catch (err) {
                // to handle symlinks
                try {
                    if ( fs.lstatSync(value).isSymbolicLink() ) {
                        return true
                    }
                } catch (linkErr) {}

                return false;
            }

        } else { // support for old version of nodejs
            return fs.existsSync(value);
        }
    }
CouchbaseStore.prototype.destroy = function(sid, fn){
        if ('function' !== typeof fn) { fn = noop; }
        sid = this.prefix + sid;
        //this.client.remove(sid, fn);
        this.client
                .remove(sid)
                .then(fn)
                .catch(fn)
    }
self.checkArch = function(done) {

        var currentArch = process.arch;
        var currentPlatform = process.platform;
        // ignored for framework:set
        var mainConfig = require( self.opt.homedir + '/main.json' );
        var defaultMainConfig = requireJSON( getPath('gina').root + '/resources/home/main.json' );
        //has registered arch ?
        var arch        = getEnvVar('GINA_ARCH') || mainConfig['def_arch'][self.release] || null; // arch by default
        if ( typeof(mainConfig.archs) == 'undefined' ) {
            mainConfig.archs = {};
            mainConfig.archs[self.release] = defaultMainConfig.archs['{release}'];
            mainConfig['def_arch'] = {}
            mainConfig['def_arch'][self.release] = currentArch;
            isUpdateNeeded = true;
        }
        if ( mainConfig.archs[self.release].indexOf(arch) < 0 ) {
            console.error('Arch [ ' + arch + ' ] not registered. Gina is not support your architecture `'+ process.arch +'` at thi...
<operator>.formatString("[Certificate] ", endpoint, " : It is like there is a problem with your CA certificate", '\n', " ", humanView, "")
var end = function (output, type, messageOnly) {
        var err = false;
        if ( typeof(output) != 'undefined') {
            if ( output instanceof Error ) {
                err = output = ( typeof(messageOnly) != 'undefined' && /^true$/i.test(messageOnly) ) ? output.message : (output.stack||output.message);
            }
            if ( typeof(type) != 'undefined' ) {
                console[type](output)
            } else {
                console.log(output);
            }
        }

        process.exit( err ? 1:0 )
    }
console.error('Scheme [ '+scheme+' ] is not an allowed scheme: check your framework configuration (~/main.json)')
var compressFile = function(method, input, output, zipInstance, isBatchProcessing, cb, isPackage) {

        var methodObject = null;
        isPackage = ( typeof(isPackage) == 'undefined' ) ? false: isPackage;

        if ( isBatchProcessing ) {

            zipInstance.file(output, fs.createReadStream(input));

            cb(false, output, zipInstance);
            return
        }

        switch (method) {
            case 'gzip':
                methodObject = zlib.createGzip();
                break;

            default:
                methodObject = zlib.createGzip();
                break;
        }


        if ( /\/\.(.*)$/.test(input.path) ) {

            if (isPackage) {
                cb(false, input)
            } else {
                cb(false, input.path)
            }
            return
        } else {
            input
                .pipe(methodObject)
                .pipe(output);
        }


        output
            .once('error', function onCompressionEr...
set('page.environment.routing', encodeRFC5987ValueChars(JSON.stringify(routing)))
var onRoutesLoaded = function(callback) {

        var config                  = new Config()
            , conf                  = config.getInstance(self.appName)
            , serverCoreConf        = self.conf.core
            , routing               = {}
            , reverseRouting        = {}
            , cacheless             = config.isCacheless()
            , env                   = self.env
            , apps                  = conf.allBundles//conf.bundles
            , filename              = ''
            , appName               = ''
            , tmp                   = {}
            , standaloneTmp         = {}
            , main                  = ''
            , tmpContent            = ''
            , i                     = 0
            , file                  = null // template file
            , wroot                 = null
            , hasWebRoot            = false
            , webrootAutoredirect   = null
            , localWroot            = null
        ...
self.models[bundle][connector]['getConnection'] = function() {
                                            return self.models[bundle][connector]['_connection']
                                        }
output
            .once('error', function onCompressionError(err) {
                cb(err, null)
            })
            .once('finish', function onCompressionFinished(){
                if (isPackage) {
                    cb(false, this, zipInstance)
                } else {
                    cb(false, this.path, zipInstance)
                }
            })
socket.on('message', function(payload){

                try {
                    console.debug('[IO SERVER ] receiving '+ payload);
                    payload = JSON.parse(payload);
                    // bind to session ID
                    if ( typeof(payload.session) != 'undefined' ) {
                        this.sessionId = payload.session.id;
                    }
                } catch(err) {
                    console.error(err.stack||err.message|| err)
                }
            })
var listBundleOnly = function() {

        var protocols   = self.protocols
            , schemes   = self.schemes
            , found     = false
            , str       = ''
            , re        = null
        ;

        var jsonCollection =  new Collection([]);
        for (let i = 0, len = protocols.length; i < len; ++i) {
            let protocol = protocols[i];
            str += '[ '+ protocol +' ]\n\r';
            for (let s = 0, sLen = schemes.length; s < sLen; ++s) {
                let scheme = schemes[s];
                let bundle = self.name;
                found = false;
                // re = new RegExp('^' + bundle + '\@', '');// searching by bundle name
                re = new RegExp('^' + bundle + '\@' + self.projectName + '\/', '');// searching by projectName
                for (let port in self.portsData[protocol][scheme]) {

                    let bundleEnv = self.portsData[protocol][scheme][port].replace(re, '\:').split(/\:/);
                    let _bun...
scan(options, function(err, ports){

                if (err) {
                    console.error(err.stack|err.message);
                    process.exit(1)
                }


                for (let p = 0; p < ports.length; ++p) {
                    local.ports.push(ports[p])
                }

                // local.ports.sort();

                ++local.b;
                addBundlePorts(local.b);
            })
local.errors[this.name].isStringLength = replace(this.error || local.errorLabels.isStringMinLength, this)
console.error('Scheme [ '+scheme+' ] is not an allowed scheme: check your framework configuration (~/main.json)')
self.checkIfSettings = function(done) {
        console.debug('Checking framework settings...');
        var main            = require( _(self.opt.homedir + '/main.json', true) )
            , version       = getEnvVar('GINA_VERSION')
            , prefix        = getEnvVar('GINA_PREFIX') || main['def_prefix'][self.release]
            , globalMode    = getEnvVar('GINA_GLOBAL_MODE') || main['def_global_mode'][self.release]
            , arch          = getEnvVar('GINA_ARCH') || main['def_arch'][self.release]
            , platform      = getEnvVar('GINA_PLATFORM') || main['def_platform'][self.release]
            , env           = getEnvVar('GINA_ENV') || main['def_env'][self.release]
            , scope         = getEnvVar('GINA_SCOPE') || main['def_scope'][self.release]
            , settings      = requireJSON( _( getPath('gina').root + '/resources/home/settings.json', true ) )
            , userSettings  = {}
            , target        = _(self.opt.homedir +'/'+ self.release +'...
var dic = {
                'prefix' : prefix,
                'global_mode': globalMode,
                'version' : version,
                'arch' : arch,
                'platform': platform,
                'env' : env,
                'env_is_dev' : (main['dev_env'][self.release] == env) ? true : false,
                'dev_env' : main['dev_env'][self.release],
                'scope' : scope,
                'scope_is_local' : (main['local_scope'][self.release] == scope) ? true : false,
                'local_scope': main['local_scope'][self.release],
                'culture' : getEnvVar('GINA_CULTURE'),
                'timezone' : getEnvVar('GINA_TIMEZONE'),
                'node_version': process.version,
                'port' : getEnvVar('GINA_PORT') || 8124, // TODO - scan for the next available port
                'debug_port' : getEnvVar('GINA_DEBUG_PORT') || process.debugPort || 5757,
                'host_v4' : getEnvVar('GINA_HOST_V4') || '127.0.0.1',
               ...
EntitySuper[callerName].instance._relations[entityName] = new modelUtil.entities[self.bundle][self.model][entity](self.getConnection(), callerName)
typeof(errors[name]) == 'undefined' && /(form\-item\-error|form\-item\-warning)/.test($parent.className) || typeof(errors[name]) != 'undefined' && errors[name].count() == 0 && /(form\-item\-error|form\-item\-warning)/.test($parent.className)
str += '"'+attr+'": "' + obj[attr]
                            .replace(/\'/g, "\\'")
                            .replace(/\"/g, '\\"') +'"'
constructor = constructor
                    .splice(constructor.length-1,1)
                    .toString()
console.warn('Dependency bundle config not found for `'+ app +'/'+ env +'`: trying to load on the fly from src')
path = (isRenderingCustomError) ? _(file) : _(localOptions.template.html +'/'+ localOptions.namespace + '/' + file)
newContent[app][env].bundlesPath = bundlesPath = appSrcPath.replace( new RegExp('/'+ app), '' )
function () { // getting rid of the middleware context

                        var Middleware = require(_(filename, true));
                        // TODO - loop on a defined SuperController property like SuperController._allowedForExport


                        // Exporting config & common methods
                        Middleware.prototype.checkBundleStatus      = controller.checkBundleStatus;
                        Middleware.prototype.getConfig              = controller.getConfig;
                        Middleware.prototype.getFormsRules          = controller.getFormsRules;
                        Middleware.prototype.getLocales             = controller.getLocales;
                        Middleware.prototype.isCacheless            = controller.isCacheless;
                        Middleware.prototype.isHaltedRequest        = controller.isHaltedRequest;
                        Middleware.prototype.isWithCredentials      = controller.isWithCredentials;
                    ...
var profilePathObj = new _(profilePath)
