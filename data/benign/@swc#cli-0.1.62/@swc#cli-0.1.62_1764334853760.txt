function _getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
program.option("-w, --watch", "Recompile files on changes")
await Object.keys(output).map(async (name)=>{
                let fullPath = '';
                if (isUserDefinedEntry(name)) {
                    fullPath = (0, _path.join)(spackOptions.output.path, spackOptions.output.name.replace('[name]', name));
                } else {
                    const ext = (0, _path.extname)(name);
                    const base = (0, _path.basename)(name, ext);
                    const filename = (0, _path.relative)(process.cwd(), name);
                    fullPath = (0, _path.join)(spackOptions.output.path, (0, _path.dirname)(filename), `${base}.js`);
                }
                await makeDir((0, _path.dirname)(fullPath), {
                    recursive: true
                });
                await write(fullPath, output[name].code, 'utf-8');
                if (output[name].map) {
                    await write(`${fullPath}.map`, output[name].map, 'utf-8');
                }
            })
program.option("-d, --out-dir [out]", "Compile an input directory of modules into an output directory")
function handleCompile = async function handleCompile(filename, outDir, sync, swcOptions) {
    const dest = getDest(filename, outDir, ".js");
    const sourceFileName = (0, _slash.default)((0, _path.relative)((0, _path.dirname)(dest), filename));
    const options = {
        ...swcOptions,
        sourceFileName
    };
    const result = await (0, _util.compile)(filename, options, sync, dest);
    if (result) {
        await (0, _compile.outputResult)(result, filename, dest, options);
        return _constants.CompileStatus.Compiled;
    } else {
        return _constants.CompileStatus.Omitted;
    }
}
program.option("--sync", "Invoke swc synchronously. Useful for debugging.", collect)
function outputResult = async function outputResult(output, sourceFile, destFile, options) {
    const destDir = (0, _path.dirname)(destFile);
    const { sourceMap , sourceMapPath , sourceCode  } = withSourceMap(output, options, destFile, destDir);
    await mkdir(destDir, {
        recursive: true
    });
    const { mode  } = await stat(sourceFile);
    if (!sourceMapPath) {
        await writeFile(destFile, sourceCode, {
            mode
        });
    } else {
        await Promise.all([
            writeFile(destFile, sourceCode, {
                mode
            }),
            writeFile(sourceMapPath, sourceMap, {
                mode
            })
        ]);
    }
}
fullPath = (0, _path.join)(spackOptions.output.path, (0, _path.dirname)(filename), `${base}.js`)
await makeDir((0, _path.dirname)(fullPath), {
                    recursive: true
                })
const fn = opts.cliOptions.outDir ? _dir.default : _file.default
const SWC_CLI_ENV = {
    // Allow to specify specific version of swc binary version to use
    SWCX_CORE_VERSION_OVERRIDE: "SWCX_CORE_VERSION_OVERRIDE",
    // Allow to skip check peer @swc/core version check
    SWCX_SKIP_CORE_VERSION_CHECK: "SWCX_SKIP_CORE_VERSION_CHECK"
}
