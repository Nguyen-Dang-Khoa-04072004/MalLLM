await normalizeErrors(async () => {
                const blob = await this.crud.get(collection, resource);
                if (!(options === null || options === void 0 ? void 0 : options.skipVerification)) {
                    const digest = await this.options.hash(blob);
                    if (hash !== digest)
                        throw new DOMException('Blob contents does not match hash', 'Integrity');
                }
                return blob;
            })
const fromSnapshot = async (snapshot, { fs, path = '/', separator = '/' }) => {
    if (!snapshot)
        return;
    switch (snapshot[0]) {
        case 0 /* SnapshotNodeType.Folder */: {
            if (!path.endsWith(separator))
                path = path + separator;
            const [, , entries] = snapshot;
            await fs.mkdir(path, { recursive: true });
            for (const [name, child] of Object.entries(entries))
                await (0, exports.fromSnapshot)(child, { fs, path: `${path}${name}`, separator });
            break;
        }
        case 1 /* SnapshotNodeType.File */: {
            const [, , data] = snapshot;
            await fs.writeFile(path, data);
            break;
        }
        case 2 /* SnapshotNodeType.Symlink */: {
            const [, { target }] = snapshot;
            await fs.symlink(target, path);
            break;
        }
    }
}
tslib_1.__asyncGenerator(this, arguments, function* entries_1() {
            const { __path: path, fs, ctx } = this;
            const list = yield tslib_1.__await(fs.promises.readdir(path, { withFileTypes: true }));
            for (const d of list) {
                const dirent = d;
                const name = dirent.name + '';
                const newPath = path + ctx.separator + name;
                if (dirent.isDirectory())
                    yield yield tslib_1.__await([name, new NodeFileSystemDirectoryHandle(fs, newPath, ctx)]);
                else if (dirent.isFile())
                    yield yield tslib_1.__await([name, new NodeFileSystemFileHandle_1.NodeFileSystemFileHandle(fs, name, ctx)]);
            }
        })
this.appendFile = (path, data, options) => {
            return (0, util_1.promisify)(this.fs, 'appendFile')(path instanceof this.FileHandle ? path.fd : path, data, options);
        }
