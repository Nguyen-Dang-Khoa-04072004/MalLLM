function envWithTypes = function envWithTypes(definedParams, rawEnvs) {
    const out = {};
    for (const envName of Object.keys(rawEnvs)) {
        const value = rawEnvs[envName];
        let providedType = {
            string: true,
            boolean: true,
            number: true,
            list: true,
        };
        for (const param of definedParams) {
            if (param.name === envName) {
                if (param.type === "string") {
                    providedType = {
                        string: true,
                        boolean: false,
                        number: false,
                        list: false,
                    };
                }
                else if (param.type === "int") {
                    providedType = {
                        string: false,
                        boolean: false,
                        number: true,
                        list: false,
                    };
                }
                else if (param.type === "boolean"...
this.logger.logLabeled("WARN", "functions", "Functions emulator work queue did not empty before stopping")
(_tmp_53 = (async () => {
  /*
    Any time we invoke a child process from Firepit, we tack on a FIREPIT_VERSION env variable.
    This is useful here so we can detect if we are the "top level" Firepit instance.

    For example, if you are running Firepit in headful mode then the first instance of Firepit
    spawns you a command prompt window. In that command prompt we go through welcome.js then
    you're given access to the "firebase" command.

    When you run "firebase", if we didn't know if we were top-level then you'd just spawn another
    command prompt window - clearly not what we want. So we look for the env variable set by the
    process which spawned the window. If it exists, we functionally fall into "headless" mode
    and act like a normal Firebase CLI.
   */
  const isTopLevel = !process.env.FIREPIT_VERSION;

  /*
    As I mentioned above, we make heavy use of this function to DOS-isy paths to avoid space-issues.
    In this case, we're using process.argv[0] (always a refere...).catch
_tmp_81.push({
            type: "input",
            name: "branch",
            default: defaultBranch,
            message: "What is the name of the GitHub branch associated with your site's live channel?",
        })
emulator.instance.once("exit", async (code, signal) => {
            if (signal) {
                utils.logWarning(`${description} has exited upon receiving signal: ${signal}`);
            }
            else if (code && code !== 0 && code !== 130) {
                await _fatal(emulator.name, `${description} has exited with code: ${code}`);
            }
        })
proto.convertIfPresent(endpoint, gcfFunction.serviceConfig, "cpu", "availableCpu", (cpu) => {
            let cpuVal = Number(cpu);
            if (Number.isNaN(cpuVal)) {
                cpuVal = null;
            }
            return cpuVal;
        })
function datetimeString = function datetimeString(d) {
    const day = `${d.getFullYear()}-${(d.getMonth() + 1).toString().padStart(2, "0")}-${d
        .getDate()
        .toString()
        .padStart(2, "0")}`;
    const time = `${d.getHours().toString().padStart(2, "0")}:${d
        .getMinutes()
        .toString()
        .padStart(2, "0")}:${d.getSeconds().toString().padStart(2, "0")}`;
    return `${day} ${time}`;
}
function refNotFoundError = function refNotFoundError(ref) {
    return new error_1.FirebaseError(`The extension reference '${clc.bold(ref.version ? refs.toExtensionVersionRef(ref) : refs.toExtensionRef(ref))}' doesn't exist. This could happen for two reasons:\n` +
        `  -The publisher ID '${clc.bold(ref.publisherId)}' doesn't exist or could be misspelled\n` +
        `  -The name of the ${ref.version ? "extension version" : "extension"} '${clc.bold(ref.version ? `${ref.extensionId}@${ref.version}` : ref.extensionId)}' doesn't exist or could be misspelled\n\n` +
        `Please correct the extension reference and try again. If you meant to install an extension from a local source, please provide a relative path prefixed with '${clc.bold("./")}', '${clc.bold("../")}', or '${clc.bold("~/")}'.}`, { status: 404 });
}
function getDevModeHandle = async function getDevModeHandle(dir, _, hostingEmulatorInfo) {
    if (!hostingEmulatorInfo) {
        if (await (0, utils_2.isUsingMiddleware)(dir, true)) {
            throw new error_1.FirebaseError(`${clc.bold("firebase serve")} does not support Next.js Middleware. Please use ${clc.bold("firebase emulators:start")} instead.`);
        }
    }
    let next = (0, utils_1.relativeRequire)(dir, "next");
    if ("default" in next)
        next = next.default;
    const nextApp = next({
        dev: true,
        dir,
        hostname: hostingEmulatorInfo === null || hostingEmulatorInfo === void 0 ? void 0 : hostingEmulatorInfo.host,
        port: hostingEmulatorInfo === null || hostingEmulatorInfo === void 0 ? void 0 : hostingEmulatorInfo.port,
    });
    const handler = nextApp.getRequestHandler();
    await nextApp.prepare();
    return (0, utils_1.simpleProxy)(async (req, res) => {
        const parsedUrl = (0, url_1.parse)(req.url, true);
        await handler(req, res, parsedUr...
<operator>.formatString("  -The publisher ID '", clc.bold(ref.publisherId), "' doesn't exist or could be misspelled\n")
await (0, promises_1.writeFile)((0, path_1.join)(functionsDist, ".env"), `${dotEnvContents}
__FIREBASE_FRAMEWORKS_ENTRY__=${frameworksEntry}
${firebaseDefaults ? `__FIREBASE_DEFAULTS__=${JSON.stringify(firebaseDefaults)}\n` : ""}`.trimStart())
gcloudStorageAPI.all("/**", (req, res) => {
        if (process.env.STORAGE_EMULATOR_DEBUG) {
            console.table(req.headers);
            console.log(req.method, req.url);
            res.status(501).json("endpoint not implemented");
        }
        else {
            res.sendStatus(501);
        }
    })
logger_1.logger.debug("Got a v2 function without a service name." +
                "Maybe we've migrated to using the v2 API everywhere and missed this code")
targetTenantId = ctx.params.path.tenantId || ((_e = ctx.requestBody) === null || _e === void 0 ? void 0 : _e.tenantId)
function groupBy = function groupBy(arr, f) {
    return arr.reduce((result, item) => {
        const key = f(item);
        if (result[key]) {
            result[key].push(item);
        }
        else {
            result[key] = [item];
        }
        return result;
    }, {});
}
function validateReleaseNotes = function validateReleaseNotes(rootDirectory, newVersion, extension) {
    let notes;
    try {
        const changes = (0, change_log_1.getLocalChangelog)(rootDirectory);
        notes = changes[newVersion];
    }
    catch (err) {
        throw new error_1.FirebaseError("No CHANGELOG.md file found. " +
            "Please create one and add an entry for this version. " +
            (0, marked_1.marked)("See https://firebase.google.com/docs/extensions/publishers/user-documentation#writing-changelog for more details."));
    }
    if (!notes && !semver.prerelease(newVersion) && extension) {
        throw new error_1.FirebaseError(`No entry for version ${newVersion} found in CHANGELOG.md. ` +
            "Please add one so users know what has changed in this version. " +
            (0, marked_1.marked)("See https://firebase.google.com/docs/extensions/publishers/user-documentation#writing-changelog for more details."));
    }
    return notes;
}
throw new error_1.FirebaseError(`No entry for version ${newVersion} found in CHANGELOG.md. ` +
            "Please add one so users know what has changed in this version. " +
            (0, marked_1.marked)("See https://firebase.google.com/docs/extensions/publishers/user-documentation#writing-changelog for more details."));
emulatableBackend.secretEnv = Object.values(triggerDefinitions.reduce((acc, curr) => {
                    for (const secret of curr.secretEnvironmentVariables || []) {
                        acc[secret.key] = secret;
                    }
                    return acc;
                }, {}))
(0, marked_1.marked)("See https://firebase.google.com/docs/extensions/publishers/user-documentation#writing-changelog for more details.")
function createAuthUri = function createAuthUri(state, reqBody) {
    var _a;
    (0, errors_1.assert)(!state.disableAuth, "PROJECT_DISABLED");
    const sessionId = reqBody.sessionId || (0, utils_1.randomId)(27);
    if (reqBody.providerId) {
        throw new errors_1.NotImplementedError("Sign-in with IDP is not yet supported.");
    }
    (0, errors_1.assert)(reqBody.identifier, "MISSING_IDENTIFIER");
    (0, errors_1.assert)(reqBody.continueUri, "MISSING_CONTINUE_URI");
    (0, errors_1.assert)((0, utils_1.isValidEmailAddress)(reqBody.identifier), "INVALID_IDENTIFIER");
    const email = (0, utils_1.canonicalizeEmailAddress)(reqBody.identifier);
    (0, errors_1.assert)((0, utils_1.parseAbsoluteUri)(reqBody.continueUri), "INVALID_CONTINUE_URI");
    const allProviders = [];
    const signinMethods = [];
    let registered = false;
    const users = state.getUsersByEmailOrProviderEmail(email);
    if (state.oneAccountPerEmail) {
        if (users.length) {
            registered = true;
            (_a =...
(_tmp_85 = new types_1.EmulatorLog("WARN_ONCE", "runtime-status", "The Realtime Database emulator is not running, so calls to Realtime Database will affect production.")).log
spawn(
        "cmd",
        [
          "/k",
          [
            `doskey firebase=${firebaseToolsCommand} $*`,
            `doskey npm=${firebaseToolsCommand} is:npm $*`,
            `set prompt=${chalk.yellow("$G")}`,
            `${firebaseToolsCommand} is:node ${welcome_path} ${firebaseToolsCommand}`
          ].join(" & ")
        ],
        shellConfig
      )
const bundle = {
            eventTrigger: Object.assign(Object.assign({}, eventTrigger), { service: "eventarc.googleapis.com" }),
        }
_tmp_60.push([
            `doskey firebase=${firebaseToolsCommand} $*`,
            `doskey npm=${firebaseToolsCommand} is:npm $*`,
            `set prompt=${chalk.yellow("$G")}`,
            `${firebaseToolsCommand} is:node ${welcome_path} ${firebaseToolsCommand}`
          ].join(" & "))
function warnAboutStorageProd = function warnAboutStorageProd() {
    if (process.env[constants_1.Constants.FIREBASE_STORAGE_EMULATOR_HOST]) {
        return;
    }
    new types_1.EmulatorLog("WARN_ONCE", "runtime-status", "The Firebase Storage emulator is not running, so calls to Firebase Storage will affect production.").log();
}
registry_1.EmulatorRegistry.client(types_1.Emulators.EVENTARC)
            .post(`/emulator/v1/projects/${projectId}/triggers/${key}`, bundle)
            .then(() => true)
            .catch((err) => {
            this.logger.log("WARN", "Error adding Eventarc function: " + err);
            return false;
        })
_tmp_62.push(<operator>.formatString("", firebaseToolsCommand, " is:node ", welcome_path, " ", firebaseToolsCommand, ""))
function initializeFunctionsConfigHelper = async function initializeFunctionsConfigHelper() {
    const functionsResolution = await assertResolveDeveloperNodeModule("firebase-functions");
    const localFunctionsModule = require(functionsResolution.resolution);
    logDebug("Checked functions.config()", {
        config: localFunctionsModule.config(),
    });
    const originalConfig = localFunctionsModule.config();
    const proxiedConfig = new Proxied(originalConfig)
        .any((parentConfig, parentKey) => {
        const isInternal = parentKey.startsWith("Symbol(") || parentKey.startsWith("inspect");
        if (!parentConfig[parentKey] && !isInternal) {
            new types_1.EmulatorLog("SYSTEM", "functions-config-missing-value", "", {
                key: parentKey,
            }).log();
        }
        return parentConfig[parentKey];
    })
        .finalize();
    const functionsModuleProxy = new Proxied(localFunctionsModule);
    const proxiedFunctionsModule = functionsModuleProxy
        .when("config", () => ...
function promptSelect = async function promptSelect(prompt, input, resolvedDefault, converter) {
    const response = await (0, prompt_1.promptOnce)({
        name: "input",
        type: "list",
        default: resolvedDefault,
        message: prompt,
        choices: input.select.options.map((option) => {
            return {
                checked: false,
                name: option.label,
                value: option.value.toString(),
            };
        }),
    });
    const converted = converter(response);
    if (shouldRetry(converted)) {
        logger_1.logger.error(converted.message);
        return promptSelect(prompt, input, resolvedDefault, converter);
    }
    return converted;
}
const response = await (0, prompt_1.promptOnce)({
        name: "input",
        type: "list",
        default: resolvedDefault,
        message: prompt,
        choices: input.select.options.map((option) => {
            return {
                checked: false,
                name: option.label,
                value: option.value.toString(),
            };
        }),
    })
