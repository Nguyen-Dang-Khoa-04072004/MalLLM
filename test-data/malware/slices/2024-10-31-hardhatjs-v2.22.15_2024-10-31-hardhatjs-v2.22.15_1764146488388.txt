function analyzeModuleNotFoundError = function analyzeModuleNotFoundError(error: any, configPath: string) {
  const stackTraceParser =
    require("stacktrace-parser") as typeof StackTraceParserT;

  if (error.code !== "MODULE_NOT_FOUND") {
    return;
  }
  const stackTrace = stackTraceParser.parse(error.stack);
  const throwingFile = stackTrace
    .filter((x) => x.file !== null)
    .map((x) => x.file!)
    // ignore frames related to source map support
    .filter((x) => !x.includes(path.join("@cspotcode", "source-map-support")))
    .find((x) => path.isAbsolute(x));

  if (throwingFile === null || throwingFile === undefined) {
    return;
  }

  // if the error comes from the config file, we ignore it because we know it's
  // a direct import that's missing
  if (throwingFile === configPath) {
    return;
  }

  const packageJsonPath = findClosestPackageJson(throwingFile);

  if (packageJsonPath === null) {
    return;
  }

  const packageJson = fsExtra.readJsonSync(packageJsonPath);
  const peerDependencies: { [na...
function getV3Release = async function getV3Release() {
    const { request } = await Promise.resolve().then(() => __importStar(require("undici")));
    let v3Release;
    try {
        const githubResponse = await request(`${GITHUB_API_URL}/repos/${GITHUB_OWNER}/${GITHUB_REPO}/releases/tags/${V3_RELEASE_TAG}`, {
            method: "GET",
            headers: {
                "User-Agent": "Hardhat",
                "X-GitHub-Api-Version": "2022-11-28",
            },
        });
        const jsonResponse = (await githubResponse.body.json());
        if (jsonResponse.message === "Not Found") {
            // eslint-disable-next-line @nomicfoundation/hardhat-internal-rules/only-hardhat-error
            throw new Error("Not Found");
        }
        v3Release = jsonResponse;
    }
    catch (error) {
        // We don't care if it fails
    }
    return v3Release;
}
exports.float = {
    name: "float",
    parse: (argName, strValue) => {
        const decimalPattern = /^(?:\d+(?:\.\d*)?|\.\d+)(?:[eE]\d+)?$/;
        const hexPattern = /^0[xX][\dABCDEabcde]+$/;
        if (strValue.match(decimalPattern) === null &&
            strValue.match(hexPattern) === null) {
            throw new errors_1.HardhatError(errors_list_1.ERRORS.ARGUMENTS.INVALID_VALUE_FOR_TYPE, {
                value: strValue,
                name: argName,
                type: exports.float.name,
            });
        }
        return Number(strValue);
    },
    /**
     * Check if argument value is of type "float".
     * Both decimal and integer number values are valid.
     *
     * @param argName {string} argument's name - used for context in case of error.
     * @param value {any} argument's value to validate.
     *
     * @throws HH301 if value is not of type "number"
     */
    validate: (argName, value) => {
        const isFloatOrInteger = typeof value === "n...
file.replaceAll(PRAGMA_DIRECTIVES_REGEX, (...groups) => {
    return `// Original pragma directive: ${removeUnnecessarySpaces(
      groups[1]
    )}`;
  })
this.paramDefinitions[name] = {
      name,
      defaultValue: false,
      type: types.boolean,
      description,
      isFlag: true,
      isOptional: true,
      isVariadic: false,
    }
_tmp_15.NOT_INSIDE_PROJECT_ON_WINDOWS = {
      number: 15,
      message: `You are not inside a project and Hardhat failed to initialize a new one.

If you were trying to create a new project, please try again using Windows Subsystem for Linux (WSL) or PowerShell.
`,
      title:
        "You are not inside a Hardhat project and Hardhat failed to initialize a new one",
      description: `You are trying to run Hardhat outside of a Hardhat project, and we couldn't initialize one.

If you were trying to create a new project, please try again using Windows Subsystem for Linux (WSL) or PowerShell.

You can learn how to use Hardhat by reading the [Getting Started guide](/hardhat-runner/docs/getting-started).`,
      shouldBeReported: false,
    }
