new Promise((resolve, reject) => {
      if (!token || typeof token !== "string")
        throw new Error(Constants.Errors.INVALID_TOKEN);
      token = token.replace(/^Bot\s*/i, "");
      this.client.manager.connectToWebSocket(token, resolve, reject);
    }).catch(e => {
      this.client.destroy();
      return Promise.reject(e);
    })
this.resetTimeout = this.client.setTimeout(() => {
              this.handle();
              this.resetTimeout = null;
            }, 1e3 + this.client.options.restTimeOffset)
item.request.gen().end((err, res) => {
        if (res && res.headers) {
          this.requestLimit = Number(res.headers["x-ratelimit-limit"]);
          this.requestResetTime =
            Number(res.headers["x-ratelimit-reset"]) * 1000;
          this.requestRemaining = Number(res.headers["x-ratelimit-remaining"]);
          this.timeDifference =
            Date.now() - new Date(res.headers.date).getTime();
        }
        if (err) {
          if (err.status === 429) {
            this.queue.unshift(item);
            this.client.setTimeout(() => {
              this.globalLimit = false;
              resolve();
            }, Number(res.headers["retry-after"]) + this.client.options.restTimeOffset);
            if (res.headers["x-ratelimit-global"]) this.globalLimit = true;
          } else if (err.status >= 500 && err.status < 600) {
            if (item.retries === this.client.options.retryLimit) {
              item.reject(err);
              resolve();
            } else {...
