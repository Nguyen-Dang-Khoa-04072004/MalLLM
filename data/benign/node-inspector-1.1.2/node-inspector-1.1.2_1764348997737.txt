WebInspector.linkifyURLAsNode = function(url, linkText, classes, isExternal, tooltipText)
{
    if (!linkText)
        linkText = url;
    classes = (classes ? classes + " " : "");
    classes += isExternal ? "webkit-html-external-link" : "webkit-html-resource-link";

    var a = createElement("a");
    var href = sanitizeHref(url);
    if (href !== null)
        a.href = href;
    a.className = classes;
    if (typeof tooltipText === "undefined")
        a.title = url;
    else if (typeof tooltipText !== "string" || tooltipText.length)
        a.title = tooltipText;
    a.textContent = linkText.trimMiddle(WebInspector.Linkifier.MaxLengthForDisplayedURLs);
    if (isExternal)
        a.setAttribute("target", "_blank");

    return a;
}
function didGetFile = function didGetFile(file)
        {
            var reader = new FileReader();

            if (typeof startOffset === "number" || typeof endOffset === "number")
                file = file.slice(/** @type {number} */ (startOffset), /** @type {number} */ (endOffset));
            /**
             * @this {FileReader}
             */
            reader.onloadend = function(e)
            {
                callback(/** @type {?string} */ (this.result));
            }
            reader.onerror = function(error)
            {
                WebInspector.console.error("Failed to read from temp file: " + error.message);
            }
            reader.readAsText(file);
        }
_tmp_11.addScript = {
    value: function(v8data, done) {
      done = done || function() {};

      var localPath = v8data.name;
      if (this._isMainAppScript(localPath)) {
        v8data.name = localPath = this.realMainAppScript;
      }

      var hidden = this.isScriptHidden(localPath) && localPath != this.mainAppScript;

      var inspectorScriptData = this._doAddScript(v8data, hidden);

      debug('addScript id: %s localPath: %s hidden? %s source? %s',
        v8data.id, localPath, hidden, !!v8data.source);

      if (hidden) return done(null, inspectorScriptData);

      if (this._isNodeInternal(localPath)) {
        this._notifyScriptParsed(inspectorScriptData);
        done(null, inspectorScriptData);
      } else {
        this._getSourceMapUrl(
          v8data.id,
          v8data.source,
          function onGetSourceMapUrlReturn(err, sourceMapUrl) {
            if (err) {
              console.log(
                'Warning: cannot parse SourceMap URL for script %s (id %d). %s',
       ...
WebInspector.AnimationSection.prototype = {
    /**
     * @return {boolean}
     */
    _expanded: function()
    {
        return this.bodyElement.classList.contains("expanded");
    },

    _toggle: function()
    {
        this.bodyElement.classList.toggle("expanded");
        this.updateCurrentTime();
    },

    /**
     * @param {boolean} expanded
     */
    expand: function(expanded)
    {
        this.bodyElement.classList.toggle("expanded", expanded);
        this.updateCurrentTime();
    },

    updateCurrentTime: function()
    {
        if (this._expanded())
            this._updateThrottler.schedule(this._updateCurrentTime.bind(this), false);
    },

    /**
     * @param {!WebInspector.Throttler.FinishCallback} finishCallback
     */
    _updateCurrentTime: function(finishCallback)
    {
        /**
         * @param {number} currentTime
         * @param {boolean} isRunning
         * @this {WebInspector.AnimationSection}
         */
        function updateSliderCal...
WebInspector.StylesSidebarPane.prototype = {
    _showInheritedComputedStyleChanged: function()
    {
        this.update(this._node);
    },

    /**
     * @param {!WebInspector.Event} event
     */
    _onAddButtonLongClick: function(event)
    {
        this._addButtonLongClickController.reset();
        var cssModel = this._target.cssModel;
        var headers = cssModel.styleSheetHeaders().filter(styleSheetResourceHeader);

        /** @type {!Array.<{text: string, handler: function()}>} */
        var contextMenuDescriptors = [];
        for (var i = 0; i < headers.length; ++i) {
            var header = headers[i];
            var handler = this._createNewRuleInStyleSheet.bind(this, header);
            contextMenuDescriptors.push({
                text: WebInspector.displayNameForURL(header.resourceURL()),
                handler: handler
            });
        }

        contextMenuDescriptors.sort(compareDescriptors);

        var contextMenu = new WebInspector.ContextMe...
WebInspector.DOMPresentationUtils.simpleSelector = function(node)
{
    var lowerCaseName = node.localName() || node.nodeName().toLowerCase();
    if (node.nodeType() !== Node.ELEMENT_NODE)
        return lowerCaseName;
    if (lowerCaseName === "input" && node.getAttribute("type") && !node.getAttribute("id") && !node.getAttribute("class"))
        return lowerCaseName + "[type=\"" + node.getAttribute("type") + "\"]";
    if (node.getAttribute("id"))
        return lowerCaseName + "#" + node.getAttribute("id");
    if (node.getAttribute("class"))
        return (lowerCaseName === "div" ? "" : lowerCaseName) + "." + node.getAttribute("class").trim().replace(/\s+/g, ".");
    return lowerCaseName;
}
WebInspector.LayerTreeBase.prototype = {
    _reset: function()
    {
        this._root = null;
        this._contentRoot = null;
    },

    /**
     * @return {?WebInspector.Layer}
     */
    root: function()
    {
        return this._root;
    },

    /**
     * @return {?WebInspector.Layer}
     */
    contentRoot: function()
    {
        return this._contentRoot;
    },

    /**
     * @param {function(!WebInspector.Layer)} callback
     * @param {?WebInspector.Layer=} root
     * @return {boolean}
     */
    forEachLayer: function(callback, root)
    {
        if (!root) {
            root = this.root();
            if (!root)
                return false;
        }
        return callback(root) || root.children().some(this.forEachLayer.bind(this, callback));
    },

    /**
     * @param {string} id
     * @return {?WebInspector.Layer}
     */
    layerById: function(id)
    {
        return this._layersById[id] || null;
    },

    /**
     * @param {!Array.<number>} re...
Element.prototype.isScrolledToBottom = function()
{
    // This code works only for 0-width border.
    // Both clientHeight and scrollHeight are rounded to integer values, so we tolerate
    // one pixel error.
    return Math.abs(this.scrollTop + this.clientHeight - this.scrollHeight) <= 1;
}
WebInspector.TimelineOverviewCalculator.prototype = {
    /**
     * @return {number}
     */
    paddingLeft: function()
    {
        return this._paddingLeft;
    },

    /**
     * @param {number} time
     * @return {number}
     */
    computePosition: function(time)
    {
        return (time - this._minimumBoundary) / this.boundarySpan() * this._workingArea + this._paddingLeft;
    },

    /**
     * @return {!{start: number, end: number}}
     */
    computeBarGraphPercentages: function(record)
    {
        var start = (record.startTime() - this._minimumBoundary) / this.boundarySpan() * 100;
        var end = (record.endTime() - this._minimumBoundary) / this.boundarySpan() * 100;
        return {start: start, end: end};
    },

    /**
     * @param {number=} minimumRecordTime
     * @param {number=} maximumRecordTime
     */
    _setWindow: function(minimumRecordTime, maximumRecordTime)
    {
        this._minimumBoundary = minimumRecordTime;
        this._maximumBoundary...
