throw new TypeError('unknown value for etag function: ' + val);
req.originalUrl = req.originalUrl || req.url
function tryStat = function tryStat(path) {
  debug('stat "%s"', path);

  try {
    return fs.statSync(path);
  } catch (e) {
    return undefined;
  }
}
var generateETag = !this.get('ETag') && typeof etagFn === 'function'
req.range = function range(size, options) {
  var range = this.get('Range');
  if (!range) return;
  return parseRange(size, range, options);
}
204 === this.statusCode || 304 === this.statusCode
var fns = flatten(slice.call(arguments, offset))
this.removeHeader('Content-Length')
var escape = app.get('json escape')
var replacer = app.get('json replacer')
var spaces = app.get('json spaces')
var body = stringify(val, replacer, spaces, escape)
req.params = self.mergeParams
      ? mergeParams(layer.params, parentParams)
      : layer.params
defineGetter(req, 'protocol', function protocol(){
  var proto = this.connection.encrypted
    ? 'https'
    : 'http';
  var trust = this.app.get('trust proxy fn');

  if (!trust(this.connection.remoteAddress, 0)) {
    return proto;
  }

  // Note: X-Forwarded-Proto is normally only ever a
  //       single value, but this is to be safe.
  var header = this.get('X-Forwarded-Proto') || proto
  var index = header.indexOf(',')

  return index !== -1
    ? header.substring(0, index).trim()
    : header.trim()
})
var trust = this.app.get('trust proxy fn')
var escape = app.get('json escape')
!trust(this.connection.remoteAddress, 0)
var spaces = app.get('json spaces')
var body = stringify(val, replacer, spaces, escape)
req.baseUrl = parentUrl + (removed[removed.length - 1] === '/'
        ? removed.substring(0, removed.length - 1)
        : removed)
this.set('X-Content-Type-Options', 'nosniff')
index !== -1 ? header.substring(0, index).trim() : header.trim()
(_tmp_12 = header.substring(0, index)).trim
defineGetter(req, 'secure', function secure(){
  return this.protocol === 'https';
})
this.protocol === 'https'
defineGetter(req, 'ip', function ip(){
  var trust = this.app.get('trust proxy fn');
  return proxyaddr(this, trust);
})
var trust = this.app.get('trust proxy fn')
proxyaddr(this, trust)
defineGetter(req, 'ips', function ips() {
  var trust = this.app.get('trust proxy fn');
  var addrs = proxyaddr.all(this, trust);

  // reverse the order (to farthest -> closest)
  // and remove socket address
  addrs.reverse().pop()

  return addrs
})
var trust = this.app.get('trust proxy fn')
var addrs = proxyaddr.all(this, trust)
(_tmp_15 = addrs.reverse()).pop
return addrs
defineGetter(req, 'subdomains', function subdomains() {
  var hostname = this.hostname;

  if (!hostname) return [];

  var offset = this.app.get('subdomain offset');
  var subdomains = !isIP(hostname)
    ? hostname.split('.').reverse()
    : [hostname];

  return subdomains.slice(offset);
})
var hostname = this.hostname
__ecma.Array.factory()
var offset = this.app.get('subdomain offset')
var subdomains = !isIP(hostname)
    ? hostname.split('.').reverse()
    : [hostname]
function paramCallback = function paramCallback(err) {
    var fn = paramCallbacks[paramIndex++];

    // store updated value
    paramCalled.value = req.params[key.name];

    if (err) {
      // store error
      paramCalled.error = err;
      param(err);
      return;
    }

    if (!fn) return param();

    try {
      fn(req, res, paramCallback, paramVal, key.name);
    } catch (e) {
      paramCallback(e);
    }
  }
subdomains.slice(offset)
defineGetter(req, 'path', function path() {
  return parse(this).pathname;
})
defineGetter(req, 'hostname', function hostname(){
  var trust = this.app.get('trust proxy fn');
  var host = this.get('X-Forwarded-Host');

  if (!host || !trust(this.connection.remoteAddress, 0)) {
    host = this.get('Host');
  } else if (host.indexOf(',') !== -1) {
    // Note: X-Forwarded-Host is normally only ever a
    //       single value, but this is to be safe.
    host = host.substring(0, host.indexOf(',')).trimRight()
  }

  if (!host) return;

  // IPv6 literal support
  var offset = host[0] === '['
    ? host.indexOf(']') + 1
    : 0;
  var index = host.indexOf(':', offset);

  return index !== -1
    ? host.substring(0, index)
    : host;
})
var trust = this.app.get('trust proxy fn')
var host = this.get('X-Forwarded-Host')
throw new TypeError('path must be a string to res.sendFile')
host = this.get('Host')
host.indexOf(',') !== -1
(_tmp_20 = host.substring(0, host.indexOf(','))).trimRight
proto.use = function use(fn) {
  var offset = 0;
  var path = '/';

  // default path to '/'
  // disambiguate router.use([fn])
  if (typeof fn !== 'function') {
    var arg = fn;

    while (Array.isArray(arg) && arg.length !== 0) {
      arg = arg[0];
    }

    // first arg is the path
    if (typeof arg !== 'function') {
      offset = 1;
      path = fn;
    }
  }

  var callbacks = flatten(slice.call(arguments, offset));

  if (callbacks.length === 0) {
    throw new TypeError('Router.use() requires a middleware function')
  }

  for (var i = 0; i < callbacks.length; i++) {
    var fn = callbacks[i];

    if (typeof fn !== 'function') {
      throw new TypeError('Router.use() requires a middleware function but got a ' + gettype(fn))
    }

    // add the middleware
    debug('use %o %s', path, fn.name || '<anonymous>')

    var layer = new Layer(path, {
      sensitive: this.caseSensitive,
      strict: false,
      end: false
    }, fn);

    layer.route = undefined;

    thi...
var offset = host[0] === '['
    ? host.indexOf(']') + 1
    : 0
host.indexOf(']') + 1
var index = host.indexOf(':', offset)
index !== -1 ? host.substring(0, index) : host
Array.isArray(arg) && arg.length !== 0
defineGetter(req, 'host', deprecate.function(function host(){
  return this.hostname;
}, 'req.host: Use req.hostname instead'))
defineGetter(req, 'fresh', function(){
  var method = this.method;
  var res = this.res
  var status = res.statusCode

  // GET or HEAD for weak freshness validation only
  if ('GET' !== method && 'HEAD' !== method) return false;

  // 2xx or 304 as per rfc2616 14.26
  if ((status >= 200 && status < 300) || 304 === status) {
    return fresh(this.headers, {
      'etag': res.get('ETag'),
      'last-modified': res.get('Last-Modified')
    })
  }

  return false;
})
throw new TypeError('Router.use() requires a middleware function but got a ' + gettype(fn))
fresh(this.headers, {
      'etag': res.get('ETag'),
      'last-modified': res.get('Last-Modified')
    })
_tmp_21.etag = res.get('ETag')
_tmp_21.last-modified = res.get('Last-Modified')
defineGetter(req, 'stale', function stale(){
  return !this.fresh;
})
this.lazyrouter()
defineGetter(req, 'xhr', function xhr(){
  var val = this.get('X-Requested-With') || '';
  return val.toLowerCase() === 'xmlhttprequest';
})
var val = this.get('X-Requested-With') || ''
val.toLowerCase() === 'xmlhttprequest'
