var checkImportMode = function() {

        if ( self.task != 'project:import')
            return;

        console.debug('Starting import mode @'+ self.projectName );
        if (!self.projects[self.projectName ]) {
            console.error('[ '+ self.projectName  +' ] is not an existing project. Instead, use gina projet:add @'+ self.projectName +' --path=/your/project_location');
            process.exit(1)
        }

        if ( typeof(self.projects[self.projectName ]) != 'undefined' ) {
            // import if exists but path just changed
            if ( typeof(self.projects[self.projectName ].path) != 'undefined') {
                var old = new _(self.projects[self.projectName ].path, true).toArray().last();
                var current = new _(self.projectLocation, true).toArray().last();

                if (old === self.projectName) {
                    self.projects[self.projectName ].path = self.projectLocation;

                    var target = _(GINA_HOMEDIR + '/projec...
gina && envIsDev && isGFFCtx && typeof(window.ginaToolbar) != 'undefined' && window.ginaToolbar
function ISO2022JPEncoder = function ISO2022JPEncoder(options) {
  var fatal = options.fatal;
  /** @enum */
  var state = {
    ASCII: 0,
    lead: 1,
    Katakana: 2
  };
  var /** @type {number} */ iso2022jp_state = state.ASCII;
  /**
   * @param {ByteOutputStream} output_byte_stream Output byte stream.
   * @param {CodePointInputStream} code_point_pointer Input stream.
   * @returns {number} The last byte emitted.
   */
  this.encode = function(output_byte_stream, code_point_pointer) {
    var code_point = code_point_pointer.get();
    if (code_point === EOF_code_point) {
      return EOF_byte;
    }
    code_point_pointer.offset(1);
    if ((inRange(code_point, 0x0000, 0x007F) ||
         code_point === 0x00A5 || code_point === 0x203E) &&
        iso2022jp_state !== state.ASCII) {
      code_point_pointer.offset(-1);
      iso2022jp_state = state.ASCII;
      return output_byte_stream.emit(0x1B, 0x28, 0x42);
    }
    if (inRange(code_point, 0x0000, 0x007F)) {
      return output_byte_stream.emit(code_poi...
var movefiles = function (i, res, files, cb) {
        if (!files.length || files.length == 0) {
            cb(false)
        } else {
            if ( fs.existsSync(files[i].target) ) new _(files[i].target).rmSync();

            var sourceStream = fs.createReadStream(files[i].source);
            var destinationStream = fs.createWriteStream(files[i].target);

            sourceStream
                .pipe(destinationStream)
                .on('error', function () {
                    var err = 'Error on SuperController::copyFile(...): Not found ' + files[i].source + ' or ' + files[i].target;
                    cb(err)
                })
                .on('close', function () {

                    try {
                        fs.unlinkSync(files[i].source);
                        files.splice(i, 1);
                    } catch (err) {
                        cb(err)
                    }

                    movefiles(i, res, files, cb)
                })
        }
    }
let xhrOptions = {
                            url: url,
                            method: method,
                            isSynchrone: isSynchrone,
                            headers : {
                                // to upload, use `multipart/form-data` for `enctype`
                                'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8',
                                // cross domain is enabled by default, but you need to setup `Access-Control-Allow-Origin`
                                'X-Requested-With': 'XMLHttpRequest' // in case of cross domain origin
                            }
                        }
typeof(self.conf[self.appName][self.env].server.webroot) != 'undefined'
isWebrootHandledByRouting = true
currentCollectionRaw[e].name == 'gina'
inRange(code_point, 0xFF61, 0xFF9F) &&
        iso2022jp_state !== state.Katakana
this.checkBundleStatus = async function(bundle, cb) {
        var opt     = self.getConfig('app').proxy[bundle];
        var route   = lib.routing.getRoute('bundle-status@'+bundle);
        opt.method  = 'GET';
        opt.path    = route.url;
        var response = { isAlive: false }, error = false;
        await util.promisify(self.query)(opt, {})
            .then( function onQueryResponse(_status) {
                response = _status
            });

        if (cb) {
            cb(error, response);
        } else {
            return response;
        }
    }
