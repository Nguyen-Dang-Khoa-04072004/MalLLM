function writeRc = function writeRc(content, cb) {
  var file = '.' + process.env.SHELL.match(/\/bin\/(\w+)/)[1] + 'rc',
  filepath = pth.join(process.env.HOME, file);
  fs.lstat(filepath, function (err, stats) {
    if(err) return cb(new Error("No " + file + " file. You'll have to run instead: " + completer + " completion >> ~/" + file));
    fs.writeFile(filepath, content, cb);
  });
}
function continueInstall = function continueInstall(CLI, module_name, opts, cb) {
  Common.printOut(cst.PREFIX_MSG_MOD + 'Calling ' + chalk.bold.red('[NPM]') + ' to install ' + module_name + ' ...');

  var canonic_module_name = Utility.getCanonicModuleName(module_name);
  var install_path = path.join(cst.DEFAULT_MODULE_PATH, canonic_module_name);

  require('mkdirp')(install_path)
    .then(function() {
      process.chdir(os.homedir());

      var install_instance = getNPMCommandLine(module_name, install_path)();

      install_instance.on('close', finalizeInstall);

      install_instance.on('error', function (err) {
        console.error(err.stack || err);
      });
    });

  function finalizeInstall(code) {
    if (code != 0) {
      // If install has failed, revert to previous module version
      return Rollback.revert(CLI, module_name, function() {
        return cb(new Error('Installation failed via NPM, module has been restored to prev version'));
      });
    }

    Common.printOut(cst.PREFIX_MSG...
setInterval(() => {
      vCheck({
        state: 'check',
        version: pkg.version
      })
    }, 1000 * 60 * 60 * 24)
const data = Object.assign(opts, {
      password_confirmation: opts.password,
      accept_terms: true
    })
this.killDaemon(function() {
      var cmd = 'rm -rf ' + that.pm2_home;
      var test_path = path.join(that.pm2_home, 'module_conf.json');
      var test_path_2 = path.join(that.pm2_home, 'pm2.pid');

      if (that.pm2_home.indexOf('.pm2') > -1)
        return cb(new Error('Destroy is not a allowed method on .pm2'));

      fs.access(test_path, fs.R_OK, function(err) {
        if (err) return cb(err);
        debug('Deleting temporary folder %s', that.pm2_home);
        sexec(cmd, cb);
      });
    })
fs.writeFile(msg.pwd, JSON.stringify(profile), (err) => {
              if (err) return cb(null, { error: err.message || err })
              return cb(null, { file : msg.pwd })
            })
require('mkdirp')(install_path)
    .then(function() {
      process.chdir(os.homedir());

      var install_instance = getNPMCommandLine(module_name, install_path)();

      install_instance.on('close', finalizeInstall);

      install_instance.on('error', function (err) {
        console.error(err.stack || err);
      });
    })
function uninstall = function uninstall(PM2, module_name, cb) {
  var module_path = path.join(cst.DEFAULT_MODULE_PATH, module_name);

  Common.logMod(`Removing ${module_name} from auto startup`)

  try {
    var pkg = require(path.join(module_path, 'package.json'))
  } catch(e) {
    Common.errMod('Could not retrieve module package.json');
    return cb(e)
  }

  var apps = pkg.apps || pkg.pm2
  apps = [].concat(apps);

  /**
   * Some time a module can have multiple processes
   */
  forEachLimit(apps, 1, (app, next) => {
    var app_name

    if (!app.name) {
      Common.renderApplicationName(app)
    }

    if (apps.length > 1)
      app_name = `${module_name}:${app.name}`
    else if (apps.length == 1 && pkg.name != apps[0].name)
      app_name = `${module_name}:${app.name}`
    else
      app_name = app.name

    PM2._operate('deleteProcessId', app_name, () => {
      deleteModulePath(module_name)
      next()
    })
  }, () => {
    Configuration.unsetSync(`${cst.MODULE_CONF_PREFIX_TAR}:${module_...
eachSeries(['ecosystem.json', 'process.json', 'package.json'], searchForCommands,
                     function(final) {
                       return cb(final ? final : []);
                     })
cb(God.logAndGenerateError('Error when getting proc || proc.pm2_env'), {})
eachLimit(processes, 1, function(proc, next) {
      console.log('Deleting process %s', proc.pm2_env.pm_id);
      God.deleteProcessId(proc.pm2_env.pm_id, function() {
        return next();
      });
    }, function(err) {
      try {
        fs.unlinkSync(that.pid_path);
      } catch(e) {}
      setTimeout(function() {
        that.isExiting = false
        console.log('Exited peacefully');
        process.exit(cst.SUCCESS_EXIT);
      }, 2);
    })
function processIds = function processIds(ids, cb) {
      eachLimit(ids, conf.CONCURRENT_ACTIONS, function(id, next) {
        that.Client.executeRemote('resetMetaProcessId', id, function(err, res) {
          if (err) console.error(err);
          Common.printOut(conf.PREFIX_MSG + 'Resetting meta for process id %d', id);
          return next();
        });
      }, function(err) {
        if (err) return cb(Common.retErr(err));
        return cb ? cb(null, {success:true}) : that.speedList();
      });
    }
eachLimit(ids, conf.CONCURRENT_ACTIONS, function(id, next) {
        that.Client.executeRemote('resetMetaProcessId', id, function(err, res) {
          if (err) console.error(err);
          Common.printOut(conf.PREFIX_MSG + 'Resetting meta for process id %d', id);
          return next();
        });
      }, function(err) {
        if (err) return cb(Common.retErr(err));
        return cb ? cb(null, {success:true}) : that.speedList();
      })
forEachLimit(param, 1, function(script, next) {
      pm2.stop(script, next);
    }, function(err) {
      pm2.speedList(err ? 1 : 0);
    })
