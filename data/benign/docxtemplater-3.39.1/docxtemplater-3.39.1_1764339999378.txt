_tmp_12.push({
    key: "functorIfInverted",
    value: function functorIfInverted(inverted, functor, value, i, length) {
      if (inverted) {
        functor(value, i, length);
      }
      return inverted;
    }
  })
server.listen(port, async function () {
	let client;
	try {
		client = await remote(options);
	} catch (e) {
		exit(e);
	}
	async function mockConsole() {
		await client.execute(() => {
			if (window.myLogs) {
				return;
			}
			window.myLogs = [];
			console.log = function () {
				const myLog = [];
				for (let i = 0, len = arguments.length; i < len; i++) {
					myLog.push(arguments[i]);
				}
				window.myLogs.push(myLog);
			};
			console.error = function () {
				const myLog = [];
				for (let i = 0, len = arguments.length; i < len; i++) {
					myLog.push(arguments[i]);
				}
				window.myLogs.push(myLog);
			};
			console.warn = function () {
				const myLog = [];
				for (let i = 0, len = arguments.length; i < len; i++) {
					myLog.push(arguments[i]);
				}
				window.myLogs.push(myLog);
			};
		});
	}
	async function getConsole() {
		return await client.execute(() => {
			if (!window.myLogs) {
				return "[]";
			}
			return JSON.stringify(window.myLogs);
		});
	}
	await m...
currentFile.resolveTags(data).then(function (result) {
              currentFile.scopeManager.finishedResolving = true;
              return result;
            }, function (errs) {
              Array.prototype.push.apply(errors, errs);
            })
<operator>.formatString("http://localhost:", port, "/test/mocha.html")
_tmp_26.push({
    key: "postparse",
    value: function postparse(parsed, _ref6) {
      var basePart = _ref6.basePart;
      if (basePart && this.docxtemplater.fileType === "docx" && parsed.length > 0) {
        basePart.sectPrCount = getSectPrHeaderFooterChangeCount(parsed);
        this.totalSectPr += basePart.sectPrCount;
        var sects = this.sects;
        sects.some(function (sect, index) {
          if (basePart.lIndex < sect[0].lIndex) {
            if (index + 1 < sects.length && isContinuous(sects[index + 1])) {
              basePart.addContinuousType = true;
            }
            return true;
          }
          if (parsed[0].lIndex < sect[0].lIndex && sect[0].lIndex < basePart.lIndex) {
            if (isNextPage(sects[index])) {
              basePart.addNextPage = {
                index: index
              };
            }
            return true;
          }
        });
        basePart.lastParagrapSectPr = getLastSectPr(parsed);
      }
      if (!basePart || basePa...)
logErrors(errors, _this3.options.errorLogging)
function isParagraphStart = function isParagraphStart(part) {
  return isTagStartStrict("w:p", part) || isTagStartStrict("a:p", part);
}
this.setModules({
        zip: this.zip,
        xmlDocuments: this.xmlDocuments
      })
const failedSuites = await client.$$("li.test.fail")
limits.sort(function (l1, l2) {
    if (l1.left === l2.left) {
      return l2.part.lIndex < l1.part.lIndex ? 1 : -1;
    }
    return l2.left < l1.left ? 1 : -1;
  })
const title = await client.execute((parent) => {
						let child = parent.firstChild;
						let ret = "";
						while (child) {
							if (child.nodeType === Node.TEXT_NODE) {
								ret += child.textContent;
							}
							child = child.nextSibling;
						}
						return ret;
					}, titleElement)
_tmp_93.explanation = "The template contains malformed xml"
this.setModules({
        compiled: this.compiled
      })
limits.forEach(function (limit, i) {
    var _postparsed;
    maxRight = Math.max(maxRight, i > 0 ? limits[i - 1].right : 0);
    if (limit.left < maxRight) {
      return;
    }
    var result;
    try {
      result = expandOne([limit.left + offset, limit.right + offset], limit.part, postparsed, options);
    } catch (error) {
      if (error instanceof XTTemplateError) {
        errors.push(error);
      } else {
        throw error;
      }
    }
    if (!result) {
      return;
    }
    offset += result.inner.length - (result.right + 1 - result.left);
    (_postparsed = postparsed).splice.apply(_postparsed, [result.left, result.right + 1 - result.left].concat(_toConsumableArray(result.inner)));
  })
_tmp_26.push({
    key: "resolve",
    value: function resolve(part, options) {
      if (!isModule(part, moduleName)) {
        return null;
      }
      var sm = options.scopeManager;
      var promisedValue = sm.getValueAsync(part.value, {
        part: part
      });
      var promises = [];
      function loopOver(scope, i, length) {
        var scopeManager = sm.createSubScopeManager(scope, part.value, i, part, length);
        promises.push(options.resolve({
          filePath: options.filePath,
          modules: options.modules,
          baseNullGetter: options.baseNullGetter,
          resolve: options.resolve,
          compiled: part.subparsed,
          tags: {},
          scopeManager: scopeManager
        }));
      }
      var errorList = [];
      return promisedValue.then(function (values) {
        return new Promise(function (resolve) {
          if (values instanceof Array) {
            Promise.all(values).then(resolve);
          } else {
            resolve(values);
   ...)
_tmp_95.explanation = "You must run `.compile()` before running `.resolveData()`"
