const create = context => ({
	AwaitExpression(node) {
		if (!notPromise(node.argument)) {
			return;
		}

		const {sourceCode} = context;
		const awaitToken = sourceCode.getFirstToken(node);
		const problem = {
			node,
			loc: awaitToken.loc,
			messageId: MESSAGE_ID,
		};

		const valueNode = node.argument;
		if (
			// Removing `await` may change them to a declaration, if there is no `id` will cause SyntaxError
			valueNode.type === 'FunctionExpression'
			|| valueNode.type === 'ClassExpression'
			// `+await +1` -> `++1`
			|| (
				node.parent.type === 'UnaryExpression'
				&& valueNode.type === 'UnaryExpression'
				&& node.parent.operator === valueNode.operator
			)
		) {
			return problem;
		}

		return Object.assign(problem, {
			/** @param {import('eslint').Rule.RuleFixer} fixer */
			* fix(fixer) {
				if (
					!isOnSameLine(awaitToken, valueNode)
					&& !isParenthesized(node, sourceCode)
				) {
					yield * addParenthesizesToReturnOrThrowExpression(fixer, node.parent, sourc...
function swapConsequentAndAlternate = function * swapConsequentAndAlternate(fixer, node, sourceCode) {
	const isIfStatement = node.type === 'IfStatement';
	const [consequent, alternate] = [
		node.consequent,
		node.alternate,
	].map(node => {
		const range = getParenthesizedRange(node, sourceCode);
		let text = sourceCode.text.slice(...range);
		// `if (!a) b(); else c()` can't fix to `if (!a) c() else b();`
		if (isIfStatement && node.type !== 'BlockStatement') {
			text = `{${text}}`;
		}

		return {
			range,
			text,
		};
	});

	if (consequent.text === alternate.text) {
		return;
	}

	yield fixer.replaceTextRange(consequent.range, alternate.text);
	yield fixer.replaceTextRange(alternate.range, consequent.text);
}
const create = context => ({
	CallExpression(callExpression) {
		if (!isMethodCall(callExpression, {
			methods: ['find', 'findLast'],
			minimumArguments: 1,
			maximumArguments: 2,
			optionalCall: false,
			optionalMember: false,
		})) {
			return;
		}

		const isCompare = isCheckingUndefined(callExpression);
		if (!isCompare && !isBooleanNode(callExpression)) {
			return;
		}

		const methodNode = callExpression.callee.property;
		return {
			node: methodNode,
			messageId: ERROR_ID_ARRAY_SOME,
			data: {method: methodNode.name},
			suggest: [
				{
					messageId: SUGGESTION_ID_ARRAY_SOME,
					* fix(fixer) {
						yield fixer.replaceText(methodNode, 'some');

						if (!isCompare) {
							return;
						}

						const parenthesizedRange = getParenthesizedRange(callExpression, context.sourceCode);
						yield fixer.replaceTextRange([parenthesizedRange[1], callExpression.parent.range[1]], '');

						if (callExpression.parent.operator === '!=' || callExpression.parent.operator === '!=...
const getForOfLoopHeadText = () => {
		const [elementText, indexText] = parameters.map(parameter => sourceCode.getText(parameter));
		const shouldUseEntries = parameters.length === 2;

		let text = 'for (';
		text += isFunctionParameterVariableReassigned(callback, sourceCode) ? 'let' : 'const';
		text += ' ';
		text += shouldUseEntries ? `[${indexText}, ${elementText}]` : elementText;
		text += ' of ';

		const shouldAddParenthesesToObject
			= isParenthesized(iterableObject, sourceCode)
			|| (
				// `1?.forEach()` -> `(1).entries()`
				isOptionalObject
				&& shouldUseEntries
				&& shouldAddParenthesesToMemberExpressionObject(iterableObject, sourceCode)
			);

		text += shouldAddParenthesesToObject ? `(${objectText})` : objectText;

		if (shouldUseEntries) {
			text += '.entries()';
		}

		text += ') ';

		return text;
	}
const create = context => {
	const style = context.options[0] || 'never';

	const listeners = {};

	// TemplateLiteral are not always safe to remove `./`, but if it's starts with `./` we'll report
	if (style === 'never') {
		listeners.TemplateLiteral = function (node) {
			if (!(
				isNewExpression(node.parent, {name: 'URL', argumentsLength: 2})
				&& node.parent.arguments[0] === node
			)) {
				return;
			}

			const firstPart = node.quasis[0];
			if (!firstPart.value.raw.startsWith(DOT_SLASH)) {
				return;
			}

			return {
				node,
				messageId: style,
				suggest: [
					{
						messageId: MESSAGE_ID_REMOVE,
						fix(fixer) {
							const start = firstPart.range[0] + 1;
							return fixer.removeRange([start, start + 2]);
						},
					},
				],
			};
		};
	}

	listeners.Literal = function (node) {
		if (!(
			isStringLiteral(node)
			&& isNewExpression(node.parent, {name: 'URL', argumentsLength: 2})
			&& node.parent.arguments[0] === node
		)) {
			return;
		}

		const {source...
const create = context => {
	const {sourceCode} = context;

	const getProblem = (node, fix, checkFunctionReturnType) => {
		if (checkFunctionReturnType) {
			const functionNode = getFunction(sourceCode.getScope(node));
			if (functionNode?.returnType) {
				return;
			}
		}

		return {
			node,
			messageId,
			fix,
		};
	};

	const options = {
		checkArguments: true,
		...context.options[0],
	};

	const removeNodeAndLeadingSpace = (node, fixer) =>
		replaceNodeOrTokenAndSpacesBefore(node, '', fixer, sourceCode);

	// `return undefined`
	context.on('Identifier', node => {
		if (
			isUndefined(node)
			&& node.parent.type === 'ReturnStatement'
			&& node.parent.argument === node
		) {
			return getProblem(
				node,
				fixer => removeNodeAndLeadingSpace(node, fixer),
				/* CheckFunctionReturnType */ true,
			);
		}
	});

	// `yield undefined`
	context.on('Identifier', node => {
		if (
			isUndefined(node)
			&& node.parent.type === 'YieldExpression'
			&& !node.parent.delegate
			&& nod...
isMethodCall(node, {
				methods: ['replaceChild', 'insertBefore'],
				argumentsLength: 2,
				optionalCall: false,
				optionalMember: false,
			})
			// We only allow Identifier for now
			&& node.arguments.every(node => node.type === 'Identifier' && node.name !== 'undefined')
			// This check makes sure that only the first method of chained methods with same identifier name e.g: parentNode.insertBefore(alfa, beta).insertBefore(charlie, delta); gets reported
			&& node.callee.object.type === 'Identifier'
listeners.TemplateLiteral = function (node) {
			if (!(
				isNewExpression(node.parent, {name: 'URL', argumentsLength: 2})
				&& node.parent.arguments[0] === node
			)) {
				return;
			}

			const firstPart = node.quasis[0];
			if (!firstPart.value.raw.startsWith(DOT_SLASH)) {
				return;
			}

			return {
				node,
				messageId: style,
				suggest: [
					{
						messageId: MESSAGE_ID_REMOVE,
						fix(fixer) {
							const start = firstPart.range[0] + 1;
							return fixer.removeRange([start, start + 2]);
						},
					},
				],
			};
		}
_tmp_50.properties = {
							camelCase: {
								type: 'boolean',
							},
							snakeCase: {
								type: 'boolean',
							},
							kebabCase: {
								type: 'boolean',
							},
							pascalCase: {
								type: 'boolean',
							},
						}
_tmp_38.description = "Enforce explicitly comparing the `length` or `size` property of a value."
function isVariableUnused = function isVariableUnused(node, sourceCode) {
	const variables = sourceCode.getDeclaredVariables(node);

	/* c8 ignore next 3 */
	if (variables.length !== 1) {
		return false;
	}

	const [{identifiers, references}] = variables;
	return identifiers.length === 1
		&& identifiers[0] === node.id
		&& references.length === 1
		&& references[0].identifier === node.id;
}
const actualImportStyles = getActualAssignmentTargetImportStyles(assignmentTargetNode)
const shouldFix = variable => getVariableIdentifiers(variable)
	.every(identifier =>
		!isExportedIdentifier(identifier)
		// In typescript parser, only `JSXOpeningElement` is added to variable
		// `<foo></foo>` -> `<bar></foo>` will cause parse error
		&& identifier.type !== 'JSXIdentifier',
	)
const isSafeName = (name, scopes) => scopes.every(scope => {
		const generatedNames = scopeToNamesGeneratedByFixer.get(scope);
		return !generatedNames || !generatedNames.has(name);
	})
_tmp_45 = dependency.condition === 'in' ? [hasTargetPackage, MESSAGE_ID_HAVE_PACKAGE] : [!hasTargetPackage, MESSAGE_ID_DONT_HAVE_PACKAGE]
dependency.condition === 'in' ? [hasTargetPackage, MESSAGE_ID_HAVE_PACKAGE] : [!hasTargetPackage, MESSAGE_ID_DONT_HAVE_PACKAGE]
