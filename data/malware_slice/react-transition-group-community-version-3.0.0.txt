// File: package/CSSTransitionGroup.js
// ======================================================================
Line 5: Object.prototype.hasOwnProperty.call(source, key)
Line 7: var _react = require('react')
Line 11: var _propTypes = require('prop-types')
Line 15: var _TransitionGroup = require('./TransitionGroup')
Line 19: var _CSSTransitionGroupChild = require('./CSSTransitionGroupChild')
Line 23: var _PropTypes = require('./utils/PropTypes')
Line 58: {
      args[_key] = arguments[_key];
    }
Line 59: args[_key] = arguments[_key]
Line 62: _tmp_11.push(this)

// File: package/CSSTransitionGroupChild.js
// ======================================================================
Line 5: Object.prototype.hasOwnProperty.call(source, key)
Line 7: var _addClass = require('dom-helpers/class/addClass')
Line 11: var _removeClass = require('dom-helpers/class/removeClass')
Line 15: var _requestAnimationFrame = require('dom-helpers/util/requestAnimationFrame')
Line 19: var _properties = require('dom-helpers/transition/properties')
Line 21: var _react = require('react')
Line 25: var _propTypes = require('prop-types')
Line 29: var _reactDom = require('react-dom')
Line 31: var _PropTypes = require('./utils/PropTypes')
Line 42: events.push(_properties.transitionEnd)
Line 43: events.push(_properties.animationEnd)
Line 48: node.addEventListener(e, listener, false)
Line 50: {
    setTimeout(listener, 0);
  }
Line 51: setTimeout(listener, 0)
Line 62: var propTypes = {
  children: _propTypes2.default.node,
  name: _PropTypes.nameShape.isRequired,

  // Once we require timeouts to be specified, we can remove the
  // boolean flags (appear etc.) and just accept a number
  // or a bool for the timeout flags (appearTimeout etc.)
  appear: _propTypes2.default.bool,
  enter: _propTypes2.default.bool,
  leave: _propTypes2.default.bool,
  appearTimeout: _propTypes2.default.number,
  enterTimeout: _propTypes2.default.number,
  leaveTimeout: _propTypes2.default.number
}
Line 85: {
      args[_key] = arguments[_key];
    }
Line 86: args[_key] = arguments[_key]
Line 89: _tmp_10.push(this)
Line 93: done()
Line 99: done()
Line 105: done()
Line 110: {
    this.classNameAndNodeQueue = [];
    this.transitionTimeouts = [];
  }
Line 111: this.classNameAndNodeQueue = []
Line 112: this.transitionTimeouts = []
Line 119: clearTimeout(this.timeout)
Line 122: clearTimeout(timeout)
Line 128: {
    var node = (0, _reactDom.findDOMNode)(this);

    if (!node) {
      if (finishCallback) {
        finishCallback();
      }
      return;
    }

    var className = this.props.name[animationType] || this.props.name + '-' + animationType;
    var activeClassName = this.props.name[animationType + 'Active'] || className + '-active';
    var timer = null;
    var removeListeners = void 0;

    (0, _addClass2.default)(node, className);

    // Need to do this to actually trigger a transition.
    this.queueClassAndNode(activeClassName, node);

    // Clean-up the animation after the specified delay
    var finish = function finish(e) {
      if (e && e.target !== node) {
        return;
      }

      clearTimeout(timer);
      if (removeListeners) removeListeners();

      (0, _removeClass2.default)(node, className);
      (0, _removeClass2.default)(node, activeClassName);

      if (removeListeners) removeListeners();

      // Usually this optional callback is used for informin...
Line 138: var className = this.props.name[animationType] || this.props.name + '-' + animationType
Line 139: var activeClassName = this.props.name[animationType + 'Active'] || className + '-active'
Line 154: clearTimeout(timer)
Line 169: {
      timer = setTimeout(finish, timeout);
      this.transitionTimeouts.push(timer);
    }
Line 170: timer = setTimeout(finish, timeout)
Line 171: this.transitionTimeouts.push(timer)
Line 180: this.classNameAndNodeQueue.push({
      className: className,
      node: node
    })
Line 217: _react2.default.cloneElement(_react2.default.Children.only(this.props.children), props)

// File: package/TransitionGroup.js
// ======================================================================
Line 5: Object.prototype.hasOwnProperty.call(source, key)
Line 7: var _chainFunction = require('chain-function')
Line 9: var _chainFunction2 = _interopRequireDefault(_chainFunction)
Line 11: var _react = require('react')
Line 15: var _propTypes = require('prop-types')
Line 19: var _warning = require('warning')
Line 23: var _ChildMapping = require('./utils/ChildMapping')
Line 52: _React$Component.call(this, props, context)
Line 54: {
      _this.currentlyTransitioningKeys[key] = true;

      if (component.componentWillAppear) {
        component.componentWillAppear(_this._handleDoneAppearing.bind(_this, key, component));
      } else {
        _this._handleDoneAppearing(key, component);
      }
    }
Line 55: _this.currentlyTransitioningKeys[key] = true
Line 58: _this._handleDoneAppearing.bind(_this, key, component)
Line 64: {
      if (component.componentDidAppear) {
        component.componentDidAppear();
      }

      delete _this.currentlyTransitioningKeys[key];

      var currentChildMapping = (0, _ChildMapping.getChildMapping)(_this.props.children);

      if (!currentChildMapping || !currentChildMapping.hasOwnProperty(key)) {
        // This was removed before it had fully appeared. Remove it.
        _this.performLeave(key, component);
      }
    }
Line 69: delete _this.currentlyTransitioningKeys[key]
Line 75: _this.performLeave(key, component)
Line 79: {
      _this.currentlyTransitioningKeys[key] = true;

      if (component.componentWillEnter) {
        component.componentWillEnter(_this._handleDoneEntering.bind(_this, key, component));
      } else {
        _this._handleDoneEntering(key, component);
      }
    }
Line 80: _this.currentlyTransitioningKeys[key] = true
Line 83: _this._handleDoneEntering.bind(_this, key, component)
Line 89: {
      if (component.componentDidEnter) {
        component.componentDidEnter();
      }

      delete _this.currentlyTransitioningKeys[key];

      var currentChildMapping = (0, _ChildMapping.getChildMapping)(_this.props.children);

      if (!currentChildMapping || !currentChildMapping.hasOwnProperty(key)) {
        // This was removed before it had fully entered. Remove it.
        _this.performLeave(key, component);
      }
    }
Line 94: delete _this.currentlyTransitioningKeys[key]
Line 100: _this.performLeave(key, component)
Line 104: {
      _this.currentlyTransitioningKeys[key] = true;

      if (component.componentWillLeave) {
        component.componentWillLeave(_this._handleDoneLeaving.bind(_this, key, component));
      } else {
        // Note that this is somewhat dangerous b/c it calls setState()
        // again, effectively mutating the component before all the work
        // is done.
        _this._handleDoneLeaving(key, component);
      }
    }
Line 105: _this.currentlyTransitioningKeys[key] = true
Line 108: _this._handleDoneLeaving.bind(_this, key, component)
Line 117: {
      if (component.componentDidLeave) {
        component.componentDidLeave();
      }

      delete _this.currentlyTransitioningKeys[key];

      var currentChildMapping = (0, _ChildMapping.getChildMapping)(_this.props.children);

      if (currentChildMapping && currentChildMapping.hasOwnProperty(key)) {
        // This entered again before it fully left. Add it again.
        _this.keysToEnter.push(key);
      } else {
        _this.setState(function (state) {
          var newChildren = _extends({}, state.children);
          delete newChildren[key];
          return { children: newChildren };
        });
      }
    }
Line 122: delete _this.currentlyTransitioningKeys[key]
Line 128: _this.keysToEnter.push(key)
Line 130: _this.setState(function (state) {
          var newChildren = _extends({}, state.children);
          delete newChildren[key];
          return { children: newChildren };
        })
Line 132: delete newChildren[key]
Line 146: {
    this.currentlyTransitioningKeys = {};
    this.keysToEnter = [];
    this.keysToLeave = [];
  }
Line 148: this.keysToEnter = []
Line 149: this.keysToLeave = []
Line 154: _iterator_1.next()
Line 155: {
        this.performAppear(key, this.childRefs[key]);
      }
Line 156: this.performAppear(key, this.childRefs[key])
Line 165: this.setState({
      children: (0, _ChildMapping.mergeChildMappings)(prevChildMapping, nextChildMapping)
    })
Line 169: _iterator_2.next()
Line 172: this.keysToEnter.push(key)
Line 176: _iterator_3.next()
Line 179: this.keysToLeave.push(_key)
Line 186: {
    var _this2 = this;

    var keysToEnter = this.keysToEnter;
    this.keysToEnter = [];
    keysToEnter.forEach(function (key) {
      return _this2.performEnter(key, _this2.childRefs[key]);
    });

    var keysToLeave = this.keysToLeave;
    this.keysToLeave = [];
    keysToLeave.forEach(function (key) {
      return _this2.performLeave(key, _this2.childRefs[key]);
    });
  }
Line 190: this.keysToEnter = []
Line 192: _this2.performEnter(key, _this2.childRefs[key])
Line 196: this.keysToLeave = []
Line 198: _this2.performLeave(key, _this2.childRefs[key])
Line 202: {
    var _this3 = this;

    // TODO: we could get rid of the need for the wrapper node
    // by cloning a single child
    var childrenToRender = [];

    var _loop = function _loop(key) {
      var child = _this3.state.children[key];
      if (child) {
        var isCallbackRef = typeof child.ref !== 'string';
        var factoryChild = _this3.props.childFactory(child);
        var ref = function ref(r) {
          _this3.childRefs[key] = r;
        };

        process.env.NODE_ENV !== 'production' ? (0, _warning2.default)(isCallbackRef, 'string refs are not supported on children of TransitionGroup and will be ignored. ' + 'Please use a callback ref instead: https://facebook.github.io/react/docs/refs-and-the-dom.html#the-ref-callback-attribute') : void 0;

        // Always chaining the refs leads to problems when the childFactory
        // wraps the child. The child ref callback gets called twice with the
        // wrapper and the child. So we only need to chain the ref if th...
Line 207: var childrenToRender = []
Line 209: {
      var child = _this3.state.children[key];
      if (child) {
        var isCallbackRef = typeof child.ref !== 'string';
        var factoryChild = _this3.props.childFactory(child);
        var ref = function ref(r) {
          _this3.childRefs[key] = r;
        };

        process.env.NODE_ENV !== 'production' ? (0, _warning2.default)(isCallbackRef, 'string refs are not supported on children of TransitionGroup and will be ignored. ' + 'Please use a callback ref instead: https://facebook.github.io/react/docs/refs-and-the-dom.html#the-ref-callback-attribute') : void 0;

        // Always chaining the refs leads to problems when the childFactory
        // wraps the child. The child ref callback gets called twice with the
        // wrapper and the child. So we only need to chain the ref if the
        // factoryChild is not different from child.
        if (factoryChild === child && isCallbackRef) {
          ref = (0, _chainFunction2.default)(child.ref, ref);
        }

       ...
Line 210: var child = _this3.state.children[key]
Line 213: _this3.props.childFactory(child)
Line 214: {
          _this3.childRefs[key] = r;
        }
Line 215: _this3.childRefs[key] = r
Line 218: process.env.NODE_ENV !== 'production' ? (0, _warning2.default)(isCallbackRef, 'string refs are not supported on children of TransitionGroup and will be ignored. ' + 'Please use a callback ref instead: https://facebook.github.io/react/docs/refs-and-the-dom.html#the-ref-callback-attribute') : void 0
Line 225: ref = (0, _chainFunction2.default)(child.ref, ref)
Line 233: childrenToRender.push(_react2.default.cloneElement(factoryChild, {
          key: key,
          ref: ref
        }))
Line 240: _iterator_4.next()

// File: package/index.js
// ======================================================================
Line 3: var _CSSTransitionGroup = require('./CSSTransitionGroup')
Line 7: var _TransitionGroup = require('./TransitionGroup')

// File: package/utils/ChildMapping.js
// ======================================================================
Line 7: var _react = require('react')
Line 22: {
    result[child.key] = child;
  }
Line 23: result[child.key] = child
Line 45: {
  prev = prev || {};
  next = next || {};

  function getValueForKey(key) {
    if (next.hasOwnProperty(key)) {
      return next[key];
    }

    return prev[key];
  }

  // For each key of `next`, the list of keys to insert before that key in
  // the combined list
  var nextKeysPending = {};

  var pendingKeys = [];
  for (var prevKey in prev) {
    if (next.hasOwnProperty(prevKey)) {
      if (pendingKeys.length) {
        nextKeysPending[prevKey] = pendingKeys;
        pendingKeys = [];
      }
    } else {
      pendingKeys.push(prevKey);
    }
  }

  var i = void 0;
  var childMapping = {};
  for (var nextKey in next) {
    if (nextKeysPending.hasOwnProperty(nextKey)) {
      for (i = 0; i < nextKeysPending[nextKey].length; i++) {
        var pendingNextKey = nextKeysPending[nextKey][i];
        childMapping[nextKeysPending[nextKey][i]] = getValueForKey(pendingNextKey);
      }
    }
    childMapping[nextKey] = getValueForKey(nextKey);
  }

  // Finally, add the keys which ...
Line 61: var pendingKeys = []
Line 62: _iterator_0.next()
Line 64: {
        nextKeysPending[prevKey] = pendingKeys;
        pendingKeys = [];
      }
Line 65: nextKeysPending[prevKey] = pendingKeys
Line 66: pendingKeys = []
Line 69: pendingKeys.push(prevKey)
Line 75: for (var nextKey in next) {
    if (nextKeysPending.hasOwnProperty(nextKey)) {
      for (i = 0; i < nextKeysPending[nextKey].length; i++) {
        var pendingNextKey = nextKeysPending[nextKey][i];
        childMapping[nextKeysPending[nextKey][i]] = getValueForKey(pendingNextKey);
      }
    }
    childMapping[nextKey] = getValueForKey(nextKey);
  }
Line 77: {
        var pendingNextKey = nextKeysPending[nextKey][i];
        childMapping[nextKeysPending[nextKey][i]] = getValueForKey(pendingNextKey);
      }
Line 78: var pendingNextKey = nextKeysPending[nextKey][i]
Line 79: childMapping[nextKeysPending[nextKey][i]] = getValueForKey(pendingNextKey)
Line 82: childMapping[nextKey] = getValueForKey(nextKey)
Line 86: {
    childMapping[pendingKeys[i]] = getValueForKey(pendingKeys[i]);
  }
Line 87: childMapping[pendingKeys[i]] = getValueForKey(pendingKeys[i])

// File: package/utils/PropTypes.js
// ======================================================================
Line 7: var _react = require('react')
Line 11: var _propTypes = require('prop-types')
Line 26: new Error(timeoutPropName + ' wasn\'t supplied to CSSTransitionGroup: ' + 'this can cause unreliable animations and won\'t be supported in ' + 'a future version of React. See ' + 'https://fb.me/react-animation-transition-group-timeout for more ' + 'information.')
Line 38: _tmp_4.push(_propTypes2.default.shape({
  enter: _propTypes2.default.string,
  leave: _propTypes2.default.string,
  active: _propTypes2.default.string
}))
Line 42: _tmp_4.push(_propTypes2.default.shape({
  enter: _propTypes2.default.string,
  enterActive: _propTypes2.default.string,
  leave: _propTypes2.default.string,
  leaveActive: _propTypes2.default.string,
  appear: _propTypes2.default.string,
  appearActive: _propTypes2.default.string
}))
