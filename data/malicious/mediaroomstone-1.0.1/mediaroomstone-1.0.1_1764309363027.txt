producer = this.#producers.get(producerId)
throw new TypeError('if given, appData must be an object');
params.maxPacketLifeTime && typeof params.maxPacketLifeTime !== 'number'
throw new TypeError('invalid params.maxPacketLifeTime');
let pipeTransportPairPromise = this.#mapRouterPairPipeTransportPairPromise.get(pipeTransportPairKey)
throw new TypeError('cannot be ordered with maxPacketLifeTime or maxRetransmits');
const internal = { ...this.internal, dataProducerId: id || (0, uuid_1.v4)() }
pipeConsumer = await localPipeTransport.consume({
                    producerId: producerId
                })
pipeProducer = await remotePipeTransport.produce({
                    id: producer.id,
                    kind: pipeConsumer.kind,
                    rtpParameters: pipeConsumer.rtpParameters,
                    paused: pipeConsumer.producerPaused,
                    appData: producer.appData
                })
const pt = dynamicPayloadTypes.shift()
_tmp_127.kind = pipeConsumer.kind
_tmp_79.rtcpFeedback = __ecma.Array.factory()
const data = await this.channel.request('transport.consumeData', internal, reqData)
this.dataConsumers.delete(dataConsumer.id)
this.#sctpStreamIds[sctpStreamId] = 0
pipeDataConsumer = await localPipeTransport.consumeData({
                    dataProducerId: dataProducerId
                })
pipeDataProducer = await remotePipeTransport.produceData({
                    id: dataProducer.id,
                    sctpStreamParameters: pipeDataConsumer.sctpStreamParameters,
                    label: pipeDataConsumer.label,
                    protocol: pipeDataConsumer.protocol,
                    appData: dataProducer.appData
                })
await this.channel.request('transport.enableTraceEvent', this.internal, reqData)
_tmp_135.sctpStreamParameters = pipeDataConsumer.sctpStreamParameters
throw new errors_1.UnsupportedError(`no RTX codec for capability codec PT ${capMediaCodec.preferredPayloadType}`);
codecToCapCodec.set(codec, associatedCapRtxCodec)
