function getEncodingHeight = function getEncodingHeight(encoding, options) {
	return options.height + (options.displayValue && encoding.text.length > 0 ? options.fontSize + options.textMargin : 0) + options.marginTop + options.marginBottom;
}
function getOptionsFromElement = function getOptionsFromElement(element) {
	var options = {};
	for (var property in _defaults2.default) {
		if (_defaults2.default.hasOwnProperty(property)) {
			// jsbarcode-*
			if (element.hasAttribute("jsbarcode-" + property.toLowerCase())) {
				options[property] = element.getAttribute("jsbarcode-" + property.toLowerCase());
			}

			// data-*
			if (element.hasAttribute("data-" + property.toLowerCase())) {
				options[property] = element.getAttribute("data-" + property.toLowerCase());
			}
		}
	}

	options["value"] = element.getAttribute("jsbarcode-value") || element.getAttribute("data-value");

	// Since all atributes are string they need to be converted to integers
	options = (0, _optionsFromStrings2.default)(options);

	return options;
}
_createClass(ErrorHandler, [{
		key: "handleCatch",
		value: function handleCatch(e) {
			// If babel supported extending of Error in a correct way instanceof would be used here
			if (e.name === "InvalidInputException") {
				if (this.api._options.valid !== this.api._defaults.valid) {
					this.api._options.valid(false);
				} else {
					throw e.message;
				}
			} else {
				throw e;
			}

			this.api.render = function () {};
		}
	}, {
		key: "wrapBarcodeCall",
		value: function wrapBarcodeCall(func) {
			try {
				var result = func.apply(undefined, arguments);
				this.api._options.valid(true);
				return result;
			} catch (e) {
				this.handleCatch(e);

				return this.api;
			}
		}
	}])
API.prototype.blank = function(size){
	const zeroes = new Array(size + 1).join("0");
	this._encodings.push({data: zeroes});
	return this;
}
var allData = fs.readFileSync('dist/JsBarcode.all.min.js')
result.push({
					data: "00000000",
					text: this.text.substr(11, 1),
					options: { textAlign: "right", fontSize: this.fontSize }
				})
API.prototype.init = function(){
	// Should do nothing if no elements where found
	if(!this._renderProperties){
		return;
	}

	// Make sure renderProperies is an array
	if(!Array.isArray(this._renderProperties)){
		this._renderProperties = [this._renderProperties];
	}

	var renderProperty;
	for(let i in this._renderProperties){
		renderProperty = this._renderProperties[i];
		var options = merge(this._options, renderProperty.options);

		if(options.format == "auto"){
			options.format = autoSelectBarcode();
		}

		this._errorHandler.wrapBarcodeCall(function(){
			var text = options.value;
			var Encoder = barcodes[options.format.toUpperCase()];
			var encoded = encode(text, Encoder, options);

			render(renderProperty, encoded, options);
		});
	}
}
bytes[0] = set === _constants.SET_A ? bytes[0] > 95 ? bytes[0] - 96 : bytes[0] : bytes[0] < 32 ? bytes[0] + 96 : bytes[0]
_tmp_22.options = {textAlign: "right", fontSize: this.fontSize}
readme = readme.replace(fileRegexp, "|  " + formatSize(fileFilesize) + "  |$1")
var options = merge(this._options, renderProperty.options)
