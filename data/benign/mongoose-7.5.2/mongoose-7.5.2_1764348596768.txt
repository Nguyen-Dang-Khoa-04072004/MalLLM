Mongoose.prototype.setDriver = function setDriver(driver) {
  const _mongoose = this instanceof Mongoose ? this : mongoose;

  if (_mongoose.__driver === driver) {
    return _mongoose;
  }

  const openConnection = _mongoose.connections && _mongoose.connections.find(conn => conn.readyState !== STATES.disconnected);
  if (openConnection) {
    const msg = 'Cannot modify Mongoose driver if a connection is already open. ' +
      'Call `mongoose.disconnect()` before modifying the driver';
    throw new MongooseError(msg);
  }
  _mongoose.__driver = driver;

  const Connection = driver.Connection;
  _mongoose.connections = [new Connection(_mongoose)];
  _mongoose.connections[0].models = _mongoose.models;

  return _mongoose;
}
_tmp_29.push({
        block: {
          markers: [
            '!'
          ],
          balanced: true
        }
      })
applyDefaults(this, fields, exclude, hasIncludedChildren, true, null)
const paths = states.reduce(function(paths, state) {
      if (_this.states[state] == null) {
        return paths;
      }
      return paths.concat(Object.keys(_this.states[state]));
    }, [])
Schema.prototype._clone = function _clone(Constructor) {
  Constructor = Constructor || (this.base == null ? Schema : this.base.Schema);

  const s = new Constructor({}, this._userProvidedOptions);
  s.base = this.base;
  s.obj = this.obj;
  s.options = clone(this.options);
  s.callQueue = this.callQueue.map(function(f) { return f; });
  s.methods = clone(this.methods);
  s.methodOptions = clone(this.methodOptions);
  s.statics = clone(this.statics);
  s.query = clone(this.query);
  s.plugins = Array.prototype.slice.call(this.plugins);
  s._indexes = clone(this._indexes);
  s.s.hooks = this.s.hooks.clone();

  s.tree = clone(this.tree);
  s.paths = clone(this.paths);
  s.nested = clone(this.nested);
  s.subpaths = clone(this.subpaths);
  for (const schemaType of Object.values(s.paths)) {
    if (schemaType.$isSingleNested) {
      const path = schemaType.path;
      for (const key of Object.keys(schemaType.schema.paths)) {
        s.singleNestedPaths[path + '.' + key] = schemaType.s...
Object.defineProperty(Document.prototype, '$where', {
  configurable: false,
  enumerable: false,
  writable: true
})
SchemaNumber.prototype.$conditionalHandlers =
    utils.options(SchemaType.prototype.$conditionalHandlers, {
      $bitsAllClear: handleBitwiseOperator,
      $bitsAnyClear: handleBitwiseOperator,
      $bitsAllSet: handleBitwiseOperator,
      $bitsAnySet: handleBitwiseOperator,
      $gt: handleSingle,
      $gte: handleSingle,
      $lt: handleSingle,
      $lte: handleSingle,
      $mod: handleArray
    })
err || (doc === null && !ctx._mongooseOptions.transformNull)
Connection.prototype.createCollections = async function createCollections(options = {}) {
  const result = {};
  const errorsMap = { };

  const { continueOnError } = options;
  delete options.continueOnError;
  for (const model of Object.values(this.models)) {
    try {
      result[model.modelName] = await model.createCollection({});
    } catch (err) {
      if (!continueOnError) {
        errorsMap[model.modelName] = err;
        break;
      } else {
        result[model.modelName] = err;
      }
    }
  }

  if (!continueOnError && Object.keys(errorsMap).length) {
    const message = Object.entries(errorsMap).map(([modelName, err]) => `${modelName}: ${err.message}`).join(', ');
    const createCollectionsError = new CreateCollectionsError(message, errorsMap);
    throw createCollectionsError;
  }
  return result;
}
SchemaArray.prototype._castForPopulate = function _castForPopulate(value, doc) {
  // lazy load
  MongooseArray || (MongooseArray = require('../types').Array);

  if (Array.isArray(value)) {
    let i;
    const rawValue = value.__array ? value.__array : value;
    const len = rawValue.length;

    const caster = this.caster;
    if (caster && this.casterConstructor !== Mixed) {
      try {
        for (i = 0; i < len; i++) {
          const opts = {};
          // Perf: creating `arrayPath` is expensive for large arrays.
          // We only need `arrayPath` if this is a nested array, so
          // skip if possible.
          if (caster.$isMongooseArray && caster._arrayParentPath != null) {
            opts.arrayPathIndex = i;
          }

          rawValue[i] = caster.cast(rawValue[i], doc, false, void 0, opts);
        }
      } catch (e) {
        // rethrow
        throw new CastError('[' + e.kind + ']', util.inspect(value), this.path + '.' + i, e, this);
      }
    }

    ...
Mongoose.prototype._model = function(name, schema, collection, options) {
  const _mongoose = this instanceof Mongoose ? this : mongoose;

  let model;
  if (typeof name === 'function') {
    model = name;
    name = model.name;
    if (!(model.prototype instanceof Model)) {
      throw new _mongoose.Error('The provided class ' + name + ' must extend Model');
    }
  }

  if (schema) {
    if (_mongoose.get('cloneSchemas')) {
      schema = schema.clone();
    }
    _mongoose._applyPlugins(schema);
  }

  // Apply relevant "global" options to the schema
  if (schema == null || !('pluralization' in schema.options)) {
    schema.options.pluralization = _mongoose.options.pluralization;
  }

  if (!collection) {
    collection = schema.get('collection') ||
      utils.toCollectionName(name, _mongoose.pluralize());
  }

  const connection = options.connection || _mongoose.connection;
  model = _mongoose.Model.compile(model || name, schema, collection, connection, _mongoose);
  // Errors ...
collection = schema.get('collection') ||
      utils.toCollectionName(name, _mongoose.pluralize())
localFieldValue.map((localFieldArrVal, localFieldArrIndex) =>
        localFieldPath.applyGetters(localFieldArrVal, localFieldHydratedValue[localFieldArrIndex]))
function handleArray = function handleArray(val, context) {
  const _this = this;
  if (!Array.isArray(val)) {
    return [this.castForQuery(null, val, context)];
  }
  return val.map(function(m) {
    return _this.castForQuery(null, m, context);
  });
}
(this.readyState === STATES.connecting || this.readyState === STATES.disconnected) && this._shouldBufferCommands()
model.discriminator(disc, schema._applyDiscriminators.get(disc))
exports.getValue = function(path, obj, map) {
  return mpath.get(path, obj, getValueLookup, map);
}
Object.defineProperty(Mongoose.prototype, 'Collection', {
  get: function() {
    return this.__driver.Collection;
  },
  set: function(Collection) {
    this.__driver.Collection = Collection;
  }
})
Object.defineProperty(Mongoose.prototype, 'Connection', {
  get: function() {
    return this.__driver.Connection;
  },
  set: function(Connection) {
    if (Connection === this.__driver.Connection) {
      return;
    }

    this.__driver.Connection = Connection;
  }
})
