const enumValues = path.get("members").map(memberPath => {
    const member = memberPath.node;
    const name = t.isIdentifier(member.id) ? member.id.name : member.id.value;
    const initializerPath = memberPath.get("initializer");
    const initializer = member.initializer;
    let value;
    if (initializer) {
      constValue = computeConstantValue(initializerPath, seen);
      if (constValue !== undefined) {
        seen.set(name, constValue);
        _assert(typeof constValue === "number" || typeof constValue === "string");
        if (constValue === Infinity || Number.isNaN(constValue)) {
          value = t.identifier(String(constValue));
        } else if (constValue === -Infinity) {
          value = t.unaryExpression("-", t.identifier("Infinity"));
        } else {
          value = t.valueToNode(constValue);
        }
      } else {
        isPure && (isPure = initializerPath.isPure());
        if (initializerPath.isReferencedIdentifier()) {
          ReferencedIdentifier(init...
const initializerPath = memberPath.get("initializer")
constValue = computeConstantValue(initializerPath, seen)
throw buildNestedAmbientModuleError(path, subNode.declaration);
path.node.accessibility = null
const transformed = handleNested(path, subNode.declaration, _core.types.identifier(name))
constValue === Infinity || Number.isNaN(constValue)
value = t.identifier(String(constValue))
value = t.unaryExpression("-", t.identifier("Infinity"))
throw paramPath.buildCodeFrameError("Parameter properties can not be destructuring patterns.");
const memberExpr = _core.types.memberExpression(parentExport, realName)
_tmp_18 = __ecma.Array.factory()
_iterator_4 = <operator>.iterator(path.get("body"))
stmt.isImportDeclaration()
_iterator_7 = <operator>.iterator(stmt.node.specifiers)
const binding = stmt.scope.getBinding(specifier.local.name)
data.get(prop.computed ? prop.value : prop.name)
stmt.isExportDeclaration()
stmt = stmt.get("declaration")
stmt.isVariableDeclaration({
              declare: true
            })
stmt.isTSTypeAliasDeclaration() || stmt.isTSDeclareFunction() && stmt.get("id").isIdentifier() || stmt.isTSInterfaceDeclaration() || stmt.isClassDeclaration({
              declare: true
            }) || stmt.isTSEnumDeclaration({
              declare: true
            }) || stmt.isTSModuleDeclaration({
              declare: true
            }) && stmt.get("id").isIdentifier()
stmt.isTSEnumDeclaration({
              declare: true
            })
function evalBinaryExpression = function evalBinaryExpression(path) {
    const left = evaluate(path.get("left"));
    if (left === undefined) {
      return undefined;
    }
    const right = evaluate(path.get("right"));
    if (right === undefined) {
      return undefined;
    }
    switch (path.node.operator) {
      case "|":
        return left | right;
      case "&":
        return left & right;
      case ">>":
        return left >> right;
      case ">>>":
        return left >>> right;
      case "<<":
        return left << right;
      case "^":
        return left ^ right;
      case "*":
        return left * right;
      case "/":
        return left / right;
      case "+":
        return left + right;
      case "-":
        return left - right;
      case "%":
        return left % right;
      case "**":
        return Math.pow(left, right);
      default:
        return undefined;
    }
  }
(_tmp_35 = stmt.get("id")).isIdentifier
