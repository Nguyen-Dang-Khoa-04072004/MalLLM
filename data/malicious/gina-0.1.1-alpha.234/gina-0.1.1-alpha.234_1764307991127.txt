function Connector = function Connector(dbString) {
    var self    = this
        , local = {
            bundle: null,
            env: null,
            options: {
                useScopeAndCollections: true,
                scope: '_default', // by default
                collection: '_default', // by default
                keepAlive: true,
                pingInterval: "2m",
                // https://docs.couchbase.com/sdk-api/couchbase-node-client/interfaces/TimeoutConfig.html
                // timeouts:  {
                //     kvTimeout: 10000, // milliseconds
                // }
            }
        }
        , sdk = {
            version: 4
        }
    ;

    /**
     * connect
     *
     * @param {object} dbString
     * @callback cb
     * */
    this.connect = async function(dbString, cb) {
        // Attention: the connection is lost 5 minutes once the bucket is opened.
        var conn = null, defaultCollection = null;

        var onError = function (err, next) {
            de...
isRealApp(bundle, function(err, appPath) {
                if (err) {
                    console.error(err.stack || err.message)
                }


                var error = null;
                //console.debug(' OPTIONS => ', opt.debugPort, opt.debugBrkEnabled);
                //console.info('running: gina bundle:restart '+ bundle + '@' + self.projectName);
                msg = 'Restarting, please wait ...';
                cmd = '$gina bundle:stop ' + bundle + ' @' + self.projectName + ' && $gina bundle:start ' + bundle + ' @' + self.projectName;
                if (self.inheritedArgv != '') {
                    cmd += ' '+ self.inheritedArgv;
                }
                if (opt.debugPort) {
                    cmd += ' --inspect';
                    if (opt.debugBrkEnabled) {
                        cmd += '-brk'
                    }
                    cmd += '='+ opt.debugPort;
                    msg = 'You should now start your debug session on port #'+opt.deb...
out = execSync('gina bundle:list @'+ self.projectName +' --format=json').toString().replace(/(\n|\r)$/, '').split(/(\n|\r)/g)
function ByteInputStream = function ByteInputStream(bytes) {
  /** @type {number} */
  var pos = 0;

  /**
   * @this {ByteInputStream}
   * @returns {number} Get the next byte from the stream.
   */
  this.get = function() {
    return (pos >= bytes.length) ? EOF_byte : Number(bytes[pos]);
  };

  /** @param {number} n Number (positive or negative) by which to
   *      offset the byte pointer. */
  this.offset = function(n) {
    pos += n;
    if (pos < 0) {
      throw new Error('Seeking past start of the buffer');
    }
    if (pos > bytes.length) {
      throw new Error('Seeking past EOF');
    }
  };

  /**
   * @param {Array.<number>} test Array of bytes to compare against.
   * @returns {boolean} True if the start of the stream matches the test
   *     bytes.
   */
  this.match = function(test) {
    if (test.length > pos + bytes.length) {
      return false;
    }
    var i;
    for (i = 0; i < test.length; i += 1) {
      if (Number(bytes[pos + i]) !== test[i]) {
        return false;
      }
    }...
var init = function(options) {

        self.projectName    = options.projectName;
        //Starting app.
        self.appName        = options.bundle;
        self.env            = options.env;
        self.version        = options.version;
        local.router        = new Router(self.env);

        //True => multiple bundles sharing the same server (port).
        self.isStandalone   = options.isStandalone;
        self.bundles        = options.bundles;
        self.executionPath  = options.executionPath;


        if (!self.isStandalone) {
            //Only load the related conf / env.
            self.conf[self.appName] = {};
            self.conf[self.appName][self.env] = options.conf[self.appName][self.env];
            self.conf[self.appName][self.env].bundlesPath = options.conf[self.appName][self.env].bundlesPath;
            self.conf[self.appName][self.env].modelsPath =  options.conf[self.appName][self.env].modelsPath;
            self.conf[self.appName][self.env].execution...
this.onReady = function(callback) {
        self.once('model#ready', function(err, bundle, model, conn) {
            // entities == null when the database server has not started.
            if ( err ) {
                console.error(err.stack||err.message)
                //console.log('No entities found for [ '+ self.name +':'+ entityName +'].\n 1) Check if the database is started.\n2) Check if exists: /models/entities/'+ entityName);
            }
            callback(err, bundle, model, conn)
        });
        setup(namespace);
        return init()
    }
this.client.upsert(sid, sess, {expiry:ttl})
                .then(function onResult(_result){
                    result = _result;
                    //fn && fn.apply(this, arguments);
                })
                .catch(function onError(_err) {
                    err = _err
                    // if(err)
                    //     debug('Session Set complete', err.stack || err.message || err);

                    //fn && fn.apply(this, arguments);
                })
var existsSync = function(value) {
        if ( typeof(fs.accessSync) != 'undefined' ) {
            try {
                fs.accessSync(value, fs.constants.F_OK);
                return true;
            } catch (err) {
                // to handle symlinks
                try {
                    if ( fs.lstatSync(value).isSymbolicLink() ) {
                        return true
                    }
                } catch (linkErr) {}

                return false;
            }

        } else { // support for old version of nodejs
            return fs.existsSync(value);
        }
    }
CouchbaseStore.prototype.destroy = function(sid, fn){
        if ('function' !== typeof fn) { fn = noop; }
        sid = this.prefix + sid;
        //this.client.remove(sid, fn);
        this.client
                .remove(sid)
                .then(fn)
                .catch(fn)
    }
self.checkArch = function(done) {

        var currentArch = process.arch;
        var currentPlatform = process.platform;
        // ignored for framework:set
        var mainConfig = require( self.opt.homedir + '/main.json' );
        var defaultMainConfig = requireJSON( getPath('gina').root + '/resources/home/main.json' );
        //has registered arch ?
        var arch        = getEnvVar('GINA_ARCH') || mainConfig['def_arch'][self.release] || null; // arch by default
        if ( typeof(mainConfig.archs) == 'undefined' ) {
            mainConfig.archs = {};
            mainConfig.archs[self.release] = defaultMainConfig.archs['{release}'];
            mainConfig['def_arch'] = {}
            mainConfig['def_arch'][self.release] = currentArch;
            isUpdateNeeded = true;
        }
        if ( mainConfig.archs[self.release].indexOf(arch) < 0 ) {
            console.error('Arch [ ' + arch + ' ] not registered. Gina is not support your architecture `'+ process.arch +'` at thi...
<operator>.formatString("[Certificate] ", endpoint, " : It is like there is a problem with your CA certificate", '\n', " ", humanView, "")
var end = function (output, type, messageOnly) {
        var err = false;
        if ( typeof(output) != 'undefined') {
            if ( output instanceof Error ) {
                err = output = ( typeof(messageOnly) != 'undefined' && /^true$/i.test(messageOnly) ) ? output.message : (output.stack||output.message);
            }
            if ( typeof(type) != 'undefined' ) {
                console[type](output)
            } else {
                console.log(output);
            }
        }

        process.exit( err ? 1:0 )
    }
console.error('Scheme [ '+scheme+' ] is not an allowed scheme: check your framework configuration (~/main.json)')
var compressFile = function(method, input, output, zipInstance, isBatchProcessing, cb, isPackage) {

        var methodObject = null;
        isPackage = ( typeof(isPackage) == 'undefined' ) ? false: isPackage;

        if ( isBatchProcessing ) {

            zipInstance.file(output, fs.createReadStream(input));

            cb(false, output, zipInstance);
            return
        }

        switch (method) {
            case 'gzip':
                methodObject = zlib.createGzip();
                break;

            default:
                methodObject = zlib.createGzip();
                break;
        }


        if ( /\/\.(.*)$/.test(input.path) ) {

            if (isPackage) {
                cb(false, input)
            } else {
                cb(false, input.path)
            }
            return
        } else {
            input
                .pipe(methodObject)
                .pipe(output);
        }


        output
            .once('error', function onCompressionEr...
set('page.environment.routing', encodeRFC5987ValueChars(JSON.stringify(routing)))
var onRoutesLoaded = function(callback) {

        var config                  = new Config()
            , conf                  = config.getInstance(self.appName)
            , serverCoreConf        = self.conf.core
            , routing               = {}
            , reverseRouting        = {}
            , cacheless             = config.isCacheless()
            , env                   = self.env
            , apps                  = conf.allBundles//conf.bundles
            , filename              = ''
            , appName               = ''
            , tmp                   = {}
            , standaloneTmp         = {}
            , main                  = ''
            , tmpContent            = ''
            , i                     = 0
            , file                  = null // template file
            , wroot                 = null
            , hasWebRoot            = false
            , webrootAutoredirect   = null
            , localWroot            = null
        ...
self.models[bundle][connector]['getConnection'] = function() {
                                            return self.models[bundle][connector]['_connection']
                                        }
output
            .once('error', function onCompressionError(err) {
                cb(err, null)
            })
            .once('finish', function onCompressionFinished(){
                if (isPackage) {
                    cb(false, this, zipInstance)
                } else {
                    cb(false, this.path, zipInstance)
                }
            })
socket.on('message', function(payload){

                try {
                    console.debug('[IO SERVER ] receiving '+ payload);
                    payload = JSON.parse(payload);
                    // bind to session ID
                    if ( typeof(payload.session) != 'undefined' ) {
                        this.sessionId = payload.session.id;
                    }
                } catch(err) {
                    console.error(err.stack||err.message|| err)
                }
            })
var listBundleOnly = function() {

        var protocols   = self.protocols
            , schemes   = self.schemes
            , found     = false
            , str       = ''
            , re        = null
        ;

        var jsonCollection =  new Collection([]);
        for (let i = 0, len = protocols.length; i < len; ++i) {
            let protocol = protocols[i];
            str += '[ '+ protocol +' ]\n\r';
            for (let s = 0, sLen = schemes.length; s < sLen; ++s) {
                let scheme = schemes[s];
                let bundle = self.name;
                found = false;
                // re = new RegExp('^' + bundle + '\@', '');// searching by bundle name
                re = new RegExp('^' + bundle + '\@' + self.projectName + '\/', '');// searching by projectName
                for (let port in self.portsData[protocol][scheme]) {

                    let bundleEnv = self.portsData[protocol][scheme][port].replace(re, '\:').split(/\:/);
                    let _bun...
scan(options, function(err, ports){

                if (err) {
                    console.error(err.stack|err.message);
                    process.exit(1)
                }


                for (let p = 0; p < ports.length; ++p) {
                    local.ports.push(ports[p])
                }

                // local.ports.sort();

                ++local.b;
                addBundlePorts(local.b);
            })
local.errors[this.name].isStringLength = replace(this.error || local.errorLabels.isStringMinLength, this)
console.error('Scheme [ '+scheme+' ] is not an allowed scheme: check your framework configuration (~/main.json)')
var profilePathObj = new _(profilePath)
